<!DOCTYPE html><html>
<head>
<title></title>
<style type="text/css">
<!--
.xflip {
    -moz-transform: scaleX(-1);
    -webkit-transform: scaleX(-1);
    -o-transform: scaleX(-1);
    transform: scaleX(-1);
    filter: fliph;
}
.yflip {
    -moz-transform: scaleY(-1);
    -webkit-transform: scaleY(-1);
    -o-transform: scaleY(-1);
    transform: scaleY(-1);
    filter: flipv;
}
.xyflip {
    -moz-transform: scaleX(-1) scaleY(-1);
    -webkit-transform: scaleX(-1) scaleY(-1);
    -o-transform: scaleX(-1) scaleY(-1);
    transform: scaleX(-1) scaleY(-1);
    filter: fliph + flipv;
}
-->
</style>
</head>
<body>
<a name=1></a><img src="Ruby-1_1.jpg"/><br/>
<hr/>
<a name=2></a><img src="Ruby-2_1.jpg"/><br/>
<hr/>
<a name=3></a><b>The Ruby Programming Language</b><br/>
&#160;<br/>
<hr/>
<a name=4></a><hr/>
<a name=5></a><b>The Ruby Programming Language</b><br/>
<i>David Flanagan and Yukihiro Matsumoto</i><br/>
Beijing&#160;<b>•&#160;</b>Cambridge&#160;<b>•&#160;</b>Farnham&#160;<b>•&#160;</b>Köln&#160;<b>•&#160;</b>Sebastopol&#160;<b>•&#160;</b>Taipei&#160;<b>•&#160;</b>Tokyo<br/>
<hr/>
<a name=6></a><b>The Ruby Programming Language<br/></b>by David Flanagan and Yukihiro Matsumoto<br/>with drawings by&#160;<i>why</i>&#160;<i>the lucky stiff</i><br/>
Copyright © 2008 David Flanagan and Yukihiro Matsumoto. All rights reserved.<br/>Printed in the United States of America.<br/>
Published by O’Reilly Media, Inc., 1005 Gravenstein Highway North, Sebastopol, CA 95472<br/>
O’Reilly&#160;books&#160;may&#160;be&#160;purchased&#160;for&#160;educational,&#160;business,&#160;or&#160;sales&#160;promotional&#160;use.&#160;Online&#160;editions<br/>are&#160;also&#160;available&#160;for&#160;most&#160;titles&#160;<a href="http://safari.oreilly.com">(<i>http://safari.oreilly.com</i></a>).&#160;For&#160;more&#160;information,&#160;contact&#160;our&#160;corporate/<br/>institutional sales department: (800) 998-9938 or&#160;<i>corporate@oreilly.com</i>.<br/>
<b>Editor:&#160;</b>Mike Loukides<br/>
<b>Indexer:&#160;</b>Joe Wizda<br/>
<b>Production Editor:&#160;</b>Sarah Schneider<br/>
<b>Cover Designer:&#160;</b>Karen Montgomery<br/>
<b>Proofreader:&#160;</b>Sarah Schneider<br/>
<b>Interior Designer:&#160;</b>David Futato<br/>
<b>Illustrators:&#160;</b>Rob Romano and&#160;<i>why</i>&#160;<i>the lucky stiff</i><br/>
<b>Printing History:</b><br/>
January 2008:<br/>
First Edition.<br/>
Nutshell&#160;Handbook,&#160;the&#160;Nutshell&#160;Handbook&#160;logo,&#160;and&#160;the&#160;O’Reilly&#160;logo&#160;are&#160;registered&#160;trademarks&#160;of<br/>O’Reilly&#160;Media,&#160;Inc.&#160;<i>The&#160;Ruby&#160;Programming&#160;Language</i>,&#160;the&#160;image&#160;of&#160;Horned&#160;Sungem&#160;hummingbirds,<br/>and related trade dress are trademarks of O’Reilly Media, Inc.<br/>
Java™&#160;and&#160;all&#160;Java-based&#160;trademarks&#160;are&#160;registered&#160;trademarks&#160;of&#160;Sun&#160;Microsystems,&#160;Inc.,&#160;in&#160;the&#160;United<br/>States and other countries. O’Reilly Media, Inc. is independent of Sun Microsystems.<br/>
Many&#160;of&#160;the&#160;designations&#160;uses&#160;by&#160;manufacturers&#160;and&#160;sellers&#160;to&#160;distinguish&#160;their&#160;products&#160;are&#160;claimed&#160;as<br/>trademarks.&#160;Where&#160;those&#160;designations&#160;appear&#160;in&#160;this&#160;book,&#160;and&#160;O’Reilly&#160;Media,&#160;Inc.&#160;was&#160;aware&#160;of&#160;a<br/>trademark claim, the designations have been printed in caps or initial caps.<br/>
While&#160;every&#160;precaution&#160;has&#160;been&#160;taken&#160;in&#160;the&#160;preparation&#160;of&#160;this&#160;book,&#160;the&#160;publisher&#160;and&#160;authors&#160;assume<br/>no responsibility for errors or omissions, or for damages resulting from the use of the information con-<br/>tained&#160;herein.&#160;The&#160;drawings&#160;on&#160;the&#160;chapter&#160;title&#160;pages&#160;were&#160;drawn&#160;by&#160;<i>why&#160;the&#160;lucky&#160;stiff</i>&#160;and&#160;are&#160;licensed<br/>under&#160;the&#160;Creative&#160;Commons&#160;Attribution-ShareAlike&#160;3.0&#160;License.&#160;To&#160;view&#160;a&#160;copy&#160;of&#160;this&#160;license,&#160;visit<br/><a href="http://creativecommons.org/licenses/by-sa/3.0/legalcode"><i>http://creativecommons.org/licenses/by-sa/3.0/legalcode</i>&#160;</a>or&#160;send&#160;a&#160;letter&#160;to&#160;Creative&#160;Commons,&#160;171&#160;2nd<br/>Street, Suite 300, San Francisco, California, 94105, USA.<br/>
<b>TM</b><br/>
This book uses RepKover™, a durable and flexible lay-flat binding.<br/>
ISBN-13: 978-0-596-51617-8<br/>
[M]<br/>
[12/08]<br/>
1264438633<br/>
<hr/>
<a name=7></a><b>Table of Contents</b><br/>
<a href="Rubys.html#11"><b>Preface&#160;&#160;</b></a><b>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;<a href="Rubys.html#11">&#160;ix</a></b><br/>
<a href="Rubys.html#15"><b>1.&#160;</b></a><br/>
<b>Introduction&#160;&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;<a href="Rubys.html#15">&#160;1</a></b><br/>
<a href="Rubys.html#16">1.1&#160;A Tour of Ruby</a><br/>
<a href="Rubys.html#16">2</a><br/>
<a href="Rubys.html#25">1.2&#160;Try Ruby</a><br/>
<a href="Rubys.html#25">11</a><br/>
<a href="Rubys.html#29">1.3&#160;About This Book</a><br/>
<a href="Rubys.html#29">15</a><br/>
<a href="Rubys.html#31">1.4&#160;A Sudoku Solver in Ruby</a><br/>
<a href="Rubys.html#31">17</a><br/>
<a href="Rubys.html#39"><b>2.&#160;</b></a><br/>
<b>The Structure and Execution of Ruby Programs&#160;&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;<a href="Rubys.html#39">&#160;25</a></b><br/>
<a href="Rubys.html#40">2.1&#160;Lexical Structure</a><br/>
<a href="Rubys.html#40">26</a><br/>
<a href="Rubys.html#47">2.2&#160;Syntactic Structure</a><br/>
<a href="Rubys.html#47">33</a><br/>
<a href="Rubys.html#49">2.3&#160;File Structure</a><br/>
<a href="Rubys.html#49">35</a><br/>
<a href="Rubys.html#50">2.4&#160;Program Encoding</a><br/>
<a href="Rubys.html#50">36</a><br/>
<a href="Rubys.html#53">2.5&#160;Program Execution</a><br/>
<a href="Rubys.html#53">39</a><br/>
<a href="Rubys.html#55"><b>3.&#160;</b></a><br/>
<b>Datatypes and Objects&#160;&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<a href="Rubys.html#55">&#160;41</a></b><br/>
<a href="Rubys.html#56">3.1&#160;Numbers</a><br/>
<a href="Rubys.html#56">42</a><br/>
<a href="Rubys.html#60">3.2&#160;Text</a><br/>
<a href="Rubys.html#60">46</a><br/>
<a href="Rubys.html#78">3.3&#160;Arrays</a><br/>
<a href="Rubys.html#78">64</a><br/>
<a href="Rubys.html#81">3.4&#160;Hashes</a><br/>
<a href="Rubys.html#81">67</a><br/>
<a href="Rubys.html#82">3.5&#160;Ranges</a><br/>
<a href="Rubys.html#82">68</a><br/>
<a href="Rubys.html#84">3.6&#160;Symbols</a><br/>
<a href="Rubys.html#84">70</a><br/>
<a href="Rubys.html#86">3.7&#160;True, False, and Nil</a><br/>
<a href="Rubys.html#86">72</a><br/>
<a href="Rubys.html#86">3.8&#160;Objects</a><br/>
<a href="Rubys.html#86">72</a><br/>
<a href="Rubys.html#99"><b>4.&#160;</b></a><br/>
<b>Expressions and Operators&#160;&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;<a href="Rubys.html#99">&#160;85</a></b><br/>
<a href="Rubys.html#100">4.1&#160;Literals and Keyword Literals</a><br/>
<a href="Rubys.html#100">86</a><br/>
<a href="Rubys.html#101">4.2&#160;Variable References</a><br/>
<a href="Rubys.html#101">87</a><br/>
<a href="Rubys.html#102">4.3&#160;Constant References</a><br/>
<a href="Rubys.html#102">88</a><br/>
<a href="Rubys.html#103">4.4&#160;Method Invocations</a><br/>
<a href="Rubys.html#103">89</a><br/>
<a href="Rubys.html#106">4.5&#160;Assignments</a><br/>
<a href="Rubys.html#106">92</a><br/>
<a href="Rubys.html#114">4.6&#160;Operators</a><br/>
<a href="Rubys.html#114">100</a><br/>
<b>v</b><br/>
<hr/>
<a name=8></a><a href="Rubys.html#131"><b>5.&#160;</b></a><br/>
<b>Statements and Control Structures&#160;&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;<a href="Rubys.html#131">&#160;117</a></b><br/>
<a href="Rubys.html#132">5.1&#160;Conditionals</a><br/>
<a href="Rubys.html#132">118</a><br/>
<a href="Rubys.html#141">5.2&#160;Loops</a><br/>
<a href="Rubys.html#141">127</a><br/>
<a href="Rubys.html#144">5.3&#160;Iterators and Enumerable Objects</a><br/>
<a href="Rubys.html#144">130</a><br/>
<a href="Rubys.html#154">5.4&#160;Blocks</a><br/>
<a href="Rubys.html#154">140</a><br/>
<a href="Rubys.html#160">5.5&#160;Altering Control Flow</a><br/>
<a href="Rubys.html#160">146</a><br/>
<a href="Rubys.html#168">5.6&#160;Exceptions and Exception Handling</a><br/>
<a href="Rubys.html#168">154</a><br/>
<a href="Rubys.html#179">5.7&#160;BEGIN and END</a><br/>
<a href="Rubys.html#179">165</a><br/>
<a href="Rubys.html#180">5.8&#160;Threads, Fibers, and Continuations</a><br/>
<a href="Rubys.html#180">166</a><br/>
<a href="Rubys.html#189"><b>6.&#160;</b></a><br/>
<b>Methods, Procs, Lambdas, and Closures&#160;&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;<a href="Rubys.html#189">&#160;175</a></b><br/>
<a href="Rubys.html#191">6.1&#160;Defining Simple Methods</a><br/>
<a href="Rubys.html#191">177</a><br/>
<a href="Rubys.html#194">6.2&#160;Method Names</a><br/>
<a href="Rubys.html#194">180</a><br/>
<a href="Rubys.html#197">6.3&#160;Methods and Parentheses</a><br/>
<a href="Rubys.html#197">183</a><br/>
<a href="Rubys.html#199">6.4&#160;Method Arguments</a><br/>
<a href="Rubys.html#199">185</a><br/>
<a href="Rubys.html#206">6.5&#160;Procs and Lambdas</a><br/>
<a href="Rubys.html#206">192</a><br/>
<a href="Rubys.html#214">6.6&#160;Closures</a><br/>
<a href="Rubys.html#214">200</a><br/>
<a href="Rubys.html#217">6.7&#160;Method Objects</a><br/>
<a href="Rubys.html#217">203</a><br/>
<a href="Rubys.html#219">6.8&#160;Functional Programming</a><br/>
<a href="Rubys.html#219">205</a><br/>
<a href="Rubys.html#227"><b>7.&#160;</b></a><br/>
<b>Classes and Modules&#160;&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;<a href="Rubys.html#227">&#160;213</a></b><br/>
<a href="Rubys.html#228">7.1&#160;Defining a Simple Class</a><br/>
<a href="Rubys.html#228">214</a><br/>
<a href="Rubys.html#246">7.2&#160;Method Visibility: Public, Protected, Private</a><br/>
<a href="Rubys.html#246">232</a><br/>
<a href="Rubys.html#248">7.3&#160;Subclassing and Inheritance</a><br/>
<a href="Rubys.html#248">234</a><br/>
<a href="Rubys.html#255">7.4&#160;Object Creation and Initialization</a><br/>
<a href="Rubys.html#255">241</a><br/>
<a href="Rubys.html#261">7.5&#160;Modules</a><br/>
<a href="Rubys.html#261">247</a><br/>
<a href="Rubys.html#266">7.6&#160;Loading and Requiring Modules</a><br/>
<a href="Rubys.html#266">252</a><br/>
<a href="Rubys.html#271">7.7&#160;Singleton Methods and the Eigenclass</a><br/>
<a href="Rubys.html#271">257</a><br/>
<a href="Rubys.html#272">7.8&#160;Method Lookup</a><br/>
<a href="Rubys.html#272">258</a><br/>
<a href="Rubys.html#275">7.9&#160;Constant Lookup</a><br/>
<a href="Rubys.html#275">261</a><br/>
<a href="Rubys.html#279"><b>8.&#160;</b></a><br/>
<b>Reflection and Metaprogramming&#160;&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;<a href="Rubys.html#279">&#160;265</a></b><br/>
<a href="Rubys.html#280">8.1&#160;Types, Classes, and Modules</a><br/>
<a href="Rubys.html#280">266</a><br/>
<a href="Rubys.html#282">8.2&#160;Evaluating Strings and Blocks</a><br/>
<a href="Rubys.html#282">268</a><br/>
<a href="Rubys.html#285">8.3&#160;Variables and Constants</a><br/>
<a href="Rubys.html#285">271</a><br/>
<a href="Rubys.html#286">8.4&#160;Methods</a><br/>
<a href="Rubys.html#286">272</a><br/>
<a href="Rubys.html#291">8.5&#160;Hooks</a><br/>
<a href="Rubys.html#291">277</a><br/>
<a href="Rubys.html#293">8.6&#160;Tracing</a><br/>
<a href="Rubys.html#293">279</a><br/>
<a href="Rubys.html#295">8.7&#160;ObjectSpace and GC</a><br/>
<a href="Rubys.html#295">281</a><br/>
<a href="Rubys.html#295">8.8&#160;Custom Control Structures</a><br/>
<a href="Rubys.html#295">281</a><br/>
<a href="Rubys.html#298">8.9&#160;Missing Methods and Missing Constants</a><br/>
<a href="Rubys.html#298">284</a><br/>
<a href="Rubys.html#301">8.10&#160;Dynamically Creating Methods</a><br/>
<a href="Rubys.html#301">287</a><br/>
<a href="Rubys.html#304">8.11&#160;Alias Chaining</a><br/>
<a href="Rubys.html#304">290</a><br/>
<b>vi&#160;|&#160;Table of Contents</b><br/>
<hr/>
<a name=9></a><a href="Rubys.html#310">8.12&#160;Domain-Specific Languages</a><br/>
<a href="Rubys.html#310">296</a><br/>
<a href="Rubys.html#317"><b>9.&#160;</b></a><br/>
<b>The Ruby Platform&#160;&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.<a href="Rubys.html#317">&#160;303</a></b><br/>
<a href="Rubys.html#318">9.1&#160;Strings</a><br/>
<a href="Rubys.html#318">304</a><br/>
<a href="Rubys.html#324">9.2&#160;Regular Expressions</a><br/>
<a href="Rubys.html#324">310</a><br/>
<a href="Rubys.html#335">9.3&#160;Numbers and Math</a><br/>
<a href="Rubys.html#335">321</a><br/>
<a href="Rubys.html#339">9.4&#160;Dates and Times</a><br/>
<a href="Rubys.html#339">325</a><br/>
<a href="Rubys.html#342">9.5&#160;Collections</a><br/>
<a href="Rubys.html#342">328</a><br/>
<a href="Rubys.html#364">9.6&#160;Files and Directories</a><br/>
<a href="Rubys.html#364">350</a><br/>
<a href="Rubys.html#370">9.7&#160;Input/Output</a><br/>
<a href="Rubys.html#370">356</a><br/>
<a href="Rubys.html#380">9.8&#160;Networking</a><br/>
<a href="Rubys.html#380">366</a><br/>
<a href="Rubys.html#387">9.9&#160;Threads and Concurrency</a><br/>
<a href="Rubys.html#387">373</a><br/>
<a href="Rubys.html#403"><b>10.&#160;&#160;</b></a><b>The Ruby Environment&#160;&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;<a href="Rubys.html#403">&#160;389</a></b><br/>
<a href="Rubys.html#404">10.1&#160;Invoking the Ruby Interpreter</a><br/>
<a href="Rubys.html#404">390</a><br/>
<a href="Rubys.html#409">10.2&#160;The Top-Level Environment</a><br/>
<a href="Rubys.html#409">395</a><br/>
<a href="Rubys.html#417">10.3&#160;Practical Extraction and Reporting Shortcuts</a><br/>
<a href="Rubys.html#417">403</a><br/>
<a href="Rubys.html#419">10.4&#160;Calling the OS</a><br/>
<a href="Rubys.html#419">405</a><br/>
<a href="Rubys.html#423">10.5&#160;Security</a><br/>
<a href="Rubys.html#423">409</a><br/>
<a href="Rubys.html#429"><b>Index&#160;&#160;</b></a><b>.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;.&#160;<a href="Rubys.html#429">&#160;415</a></b><br/>
<b>Table of Contents&#160;|&#160;vii</b><br/>
<hr/>
<a name=10></a><hr/>
<a name=11></a><b>Preface</b><br/>
This&#160;book&#160;is&#160;an&#160;updated&#160;and&#160;expanded&#160;version&#160;of&#160;<i>Ruby&#160;in&#160;a&#160;Nutshell</i>&#160;(O’Reilly)&#160;by<br/>Yukihiro&#160;Matsumoto,&#160;who&#160;is&#160;better&#160;known&#160;as&#160;Matz.&#160;It&#160;is&#160;loosely&#160;modeled&#160;after&#160;the<br/>classic&#160;<i>The&#160;C&#160;Programming&#160;Language</i>&#160;(Prentice&#160;Hall)&#160;by&#160;Brian&#160;Kernighan&#160;and&#160;Dennis<br/>Ritchie,&#160;and&#160;aims&#160;to&#160;document&#160;the&#160;Ruby&#160;language&#160;comprehensively&#160;but&#160;without&#160;the<br/>formality&#160;of&#160;a&#160;language&#160;specification.&#160;It&#160;is&#160;written&#160;for&#160;experienced&#160;programmers&#160;who<br/>are&#160;new&#160;to&#160;Ruby,&#160;and&#160;for&#160;current&#160;Ruby&#160;programmers&#160;who&#160;want&#160;to&#160;take&#160;their&#160;under-<br/>standing and mastery of the language to the next level.<br/><a href="Rubys.html#15">You’ll find a guide to the structure and organization of this book in Chapter 1.</a><br/>
<b>Acknowledgments</b><br/>
<b>David Flanagan<br/></b>Before&#160;anything&#160;else,&#160;I&#160;must&#160;thank&#160;Matz&#160;for&#160;the&#160;beautiful&#160;language&#160;he&#160;has&#160;designed,&#160;for<br/>his help understanding that language, and for the&#160;<i>Nutshell</i>&#160;that this book grew out of.<br/>Thanks also to:<br/>
•&#160;<i>why&#160;the&#160;lucky&#160;stiff</i>&#160;for&#160;the&#160;delightful&#160;drawings&#160;that&#160;grace&#160;these&#160;pages&#160;(you’ll&#160;find<br/>
them&#160;on&#160;the&#160;chapter&#160;title&#160;pages)&#160;and,&#160;of&#160;course,&#160;for&#160;his&#160;own&#160;book&#160;on&#160;Ruby,&#160;<i>why’s<br/>(poignant)&#160;guide&#160;to&#160;Ruby</i>,&#160;which&#160;you&#160;can&#160;find&#160;online&#160;at&#160;<a href="http://poignantguide.net/ruby/"><i>http://poignantguide.net/<br/>ruby/</i>.</a><br/>
•&#160;My&#160;technical&#160;reviewers:&#160;David&#160;A.&#160;Black,&#160;director&#160;of&#160;Ruby&#160;Power&#160;and&#160;Light,&#160;LLC<br/>
<a href="http://www.rubypal.com">(<i>http://www.rubypal.com</i>);&#160;&#160;</a>Charles&#160;&#160;Oliver&#160;&#160;Nutter&#160;&#160;of&#160;&#160;the&#160;&#160;JRuby&#160;&#160;team&#160;&#160;<a href="http://www.jruby.org">(<i>http://<br/>www.jruby.org</i></a>)&#160;at&#160;Sun&#160;Microsystems;&#160;Shyouhei&#160;Urabe,&#160;the&#160;maintainer&#160;of&#160;the&#160;Ruby<br/>1.8.6&#160;branch;&#160;and&#160;Ken&#160;Cooper.&#160;Their&#160;comments&#160;helped&#160;improve&#160;the&#160;quality&#160;and<br/>clarity of the book. Any errors that remain are, of course, my own.<br/>
•&#160;My&#160;editor,&#160;Mike&#160;Loukides,&#160;for&#160;asking&#160;and&#160;persistently&#160;encouraging&#160;me&#160;to&#160;write&#160;this<br/>
book, and for his patience while I did so.<br/>
<b>ix</b><br/>
<hr/>
<a name=12></a>Finally, of course, my love and thanks to my family.<br/>
<i>—David Flanagan</i><br/>
<a href="http://www.davidflanagan.com"><i>http://www.davidflanagan.com</i></a><br/>
<i>January 2008</i><br/>
<b>Yukihiro Matsumoto<br/></b>In&#160;addition&#160;to&#160;the&#160;people&#160;listed&#160;by&#160;David&#160;(except&#160;myself),&#160;I&#160;appreciate&#160;the&#160;help&#160;from<br/>community&#160;&#160;members&#160;&#160;all&#160;&#160;around&#160;&#160;the&#160;&#160;world,&#160;&#160;especially&#160;&#160;from&#160;&#160;Japan:&#160;&#160;Koichi&#160;&#160;Sasada,<br/>Nobuyoshi&#160;Nakada,&#160;Akira&#160;Tanaka,&#160;Shugo&#160;Maeda,&#160;Usaku&#160;Nakamura,&#160;and&#160;Shyouhei<br/>Urabe to name a few (not in any particular order).<br/>And&#160;finally,&#160;I&#160;thank&#160;my&#160;family,&#160;who&#160;hopefully&#160;forgive&#160;their&#160;husband&#160;and&#160;father&#160;for<br/>dedicating time to Ruby development.<br/>
<i>—Yukihiro Matsumoto</i><br/>
<i>January 2008</i><br/>
<b>Conventions Used in This Book<br/></b>The following typographical conventions are used in this book:<br/>
<i>Italic</i><br/>
Indicates new terms, URLs, email addresses, filenames, and file extensions.<br/>
Constant width<br/>
Used&#160;for&#160;program&#160;listings,&#160;as&#160;well&#160;as&#160;within&#160;paragraphs&#160;to&#160;refer&#160;to&#160;program&#160;elements<br/>such&#160;as&#160;variable&#160;or&#160;function&#160;names,&#160;datatypes,&#160;environment&#160;variables,&#160;statements,<br/>
&#160;<br/>
and keywords.<br/>
<b>Constant width bold</b><br/>
Shows commands or other text that should be typed literally by the user.<br/>
<i>Constant width italic</i><br/>
Shows&#160;text&#160;that&#160;should&#160;be&#160;replaced&#160;with&#160;user-supplied&#160;values&#160;or&#160;by&#160;values&#160;deter-<br/>mined by context.<br/>
<b>Using Code Examples<br/></b>This&#160;book&#160;is&#160;here&#160;to&#160;help&#160;you&#160;get&#160;your&#160;job&#160;done.&#160;In&#160;general,&#160;you&#160;may&#160;use&#160;the&#160;code&#160;in<br/>this&#160;book&#160;in&#160;your&#160;programs&#160;and&#160;documentation.&#160;You&#160;do&#160;not&#160;need&#160;to&#160;contact&#160;us&#160;for<br/>permission&#160;unless&#160;you’re&#160;reproducing&#160;a&#160;significant&#160;portion&#160;of&#160;the&#160;code.&#160;For&#160;example,<br/>writing&#160;a&#160;program&#160;that&#160;uses&#160;several&#160;chunks&#160;of&#160;code&#160;from&#160;this&#160;book&#160;does&#160;not&#160;require<br/>permission.&#160;Selling&#160;or&#160;distributing&#160;a&#160;CD-ROM&#160;of&#160;examples&#160;from&#160;O’Reilly&#160;books&#160;does<br/>require&#160;permission.&#160;Answering&#160;a&#160;question&#160;by&#160;citing&#160;this&#160;book&#160;and&#160;quoting&#160;example<br/>
<b>x&#160;|&#160;Preface</b><br/>
<hr/>
<a name=13></a>code&#160;does&#160;not&#160;require&#160;permission.&#160;Incorporating&#160;a&#160;significant&#160;amount&#160;of&#160;example&#160;code<br/>from this book into your product’s documentation does require permission.<br/>We&#160;appreciate,&#160;but&#160;do&#160;not&#160;require,&#160;attribution.&#160;An&#160;attribution&#160;usually&#160;includes&#160;the&#160;title,<br/>author,&#160;publisher,&#160;and&#160;ISBN.&#160;For&#160;example:&#160;“<i>The&#160;Ruby&#160;Programming&#160;Language</i>&#160;by&#160;David<br/>Flanagan&#160;&#160;and&#160;&#160;Yukihiro&#160;&#160;Matsumoto.&#160;&#160;Copyright&#160;&#160;2008&#160;&#160;David&#160;&#160;Flanagan&#160;&#160;and&#160;&#160;Yukihiro<br/>Matsumoto, 978-0-596-51617-8.”<br/>If&#160;you&#160;feel&#160;your&#160;use&#160;of&#160;code&#160;examples&#160;falls&#160;outside&#160;fair&#160;use&#160;or&#160;the&#160;permission&#160;given&#160;above,<br/>feel free to contact us at&#160;<i>permissions@oreilly.com</i>.<br/>
<b>How to Contact Us<br/></b>Please address comments and questions concerning this book to the publisher:<br/>
O’Reilly Media, Inc.<br/>1005 Gravenstein Highway North<br/>Sebastopol, CA 95472<br/>800-998-9938 (in the United States or Canada)<br/>707-829-0515 (international or local)<br/>707 829-0104 (fax)<br/>
We have a web page for this book, where we list errata, examples, and any additional<br/>information. You can access this page at:<br/>
<a href="http://www.oreilly.com/catalog/9780596516178"><i>http://www.oreilly.com/catalog/9780596516178</i></a><br/>
To comment or ask technical questions about this book, send email to:<br/>
<i>bookquestions@oreilly.com</i><br/>
For&#160;&#160;more&#160;&#160;information&#160;&#160;about&#160;&#160;our&#160;&#160;books,&#160;&#160;conferences,&#160;&#160;Resource&#160;&#160;Centers,&#160;&#160;and&#160;&#160;the<br/>O’Reilly Network, see our web site at:<br/>
<a href="http://www.oreilly.com"><i>http://www.oreilly.com</i></a><br/>
<b>Safari® Enabled</b><br/>
When&#160;you&#160;see&#160;a&#160;Safari®&#160;Enabled&#160;icon&#160;on&#160;the&#160;cover&#160;of&#160;your&#160;favorite&#160;tech-<br/>nology&#160;book,&#160;that&#160;means&#160;the&#160;book&#160;is&#160;available&#160;online&#160;through&#160;the&#160;O’Reilly<br/>Network Safari Bookshelf.<br/>
Safari&#160;offers&#160;a&#160;solution&#160;that’s&#160;better&#160;than&#160;e-books.&#160;It’s&#160;a&#160;virtual&#160;library&#160;that&#160;lets&#160;you&#160;easily<br/>search&#160;thousands&#160;of&#160;top&#160;tech&#160;books,&#160;cut&#160;and&#160;paste&#160;code&#160;samples,&#160;download&#160;chapters,<br/>and&#160;find&#160;quick&#160;answers&#160;when&#160;you&#160;need&#160;the&#160;most&#160;accurate,&#160;current&#160;information.&#160;Try&#160;it<br/>for free at&#160;<a href="http://safari.oreilly.com"><i>http://safari.oreilly.com</i></a>.<br/>
<b>Preface&#160;|&#160;xi</b><br/>
<hr/>
<a name=14></a><hr/>
<a name=15></a><img src="Ruby-15_1.jpg"/><br/>
<b>CHAPTER&#160;1</b><br/>
<b>Introduction</b><br/>
<b>1</b><br/>
<hr/>
<a name=16></a>Ruby&#160;is&#160;a&#160;dynamic&#160;programming&#160;language&#160;with&#160;a&#160;complex&#160;but&#160;expressive&#160;grammar&#160;and<br/>a&#160;core&#160;class&#160;library&#160;with&#160;a&#160;rich&#160;and&#160;powerful&#160;API.&#160;Ruby&#160;draws&#160;inspiration&#160;from&#160;Lisp,<br/>Smalltalk, and Perl, but uses a grammar that is easy for C and Java™ programmers to<br/>learn.&#160;Ruby&#160;is&#160;a&#160;pure&#160;object-oriented&#160;language,&#160;but&#160;it&#160;is&#160;also&#160;suitable&#160;for&#160;procedural&#160;and<br/>functional&#160;&#160;programming&#160;&#160;styles.&#160;&#160;It&#160;&#160;includes&#160;&#160;powerful&#160;&#160;metaprogramming&#160;&#160;capabilities<br/>and can be used to create domain-specific languages or DSLs.<br/>
<b>Matz on Ruby</b><br/>
Yukihiro&#160;Matsumoto,&#160;known&#160;as&#160;Matz&#160;to&#160;the&#160;English-speaking&#160;Ruby&#160;community,&#160;is&#160;the<br/>creator&#160;of&#160;Ruby&#160;and&#160;the&#160;author&#160;of&#160;<i>Ruby&#160;in&#160;a&#160;Nutshell</i>&#160;(O’Reilly)&#160;(which&#160;has&#160;been&#160;updated<br/>and expanded into the present book). He says:<br/>
<i>I&#160;knew&#160;many&#160;languages&#160;before&#160;I&#160;created&#160;Ruby,&#160;but&#160;I&#160;was&#160;never&#160;fully&#160;satisfied&#160;with<br/>them.&#160;They&#160;were&#160;uglier,&#160;tougher,&#160;more&#160;complex,&#160;or&#160;more&#160;simple&#160;than&#160;I&#160;expected.&#160;I<br/>wanted&#160;to&#160;create&#160;my&#160;own&#160;language&#160;that&#160;satisfied&#160;me,&#160;as&#160;a&#160;programmer.&#160;I&#160;knew&#160;a&#160;lot<br/>about&#160;the&#160;language’s&#160;target&#160;audience:&#160;myself.&#160;To&#160;my&#160;surprise,&#160;many&#160;programmers<br/>all&#160;over&#160;the&#160;world&#160;feel&#160;very&#160;much&#160;like&#160;I&#160;do.&#160;They&#160;feel&#160;happy&#160;when&#160;they&#160;discover&#160;and<br/>program in Ruby.</i><br/>
<i>Throughout&#160;&#160;the&#160;&#160;development&#160;&#160;of&#160;&#160;the&#160;&#160;Ruby&#160;&#160;language,&#160;&#160;I've&#160;&#160;focused&#160;&#160;my&#160;&#160;energies&#160;&#160;on<br/>making&#160;&#160;programming&#160;&#160;faster&#160;&#160;and&#160;&#160;easier.&#160;&#160;All&#160;&#160;features&#160;&#160;in&#160;&#160;Ruby,&#160;&#160;including&#160;&#160;object-<br/>oriented&#160;features,&#160;are&#160;designed&#160;to&#160;work&#160;as&#160;ordinary&#160;programmers&#160;(e.g.,&#160;me)&#160;expect<br/>them&#160;to&#160;work.&#160;Most&#160;programmers&#160;feel&#160;it&#160;is&#160;elegant,&#160;easy&#160;to&#160;use,&#160;and&#160;a&#160;pleasure&#160;to<br/>program.</i><br/>
Matz’s&#160;&#160;guiding&#160;&#160;philosophy&#160;&#160;for&#160;&#160;the&#160;&#160;design&#160;&#160;of&#160;&#160;Ruby&#160;&#160;is&#160;&#160;summarized&#160;&#160;in&#160;&#160;an&#160;&#160;oft-quoted<br/>remark of his:<br/>
<i>Ruby is designed to make programmers happy.</i><br/>
<b>1.1 &#160;A Tour of Ruby<br/></b>This&#160;section&#160;is&#160;a&#160;guided,&#160;but&#160;meandering,&#160;tour&#160;through&#160;some&#160;of&#160;the&#160;most&#160;interesting<br/>features&#160;of&#160;Ruby.&#160;Everything&#160;discussed&#160;here&#160;will&#160;be&#160;documented&#160;in&#160;detail&#160;later&#160;in&#160;the<br/>book, but this first look will give you the flavor of the language.<br/>
<b>1.1.1 &#160;Ruby Is Object-Oriented<br/></b>We’ll&#160;begin&#160;with&#160;the&#160;fact&#160;that&#160;Ruby&#160;is&#160;a&#160;<i>completely</i>&#160;object-oriented&#160;language.&#160;Every&#160;value<br/>is&#160;an&#160;object,&#160;even&#160;simple&#160;numeric&#160;literals&#160;and&#160;the&#160;values&#160;true,&#160;false,&#160;and&#160;nil&#160;(nil&#160;is&#160;a<br/>special&#160;value&#160;that&#160;indicates&#160;the&#160;absence&#160;of&#160;value;&#160;it&#160;is&#160;Ruby’s&#160;version&#160;of&#160;null). Here&#160;we<br/>invoke&#160;a&#160;method&#160;named&#160;class&#160;on&#160;these&#160;values.&#160;Comments&#160;begin&#160;with&#160;#&#160;in&#160;Ruby,&#160;and<br/>the&#160;=&gt;&#160;arrows&#160;in&#160;the&#160;comments&#160;indicate&#160;the&#160;value&#160;returned&#160;by&#160;the&#160;commented&#160;code&#160;(this<br/>is a convention used throughout this book):<br/>
1.class &#160; &#160; &#160;# =&gt; Fixnum: the number 1 is a Fixnum<br/>0.0.class &#160; &#160;# =&gt; Float: floating-point numbers have class Float<br/>
<b>2&#160;|&#160;Chapter 1:</b> <b>Introduction</b><br/>
<hr/>
<a name=17></a>true.class &#160; # =&gt; TrueClass: true is a the singleton instance of TrueClass<br/>false.class &#160;# =&gt; FalseClass<br/>nil.class &#160; &#160;# =&gt; NilClass<br/>
In&#160;many&#160;languages,&#160;function&#160;and&#160;method&#160;invocations&#160;require&#160;parentheses,&#160;but&#160;there<br/>are&#160;no&#160;parentheses&#160;in&#160;any&#160;of&#160;the&#160;code&#160;above.&#160;In&#160;Ruby,&#160;parentheses&#160;are&#160;usually&#160;optional<br/>and&#160;they&#160;are&#160;commonly&#160;omitted,&#160;especially&#160;when&#160;the&#160;method&#160;being&#160;invoked&#160;takes&#160;no<br/>arguments.&#160;The&#160;fact&#160;that&#160;the&#160;parentheses&#160;are&#160;omitted&#160;in&#160;the&#160;method&#160;invocations&#160;here<br/>makes&#160;them&#160;look&#160;like&#160;references&#160;to&#160;named&#160;fields&#160;or&#160;named&#160;variables&#160;of&#160;the&#160;object.&#160;This<br/>is&#160;intentional,&#160;but&#160;the&#160;fact&#160;is,&#160;Ruby&#160;is&#160;very&#160;strict&#160;about&#160;encapsulation&#160;of&#160;its&#160;objects;&#160;there<br/>is&#160;no&#160;access&#160;to&#160;the&#160;internal&#160;state&#160;of&#160;an&#160;object&#160;from&#160;outside&#160;the&#160;object.&#160;Any&#160;such&#160;access<br/>must be mediated by an accessor method, such as the&#160;class&#160;method shown above.<br/>
<b>1.1.2 &#160;Blocks and Iterators<br/></b>The fact that&#160;we&#160;can&#160;invoke&#160;methods&#160;on&#160;integers&#160;isn’t&#160;just&#160;an&#160;esoteric&#160;aspect&#160;of&#160;Ruby.<br/>It is actually something that Ruby programmers do with some frequency:<br/>
3.times { print &#34;Ruby! &#34; } &#160; # Prints &#34;Ruby! Ruby! Ruby! &#34;<br/>1.upto(9) {|x| print x } &#160; &#160; # Prints &#34;123456789&#34;<br/>
times&#160;and&#160;upto&#160;are&#160;methods&#160;implemented&#160;by&#160;integer&#160;objects.&#160;They&#160;are&#160;a&#160;special&#160;kind&#160;of<br/>method&#160;known&#160;as&#160;an&#160;<i>iterator</i>,&#160;and&#160;they&#160;behave&#160;like&#160;loops.&#160;The&#160;code&#160;within&#160;curly&#160;braces<br/>—known&#160;as&#160;a&#160;<i>block</i>—is&#160;associated&#160;with&#160;the&#160;method&#160;invocation&#160;and&#160;serves&#160;as&#160;the&#160;body<br/>of&#160;the&#160;loop.&#160;The&#160;use&#160;of&#160;iterators&#160;and&#160;blocks&#160;is&#160;another&#160;notable&#160;feature&#160;of&#160;Ruby;&#160;although<br/>the&#160;language&#160;does&#160;support&#160;an&#160;ordinary&#160;while&#160;loop,&#160;it&#160;is&#160;more&#160;common&#160;to&#160;perform&#160;loops<br/>with constructs that are actually method calls.<br/>Integers&#160;are&#160;not&#160;the&#160;only&#160;values&#160;that&#160;have&#160;iterator&#160;methods.&#160;Arrays&#160;(and&#160;similar&#160;“enu-<br/>merable”&#160;objects)&#160;define&#160;an&#160;iterator&#160;named&#160;each,&#160;which&#160;invokes&#160;the&#160;associated&#160;block<br/>once&#160;for&#160;each&#160;element&#160;in&#160;the&#160;array.&#160;Each&#160;invocation&#160;of&#160;the&#160;block&#160;is&#160;passed&#160;a&#160;single<br/>element from the array:<br/>
a = [3, 2, 1] &#160; &#160; # This is an array literal<br/>a[3] = a[2] - 1 &#160; # Use square brackets to query and set array elements<br/>a.each do |elt| &#160; # each is an iterator. The block has a parameter elt<br/>&#160; print elt+1 &#160; &#160; # Prints &#34;4321&#34;<br/>end &#160; &#160; &#160; &#160; &#160; &#160; &#160; # This block was delimited with do/end instead of {}<br/>
Various other useful iterators are defined on top of&#160;each:<br/>
a = [1,2,3,4] &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Start with an array<br/>b = a.map {|x| x*x } &#160; &#160; &#160; &#160; # Square elements: b is [1,4,9,16]<br/>c = a.select {|x| x%2==0 } &#160; # Select even elements: c is [2,4]<br/>a.inject do |sum,x| &#160; &#160; &#160; &#160; &#160;# Compute the sum of the elements =&gt; 10<br/>&#160; sum + x&#160;<br/>end<br/>
Hashes,&#160;like&#160;arrays,&#160;are&#160;a&#160;fundamental&#160;data&#160;structure&#160;in&#160;Ruby.&#160;As&#160;their&#160;name&#160;implies,<br/>they&#160;are&#160;based&#160;on&#160;the&#160;hashtable&#160;data&#160;structure&#160;and&#160;serve&#160;to&#160;map&#160;arbitrary&#160;key&#160;objects<br/>to&#160;value&#160;objects.&#160;(To&#160;put&#160;this&#160;another&#160;way,&#160;we&#160;can&#160;say&#160;that&#160;a&#160;hash&#160;associates&#160;arbitrary<br/>
<b>1.1 &#160;A Tour of Ruby&#160;|&#160;3</b><br/>
<hr/>
<a name=18></a>value&#160;objects&#160;with&#160;key&#160;objects.)&#160;Hashes&#160;use&#160;square&#160;brackets,&#160;like&#160;arrays&#160;do,&#160;to&#160;query<br/>and&#160;set&#160;values&#160;in&#160;the&#160;hash.&#160;Instead&#160;of&#160;using&#160;an&#160;integer&#160;index,&#160;they&#160;expect&#160;key&#160;objects<br/>within&#160;the&#160;square&#160;brackets.&#160;Like&#160;the&#160;Array&#160;class,&#160;the&#160;Hash&#160;class&#160;also&#160;defines&#160;an&#160;each<br/>iterator&#160;method.&#160;This&#160;method&#160;invokes&#160;the&#160;associated&#160;block&#160;of&#160;code&#160;once&#160;for&#160;each&#160;key/<br/>value&#160;pair&#160;in&#160;the&#160;hash,&#160;and&#160;(this&#160;is&#160;where&#160;it&#160;differs&#160;from&#160;Array)&#160;passes&#160;both&#160;the&#160;key&#160;and<br/>the value as parameters to the block:<br/>
h = { &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # A hash that maps number names to digits<br/>&#160; :one =&gt; 1, &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# The &#34;arrows&#34; show mappings: key=&gt;value<br/>&#160; :two =&gt; 2 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # The colons indicate Symbol literals<br/>} &#160;<br/>h[:one] &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; 1. &#160;Access a value by key<br/>h[:three] = 3 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Add a new key/value pair to the hash<br/>h.each do |key,value| &#160; &#160; &#160; &#160; # Iterate through the key/value pairs<br/>&#160; print &#34;#{value}:#{key}; &#34; &#160; # Note variables substituted into string&#160;<br/>end &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Prints &#34;1:one; 2:two; 3:three; &#34;<br/>
Ruby’s hashes can use any object as a key, but&#160;Symbol&#160;objects&#160;are the most commonly<br/>used.&#160;&#160;Symbols&#160;&#160;are&#160;&#160;immutable,&#160;&#160;interned&#160;&#160;strings.&#160;&#160;They&#160;&#160;can&#160;&#160;be&#160;&#160;compared&#160;&#160;by&#160;&#160;identity<br/>rather&#160;than&#160;by&#160;textual&#160;content&#160;(because&#160;two&#160;distinct&#160;Symbol&#160;objects&#160;will&#160;never&#160;have&#160;the<br/>same content).<br/>The&#160;ability&#160;to&#160;associate&#160;a&#160;block&#160;of&#160;code&#160;with&#160;a&#160;method&#160;invocation&#160;is&#160;a&#160;fundamental&#160;and<br/>very&#160;powerful&#160;feature&#160;of&#160;Ruby.&#160;Although&#160;its&#160;most&#160;obvious&#160;use&#160;is&#160;for&#160;loop-like&#160;constructs,<br/>it is also useful for methods that only invoke the block once. For example:<br/>
File.open(&#34;data.txt&#34;) do |f| # Open named file and pass stream to block<br/>&#160; line = f.readline &#160; &#160; &#160; &#160; &#160;# Use the stream to read from the file<br/>end &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Stream automatically closed at block end<br/>
t = Thread.new do &#160; &#160; &#160; # Run this block in a new thread<br/>&#160; File.read(&#34;data.txt&#34;) # Read a file in the background<br/>end &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # File contents available as thread value<br/>
As&#160;an&#160;aside,&#160;notice&#160;that&#160;the&#160;Hash.each&#160;example&#160;previously&#160;included&#160;this&#160;interesting&#160;line<br/>of code:<br/>
print &#34;#{value}:#{key}; &#34; &#160; &#160;# Note variables substituted into string&#160;<br/>
Double-quoted&#160;strings&#160;can&#160;include&#160;arbitrary&#160;Ruby&#160;expressions&#160;delimited&#160;by&#160;#{&#160;and&#160;}.<br/>The&#160;value&#160;of&#160;the&#160;expression&#160;within&#160;these&#160;delimiters&#160;is&#160;converted&#160;to&#160;a&#160;string&#160;(by&#160;calling<br/>its&#160;to_s&#160;method,&#160;which&#160;is&#160;supported&#160;by&#160;all&#160;objects).&#160;The&#160;resulting&#160;string&#160;is&#160;then&#160;used&#160;to<br/>replace&#160;the&#160;expression&#160;text&#160;and&#160;its&#160;delimiters&#160;in&#160;the&#160;string&#160;literal.&#160;This&#160;substitution&#160;of<br/>expression values into strings is usually called&#160;<i>string interpolation</i>.<br/>
<b>1.1.3 &#160;Expressions and Operators in Ruby<br/></b>Ruby’s&#160;syntax&#160;is&#160;expression-oriented.&#160;Control&#160;structures&#160;such&#160;as&#160;if&#160;that&#160;would&#160;be&#160;called<br/>statements&#160;in&#160;other&#160;languages&#160;are&#160;actually&#160;expressions&#160;in&#160;Ruby.&#160;They&#160;have&#160;values&#160;like<br/>other simpler expressions do, and we can write code like this:<br/>
minimum = if x &lt; y then x else y end<br/>
<b>4&#160;|&#160;Chapter 1:</b> <b>Introduction</b><br/>
<hr/>
<a name=19></a>Although&#160;&#160;all&#160;&#160;“statements”&#160;&#160;in&#160;&#160;Ruby&#160;&#160;are&#160;&#160;actually&#160;&#160;expressions,&#160;&#160;they&#160;&#160;do&#160;&#160;not&#160;&#160;all&#160;&#160;return<br/>meaningful&#160;values.&#160;while&#160;loops&#160;and&#160;method&#160;definitions,&#160;for&#160;example,&#160;are&#160;expressions<br/>that normally return the value&#160;nil.<br/>As&#160;in&#160;most&#160;languages,&#160;expressions&#160;in&#160;Ruby&#160;are&#160;usually&#160;built&#160;out&#160;of&#160;values&#160;and&#160;operators.<br/>For&#160;the&#160;most&#160;part,&#160;Ruby’s&#160;operators&#160;will&#160;be&#160;familiar&#160;to&#160;anyone&#160;who&#160;knows&#160;C,&#160;Java,<br/>JavaScript,&#160;&#160;or&#160;&#160;any&#160;&#160;similar&#160;&#160;programming&#160;&#160;language.&#160;&#160;Here&#160;&#160;are&#160;&#160;examples&#160;&#160;of&#160;&#160;some<br/>commonplace and some more unusual Ruby operators:<br/>
1 + 2 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; 3: addition<br/>1 * 2 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; 2: multiplication<br/>1 + 2 == 3 &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; true: == tests equality<br/>2 ** 1024 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# 2 to the power 1024: Ruby has arbitrary size ints<br/>&#34;Ruby&#34; + &#34; rocks!&#34; &#160; &#160; &#160; # =&gt; &#34;Ruby rocks!&#34;: string concatenation<br/>&#34;Ruby! &#34; * 3 &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; &#34;Ruby! Ruby! Ruby! &#34;: string repetition<br/>&#34;%d %s&#34; % [3, &#34;rubies&#34;] &#160;# =&gt; &#34;3 rubies&#34;: Python-style, printf formatting<br/>max = x &gt; y ? x : y &#160; &#160; &#160;# The conditional operator<br/>
Many&#160;of&#160;Ruby’s&#160;operators&#160;are&#160;implemented&#160;as&#160;methods,&#160;and&#160;classes&#160;can&#160;define&#160;(or<br/>redefine)&#160;these&#160;methods&#160;however&#160;they&#160;want.&#160;(They&#160;can’t&#160;define&#160;completely&#160;new&#160;oper-<br/>ators,&#160;however;&#160;there&#160;is&#160;only&#160;a&#160;fixed&#160;set&#160;of&#160;recognized&#160;operators.)&#160;As&#160;examples,&#160;notice<br/>that&#160;the&#160;+&#160;and&#160;*&#160;operators&#160;behave&#160;differently&#160;for&#160;integers&#160;and&#160;strings.&#160;And&#160;you&#160;can&#160;define<br/>these&#160;operators&#160;any&#160;way&#160;you&#160;want&#160;in&#160;your&#160;own&#160;classes.&#160;The&#160;&lt;&lt;&#160;operator&#160;is&#160;another&#160;good<br/>example.&#160;The&#160;integer&#160;classes&#160;Fixnum&#160;and&#160;Bignum&#160;use&#160;this&#160;operator&#160;for&#160;the&#160;bitwise&#160;left-<br/>shift&#160;operation,&#160;following&#160;the&#160;C&#160;programming&#160;language.&#160;At&#160;the&#160;same&#160;time&#160;(following<br/>C++),&#160;other&#160;classes—such&#160;as&#160;strings,&#160;arrays,&#160;and&#160;streams—use&#160;this&#160;operator&#160;for&#160;an<br/>append&#160;operation.&#160;If&#160;you&#160;create&#160;a&#160;new&#160;class&#160;that&#160;can&#160;have&#160;values&#160;appended&#160;to&#160;it&#160;in&#160;some<br/>way, it is a very good idea to define&#160;&lt;&lt;.<br/>One&#160;of&#160;the&#160;most&#160;powerful&#160;operators&#160;to&#160;override&#160;is&#160;[].&#160;The&#160;Array&#160;and&#160;Hash&#160;classes&#160;use<br/>this&#160;operator&#160;to&#160;access&#160;array&#160;elements&#160;by&#160;index&#160;and&#160;hash&#160;values&#160;by&#160;key.&#160;But&#160;you&#160;can<br/>define&#160;[]&#160;in&#160;your&#160;classes&#160;for&#160;any&#160;purpose&#160;you&#160;want.&#160;You&#160;can&#160;even&#160;define&#160;it&#160;as&#160;a&#160;method<br/>that&#160;expects&#160;multiple&#160;arguments,&#160;comma-separated&#160;between&#160;the&#160;square&#160;brackets.&#160;(The<br/>Array&#160;class&#160;accepts&#160;an&#160;index&#160;and&#160;a&#160;length&#160;between&#160;the&#160;square&#160;brackets&#160;to&#160;indicate&#160;a<br/>subarray&#160;or&#160;“slice”&#160;of&#160;the&#160;array.)&#160;And&#160;if&#160;you&#160;want&#160;to&#160;allow&#160;square&#160;brackets&#160;to&#160;be&#160;used<br/>on&#160;the&#160;lefthand&#160;side&#160;of&#160;an&#160;assignment&#160;expression,&#160;you&#160;can&#160;define&#160;the&#160;corresponding<br/>[]=&#160;operator.&#160;The&#160;value&#160;on&#160;the&#160;righthand&#160;side&#160;of&#160;the&#160;assignment&#160;will&#160;be&#160;passed&#160;as&#160;the<br/>final argument to the method that implements this operator.<br/>
<b>1.1.4 &#160;Methods<br/></b>Methods are defined&#160;with the&#160;def&#160;keyword.&#160;The&#160;return&#160;value&#160;of&#160;a&#160;method&#160;is&#160;the&#160;value<br/>of the last expression evaluated in its body:<br/>
def square(x) &#160; # Define a method named square with one parameter x<br/>&#160; x*x &#160; &#160; &#160; &#160; &#160; # Return x squared<br/>end &#160; &#160; &#160; &#160; &#160; &#160; # End of the method<br/>
<b>1.1 &#160;A Tour of Ruby&#160;|&#160;5</b><br/>
<hr/>
<a name=20></a>When&#160;a&#160;method,&#160;like&#160;the&#160;one&#160;above,&#160;is&#160;defined&#160;outside&#160;of&#160;a&#160;class&#160;or&#160;a&#160;module,&#160;it&#160;is<br/>effectively&#160;a&#160;global&#160;function&#160;rather&#160;than&#160;a&#160;method&#160;to&#160;be&#160;invoked&#160;on&#160;an&#160;object.&#160;(Tech-<br/>nically,&#160;however,&#160;a&#160;method&#160;like&#160;this&#160;becomes&#160;a&#160;private&#160;method&#160;of&#160;the&#160;Object&#160;class.)<br/>Methods&#160;can&#160;also&#160;be&#160;defined&#160;on&#160;individual&#160;objects&#160;by&#160;prefixing&#160;the&#160;name&#160;of&#160;the&#160;method<br/>with&#160;&#160;the&#160;&#160;object&#160;&#160;on&#160;&#160;which&#160;&#160;it&#160;&#160;is&#160;&#160;defined.&#160;&#160;Methods&#160;&#160;like&#160;&#160;these&#160;&#160;are&#160;&#160;known&#160;&#160;as&#160;&#160;<i>single-<br/>tonmethods</i>, and they are how Ruby defines class methods:<br/>
def Math.square(x) &#160;# Define a class method of the Math module<br/>&#160; x*x<br/>end<br/>
The&#160;Math&#160;module&#160;is&#160;part&#160;of&#160;the&#160;core&#160;Ruby&#160;library,&#160;and&#160;this&#160;code&#160;adds&#160;a&#160;new&#160;method&#160;to<br/>it.&#160;This&#160;is&#160;a&#160;key&#160;feature&#160;of&#160;Ruby—classes&#160;and&#160;modules&#160;are&#160;“open”&#160;and&#160;can&#160;be&#160;modified<br/>and extended at runtime.<br/>Method&#160;&#160;parameters&#160;&#160;may&#160;&#160;have&#160;&#160;default&#160;&#160;values&#160;&#160;specified,&#160;&#160;and&#160;&#160;methods&#160;&#160;may&#160;&#160;accept<br/>arbitrary numbers of arguments.<br/>
<b>1.1.5 &#160;Assignment<br/></b>The (nonoverridable)&#160;=&#160;operator in Ruby assigns a value to a variable:<br/>
x = 1<br/>
Assignment can be combined with other operators such as&#160;+&#160;and&#160;-:<br/>
x += 1 &#160; &#160; &#160; &#160; &#160;# Increment x: note Ruby does not have ++.<br/>y -= 1 &#160; &#160; &#160; &#160; &#160;# Decrement y: no -- operator, either.<br/>
Ruby supports&#160;parallel&#160;assignment,&#160;allowing&#160;more&#160;than&#160;one&#160;value&#160;and&#160;more&#160;than&#160;one<br/>variable in assignment expressions:<br/>
x, y = 1, 2 &#160; &#160; # Same as x = 1; y = 2<br/>a, b = b, a &#160; &#160; # Swap the value of two variables<br/>x,y,z = [1,2,3] # Array elements automatically assigned to variables<br/>
Methods&#160;in&#160;Ruby&#160;are&#160;allowed&#160;to&#160;return&#160;more&#160;than&#160;one&#160;value,&#160;and&#160;parallel&#160;assignment<br/>is helpful in conjunction with such methods. For example:<br/>
# Define a method to convert Cartesian (x,y) coordinates to Polar<br/>def polar(x,y)<br/>&#160; theta = Math.atan2(y,x) &#160; # Compute the angle<br/>&#160; r = Math.hypot(x,y) &#160; &#160; &#160; # Compute the distance<br/>&#160; [r, theta] &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# The last expression is the return value<br/>end<br/>
# Here's how we use this method with parallel assignment<br/>distance, angle = polar(2,2)<br/>
Methods&#160;that&#160;end&#160;with&#160;an&#160;equals&#160;sign&#160;(=) are&#160;special&#160;because&#160;Ruby&#160;allows&#160;them&#160;to&#160;be<br/>invoked&#160;&#160;using&#160;&#160;assignment&#160;&#160;syntax.&#160;&#160;If&#160;&#160;an&#160;&#160;object&#160;&#160;o&#160;&#160;has&#160;&#160;a&#160;&#160;method&#160;&#160;named&#160;&#160;x=,&#160;&#160;then&#160;&#160;the<br/>following two lines of code do the very same thing:<br/>
<b>6&#160;|&#160;Chapter 1:</b> <b>Introduction</b><br/>
<hr/>
<a name=21></a>o.x=(1) &#160; &#160; &#160; &#160; # Normal method invocation syntax<br/>o.x = 1 &#160; &#160; &#160; &#160; # Method invocation through assignment<br/>
<b>1.1.6 &#160;Punctuation Suffixes and Prefixes<br/></b>We&#160;saw&#160;previously&#160;that&#160;methods&#160;whose&#160;names&#160;end&#160;with&#160;=&#160;can&#160;be&#160;invoked&#160;by&#160;assignment<br/>expressions.&#160;Ruby&#160;methods&#160;can&#160;also&#160;end&#160;with&#160;a&#160;question&#160;mark&#160;or&#160;an&#160;exclamation&#160;point.<br/>A&#160;question&#160;mark&#160;is&#160;used&#160;to&#160;mark&#160;predicates—methods&#160;that&#160;return&#160;a&#160;Boolean&#160;value.&#160;For<br/>example,&#160;&#160;the&#160;&#160;Array&#160;&#160;and&#160;&#160;Hash&#160;&#160;classes&#160;&#160;both&#160;&#160;define&#160;&#160;methods&#160;&#160;named&#160;&#160;empty?&#160;&#160;that&#160;&#160;test<br/>whether&#160;the&#160;data&#160;structure&#160;has&#160;any&#160;elements.&#160;An&#160;exclamation&#160;mark&#160;at&#160;the&#160;end&#160;of&#160;a<br/>method&#160;name&#160;is&#160;used&#160;to&#160;indicate&#160;that&#160;caution&#160;is&#160;required&#160;with&#160;the&#160;use&#160;of&#160;the&#160;method.<br/>A&#160;number&#160;of&#160;core&#160;Ruby&#160;classes&#160;define&#160;pairs&#160;of&#160;methods&#160;with&#160;the&#160;same&#160;name,&#160;except<br/>that&#160;one&#160;ends&#160;with&#160;an&#160;exclamation&#160;mark&#160;and&#160;one&#160;does&#160;not.&#160;Usually,&#160;the&#160;method&#160;without<br/>the&#160;exclamation&#160;mark&#160;returns&#160;a&#160;modified&#160;copy&#160;of&#160;the&#160;object&#160;it&#160;is&#160;invoked&#160;on,&#160;and&#160;the<br/>one&#160;with&#160;the&#160;exclamation&#160;mark&#160;is&#160;a&#160;mutator&#160;method&#160;that&#160;alters&#160;the&#160;object&#160;in&#160;place.&#160;The<br/>Array&#160;class, for example, defines methods&#160;sort&#160;and&#160;sort!.<br/>
In&#160;addition&#160;to&#160;these&#160;punctuation&#160;characters&#160;at&#160;the&#160;end&#160;of&#160;method&#160;names,&#160;you’ll&#160;notice<br/>punctuation&#160;characters&#160;at&#160;the&#160;start&#160;of&#160;Ruby&#160;variable&#160;names:&#160;global&#160;variables&#160;are&#160;prefixed<br/>with&#160;$,&#160;instance&#160;variables&#160;are&#160;prefixed&#160;with&#160;@,&#160;and&#160;class&#160;variables&#160;are&#160;prefixed&#160;with&#160;@@.<br/>These&#160;prefixes&#160;can&#160;take&#160;a&#160;little&#160;getting&#160;used&#160;to,&#160;but&#160;after&#160;a&#160;while&#160;you&#160;may&#160;come&#160;to<br/>appreciate&#160;the&#160;fact&#160;that&#160;the&#160;prefix&#160;tells&#160;you&#160;the&#160;scope&#160;of&#160;the&#160;variable.&#160;The&#160;prefixes&#160;are<br/>required&#160;in&#160;order&#160;to&#160;disambiguate&#160;Ruby’s&#160;very&#160;flexible&#160;grammar.&#160;One&#160;way&#160;to&#160;think&#160;of<br/>variable&#160;prefixes&#160;is&#160;that&#160;they&#160;are&#160;one&#160;price&#160;we&#160;pay&#160;for&#160;being&#160;able&#160;to&#160;omit&#160;parentheses<br/>around method invocations.<br/>
<b>1.1.7 &#160;Regexp and Range<br/></b>We&#160;mentioned&#160;arrays&#160;and&#160;hashes&#160;earlier&#160;as&#160;fundamental&#160;data&#160;structures&#160;in&#160;Ruby.&#160;We<br/>demonstrated&#160;the&#160;use&#160;of&#160;numbers&#160;and&#160;strings&#160;as&#160;well.&#160;Two&#160;other&#160;datatypes&#160;are&#160;worth<br/>mentioning&#160;here.&#160;A&#160;Regexp&#160;(regular&#160;expression)&#160;object&#160;describes&#160;a&#160;textual&#160;pattern&#160;and<br/>has&#160;methods&#160;for&#160;determining&#160;whether&#160;a&#160;given&#160;string&#160;matches&#160;that&#160;pattern&#160;or&#160;not.&#160;And<br/>a&#160;&#160;Range&#160;&#160;represents&#160;&#160;the&#160;&#160;values&#160;&#160;(usually&#160;&#160;integers)&#160;&#160;between&#160;&#160;two&#160;&#160;endpoints.&#160;&#160;Regular<br/>expressions and ranges have a literal syntax in Ruby:<br/>
/[Rr]uby/ &#160; &#160; &#160; &#160;# Matches &#34;Ruby&#34; or &#34;ruby&#34;<br/>/\d{5}/ &#160; &#160; &#160; &#160; &#160;# Matches 5 consecutive digits<br/>1..3 &#160; &#160; &#160; &#160; &#160; &#160; # All x where 1 &lt;= x &lt;= 3<br/>1...3 &#160; &#160; &#160; &#160; &#160; &#160;# All x where 1 &lt;= x &lt; 3<br/>
Regexp&#160;and&#160;Range&#160;objects&#160;define&#160;the&#160;normal&#160;==&#160;operator&#160;for&#160;testing&#160;equality.&#160;In&#160;addition,<br/>they&#160;also&#160;define&#160;the&#160;===&#160;operator&#160;for&#160;testing&#160;matching&#160;and&#160;membership.&#160;Ruby’s&#160;case<br/>statement (like the&#160;switch&#160;statement of C or Java) matches its expression against each<br/>of&#160;the&#160;possible&#160;cases&#160;using&#160;===,&#160;so&#160;this&#160;operator&#160;is&#160;often&#160;called&#160;the&#160;<i>case equality opera-<br/>tor</i>. It leads to conditional tests like these:<br/>
<b>1.1 &#160;A Tour of Ruby&#160;|&#160;7</b><br/>
<hr/>
<a name=22></a># Determine US generation name based on birth year<br/># Case expression tests ranges with ===<br/>generation = case birthyear<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160;when 1946..1963: &#34;Baby Boomer&#34;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160;when 1964..1976: &#34;Generation X&#34;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160;when 1978..2000: &#34;Generation Y&#34;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160;else nil<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160;end<br/>
# A method to ask the user to confirm something<br/>def are_you_sure? &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Define a method. Note question mark!<br/>&#160; while true &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Loop until we explicitly return<br/>&#160; &#160; print &#34;Are you sure? [y/n]: &#34; &#160;# Ask the user a question<br/>&#160; &#160; response = gets &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Get her answer<br/>&#160; &#160; case response &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Begin case conditional<br/>&#160; &#160; when /^[yY]/ &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # If response begins with y or Y<br/>&#160; &#160; &#160; return true &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Return true from the method<br/>&#160; &#160; when /^[nN]/, /^$/ &#160; &#160; &#160; &#160; &#160; &#160; # If response begins with n,N or is empty<br/>&#160; &#160; &#160; return false &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Return false<br/>&#160; &#160; end<br/>&#160; end<br/>end<br/>
<b>1.1.8 &#160;Classes and Modules<br/></b>A&#160;class&#160;is&#160;a&#160;collection&#160;of&#160;related&#160;methods&#160;that&#160;operate&#160;on&#160;the&#160;state&#160;of&#160;an&#160;object.&#160;An<br/>object’s&#160;state&#160;is&#160;held&#160;by&#160;its&#160;instance&#160;variables:&#160;variables&#160;whose&#160;names&#160;begin&#160;with&#160;@&#160;and<br/>whose&#160;values&#160;are&#160;specific&#160;to&#160;that&#160;particular&#160;object.&#160;The&#160;following&#160;code&#160;defines&#160;an&#160;ex-<br/>ample&#160;&#160;class&#160;&#160;named&#160;&#160;Sequence&#160;&#160;and&#160;&#160;demonstrates&#160;&#160;how&#160;&#160;to&#160;&#160;write&#160;&#160;iterator&#160;&#160;methods&#160;&#160;and<br/>define operators:<br/>
#<br/># This class represents a sequence of numbers characterized by the three<br/># parameters from, to, and by. The numbers x in the sequence obey the<br/># following two constraints:<br/>#<br/># &#160; &#160;from &lt;= x &lt;= to<br/># &#160; &#160;x = from + n*by, where n is an integer<br/>#&#160;<br/>class Sequence<br/>&#160; # This is an enumerable class; it defines an each iterator below.<br/>&#160; include Enumerable &#160; # Include the methods of this module in this class<br/>
&#160; # The initialize method is special; it is automatically invoked to<br/>&#160; # initialize newly created instances of the class<br/>&#160; def initialize(from, to, by)<br/>&#160; &#160; # Just save our parameters into instance variables for later use<br/>&#160; &#160; @from, @to, @by = from, to, by &#160;# Note parallel assignment and @ prefix<br/>&#160; end<br/>
&#160; # This is the iterator required by the Enumerable module<br/>&#160; def each<br/>&#160; &#160; x = @from &#160; &#160; &#160; # Start at the starting point<br/>&#160; &#160; while x &lt;= @to &#160;# While we haven't reached the end<br/>
<b>8&#160;|&#160;Chapter 1:</b> <b>Introduction</b><br/>
<hr/>
<a name=23></a>&#160; &#160; &#160; yield x &#160; &#160; &#160; # Pass x to the block associated with the iterator<br/>&#160; &#160; &#160; x += @by &#160; &#160; &#160;# Increment x<br/>&#160; &#160; end<br/>&#160; end<br/>
&#160; # Define the length method (following arrays) to return the number of<br/>&#160; # values in the sequence<br/>&#160; def length<br/>&#160; &#160; return 0 if @from &gt; @to &#160; &#160; &#160; # Note if used as a statement modifier&#160;<br/>&#160; &#160; Integer((@to-@from)/@by) + 1 &#160;# Compute and return length of sequence<br/>&#160; end<br/>
&#160; # Define another name for the same method.<br/>&#160; # It is common for methods to have multiple names in Ruby<br/>&#160; alias size length &#160;# size is now a synonym for length<br/>
&#160; # Override the array-access operator to give random access to the sequence<br/>&#160; def[](index)<br/>&#160; &#160; return nil if index &lt; 0 # Return nil for negative indexes<br/>&#160; &#160; v = @from + index*@by &#160; # Compute the value<br/>&#160; &#160; if v &lt;= @to &#160; &#160; &#160; &#160; &#160; &#160; # If it is part of the sequence<br/>&#160; &#160; &#160; v &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Return it<br/>&#160; &#160; else &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Otherwise...<br/>&#160; &#160; &#160; nil &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Return nil<br/>&#160; &#160; end<br/>&#160; end<br/>
&#160; # Override arithmetic operators to return new Sequence objects<br/>&#160; def *(factor)<br/>&#160; &#160; Sequence.new(@from*factor, @to*factor, @by*factor)<br/>&#160; end<br/>
&#160; def +(offset)<br/>&#160; &#160; Sequence.new(@from+offset, @to+offset, @by)<br/>&#160; end<br/>end<br/>
Here is some code that uses this&#160;Sequence&#160;class:<br/>
s = Sequence.new(1, 10, 2) &#160;# From 1 to 10 by 2's<br/>s.each {|x| print x } &#160; &#160; &#160; # Prints &#34;13579&#34;<br/>print s[s.size-1] &#160; &#160; &#160; &#160; &#160; # Prints 9<br/>t = (s+1)*2 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # From 4 to 22 by 4's<br/>
The&#160;key&#160;feature&#160;of&#160;our&#160;Sequence&#160;class&#160;is&#160;its&#160;each&#160;iterator.&#160;If&#160;we&#160;are&#160;only&#160;interested&#160;in&#160;the<br/>iterator&#160;method,&#160;there&#160;is&#160;no&#160;need&#160;to&#160;define&#160;the&#160;whole&#160;class.&#160;Instead,&#160;we&#160;can&#160;simply&#160;write<br/>an&#160;iterator&#160;method&#160;that&#160;accepts&#160;the&#160;from,&#160;to,&#160;and&#160;by&#160;parameters.&#160;Instead&#160;of&#160;making&#160;this<br/>a global function, let’s define it in a module of its own:<br/>
module Sequences &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Begin a new module<br/>&#160; def self.fromtoby(from, to, by) &#160;# A singleton method of the module<br/>&#160; &#160; x = from<br/>&#160; &#160; while x &lt;= to<br/>&#160; &#160; &#160; yield x<br/>&#160; &#160; &#160; x += by<br/>&#160; &#160; end<br/>
<b>1.1 &#160;A Tour of Ruby&#160;|&#160;9</b><br/>
<hr/>
<a name=24></a>&#160; end<br/>end<br/>
With the iterator defined this way, we write code like this:<br/>
Sequences.fromtoby(1, 10, 2) {|x| print x } &#160;# Prints &#34;13579&#34;<br/>
An&#160;&#160;iterator&#160;&#160;like&#160;&#160;this&#160;&#160;makes&#160;&#160;it&#160;&#160;unnecessary&#160;&#160;to&#160;&#160;create&#160;&#160;a&#160;&#160;Sequence&#160;&#160;object&#160;&#160;to&#160;&#160;iterate&#160;&#160;a<br/>sequence&#160;of&#160;numbers.&#160;But&#160;the&#160;name&#160;of&#160;the&#160;method&#160;is&#160;quite&#160;long,&#160;and&#160;its&#160;invocation<br/>syntax&#160;is&#160;unsatisfying.&#160;What&#160;we&#160;really&#160;want&#160;is&#160;a&#160;way&#160;to&#160;iterate&#160;numeric&#160;Range&#160;objects<br/>by&#160;steps&#160;other&#160;than&#160;1.&#160;One&#160;of&#160;the&#160;amazing&#160;features&#160;of&#160;Ruby&#160;is&#160;that&#160;its&#160;classes,&#160;even&#160;the<br/>built-in&#160;core&#160;classes,&#160;are&#160;<i>open</i>:&#160;any&#160;program&#160;can&#160;add&#160;methods&#160;to&#160;them.&#160;So&#160;we&#160;really&#160;can<br/>define a new iterator method for ranges:<br/>
class Range &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Open an existing class for additions<br/>&#160; def by(step) &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Define an iterator named by<br/>&#160; &#160; x = self.begin &#160; &#160; &#160; &#160; &#160; # Start at one endpoint of the range<br/>&#160; &#160; if exclude_end? &#160; &#160; &#160; &#160; &#160;# For ... ranges that exclude the end<br/>&#160; &#160; &#160; while x &lt; self.end &#160; &#160; # Test with the &lt; operator<br/>&#160; &#160; &#160; &#160; yield x<br/>&#160; &#160; &#160; &#160; x += step<br/>&#160; &#160; &#160; end<br/>&#160; &#160; else &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Otherwise, for .. ranges that include the end<br/>&#160; &#160; &#160; while x &lt;= self.end &#160; &#160;# Test with &lt;= operator<br/>&#160; &#160; &#160; &#160; yield x<br/>&#160; &#160; &#160; &#160; x += step<br/>&#160; &#160; &#160; end<br/>&#160; &#160; end<br/>&#160; end &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# End of method definition<br/>end &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# End of class modification<br/>
# Examples<br/>(0..10).by(2) {|x| print x} &#160;# Prints &#34;0246810&#34;<br/>(0...10).by(2) {|x| print x} # Prints &#34;02468&#34;<br/>
This&#160;by&#160;method&#160;is&#160;convenient&#160;but&#160;unnecessary;&#160;the&#160;Range&#160;class&#160;already&#160;defines&#160;an&#160;iterator<br/>named&#160;step&#160;that&#160;serves&#160;the&#160;same&#160;purpose.&#160;The&#160;core&#160;Ruby&#160;API&#160;is&#160;a&#160;rich&#160;one,&#160;and&#160;it&#160;is<br/>worth&#160;&#160;taking&#160;&#160;the&#160;&#160;time&#160;&#160;to&#160;&#160;study&#160;&#160;the&#160;&#160;platform&#160;&#160;(see&#160;&#160;<a href="Rubys.html#317">Chapter&#160;&#160;9)&#160;&#160;</a>so&#160;&#160;you&#160;&#160;don’t&#160;&#160;end&#160;&#160;up<br/>spending time writing methods that have already been implemented for you!<br/>
<b>1.1.9 &#160;Ruby Surprises<br/></b>Every&#160;language&#160;has&#160;features&#160;that&#160;trip&#160;up&#160;programmers&#160;who&#160;are&#160;new&#160;to&#160;the&#160;language.<br/>Here we describe two of Ruby’s surprising features.<br/>Ruby’s&#160;strings&#160;are&#160;mutable,&#160;which&#160;may&#160;be&#160;surprising&#160;to&#160;Java&#160;programmers&#160;in&#160;particular.<br/>The&#160;[]=&#160;operator&#160;allows&#160;you&#160;to&#160;alter&#160;the&#160;characters&#160;of&#160;a&#160;string&#160;or&#160;to&#160;insert,&#160;delete,&#160;and<br/>replace&#160;substrings.&#160;The&#160;&lt;&lt;&#160;operator&#160;allows&#160;you&#160;to&#160;append&#160;to&#160;a&#160;string,&#160;and&#160;the&#160;String<br/>class&#160;defines&#160;various&#160;other&#160;methods&#160;that&#160;alter&#160;strings&#160;in&#160;place.&#160;Because&#160;strings&#160;are&#160;mu-<br/>table,&#160;string&#160;literals&#160;in&#160;a&#160;program&#160;are&#160;not&#160;unique&#160;objects.&#160;If&#160;you&#160;include&#160;a&#160;string&#160;literal<br/>within&#160;&#160;a&#160;&#160;loop,&#160;&#160;it&#160;&#160;evaluates&#160;&#160;to&#160;&#160;a&#160;&#160;new&#160;&#160;object&#160;&#160;on&#160;&#160;each&#160;&#160;iteration&#160;&#160;of&#160;&#160;the&#160;&#160;loop.&#160;&#160;Call&#160;&#160;the<br/>
<b>10&#160;|&#160;Chapter 1:</b> <b>Introduction</b><br/>
<hr/>
<a name=25></a>freeze&#160;method&#160;on&#160;a&#160;string&#160;(or&#160;on&#160;any&#160;object)&#160;to&#160;prevent&#160;any&#160;future&#160;modifications&#160;to<br/>that object.<br/>Ruby’s&#160;conditionals&#160;and&#160;loops&#160;(such&#160;as&#160;if&#160;and&#160;while)&#160;evaluate&#160;conditional&#160;expressions<br/>to&#160;determine&#160;which&#160;branch&#160;to&#160;evaluate&#160;or&#160;whether&#160;to&#160;continue&#160;looping.&#160;Conditional<br/>expressions&#160;often&#160;evaluate&#160;to&#160;true&#160;or&#160;false,&#160;but&#160;this&#160;is&#160;not&#160;required.&#160;The&#160;value&#160;of&#160;nil&#160;is<br/>treated&#160;the&#160;same&#160;as&#160;false,&#160;and&#160;<i>any&#160;other&#160;value&#160;is&#160;the&#160;same&#160;as</i>&#160;true.&#160;This&#160;is&#160;likely&#160;to<br/>surprise&#160;C&#160;programmers&#160;who&#160;expect&#160;0&#160;to&#160;work&#160;like&#160;false,&#160;and&#160;JavaScript&#160;programmers<br/>who expect the empty string&#160;&#34;&#34;&#160;to be the same as&#160;false.<br/>
<b>1.2 &#160;Try Ruby<br/></b>We&#160;hope&#160;our&#160;tour&#160;of&#160;Ruby’s&#160;key&#160;features&#160;has&#160;piqued&#160;your&#160;interest&#160;and&#160;you&#160;are&#160;eager&#160;to<br/>try&#160;Ruby&#160;out.&#160;To&#160;do&#160;that,&#160;you’ll&#160;need&#160;a&#160;Ruby&#160;interpreter,&#160;and&#160;you’ll&#160;also&#160;want&#160;to&#160;know<br/>how&#160;to&#160;use&#160;three&#160;tools—<i>irb</i>,&#160;<i>ri</i>,&#160;and&#160;<i>gem</i>—that&#160;are&#160;bundled&#160;with&#160;the&#160;interpreter.&#160;This<br/>section explains how to get and use them.<br/>
<b>1.2.1 &#160;The Ruby Interpreter<br/></b>The&#160;&#160;official&#160;&#160;web&#160;&#160;site&#160;&#160;for&#160;&#160;Ruby&#160;&#160;is&#160;&#160;<a href="http://www.ruby-lang.org"><i>http://www.ruby-lang.org</i></a>.&#160;&#160;If&#160;&#160;Ruby&#160;&#160;is&#160;&#160;not&#160;&#160;already<br/>installed&#160;on&#160;your&#160;computer,&#160;you&#160;can&#160;follow&#160;the&#160;download&#160;link&#160;on&#160;the&#160;<a href="http://ruby-lang.org">ruby-lang.org<br/>(<i>http://ruby-lang.org</i></a>)&#160;home&#160;page&#160;for&#160;instructions&#160;on&#160;downloading&#160;and&#160;installing&#160;the<br/>standard C-based reference implementation of Ruby.<br/>Once&#160;&#160;you&#160;&#160;have&#160;&#160;Ruby&#160;&#160;installed,&#160;&#160;you&#160;&#160;can&#160;&#160;invoke&#160;&#160;the&#160;&#160;Ruby&#160;&#160;interpreter&#160;&#160;with&#160;&#160;the&#160;&#160;ruby<br/>command:<br/>
% ruby -e 'puts &#34;hello world!&#34;'<br/>
&#160;<br/>
hello world!<br/>
The&#160;-e&#160;command-line&#160;option&#160;causes&#160;the&#160;interpreter&#160;to&#160;execute&#160;a&#160;single&#160;specified&#160;line&#160;of<br/>Ruby&#160;code.&#160;More&#160;commonly,&#160;you’d&#160;place&#160;your&#160;Ruby&#160;program&#160;in&#160;a&#160;file&#160;and&#160;tell&#160;the<br/>interpreter to invoke it:<br/>
% ruby hello.rb<br/>hello world!<br/>
<b>Other Ruby Implementations</b><br/>
In&#160;the&#160;absence&#160;of&#160;a&#160;formal&#160;specification&#160;for&#160;the&#160;Ruby&#160;language,&#160;the&#160;Ruby&#160;interpreter<br/>from&#160;<a href="http://ruby-lang.org">ruby-lang.org (<i>http://ruby-lang.org</i></a>)&#160;is&#160;the&#160;reference&#160;implementation&#160;that&#160;defines<br/>the&#160;language.&#160;It&#160;is&#160;sometimes&#160;known&#160;as&#160;MRI,&#160;or&#160;“Matz’s&#160;Ruby&#160;Implementation.”&#160;For<br/>Ruby&#160;1.9,&#160;the&#160;original&#160;MRI&#160;interpreter&#160;was&#160;merged&#160;with&#160;YARV&#160;(“Yet&#160;Another&#160;Ruby<br/>Virtual&#160;machine”)&#160;to&#160;produce&#160;a&#160;new&#160;reference&#160;implementation&#160;that&#160;performs&#160;internal<br/>compilation to bytecode and then executes that bytecode on a virtual machine.<br/>
The&#160;reference&#160;implementation&#160;is&#160;not&#160;the&#160;only&#160;one&#160;available,&#160;however.&#160;At&#160;the&#160;time&#160;of<br/>this&#160;writing,&#160;there&#160;is&#160;one&#160;alternative&#160;implementation&#160;(JRuby)&#160;released&#160;and&#160;several&#160;other<br/>implementations under development:<br/>
<b>1.2 &#160;Try Ruby&#160;|&#160;11</b><br/>
<hr/>
<a name=26></a><i>JRuby</i><br/>
JRuby&#160;is&#160;a&#160;Java-based&#160;implementation&#160;of&#160;Ruby,&#160;available&#160;<a href="http://jruby.org">from&#160;<i>http://jruby.org</i></a>. At<br/>the&#160;time&#160;of&#160;this&#160;writing,&#160;the&#160;current&#160;release&#160;is&#160;JRuby&#160;1.1,&#160;which&#160;is&#160;compatible&#160;with<br/>Ruby&#160;1.8.&#160;A&#160;1.9-compatible&#160;release&#160;of&#160;JRuby&#160;may&#160;be&#160;available&#160;by&#160;the&#160;time&#160;you&#160;read<br/>this. JRuby is open source software, developed primarily at Sun Microsystems.<br/>
<i>IronRuby</i><br/>
IronRuby&#160;is&#160;Microsoft’s&#160;implementation&#160;of&#160;Ruby&#160;for&#160;their&#160;.NET&#160;framework&#160;and<br/>DLR&#160;(Dynamic&#160;Language&#160;Runtime).&#160;The&#160;source&#160;code&#160;for&#160;IronRuby&#160;is&#160;available<br/>under&#160;the&#160;Microsoft&#160;Permissive&#160;License.&#160;At&#160;the&#160;time&#160;of&#160;this&#160;writing,&#160;IronRuby&#160;is<br/><a href="http://www.ironruby.net">not yet at a 1.0 release level. The project home page is&#160;<i>http://www.ironruby.net</i>.</a><br/>
<i>Rubinius</i><br/>
Rubinius&#160;is&#160;an&#160;open&#160;source&#160;project&#160;that&#160;describes&#160;itself&#160;as&#160;“an&#160;alternative&#160;Ruby<br/>implementation&#160;written&#160;largely&#160;in&#160;Ruby.&#160;The&#160;Rubinius&#160;virtual&#160;machine,&#160;named<br/>shotgun,&#160;is&#160;based&#160;loosely&#160;on&#160;the&#160;Smalltalk-80&#160;VM&#160;architecture.”&#160;At&#160;the&#160;time&#160;of&#160;this<br/>writing,&#160;Rubinius&#160;is&#160;not&#160;at&#160;version&#160;1.0.&#160;The&#160;home&#160;page&#160;for&#160;the&#160;Rubinius&#160;project&#160;is<br/><a href="http://rubini.us"><i>http://rubini.us</i>.</a><br/>
<i>Cardinal</i><br/>
Cardinal&#160;is&#160;a&#160;Ruby&#160;implementation&#160;intended&#160;to&#160;run&#160;on&#160;the&#160;Parrot&#160;VM&#160;(which&#160;aims<br/>to&#160;power&#160;Perl&#160;6&#160;and&#160;a&#160;number&#160;of&#160;other&#160;dynamic&#160;languages).&#160;At&#160;the&#160;time&#160;of&#160;this<br/>writing,&#160;neither&#160;Parrot&#160;nor&#160;Cardinal&#160;have&#160;released&#160;a&#160;1.0&#160;version.&#160;Cardinal&#160;does&#160;not<br/>have&#160;its&#160;own&#160;home&#160;page;&#160;it&#160;is&#160;hosted&#160;as&#160;part&#160;of&#160;the&#160;open&#160;source&#160;Parrot&#160;project&#160;at<br/><a href="http://www.parrotcode.org"><i>http://www.parrotcode.org</i></a>.<br/>
<b>1.2.2 &#160;Displaying Output<br/></b>In&#160;order&#160;to&#160;try&#160;out&#160;Ruby&#160;features,&#160;you&#160;need&#160;a&#160;way&#160;to&#160;display&#160;output&#160;so&#160;that&#160;your&#160;test<br/>programs&#160;can&#160;print&#160;their&#160;results.&#160;The&#160;puts&#160;function—used&#160;in&#160;the&#160;“hello&#160;world”&#160;code<br/>earlier—is&#160;one&#160;way&#160;to&#160;do&#160;this.&#160;Loosely&#160;speaking,&#160;puts&#160;prints&#160;a&#160;string&#160;of&#160;text&#160;to&#160;the<br/>console&#160;and&#160;appends&#160;a&#160;newline&#160;(unless&#160;the&#160;string&#160;already&#160;ends&#160;with&#160;one).&#160;If&#160;passed&#160;an<br/>object&#160;that&#160;is&#160;not&#160;a&#160;string,&#160;puts&#160;calls&#160;the&#160;to_s&#160;method&#160;of&#160;that&#160;object&#160;and&#160;prints&#160;the&#160;string<br/>returned&#160;by&#160;that&#160;method.&#160;print&#160;does&#160;more&#160;or&#160;less&#160;the&#160;same&#160;thing,&#160;but&#160;it&#160;does&#160;not&#160;append<br/>a newline.&#160;For&#160;example,&#160;type&#160;the&#160;following&#160;two-line&#160;program&#160;in&#160;a&#160;text&#160;editor&#160;and&#160;save<br/>it in a file named&#160;<i>count.rb</i>:<br/>
9.downto(1) {|n| print n } &#160; # No newline between numbers<br/>puts &#34; blastoff!&#34; &#160; &#160; &#160; &#160; &#160; &#160;# End with a newline<br/>
Now run the program with your Ruby interpreter:<br/>
% ruby count.rb<br/>
It should produce the following output:<br/>
987654321 blastoff!<br/>
You may find the function&#160;p&#160;to be a useful alternative to&#160;puts. Not only is it shorter to<br/>type,&#160;&#160;but&#160;&#160;it&#160;&#160;converts&#160;&#160;objects&#160;&#160;to&#160;&#160;strings&#160;&#160;with&#160;&#160;the&#160;&#160;inspect&#160;&#160;method,&#160;&#160;which&#160;&#160;sometimes<br/>
<b>12&#160;|&#160;Chapter 1:</b> <b>Introduction</b><br/>
<hr/>
<a name=27></a>returns&#160;more&#160;programmer-friendly&#160;representations&#160;than&#160;to_s&#160;does.&#160;When&#160;printing&#160;an<br/>array,&#160;for&#160;example,&#160;p&#160;outputs&#160;it&#160;using&#160;array&#160;literal&#160;notation,&#160;whereas&#160;puts&#160;simply&#160;prints<br/>each element of the array on a line by itself.<br/>
<b>1.2.3 &#160;Interactive Ruby with irb<br/></b><i>irb</i>&#160;&#160;(short&#160;&#160;for&#160;&#160;“interactive&#160;&#160;Ruby”)&#160;&#160;is&#160;&#160;a&#160;&#160;Ruby&#160;&#160;shell.&#160;&#160;Type&#160;&#160;any&#160;&#160;Ruby&#160;&#160;expression&#160;&#160;at&#160;&#160;its<br/>prompt&#160;and&#160;it&#160;will&#160;evaluate&#160;it&#160;and&#160;display&#160;its&#160;value&#160;for&#160;you.&#160;This&#160;is&#160;often&#160;the&#160;easiest&#160;way<br/>to&#160;try&#160;out&#160;the&#160;language&#160;features&#160;you&#160;read&#160;about&#160;in&#160;this&#160;book.&#160;Here&#160;is&#160;an&#160;example&#160;<i>irb<br/></i>session, with annotations:<br/>
$ irb --simple-prompt &#160; &#160; &#160; # Start irb from the terminal<br/>&gt;&gt; 2**3 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Try exponentiation<br/>=&gt; 8 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# This is the result<br/>&gt;&gt; &#34;Ruby! &#34; * 3 &#160; &#160; &#160; &#160; &#160; &#160; # Try string repetition<br/>=&gt; &#34;Ruby! Ruby! Ruby! &#34; &#160; &#160; # The result<br/>&gt;&gt; 1.upto(3){|x| puts x } &#160; # Try an iterator<br/>1 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Three lines of output&#160;<br/>2 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Because we called puts 3 times<br/>3<br/>=&gt; 1 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# The return value of 1.upto(3)<br/>&gt;&gt; quit &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Exit irb<br/>$ &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Back to the terminal prompt<br/>
This&#160;example&#160;session&#160;shows&#160;you&#160;all&#160;you&#160;need&#160;to&#160;know&#160;about&#160;<i>irb</i>&#160;to&#160;make&#160;productive<br/>use&#160;of&#160;it&#160;while&#160;exploring&#160;Ruby.&#160;It&#160;does&#160;have&#160;a&#160;number&#160;of&#160;other&#160;important&#160;features,<br/>however,&#160;&#160;including&#160;&#160;subshells&#160;&#160;(type&#160;&#160;“irb”&#160;&#160;at&#160;&#160;the&#160;&#160;prompt&#160;&#160;to&#160;&#160;start&#160;&#160;a&#160;&#160;subshell)&#160;&#160;and<br/>configurability.<br/>
<b>1.2.4 &#160;Viewing Ruby Documentation with ri<br/></b>Another critical Ruby tool is the&#160;<i>ri</i>*&#160;documentation viewer. Invoke&#160;<i>ri</i>&#160;on&#160;the command<br/>line&#160;followed&#160;by&#160;the&#160;name&#160;of&#160;a&#160;Ruby&#160;class,&#160;module,&#160;or&#160;method,&#160;and&#160;<i>ri</i>&#160;will&#160;display<br/>documentation&#160;for&#160;you.&#160;You&#160;may&#160;specify&#160;a&#160;method&#160;name&#160;without&#160;a&#160;qualifying&#160;class&#160;or<br/>module&#160;name,&#160;but&#160;this&#160;will&#160;just&#160;show&#160;you&#160;a&#160;list&#160;of&#160;all&#160;methods&#160;by&#160;that&#160;name&#160;(unless&#160;the<br/>method&#160;is&#160;unique).&#160;Normally,&#160;you&#160;can&#160;separate&#160;a&#160;class&#160;or&#160;module&#160;name&#160;from&#160;a&#160;method<br/>name&#160;with&#160;a&#160;period.&#160;If&#160;a&#160;class&#160;defines&#160;a&#160;class&#160;method&#160;and&#160;an&#160;instance&#160;method&#160;by&#160;the<br/>same&#160;name,&#160;you&#160;must&#160;instead&#160;use&#160;::&#160;to&#160;refer&#160;to&#160;the&#160;class&#160;method&#160;or&#160;#&#160;to&#160;refer&#160;to&#160;the<br/>instance method. Here are some example invocations of&#160;<i>ri</i>:<br/>
ri Array<br/>ri Array.sort<br/>ri Hash#each<br/>ri Math::sqrt<br/>
*&#160;Opinions&#160;differ&#160;as&#160;to&#160;what&#160;“ri”&#160;stands&#160;for.&#160;It&#160;has&#160;been&#160;called&#160;“Ruby&#160;Index,”&#160;“Ruby&#160;Information,”&#160;and&#160;“Ruby<br/>
Interactive.”<br/>
<b>1.2 &#160;Try Ruby&#160;|&#160;13</b><br/>
<hr/>
<a name=28></a>This&#160;documentation&#160;displayed&#160;by&#160;<i>ri</i>&#160;is&#160;extracted&#160;from&#160;specially&#160;formatted&#160;comments&#160;in<br/><a href="Rubys.html#41">Ruby source code. See §2.1.1.2 for details.</a><br/>
<b>1.2.5 &#160;Ruby Package Management with gem<br/></b>Ruby’s&#160;package&#160;management&#160;system&#160;is&#160;known&#160;as&#160;RubyGems,&#160;and&#160;packages&#160;or&#160;modules<br/>distributed&#160;using&#160;RubyGems&#160;are&#160;called&#160;“gems.”&#160;RubyGems&#160;makes&#160;it&#160;easy&#160;to&#160;install&#160;Ruby<br/>software and can automatically manage complex dependencies between packages.<br/>The&#160;frontend&#160;script&#160;for&#160;RubyGems&#160;is&#160;<i>gem</i>,&#160;and&#160;it’s&#160;distributed&#160;with&#160;Ruby&#160;1.9&#160;just&#160;as<br/><i>irb</i>&#160;and&#160;<i>ri</i>&#160;are.&#160;In&#160;Ruby&#160;1.8,&#160;you&#160;must&#160;install&#160;it&#160;<a href="http://rubygems.org">separately—see&#160;<i>http://rubygems.org</i></a>.&#160;Once<br/>the&#160;<i>gem</i>&#160;program is installed, you might use it like this:<br/>
# gem install rails<br/>Successfully installed activesupport-1.4.4<br/>Successfully installed activerecord-1.15.5<br/>Successfully installed actionpack-1.13.5<br/>Successfully installed actionmailer-1.3.5<br/>Successfully installed actionwebservice-1.2.5<br/>Successfully installed rails-1.2.5<br/>6 gems installed<br/>Installing ri documentation for activesupport-1.4.4...<br/>Installing ri documentation for activerecord-1.15.5...<br/>...etc...<br/>
As&#160;you&#160;can&#160;see,&#160;the&#160;gem install&#160;command&#160;installs&#160;the&#160;most&#160;recent&#160;version&#160;of&#160;the&#160;gem<br/>you request and also installs any gems that the requested gem requires.&#160;<i>gem</i>&#160;has other<br/>useful subcommands as well. Some examples:<br/>
gem list &#160; &#160; &#160; &#160; &#160; &#160; &#160; # List installed gems<br/>gem enviroment &#160; &#160; &#160; &#160; # Display RubyGems configuration information<br/>gem update rails &#160; &#160; &#160; # Update a named gem<br/>gem update &#160; &#160; &#160; &#160; &#160; &#160; # Update all installed gems<br/>gem update --system &#160; &#160;# Update RubyGems itself<br/>gem uninstall rails &#160; &#160;# Remove an installed gem<br/>
In&#160;Ruby&#160;1.8,&#160;the&#160;gems&#160;you&#160;install&#160;cannot&#160;be&#160;automatically&#160;loaded&#160;by&#160;Ruby’s&#160;require<br/>method.&#160;(See&#160;<a href="Rubys.html#266">§7.6&#160;</a>for&#160;more&#160;about&#160;loading&#160;modules&#160;of&#160;Ruby&#160;code&#160;with&#160;the&#160;require<br/>method.)&#160;If&#160;you’re&#160;writing&#160;a&#160;program&#160;that&#160;will&#160;be&#160;using&#160;modules&#160;installed&#160;as&#160;gems,&#160;you<br/>must&#160;first&#160;require&#160;the&#160;rubygems&#160;module.&#160;Some&#160;Ruby&#160;1.8&#160;distributions&#160;are&#160;preconfigured<br/>with&#160;the&#160;RubyGems&#160;library,&#160;but&#160;you&#160;may&#160;need&#160;to&#160;download&#160;and&#160;install&#160;this&#160;manually.<br/>Loading&#160;this&#160;rubygems&#160;module&#160;alters&#160;the&#160;require&#160;method&#160;itself&#160;so&#160;that&#160;it&#160;searches&#160;the<br/>set&#160;of&#160;installed&#160;gems&#160;before&#160;it&#160;searches&#160;the&#160;standard&#160;library.&#160;You&#160;can&#160;also&#160;automatically<br/>enable&#160;RubyGems&#160;support&#160;by&#160;running&#160;Ruby&#160;with&#160;the&#160;-rubygems&#160;command-line&#160;option.<br/>And&#160;&#160;if&#160;&#160;you&#160;&#160;add&#160;&#160;-rubygems&#160;&#160;to&#160;&#160;the&#160;&#160;RUBYOPT&#160;&#160;environment&#160;&#160;variable,&#160;&#160;then&#160;&#160;the&#160;&#160;RubyGems<br/>library will be loaded on every invocation of Ruby.<br/>The&#160;rubygems&#160;module&#160;is&#160;part&#160;of&#160;the&#160;standard&#160;library&#160;in&#160;Ruby&#160;1.9,&#160;but&#160;it&#160;is&#160;no&#160;longer<br/>required&#160;to&#160;load&#160;gems.&#160;Ruby&#160;1.9&#160;knows&#160;how&#160;to&#160;find&#160;installed&#160;gems&#160;on&#160;its&#160;own,&#160;and&#160;you<br/>do not have to put&#160;require 'rubygems'&#160;in your programs that use gems.<br/>
<b>14&#160;|&#160;Chapter 1:</b> <b>Introduction</b><br/>
<hr/>
<a name=29></a>When&#160;&#160;you&#160;&#160;load&#160;&#160;a&#160;&#160;gem&#160;&#160;with&#160;&#160;require&#160;&#160;(in&#160;&#160;either&#160;&#160;1.8&#160;&#160;or&#160;&#160;1.9),&#160;&#160;it&#160;&#160;loads&#160;&#160;the&#160;&#160;most&#160;&#160;recent<br/>installed&#160;version&#160;of&#160;the&#160;gem&#160;you&#160;specify.&#160;If&#160;you&#160;have&#160;more&#160;specific&#160;version&#160;requirements,<br/>you&#160;can&#160;use&#160;the&#160;gem&#160;method&#160;before&#160;calling&#160;require.&#160;This&#160;finds&#160;a&#160;version&#160;of&#160;the&#160;gem<br/>matching&#160;the&#160;version&#160;constraints&#160;you&#160;specify&#160;and&#160;“activates”&#160;it,&#160;so&#160;that&#160;a&#160;subsequent<br/>require&#160;will load that version:<br/>
require 'rubygems' &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Not necessary in Ruby 1.9<br/>gem 'RedCloth', '&gt; 2.0', '&lt; 4.0' # Activate RedCloth version 2.x or 3.x<br/>require 'RedCloth' &#160; &#160; &#160; &#160; &#160; &#160; &#160; # And now load it<br/>
You’ll&#160;find&#160;more&#160;about&#160;require&#160;and&#160;gems&#160;<a href="Rubys.html#267">in&#160;§7.6.1.&#160;</a>Complete&#160;coverage&#160;of&#160;RubyGems,<br/>the&#160;<i>gem</i>&#160;program,&#160;and&#160;the&#160;rubygems&#160;module&#160;are&#160;beyond&#160;the&#160;scope&#160;of&#160;this&#160;book.&#160;The<br/>gem&#160;command&#160;is&#160;self-documenting—start&#160;by&#160;running&#160;gem help.&#160;For&#160;details&#160;on&#160;the&#160;gem<br/>method,&#160;try&#160;ri gem.&#160;And&#160;for&#160;complete&#160;details,&#160;see&#160;the&#160;documentation&#160;at&#160;<a href="http://rubygems.org"><i>http://ruby<br/>gems.org</i></a>.<br/>
<b>1.2.6 &#160;More Ruby Tutorials<br/></b>This&#160;chapter&#160;began&#160;with&#160;a&#160;tutorial&#160;introduction&#160;to&#160;the&#160;Ruby&#160;language.&#160;You&#160;can&#160;try&#160;out<br/>the&#160;code&#160;snippets&#160;of&#160;that&#160;tutorial&#160;using&#160;<i>irb</i>.&#160;If&#160;you&#160;want&#160;more&#160;tutorials&#160;before&#160;diving<br/>into&#160;the&#160;language&#160;more&#160;formally,&#160;there&#160;are&#160;two&#160;good&#160;ones&#160;available&#160;by&#160;following&#160;links<br/><a href="http://www.ruby-lang.org">on the&#160;<i>http://www.ruby-lang.org</i>&#160;home page. One&#160;</a><i>irb</i>-based tutorial is called “Ruby in<br/>Twenty&#160;Minutes.”*&#160;Another&#160;tutorial,&#160;called&#160;“Try&#160;Ruby!”,&#160;is&#160;interesting&#160;because&#160;it&#160;works<br/>in&#160;your&#160;web&#160;browser&#160;and&#160;does&#160;not&#160;require&#160;you&#160;to&#160;have&#160;Ruby&#160;or&#160;<i>irb</i>&#160;installed&#160;on&#160;your<br/>system.†<br/>
<b>1.2.7 &#160;Ruby Resources<br/></b>The&#160;Ruby&#160;web&#160;site&#160;(<a href="http://www.ruby-lang.org"><i>http://www.ruby-lang.org</i></a>)&#160;is&#160;the&#160;place&#160;to&#160;find&#160;links&#160;to&#160;other&#160;Ruby<br/>resources, such as online documentation, libraries, mailing lists, blogs, IRC channels,<br/>user&#160;&#160;groups,&#160;&#160;and&#160;&#160;conferences.&#160;&#160;Try&#160;&#160;the&#160;&#160;“Documentation,”&#160;&#160;“Libraries,”&#160;&#160;and<br/>“Community” links on the home page.<br/>
<b>1.3 &#160;About This Book<br/></b>As&#160;its&#160;title&#160;implies,&#160;this&#160;book&#160;covers&#160;the&#160;Ruby&#160;programming&#160;language&#160;and&#160;aspires&#160;to&#160;do<br/>so&#160;comprehensively&#160;and&#160;accessibly.&#160;This&#160;edition&#160;of&#160;the&#160;book&#160;covers&#160;language&#160;versions<br/>1.8&#160;and&#160;1.9.&#160;Ruby&#160;blurs&#160;the&#160;distinction&#160;between&#160;language&#160;and&#160;platform,&#160;and&#160;so&#160;our<br/>coverage&#160;of&#160;the&#160;language&#160;includes&#160;a&#160;detailed&#160;overview&#160;of&#160;the&#160;core&#160;Ruby&#160;API.&#160;But&#160;this<br/>book&#160;is&#160;not&#160;an&#160;API&#160;reference&#160;and&#160;does&#160;not&#160;cover&#160;the&#160;core&#160;classes&#160;comprehensively.&#160;Also,<br/>
*&#160;At&#160;the&#160;time&#160;of&#160;this&#160;writing,&#160;the&#160;direct&#160;URL&#160;for&#160;this&#160;tutorial&#160;is&#160;<a href="http://www.ruby-lang.org/en/documentation/quickstart/"><i>http://www.ruby-lang.org/en/documentation/</i></a><br/>
<a href="http://www.ruby-lang.org/en/documentation/quickstart/"><i>quickstart/</i>.</a><br/>
†&#160;If you can’t find the “Try Ruby!” link on the Ruby home page, try this URL:&#160;<a href="http://tryruby.hobix.com"><i>http://tryruby.hobix.com</i></a>.<br/>
<b>1.3 &#160;About This Book&#160;|&#160;15</b><br/>
<hr/>
<a name=30></a>this&#160;is&#160;not&#160;a&#160;book&#160;about&#160;Ruby&#160;frameworks&#160;(like&#160;Rails),&#160;nor&#160;a&#160;book&#160;about&#160;Ruby&#160;tools<br/>(like&#160;<i>rake</i>&#160;and&#160;<i>gem</i>).<br/>This&#160;chapter&#160;concludes&#160;with&#160;a&#160;heavily&#160;commented&#160;extended&#160;example&#160;demonstrating&#160;a<br/>nontrivial Ruby program. The chapters that follow cover Ruby from the bottom up:<br/>
•&#160;<a href="Rubys.html#39">Chapter&#160;2&#160;</a>covers&#160;the&#160;lexical&#160;and&#160;syntactic&#160;structure&#160;of&#160;Ruby,&#160;including&#160;basic&#160;issues<br/>
like character set, case sensitivity, and reserved words.<br/>
•&#160;<a href="Rubys.html#55">Chapter 3</a>&#160;explains&#160;the&#160;kinds&#160;of&#160;data—numbers,&#160;strings,&#160;ranges,&#160;arrays,&#160;and&#160;so&#160;on<br/>
—that&#160;Ruby&#160;programs&#160;can&#160;manipulate,&#160;and&#160;it&#160;covers&#160;the&#160;basic&#160;features&#160;of&#160;all&#160;Ruby<br/>objects.<br/>
•&#160;<a href="Rubys.html#99">Chapter&#160;4&#160;</a>covers&#160;primary&#160;expressions&#160;in&#160;Ruby—literals,&#160;variable&#160;references,&#160;<i>meth-</i><br/>
<i>od</i>&#160;invocations,&#160;and&#160;assignments—and&#160;it&#160;explains&#160;the&#160;operators&#160;used&#160;to&#160;combine<br/>primary expressions into compound expressions.<br/>
•&#160;<a href="Rubys.html#131">Chapter&#160;5&#160;</a>explains&#160;conditionals,&#160;loops&#160;(including&#160;blocks&#160;and&#160;iterator&#160;methods),<br/>
exceptions,&#160;and&#160;the&#160;other&#160;Ruby&#160;expressions&#160;that&#160;would&#160;be&#160;called&#160;statements&#160;or<br/>control structures in other languages.<br/>
•&#160;<a href="Rubys.html#189">Chapter&#160;6&#160;</a>formally&#160;documents&#160;Ruby’s&#160;method&#160;definition&#160;and&#160;invocation&#160;syntax,<br/>
and&#160;it&#160;also&#160;covers&#160;the&#160;invocable&#160;objects&#160;known&#160;as&#160;procs&#160;and&#160;lambdas.&#160;This&#160;chapter<br/>includes&#160;an&#160;explanation&#160;of&#160;closures&#160;and&#160;an&#160;exploration&#160;of&#160;functional&#160;programming<br/>techniques in Ruby.<br/>
•&#160;<a href="Rubys.html#227">Chapter&#160;7&#160;</a>explains&#160;how&#160;to&#160;define&#160;classes&#160;and&#160;modules&#160;in&#160;Ruby.&#160;Classes&#160;are&#160;fun-<br/>
damental&#160;to&#160;object-oriented&#160;programming,&#160;and&#160;this&#160;chapter&#160;also&#160;covers&#160;topics&#160;such<br/>as&#160;inheritance,&#160;method&#160;visibility,&#160;mixin&#160;modules,&#160;and&#160;the&#160;method&#160;name&#160;resolution<br/>algorithm.<br/>
•&#160;<a href="Rubys.html#279">Chapter&#160;8&#160;</a>covers&#160;Ruby’s&#160;APIs&#160;that&#160;allow&#160;a&#160;program&#160;to&#160;inspect&#160;and&#160;manipulate&#160;itself,<br/>
and&#160;then&#160;demonstrates&#160;metaprogramming&#160;techniques&#160;that&#160;use&#160;those&#160;APIs&#160;to&#160;make<br/>programming&#160;&#160;easier.&#160;&#160;The&#160;&#160;chapter&#160;&#160;includes&#160;&#160;an&#160;&#160;example&#160;&#160;of&#160;&#160;domain-specific<br/>language.<br/>
•&#160;<a href="Rubys.html#317">Chapter&#160;9&#160;</a>demonstrates&#160;the&#160;most&#160;important&#160;classes&#160;and&#160;methods&#160;of&#160;the&#160;core&#160;Ruby<br/>
platform&#160;with&#160;simple&#160;code&#160;fragments.&#160;This&#160;is&#160;not&#160;a&#160;reference&#160;but&#160;a&#160;detailed&#160;overview<br/>of&#160;the&#160;core&#160;classes.&#160;Topics&#160;include&#160;text&#160;processing,&#160;numeric&#160;computation,&#160;collec-<br/>tions&#160;(such&#160;as&#160;arrays&#160;and&#160;hashes),&#160;input/output,&#160;networking,&#160;and&#160;threads.&#160;After<br/>reading&#160;this&#160;chapter,&#160;you’ll&#160;understand&#160;the&#160;breadth&#160;of&#160;the&#160;Ruby&#160;platform,&#160;and&#160;you’ll<br/>be able to use the&#160;<i>ri</i>&#160;tool or an online reference to explore the platform in depth.<br/>
•&#160;<a href="Rubys.html#403">Chapter&#160;10&#160;</a>covers&#160;the&#160;top-level&#160;Ruby&#160;programming&#160;environment,&#160;including&#160;global<br/>
variables&#160;and&#160;global&#160;functions,&#160;command-line&#160;arguments&#160;supported&#160;by&#160;the&#160;Ruby<br/>interpreter, and Ruby’s security mechanism.<br/>
<b>16&#160;|&#160;Chapter 1:</b> <b>Introduction</b><br/>
<hr/>
<a name=31></a><b>1.3.1 &#160;How to Read This Book<br/></b>It&#160;is&#160;easy&#160;to&#160;program&#160;in&#160;Ruby,&#160;but&#160;Ruby&#160;is&#160;not&#160;a&#160;simple&#160;language.&#160;Because&#160;this&#160;book<br/>documents&#160;Ruby&#160;comprehensively,&#160;it&#160;is&#160;not&#160;a&#160;simple&#160;book&#160;(though&#160;we&#160;hope&#160;that&#160;you<br/>find&#160;it&#160;easy&#160;to&#160;read&#160;and&#160;understand).&#160;It&#160;is&#160;intended&#160;for&#160;experienced&#160;programmers&#160;who<br/>want&#160;to&#160;master&#160;Ruby&#160;and&#160;are&#160;willing&#160;to&#160;read&#160;carefully&#160;and&#160;thoughtfully&#160;to&#160;achieve&#160;that<br/>goal.<br/>Like&#160;all&#160;similar&#160;programming&#160;books,&#160;this&#160;book&#160;contains&#160;forward&#160;and&#160;backward&#160;refer-<br/>ences&#160;throughout.&#160;Programming&#160;languages&#160;are&#160;not&#160;linear&#160;systems,&#160;and&#160;it&#160;is&#160;impossible<br/>to&#160;document&#160;them&#160;linearly.&#160;As&#160;you&#160;can&#160;see&#160;from&#160;the&#160;chapter&#160;outline,&#160;this&#160;book&#160;takes&#160;a<br/>bottom-up&#160;approach&#160;to&#160;Ruby:&#160;it&#160;starts&#160;with&#160;the&#160;simplest&#160;elements&#160;of&#160;Ruby’s&#160;grammar<br/>and&#160;moves&#160;on&#160;to&#160;document&#160;successively&#160;higher-level&#160;syntactic&#160;structures—from&#160;tokens<br/>to&#160;values&#160;to&#160;expressions&#160;and&#160;control&#160;structures&#160;to&#160;methods&#160;and&#160;classes.&#160;This&#160;is&#160;a&#160;classic<br/>approach&#160;to&#160;documenting&#160;programming&#160;languages,&#160;but&#160;it&#160;does&#160;not&#160;avoid&#160;the&#160;problem<br/>of forward references.<br/>The&#160;book&#160;is&#160;intended&#160;to&#160;be&#160;read&#160;in&#160;the&#160;order&#160;it&#160;is&#160;written,&#160;but&#160;some&#160;advanced&#160;topics&#160;are<br/>best&#160;skimmed&#160;or&#160;skipped&#160;on&#160;the&#160;first&#160;reading;&#160;they&#160;will&#160;make&#160;much&#160;more&#160;sense&#160;when<br/>you&#160;come&#160;back&#160;to&#160;them&#160;after&#160;having&#160;read&#160;the&#160;chapters&#160;that&#160;follow.&#160;On&#160;the&#160;other&#160;hand,<br/>don’t&#160;let&#160;every&#160;forward&#160;reference&#160;scare&#160;you&#160;off.&#160;Many&#160;of&#160;them&#160;are&#160;simply&#160;informative,<br/>letting&#160;you&#160;know&#160;that&#160;more&#160;details&#160;will&#160;be&#160;presented&#160;later.&#160;The&#160;reference&#160;does&#160;not&#160;nec-<br/>essarily&#160;imply&#160;that&#160;those&#160;future&#160;details&#160;are&#160;required&#160;to&#160;understand&#160;the&#160;current&#160;material.<br/>
<b>1.4 &#160;A Sudoku Solver in Ruby<br/></b>This&#160;chapter&#160;concludes&#160;with&#160;a&#160;nontrivial&#160;Ruby&#160;application&#160;to&#160;give&#160;you&#160;a&#160;better&#160;idea&#160;of<br/>what&#160;Ruby&#160;programs&#160;actually&#160;look&#160;like.&#160;We’ve&#160;chosen&#160;a&#160;Sudoku*&#160;solver&#160;as&#160;a&#160;good&#160;short<br/>to&#160;medium-length&#160;program&#160;that&#160;demonstrates&#160;a&#160;number&#160;of&#160;features&#160;of&#160;Ruby.&#160;Don’t<br/>expect&#160;to&#160;understand&#160;every&#160;detail&#160;<a href="Rubys.html#31">of&#160;Example 1-1,&#160;</a>but&#160;do&#160;read&#160;through&#160;the&#160;code;&#160;it&#160;is<br/>very thoroughly commented, and you should have little difficulty following along.<br/>
<i>Example 1-1. A Sudoku solver in Ruby</i><br/>
#<br/># This module defines a Sudoku::Puzzle class to represent a 9x9<br/># Sudoku puzzle and also defines exception classes raised for&#160;<br/># invalid input and over-constrained puzzles. This module also defines&#160;<br/># the method Sudoku.solve to solve a puzzle. The solve method uses<br/># the Sudoku.scan method, which is also defined here.<br/>#&#160;<br/># Use this module to solve Sudoku puzzles with code like this:<br/>
*&#160;Sudoku&#160;is&#160;a&#160;logic&#160;puzzle&#160;that&#160;takes&#160;the&#160;form&#160;of&#160;a&#160;9&#160;×&#160;9&#160;grid&#160;of&#160;numbers&#160;and&#160;blank&#160;squares.&#160;The&#160;task&#160;is&#160;to&#160;fill<br/>
each&#160;blank&#160;with&#160;a&#160;digit&#160;1&#160;to&#160;9&#160;so&#160;that&#160;no&#160;row&#160;or&#160;column&#160;or&#160;3&#160;×&#160;3&#160;subgrid&#160;includes&#160;the&#160;same&#160;digit&#160;twice.&#160;Sudoku<br/>has&#160;been&#160;popular&#160;in&#160;Japan&#160;for&#160;some&#160;time,&#160;but&#160;it&#160;gained&#160;sudden&#160;popularity&#160;in&#160;the&#160;English-speaking&#160;world&#160;in<br/>2004 and 2005. If you are unfamiliar with Sudoku, try reading the Wikipedia entry (<a href="http://en.wikipedia.org/wiki/Sudoku"><i>http://en.wikipedia.org/<br/>wiki/Sudoku</i></a>) and try an online puzzle (<a href="http://websudoku.com/"><i>http://websudoku.com/</i>).</a><br/>
<b>1.4 &#160;A Sudoku Solver in Ruby&#160;|&#160;17</b><br/>
<hr/>
<a name=32></a>#<br/># &#160;require 'sudoku'<br/># &#160;puts Sudoku.solve(Sudoku::Puzzle.new(ARGF.readlines))<br/>#<br/>module Sudoku<br/>
&#160; #<br/>&#160; # The Sudoku::Puzzle class represents the state of a 9x9 Sudoku puzzle.<br/>&#160; #&#160;<br/>&#160; # Some definitions and terminology used in this implementation:&#160;<br/>&#160; #<br/>&#160; # - Each element of a puzzle is called a &#34;cell&#34;.<br/>&#160; # - Rows and columns are numbered from 0 to 8, and the coordinates [0,0]<br/>&#160; # &#160; refer to the cell in the upper-left corner of the puzzle.<br/>&#160; # - The nine 3x3 subgrids are known as &#34;boxes&#34; and are also numbered from<br/>&#160; # &#160; 0 to 8, ordered from left to right and top to bottom. The box in<br/>&#160; # &#160; the upper-left is box 0. The box in the upper-right is box 2. The<br/>&#160; # &#160; box in the middle is box 4. The box in the lower-right is box 8.<br/>&#160; #&#160;<br/>&#160; # Create a new puzzle with Sudoku::Puzzle.new, specifying the initial<br/>&#160; # state as a string or as an array of strings. The string(s) should use<br/>&#160; # the characters 1 through 9 for the given values, and '.' for cells<br/>&#160; # whose value is unspecified. Whitespace in the input is ignored.<br/>&#160; #<br/>&#160; # Read and write access to individual cells of the puzzle is through the<br/>&#160; # [] and []= operators, which expect two-dimensional [row,column] indexing.<br/>&#160; # These methods use numbers (not characters) 0 to 9 for cell contents.<br/>&#160; # 0 represents an unknown value.<br/>&#160; #&#160;<br/>&#160; # The has_duplicates? predicate returns true if the puzzle is invalid<br/>&#160; # because any row, column, or box includes the same digit twice.<br/>&#160; #<br/>&#160; # The each_unknown method is an iterator that loops through the cells of<br/>&#160; # the puzzle and invokes the associated block once for each cell whose<br/>&#160; # value is unknown.<br/>&#160; #<br/>&#160; # The possible method returns an array of integers in the range 1..9.<br/>&#160; # The elements of the array are the only values allowed in the specified<br/>&#160; # cell. If this array is empty, then the puzzle is over-specified and&#160;<br/>&#160; # cannot be solved. If the array has only one element, then that element<br/>&#160; # must be the value for that cell of the puzzle.<br/>&#160; #<br/>&#160; class Puzzle<br/>
&#160; &#160; # These constants are used for translating between the external&#160;<br/>&#160; &#160; # string representation of a puzzle and the internal representation.<br/>&#160; &#160; ASCII = &#34;.123456789&#34;<br/>&#160; &#160; BIN = &#34;\000\001\002\003\004\005\006\007\010\011&#34;<br/>
&#160; &#160; # This is the initialization method for the class. It is automatically<br/>&#160; &#160; # invoked on new Puzzle instances created with Puzzle.new. Pass the input<br/>&#160; &#160; # puzzle as an array of lines or as a single string. Use ASCII digits 1<br/>&#160; &#160; # to 9 and use the '.' character for unknown cells. Whitespace,&#160;<br/>&#160; &#160; # including newlines, will be stripped.<br/>&#160; &#160; def initialize(lines)<br/>
<b>18&#160;|&#160;Chapter 1:</b> <b>Introduction</b><br/>
<hr/>
<a name=33></a>&#160; &#160; &#160; if (lines.respond_to? :join) &#160;# If argument looks like an array of lines<br/>&#160; &#160; &#160; &#160; s = lines.join &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Then join them into a single string<br/>&#160; &#160; &#160; else &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Otherwise, assume we have a string<br/>&#160; &#160; &#160; &#160; s = lines.dup &#160; &#160; &#160; &#160; &#160; &#160; &#160; # And make a private copy of it<br/>&#160; &#160; &#160; end<br/>
&#160; &#160; &#160; # Remove whitespace (including newlines) from the data<br/>&#160; &#160; &#160; # The '!' in gsub! indicates that this is a mutator method that<br/>&#160; &#160; &#160; # alters the string directly rather than making a copy.<br/>&#160; &#160; &#160; s.gsub!(/\s/, &#34;&#34;) &#160;# /\s/ is a Regexp that matches any whitespace<br/>
&#160; &#160; &#160; # Raise an exception if the input is the wrong size.<br/>&#160; &#160; &#160; # Note that we use unless instead of if, and use it in modifier form.<br/>&#160; &#160; &#160; raise Invalid, &#34;Grid is the wrong size&#34; unless s.size == 81<br/>&#160; &#160; &#160;&#160;<br/>&#160; &#160; &#160; # Check for invalid characters, and save the location of the first.<br/>&#160; &#160; &#160; # Note that we assign and test the value assigned at the same time.<br/>&#160; &#160; &#160; if i = s.index(/[^123456789\.]/)<br/>&#160; &#160; &#160; &#160; # Include the invalid character in the error message.<br/>&#160; &#160; &#160; &#160; # Note the Ruby expression inside #{} in string literal.<br/>&#160; &#160; &#160; &#160; raise Invalid, &#34;Illegal character #{s[i,1]} in puzzle&#34;<br/>&#160; &#160; &#160; end<br/>
&#160; &#160; &#160; # The following two lines convert our string of ASCII characters<br/>&#160; &#160; &#160; # to an array of integers, using two powerful String methods.<br/>&#160; &#160; &#160; # The resulting array is stored in the instance variable @grid<br/>&#160; &#160; &#160; # The number 0 is used to represent an unknown value.<br/>&#160; &#160; &#160; s.tr!(ASCII, BIN) &#160; &#160; &#160;# Translate ASCII characters into bytes<br/>&#160; &#160; &#160; @grid = s.unpack('c*') # Now unpack the bytes into an array of numbers<br/>
&#160; &#160; &#160; # Make sure that the rows, columns, and boxes have no duplicates.<br/>&#160; &#160; &#160; raise Invalid, &#34;Initial puzzle has duplicates&#34; if has_duplicates?<br/>&#160; &#160; end<br/>
&#160; &#160; # Return the state of the puzzle as a string of 9 lines with 9&#160;<br/>&#160; &#160; # characters (plus newline) each. &#160;<br/>&#160; &#160; def to_s<br/>&#160; &#160; &#160; # This method is implemented with a single line of Ruby magic that<br/>&#160; &#160; &#160; # reverses the steps in the initialize() method. Writing dense code<br/>&#160; &#160; &#160; # like this is probably not good coding style, but it demonstrates<br/>&#160; &#160; &#160; # the power and expressiveness of the language.<br/>&#160; &#160; &#160; #<br/>&#160; &#160; &#160; # Broken down, the line below works like this:<br/>&#160; &#160; &#160; # (0..8).collect invokes the code in curly braces 9 times--once<br/>&#160; &#160; &#160; # for each row--and collects the return value of that code into an<br/>&#160; &#160; &#160; # array. The code in curly braces takes a subarray of the grid<br/>&#160; &#160; &#160; # representing a single row and packs its numbers into a string.<br/>&#160; &#160; &#160; # The join() method joins the elements of the array into a single<br/>&#160; &#160; &#160; # string with newlines between them. Finally, the tr() method<br/>&#160; &#160; &#160; # translates the binary string representation into ASCII digits.<br/>&#160; &#160; &#160; (0..8).collect{|r| @grid[r*9,9].pack('c9')}.join(&#34;\n&#34;).tr(BIN,ASCII)<br/>&#160; &#160; end<br/>
&#160; &#160; # Return a duplicate of this Puzzle object.<br/>&#160; &#160; # This method overrides Object.dup to copy the @grid array.<br/>
<b>1.4 &#160;A Sudoku Solver in Ruby&#160;|&#160;19</b><br/>
<hr/>
<a name=34></a>&#160; &#160; def dup<br/>&#160; &#160; &#160; copy = super &#160; &#160; &#160; # Make a shallow copy by calling Object.dup<br/>&#160; &#160; &#160; @grid = @grid.dup &#160;# Make a new copy of the internal data&#160;<br/>&#160; &#160; &#160; copy &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Return the copied object<br/>&#160; &#160; end<br/>
&#160; &#160; # We override the array access operator to allow access to the&#160;<br/>&#160; &#160; # individual cells of a puzzle. Puzzles are two-dimensional,<br/>&#160; &#160; # and must be indexed with row and column coordinates.<br/>&#160; &#160; def [](row, col)<br/>&#160; &#160; &#160; # Convert two-dimensional (row,col) coordinates into a one-dimensional<br/>&#160; &#160; &#160; # array index and get and return the cell value at that index<br/>&#160; &#160; &#160; @grid[row*9 + col]<br/>&#160; &#160; end<br/>
&#160; &#160; # This method allows the array access operator to be used on the&#160;<br/>&#160; &#160; # lefthand side of an assignment operation. It sets the value of&#160;<br/>&#160; &#160; # the cell at (row, col) to newvalue.<br/>&#160; &#160; def []=(row, col, newvalue)<br/>&#160; &#160; &#160; # Raise an exception unless the new value is in the range 0 to 9.<br/>&#160; &#160; &#160; unless (0..9).include? newvalue<br/>&#160; &#160; &#160; &#160; raise Invalid, &#34;illegal cell value&#34;&#160;<br/>&#160; &#160; &#160; end<br/>&#160; &#160; &#160; # Set the appropriate element of the internal array to the value.<br/>&#160; &#160; &#160; @grid[row*9 + col] = newvalue<br/>&#160; &#160; end<br/>
&#160; &#160; # This array maps from one-dimensional grid index to box number.<br/>&#160; &#160; # It is used in the method below. The name BoxOfIndex begins with a&#160;<br/>&#160; &#160; # capital letter, so this is a constant. Also, the array has been<br/>&#160; &#160; # frozen, so it cannot be modified.<br/>&#160; &#160; BoxOfIndex = [<br/>&#160; &#160; &#160; 0,0,0,1,1,1,2,2,2,0,0,0,1,1,1,2,2,2,0,0,0,1,1,1,2,2,2,<br/>&#160; &#160; &#160; 3,3,3,4,4,4,5,5,5,3,3,3,4,4,4,5,5,5,3,3,3,4,4,4,5,5,5,<br/>&#160; &#160; &#160; 6,6,6,7,7,7,8,8,8,6,6,6,7,7,7,8,8,8,6,6,6,7,7,7,8,8,8<br/>&#160; &#160; ].freeze<br/>
&#160; &#160; # This method defines a custom looping construct (an &#34;iterator&#34;) for<br/>&#160; &#160; # Sudoku puzzles. &#160;For each cell whose value is unknown, this method<br/>&#160; &#160; # passes (&#34;yields&#34;) the row number, column number, and box number to the&#160;<br/>&#160; &#160; # block associated with this iterator.<br/>&#160; &#160; def each_unknown<br/>&#160; &#160; &#160; 0.upto 8 do |row| &#160; &#160; &#160; &#160; &#160; &#160; # For each row<br/>&#160; &#160; &#160; &#160; 0.upto 8 do |col| &#160; &#160; &#160; &#160; &#160; # For each column<br/>&#160; &#160; &#160; &#160; &#160; index = row*9+col &#160; &#160; &#160; &#160; # Cell index for (row,col)<br/>&#160; &#160; &#160; &#160; &#160; next if @grid[index] != 0 # Move on if we know the cell's value&#160;<br/>&#160; &#160; &#160; &#160; &#160; box = BoxOfIndex[index] &#160; # Figure out the box for this cell<br/>&#160; &#160; &#160; &#160; &#160; yield row, col, box &#160; &#160; &#160; # Invoke the associated block<br/>&#160; &#160; &#160; &#160; end<br/>&#160; &#160; &#160; end<br/>&#160; &#160; end<br/>
&#160; &#160; # Returns true if any row, column, or box has duplicates.<br/>&#160; &#160; # Otherwise returns false. Duplicates in rows, columns, or boxes are not<br/>&#160; &#160; # allowed in Sudoku, so a return value of true means an invalid puzzle.<br/>
<b>20&#160;|&#160;Chapter 1:</b> <b>Introduction</b><br/>
<hr/>
<a name=35></a>&#160; &#160; def has_duplicates?<br/>&#160; &#160; &#160; # uniq! returns nil if all the elements in an array are unique.<br/>&#160; &#160; &#160; # So if uniq! returns something then the board has duplicates.<br/>&#160; &#160; &#160; 0.upto(8) {|row| return true if rowdigits(row).uniq! }<br/>&#160; &#160; &#160; 0.upto(8) {|col| return true if coldigits(col).uniq! }<br/>&#160; &#160; &#160; 0.upto(8) {|box| return true if boxdigits(box).uniq! }<br/>&#160; &#160; &#160;&#160;<br/>&#160; &#160; &#160; false &#160;# If all the tests have passed, then the board has no duplicates<br/>&#160; &#160; end<br/>
&#160; &#160; # This array holds a set of all Sudoku digits. Used below.<br/>&#160; &#160; AllDigits = [1, 2, 3, 4, 5, 6, 7, 8, 9].freeze<br/>
&#160; &#160; # Return an array of all values that could be placed in the cell&#160;<br/>&#160; &#160; # at (row,col) without creating a duplicate in the row, column, or box.<br/>&#160; &#160; # Note that the + operator on arrays does concatenation but that the -&#160;<br/>&#160; &#160; # operator performs a set difference operation.<br/>&#160; &#160; def possible(row, col, box)<br/>&#160; &#160; &#160; AllDigits - (rowdigits(row) + coldigits(col) + boxdigits(box))<br/>&#160; &#160; end<br/>
&#160; &#160; private &#160;# All methods after this line are private to the class<br/>
&#160; &#160; # Return an array of all known values in the specified row.<br/>&#160; &#160; def rowdigits(row)<br/>&#160; &#160; &#160; # Extract the subarray that represents the row and remove all zeros.<br/>&#160; &#160; &#160; # Array subtraction is set difference, with duplicate removal.<br/>&#160; &#160; &#160; @grid[row*9,9] - [0]<br/>&#160; &#160; end<br/>
&#160; &#160; # Return an array of all known values in the specified column.<br/>&#160; &#160; def coldigits(col)<br/>&#160; &#160; &#160; result = [] &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Start with an empty array<br/>&#160; &#160; &#160; col.step(80, 9) {|i| &#160; &#160; &#160; # Loop from col by nines up to 80<br/>&#160; &#160; &#160; &#160; v = @grid[i] &#160; &#160; &#160; &#160; &#160; &#160; # Get value of cell at that index<br/>&#160; &#160; &#160; &#160; result &lt;&lt; v if (v != 0) &#160;# Add it to the array if non-zero<br/>&#160; &#160; &#160; }<br/>&#160; &#160; &#160; result &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Return the array<br/>&#160; &#160; end<br/>
&#160; &#160; # Map box number to the index of the upper-left corner of the box.<br/>&#160; &#160; BoxToIndex = [0, 3, 6, 27, 30, 33, 54, 57, 60].freeze<br/>
&#160; &#160; # Return an array of all the known values in the specified box.<br/>&#160; &#160; def boxdigits(b)<br/>&#160; &#160; &#160; # Convert box number to index of upper-left corner of the box.<br/>&#160; &#160; &#160; i = BoxToIndex[b]<br/>&#160; &#160; &#160; # Return an array of values, with 0 elements removed.<br/>&#160; &#160; &#160; [<br/>&#160; &#160; &#160; &#160; @grid[i], &#160; &#160;@grid[i+1], &#160;@grid[i+2],<br/>&#160; &#160; &#160; &#160; @grid[i+9], &#160;@grid[i+10], @grid[i+11],<br/>&#160; &#160; &#160; &#160; @grid[i+18], @grid[i+19], @grid[i+20]<br/>&#160; &#160; &#160; ] - [0]<br/>&#160; &#160; end<br/>&#160; end &#160;# This is the end of the Puzzle class<br/>
<b>1.4 &#160;A Sudoku Solver in Ruby&#160;|&#160;21</b><br/>
<hr/>
<a name=36></a>&#160; # An exception of this class indicates invalid input,<br/>&#160; class Invalid &lt; StandardError<br/>&#160; end<br/>
&#160; # An exception of this class indicates that a puzzle is over-constrained<br/>&#160; # and that no solution is possible.<br/>&#160; class Impossible &lt; StandardError<br/>&#160; end<br/>
&#160; #<br/>&#160; # This method scans a Puzzle, looking for unknown cells that have only<br/>&#160; # a single possible value. If it finds any, it sets their value. Since<br/>&#160; # setting a cell alters the possible values for other cells, it&#160;<br/>&#160; # continues scanning until it has scanned the entire puzzle without&#160;<br/>&#160; # finding any cells whose value it can set.<br/>&#160; #<br/>&#160; # This method returns three values. If it solves the puzzle, all three&#160;<br/>&#160; # values are nil. Otherwise, the first two values returned are the row and<br/>&#160; # column of a cell whose value is still unknown. The third value is the<br/>&#160; # set of values possible at that row and column. This is a minimal set of<br/>&#160; # possible values: there is no unknown cell in the puzzle that has fewer<br/>&#160; # possible values. This complex return value enables a useful heuristic&#160;<br/>&#160; # in the solve() method: that method can guess at values for cells where<br/>&#160; # the guess is most likely to be correct.<br/>&#160; #&#160;<br/>&#160; # This method raises Impossible if it finds a cell for which there are<br/>&#160; # no possible values. This can happen if the puzzle is over-constrained,<br/>&#160; # or if the solve() method below has made an incorrect guess.<br/>&#160; #<br/>&#160; # This method mutates the specified Puzzle object in place.<br/>&#160; # If has_duplicates? is false on entry, then it will be false on exit.<br/>&#160; #<br/>&#160; def Sudoku.scan(puzzle)<br/>&#160; &#160; unchanged = false &#160;# This is our loop variable<br/>
&#160; &#160; # Loop until we've scanned the whole board without making a change.<br/>&#160; &#160; until unchanged&#160;<br/>&#160; &#160; &#160; unchanged = true &#160; &#160; &#160;# Assume no cells will be changed this time<br/>&#160; &#160; &#160; rmin,cmin,pmin = nil &#160;# Track cell with minimal possible set<br/>&#160; &#160; &#160; min = 10 &#160; &#160; &#160; &#160; &#160; &#160; &#160;# More than the maximal number of possibilities<br/>
&#160; &#160; &#160; # Loop through cells whose value is unknown.<br/>&#160; &#160; &#160; puzzle.each_unknown do |row, col, box|<br/>&#160; &#160; &#160; &#160; # Find the set of values that could go in this cell<br/>&#160; &#160; &#160; &#160; p = puzzle.possible(row, col, box)<br/>&#160; &#160; &#160; &#160;&#160;<br/>&#160; &#160; &#160; &#160; # Branch based on the size of the set p.&#160;<br/>&#160; &#160; &#160; &#160; # We care about 3 cases: p.size==0, p.size==1, and p.size &gt; 1.<br/>&#160; &#160; &#160; &#160; case p.size<br/>&#160; &#160; &#160; &#160; when 0 &#160;# No possible values means the puzzle is over-constrained<br/>&#160; &#160; &#160; &#160; &#160; raise Impossible<br/>&#160; &#160; &#160; &#160; when 1 &#160;# We've found a unique value, so set it in the grid<br/>&#160; &#160; &#160; &#160; &#160; puzzle[row,col] = p[0] # Set that position on the grid to the value<br/>&#160; &#160; &#160; &#160; &#160; unchanged = false &#160; &#160; &#160;# Note that we've made a change<br/>
<b>22&#160;|&#160;Chapter 1:</b> <b>Introduction</b><br/>
<hr/>
<a name=37></a>&#160; &#160; &#160; &#160; else &#160; &#160;# For any other number of possibilities<br/>&#160; &#160; &#160; &#160; &#160; # Keep track of the smallest set of possibilities.<br/>&#160; &#160; &#160; &#160; &#160; # But don't bother if we're going to repeat this loop.<br/>&#160; &#160; &#160; &#160; &#160; if unchanged &amp;&amp; p.size &lt; min<br/>&#160; &#160; &#160; &#160; &#160; &#160; min = p.size &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Current smallest size<br/>&#160; &#160; &#160; &#160; &#160; &#160; rmin, cmin, pmin = row, col, p &#160;# Note parallel assignment<br/>&#160; &#160; &#160; &#160; &#160; end<br/>&#160; &#160; &#160; &#160; end<br/>&#160; &#160; &#160; end<br/>&#160; &#160; end<br/>&#160; &#160; &#160;&#160;<br/>&#160; &#160; # Return the cell with the minimal set of possibilities.<br/>&#160; &#160; # Note multiple return values.<br/>&#160; &#160; return rmin, cmin, pmin<br/>&#160; end<br/>
&#160; # Solve a Sudoku puzzle using simple logic, if possible, but fall back<br/>&#160; # on brute-force when necessary. This is a recursive method. It either<br/>&#160; # returns a solution or raises an exception. The solution is returned<br/>&#160; # as a new Puzzle object with no unknown cells. This method does not&#160;<br/>&#160; # modify the Puzzle it is passed. Note that this method cannot detect<br/>&#160; # an under-constrained puzzle.<br/>&#160; def Sudoku.solve(puzzle)<br/>&#160; &#160; # Make a private copy of the puzzle that we can modify.<br/>&#160; &#160; puzzle = puzzle.dup<br/>
&#160; &#160; # Use logic to fill in as much of the puzzle as we can.<br/>&#160; &#160; # This method mutates the puzzle we give it, but always leaves it valid.<br/>&#160; &#160; # It returns a row, a column, and set of possible values at that cell.<br/>&#160; &#160; # Note parallel assignment of these return values to three variables.<br/>&#160; &#160; r,c,p = scan(puzzle)<br/>
&#160; &#160; # If we solved it with logic, return the solved puzzle.<br/>&#160; &#160; return puzzle if r == nil<br/>
&#160;<br/>
&#160; &#160;&#160;<br/>&#160; &#160; # Otherwise, try each of the values in p for cell [r,c].<br/>&#160; &#160; # Since we're picking from a set of possible values, the guess leaves<br/>&#160; &#160; # the puzzle in a valid state. The guess will either lead to a solution<br/>&#160; &#160; # or to an impossible puzzle. We'll know we have an impossible<br/>&#160; &#160; # puzzle if a recursive call to scan throws an exception. If this happens<br/>&#160; &#160; # we need to try another guess, or re-raise an exception if we've tried<br/>&#160; &#160; # all the options we've got.<br/>&#160; &#160; p.each do |guess| &#160; &#160; &#160; &#160;# For each value in the set of possible values<br/>&#160; &#160; &#160; puzzle[r,c] = guess &#160; &#160;# Guess the value<br/>&#160; &#160; &#160;&#160;<br/>&#160; &#160; &#160; begin<br/>&#160; &#160; &#160; &#160; # Now try (recursively) to solve the modified puzzle.<br/>&#160; &#160; &#160; &#160; # This recursive invocation will call scan() again to apply logic<br/>&#160; &#160; &#160; &#160; # to the modified board, and will then guess another cell if needed.<br/>&#160; &#160; &#160; &#160; # Remember that solve() will either return a valid solution or&#160;<br/>&#160; &#160; &#160; &#160; # raise an exception. &#160;<br/>&#160; &#160; &#160; &#160; return solve(puzzle) &#160;# If it returns, we just return the solution<br/>&#160; &#160; &#160; rescue Impossible<br/>&#160; &#160; &#160; &#160; next &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# If it raises an exception, try the next guess<br/>&#160; &#160; &#160; end<br/>
<b>1.4 &#160;A Sudoku Solver in Ruby&#160;|&#160;23</b><br/>
<hr/>
<a name=38></a>&#160; &#160; end<br/>
&#160; &#160; # If we get here, then none of our guesses worked out<br/>&#160; &#160; # so we must have guessed wrong sometime earlier.<br/>&#160; &#160; raise Impossible<br/>&#160; end<br/>end<br/>
<a href="Rubys.html#31">Example 1-1</a>&#160;is&#160;345&#160;lines&#160;long.&#160;Because&#160;the&#160;example&#160;was&#160;written&#160;for&#160;this&#160;introductory<br/>chapter,&#160;it&#160;has&#160;particularly&#160;verbose&#160;comments.&#160;Strip&#160;away&#160;the&#160;comments&#160;and&#160;the&#160;blank<br/>lines&#160;and&#160;you’re&#160;left&#160;with&#160;just&#160;129&#160;lines&#160;of&#160;code,&#160;which&#160;is&#160;pretty&#160;good&#160;for&#160;an&#160;object-<br/>oriented&#160;Sudoku&#160;solver&#160;that&#160;does&#160;not&#160;rely&#160;on&#160;a&#160;simple&#160;brute-force&#160;algorithm.&#160;We&#160;hope<br/>that this example demonstrates the power and expressiveness of Ruby.<br/>
<b>24&#160;|&#160;Chapter 1:</b> <b>Introduction</b><br/>
<hr/>
<a name=39></a><img src="Ruby-39_1.jpg"/><br/>
<b>CHAPTER&#160;2</b><br/>
<b>The Structure and Execution of Ruby</b><br/>
<b>Programs</b><br/>
<b>25</b><br/>
<hr/>
<a name=40></a>This&#160;chapter&#160;explains&#160;the&#160;structure&#160;of&#160;Ruby&#160;programs.&#160;It&#160;starts&#160;with&#160;the&#160;lexical&#160;structure,<br/>covering&#160;tokens&#160;and&#160;the&#160;characters&#160;that&#160;comprise&#160;them.&#160;Next,&#160;it&#160;covers&#160;the&#160;syntactic<br/>structure&#160;of&#160;a&#160;Ruby&#160;program,&#160;explaining&#160;how&#160;expressions,&#160;control&#160;structures,&#160;methods,<br/>classes,&#160;and&#160;so&#160;on&#160;are&#160;written&#160;as&#160;a&#160;series&#160;of&#160;tokens.&#160;Finally,&#160;the&#160;chapter&#160;describes&#160;files<br/>of&#160;Ruby&#160;code,&#160;explaining&#160;how&#160;Ruby&#160;programs&#160;can&#160;be&#160;split&#160;across&#160;multiple&#160;files&#160;and&#160;how<br/>the Ruby interpreter executes a file of Ruby code.<br/>
<b>2.1 &#160;Lexical Structure<br/></b>The&#160;Ruby&#160;interpreter&#160;parses&#160;a&#160;program&#160;as&#160;a&#160;sequence&#160;of&#160;<i>tokens</i>.&#160;Tokens&#160;include&#160;com-<br/>ments,&#160;literals,&#160;punctuation,&#160;identifiers,&#160;and&#160;keywords.&#160;This&#160;section&#160;introduces&#160;these<br/>types&#160;&#160;of&#160;&#160;tokens&#160;&#160;and&#160;&#160;also&#160;&#160;includes&#160;&#160;important&#160;&#160;information&#160;&#160;about&#160;&#160;the&#160;&#160;characters&#160;&#160;that<br/>comprise the tokens and the whitespace that separates the tokens.<br/>
<b>2.1.1 &#160;Comments<br/></b>Comments&#160;in&#160;Ruby&#160;begin&#160;with&#160;a&#160;#&#160;character&#160;and&#160;continue&#160;to&#160;the&#160;end&#160;of&#160;the&#160;line.&#160;The<br/>Ruby&#160;interpreter&#160;ignores&#160;the&#160;#&#160;character&#160;and&#160;any&#160;text&#160;that&#160;follows&#160;it&#160;(but&#160;does&#160;not&#160;ignore<br/>the&#160;newline&#160;character,&#160;which&#160;is&#160;meaningful&#160;whitespace&#160;and&#160;may&#160;serve&#160;as&#160;a&#160;statement<br/>terminator).&#160;If&#160;a&#160;#&#160;character&#160;appears&#160;within&#160;a&#160;string&#160;or&#160;regular&#160;expression&#160;literal&#160;(see<br/><a href="Rubys.html#55">Chapter&#160;&#160;3),&#160;&#160;</a>then&#160;&#160;it&#160;&#160;is&#160;&#160;simply&#160;&#160;part&#160;&#160;of&#160;&#160;the&#160;&#160;string&#160;&#160;or&#160;&#160;regular&#160;&#160;expression&#160;&#160;and&#160;&#160;does&#160;&#160;not<br/>introduce a comment:<br/>
# This entire line is a comment<br/>x = &#34;#This is a string&#34; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # And this is a comment<br/>y = /#This is a regular expression/ &#160; # Here's another comment<br/>
Multiline comments&#160;are usually written simply by beginning each line with a separate<br/>#&#160;character:<br/>
#<br/># This class represents a Complex number<br/># Despite its name, it is not complex at all.<br/>#<br/>
Note&#160;that&#160;Ruby&#160;has&#160;no&#160;equivalent&#160;of&#160;the&#160;C-style&#160;/*...*/&#160;comment.&#160;There&#160;is&#160;no&#160;way&#160;to<br/>embed a comment in the middle of a line of code.<br/>
<b>2.1.1.1 &#160;Embedded documents<br/></b>Ruby&#160;supports&#160;another&#160;style&#160;of&#160;multiline&#160;comment&#160;known&#160;as&#160;an&#160;<i>embedded document</i>.<br/>These&#160;start&#160;on&#160;a&#160;line&#160;that&#160;begins&#160;=begin&#160;and&#160;continue&#160;until&#160;(and&#160;include)&#160;a&#160;line&#160;that<br/>begins&#160;=end.&#160;Any&#160;text&#160;that&#160;appears&#160;after&#160;=begin&#160;or&#160;=end&#160;is&#160;part&#160;of&#160;the&#160;comment&#160;and&#160;is<br/>also&#160;ignored,&#160;but&#160;that&#160;extra&#160;text&#160;must&#160;be&#160;separated&#160;from&#160;the&#160;=begin&#160;and&#160;=end&#160;by&#160;at&#160;least<br/>one space.<br/>Embedded&#160;documents&#160;are&#160;a&#160;convenient&#160;way&#160;to&#160;comment&#160;out&#160;long&#160;blocks&#160;of&#160;code&#160;with-<br/>out prefixing each line with a&#160;#&#160;character:<br/>
<b>26&#160;|&#160;Chapter 2:</b> <b>The Structure and Execution of Ruby Programs</b><br/>
<hr/>
<a name=41></a>=begin Someone needs to fix the broken code below!<br/>&#160; &#160;&#160;<i>Any code here is commented out<br/></i>=end<br/>
Note&#160;that&#160;embedded&#160;documents&#160;only&#160;work&#160;if&#160;the&#160;=&#160;signs&#160;are&#160;the&#160;first&#160;characters&#160;of&#160;each<br/>line:<br/>
# =begin This used to begin a comment. Now it is itself commented out!<br/>&#160; &#160;&#160;<i>The code that goes here is no longer commented out<br/></i># =end<br/>
As&#160;their&#160;name&#160;implies,&#160;embedded&#160;documents&#160;can&#160;be&#160;used&#160;to&#160;include&#160;long&#160;blocks&#160;of<br/>documentation&#160;within&#160;a&#160;program,&#160;or&#160;to&#160;embed&#160;source&#160;code&#160;of&#160;another&#160;language&#160;(such<br/>as&#160;HTML&#160;or&#160;SQL)&#160;within&#160;a&#160;Ruby&#160;program.&#160;Embedded&#160;documents&#160;are&#160;usually&#160;intended<br/>to&#160;be&#160;used&#160;by&#160;some&#160;kind&#160;of&#160;postprocessing&#160;tool&#160;that&#160;is&#160;run&#160;over&#160;the&#160;Ruby&#160;source&#160;code,<br/>and&#160;&#160;it&#160;&#160;is&#160;&#160;typical&#160;&#160;to&#160;&#160;follow&#160;&#160;=begin&#160;&#160;with&#160;&#160;an&#160;&#160;identifier&#160;&#160;that&#160;&#160;indicates&#160;&#160;which&#160;&#160;tool&#160;&#160;the<br/>comment is intended for.<br/>
<b>2.1.1.2 &#160;Documentation comments<br/></b>Ruby&#160;programs&#160;can&#160;include&#160;embedded&#160;API&#160;documentation&#160;as&#160;specially&#160;formatted&#160;com-<br/>ments&#160;&#160;that&#160;&#160;precede&#160;&#160;method,&#160;&#160;class,&#160;&#160;and&#160;&#160;module&#160;&#160;definitions.&#160;&#160;You&#160;&#160;can&#160;&#160;browse&#160;&#160;this<br/>documentation&#160;using&#160;the&#160;<i>ri</i>&#160;tool&#160;described&#160;earlier&#160;<a href="Rubys.html#27">in&#160;§1.2.4.&#160;</a>The&#160;<i>rdoc</i>&#160;tool&#160;extracts&#160;doc-<br/>umentation&#160;comments&#160;from&#160;Ruby&#160;source&#160;and&#160;formats&#160;them&#160;as&#160;HTML&#160;or&#160;prepares&#160;them<br/>for&#160;display&#160;by&#160;<i>ri</i>.&#160;Documentation&#160;of&#160;the&#160;<i>rdoc</i>&#160;tool&#160;is&#160;beyond&#160;the&#160;scope&#160;of&#160;this&#160;book;&#160;see<br/>the file&#160;<i>lib/rdoc/README</i>&#160;in the Ruby source code for details.<br/>Documentation&#160;&#160;comments&#160;&#160;must&#160;&#160;come&#160;&#160;immediately&#160;&#160;before&#160;&#160;the&#160;&#160;module,&#160;&#160;class,&#160;&#160;or<br/>method&#160;whose&#160;API&#160;they&#160;document.&#160;They&#160;are&#160;usually&#160;written&#160;as&#160;multiline&#160;comments<br/>where&#160;each&#160;line&#160;begins&#160;with&#160;#,&#160;but&#160;they&#160;can&#160;also&#160;be&#160;written&#160;as&#160;embedded&#160;documents<br/>that&#160;start&#160;=begin rdoc.&#160;(The&#160;<i>rdoc</i>&#160;tool&#160;will&#160;not&#160;process&#160;these&#160;comments&#160;if&#160;you&#160;leave&#160;out<br/>the “rdoc”.)<br/>The&#160;&#160;following&#160;&#160;example&#160;&#160;comment&#160;&#160;demonstrates&#160;&#160;the&#160;&#160;most&#160;&#160;important&#160;&#160;formatting&#160;&#160;ele-<br/>ments&#160;of&#160;the&#160;markup&#160;grammar&#160;used&#160;in&#160;Ruby’s&#160;documentation&#160;comments;&#160;a&#160;detailed<br/>description of the grammar is available in the&#160;<i>README</i>&#160;file mentioned previously:<br/>
#<br/># Rdoc comments use a simple markup grammar like those used in wikis.<br/>#&#160;<br/># Separate paragraphs with a blank line.<br/>#&#160;<br/># = Headings<br/>#&#160;<br/># Headings begin with an equals sign<br/>#&#160;<br/># == Sub-Headings<br/># The line above produces a subheading.<br/># === Sub-Sub-Heading<br/># And so on.<br/>#&#160;<br/># = Examples<br/>
<b>2.1 &#160;Lexical Structure&#160;|&#160;27</b><br/>
<hr/>
<a name=42></a>#&#160;<br/># &#160; Indented lines are displayed verbatim in code font.<br/># &#160; &#160; Be careful not to indent your headings and lists, though.<br/>#&#160;<br/># = Lists and Fonts<br/>#&#160;<br/># List items begin with * or -. Indicate fonts with punctuation or HTML:<br/># * _italic_ or &lt;i&gt;multi-word italic&lt;/i&gt;<br/># * *bold* or &lt;b&gt;multi-word bold&lt;/b&gt;<br/># * +code+ or &lt;tt&gt;multi-word code&lt;/tt&gt;<br/>#&#160;<br/># 1. Numbered lists begin with numbers.<br/># 99. Any number will do; they don't have to be sequential.<br/># 1. There is no way to do nested lists.<br/>#&#160;<br/># The terms of a description list are bracketed:<br/># [item 1] &#160;This is a description of item 1<br/># [item 2] &#160;This is a description of item 2<br/>#&#160;<br/>
<b>2.1.2 &#160;Literals<br/></b>Literals&#160;are&#160;values&#160;that&#160;appear&#160;directly&#160;in&#160;Ruby&#160;source&#160;code.&#160;They&#160;include&#160;numbers,<br/>strings&#160;of&#160;text,&#160;and&#160;regular&#160;expressions.&#160;(Other&#160;literals,&#160;such&#160;as&#160;array&#160;and&#160;hash&#160;values,<br/>are&#160;not&#160;individual&#160;tokens&#160;but&#160;are&#160;more&#160;complex&#160;expressions.)&#160;Ruby&#160;number&#160;and&#160;string<br/>literal&#160;syntax&#160;is&#160;actually&#160;quite&#160;complicated,&#160;and&#160;is&#160;covered&#160;in&#160;detail&#160;in&#160;<a href="Rubys.html#55">Chapter&#160;3.&#160;</a>For<br/>now, an example suffices to illustrate what Ruby literals look like:<br/>
1 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# An integer literal<br/>1.0 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# A floating-point literal<br/>'one' &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# A string literal<br/>&#34;two&#34; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Another string literal<br/>/three/ &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# A regular expression literal<br/>
<b>2.1.3 &#160;Punctuation<br/></b>Ruby&#160;uses&#160;punctuation&#160;characters&#160;for&#160;a&#160;number&#160;of&#160;purposes.&#160;Most&#160;Ruby&#160;operators&#160;are<br/>written using punctuation characters, such as&#160;+&#160;for addition,&#160;*&#160;for multiplication, and<br/>||&#160;for&#160;the&#160;Boolean&#160;OR&#160;operation.&#160;<a href="Rubys.html#114">See&#160;§4.6&#160;</a>for&#160;a&#160;complete&#160;list&#160;of&#160;Ruby&#160;operators. Punc-<br/>tuation&#160;&#160;characters&#160;&#160;also&#160;&#160;serve&#160;&#160;to&#160;&#160;delimit&#160;&#160;string,&#160;&#160;regular&#160;&#160;expression,&#160;&#160;array,&#160;&#160;and&#160;&#160;hash<br/>literals,&#160;and&#160;to&#160;group&#160;and&#160;separate&#160;expressions,&#160;method&#160;arguments,&#160;and&#160;array&#160;indexes.<br/>We’ll see miscellaneous other uses of punctuation scattered throughout Ruby syntax.<br/>
<b>2.1.4 &#160;Identifiers<br/></b>An&#160;<i>identifier</i>&#160;is&#160;simply&#160;a&#160;name.&#160;Ruby&#160;uses&#160;identifiers&#160;to&#160;name&#160;variables,&#160;methods,&#160;classes,<br/>and&#160;so&#160;forth.&#160;Ruby&#160;identifiers&#160;consist&#160;of&#160;letters,&#160;numbers,&#160;and&#160;underscore&#160;characters,<br/>but&#160;&#160;they&#160;&#160;may&#160;&#160;not&#160;&#160;begin&#160;&#160;with&#160;&#160;a&#160;&#160;number.&#160;&#160;Identifiers&#160;&#160;may&#160;&#160;not&#160;&#160;include&#160;&#160;whitespace&#160;&#160;or<br/>
<b>28&#160;|&#160;Chapter 2:</b> <b>The Structure and Execution of Ruby Programs</b><br/>
<hr/>
<a name=43></a>nonprinting&#160;characters,&#160;and&#160;they&#160;may&#160;not&#160;include&#160;punctuation&#160;characters&#160;except&#160;as<br/>described here.<br/>Identifiers that begin with a capital letter A–Z are constants, and the Ruby interpreter<br/>will&#160;issue&#160;a&#160;warning&#160;(but&#160;not&#160;an&#160;error)&#160;if&#160;you&#160;alter&#160;the&#160;value&#160;of&#160;such&#160;an&#160;identifier.&#160;Class<br/>and&#160;module&#160;names&#160;must&#160;begin&#160;with&#160;initial&#160;capital&#160;letters.&#160;The&#160;following&#160;are&#160;identifiers:<br/>
i<br/>x2<br/>old_value<br/>_internal &#160; &#160;# Identifiers may begin with underscores<br/>PI &#160; &#160; &#160; &#160; &#160; # Constant<br/>
By&#160;convention,&#160;multiword&#160;identifiers&#160;that&#160;are&#160;not&#160;constants&#160;are&#160;written&#160;with&#160;under-<br/>scores&#160;like_this, whereas multiword constants are written&#160;LikeThis&#160;or&#160;LIKE_THIS.<br/>
<b>2.1.4.1 &#160;Case sensitivity<br/></b>Ruby is a case-sensitive&#160;language. Lowercase letters and uppercase letters are distinct.<br/>The keyword&#160;end, for example, is completely different from the keyword&#160;END.<br/>
<b>2.1.4.2 &#160;Unicode characters in identifiers<br/></b>Ruby’s&#160;rules&#160;for&#160;forming&#160;identifiers&#160;are&#160;defined&#160;in&#160;terms&#160;of&#160;ASCII&#160;characters&#160;that&#160;are<br/>not&#160;allowed.&#160;In&#160;general,&#160;all&#160;characters&#160;outside&#160;of&#160;the&#160;ASCII&#160;character&#160;set&#160;are&#160;valid&#160;in<br/>identifiers,&#160;including&#160;characters&#160;that&#160;appear&#160;to&#160;be&#160;punctuation.&#160;In&#160;a&#160;UTF-8&#160;encoded<br/>file, for example, the following Ruby code is valid:<br/>
def ×(x,y) &#160;# The name of this method is the Unicode multiplication sign<br/>&#160; x*y &#160; &#160; &#160; # The body of this method multiplies its arguments<br/>end &#160; &#160; &#160; &#160;&#160;<br/>
Similarly,&#160;&#160;a&#160;&#160;Japanese&#160;&#160;programmer&#160;&#160;writing&#160;&#160;a&#160;&#160;program&#160;&#160;encoded&#160;&#160;in&#160;&#160;SJIS&#160;&#160;or&#160;&#160;EUC&#160;&#160;can<br/>include&#160;Kanji&#160;characters&#160;in&#160;her&#160;identifiers.&#160;See&#160;&#160;<a href="Rubys.html#51">§2.4.1&#160;</a>for&#160;more&#160;about&#160;writing&#160;Ruby<br/>programs using encodings other than ASCII.<br/>The&#160;special&#160;rules&#160;about&#160;forming&#160;identifiers&#160;are&#160;based&#160;on&#160;ASCII&#160;characters&#160;and&#160;are&#160;not<br/>enforced&#160;for&#160;characters&#160;outside&#160;of&#160;that&#160;set.&#160;An&#160;identifier&#160;may&#160;not&#160;begin&#160;with&#160;an&#160;ASCII<br/>digit,&#160;for&#160;example,&#160;but&#160;it&#160;may&#160;begin&#160;with&#160;a&#160;digit&#160;from&#160;a&#160;non-Latin&#160;alphabet.&#160;Similarly,<br/>an&#160;identifier&#160;must&#160;begin&#160;with&#160;an&#160;ASCII&#160;capital&#160;letter&#160;in&#160;order&#160;to&#160;be&#160;considered&#160;a&#160;constant.<br/>The identifier&#160;Å, for example, is not a constant.<br/>Two&#160;identifiers&#160;are&#160;the&#160;same&#160;only&#160;if&#160;they&#160;are&#160;represented&#160;by&#160;the&#160;same&#160;sequence&#160;of&#160;bytes.<br/>Some&#160;character&#160;sets,&#160;such&#160;as&#160;Unicode,&#160;have&#160;more&#160;than&#160;one&#160;codepoint&#160;that&#160;represents<br/>the&#160;same&#160;character.&#160;No&#160;Unicode&#160;normalization&#160;is&#160;performed&#160;in&#160;Ruby,&#160;and&#160;two&#160;distinct<br/>codepoints&#160;are&#160;treated&#160;as&#160;distinct&#160;characters,&#160;even&#160;if&#160;they&#160;have&#160;the&#160;same&#160;meaning&#160;or&#160;are<br/>represented by the same font glyph.<br/>
<b>2.1 &#160;Lexical Structure&#160;|&#160;29</b><br/>
<hr/>
<a name=44></a><b>2.1.4.3 &#160;Punctuation in identifiers<br/></b>Punctuation&#160;characters&#160;may&#160;appear&#160;at&#160;the&#160;start&#160;and&#160;end&#160;of&#160;Ruby&#160;identifiers.&#160;They&#160;have<br/>the following meanings:<br/>
$<br/>
Global variables are prefixed with a dollar sign. Following Perl’s example, Ruby defines a number of global variables that<br/>include other punctuation characters, such as&#160;$_&#160;and&#160;$-K<a href="Rubys.html#403">. See Chapter 10 for a list of these special globals.</a><br/>
@<br/>
Instance variables are prefixed with a single at sign, and class variables are prefixed with two at signs. Instance variables<br/><a href="Rubys.html#227">and class variables are explained in Chapter 7.</a><br/>
?<br/>
As a helpful convention, methods that return Boolean values often have names that end with a question mark.<br/>
!<br/>
Method names may end with an exclamation point to indicate that they should be used cautiously. This naming convention<br/>is often to distinguish mutator methods that alter the object on which they are invoked from variants that return a modified<br/>copy of the original object.<br/>
=<br/>
Methods whose names end with an equals sign can be invoked by placing the method name, without the equals sign, on<br/><a href="Rubys.html#108">the left side of an assignment operator. (You can read more about this in §4.5.3 and §7.1.5.)</a><br/>
Here&#160;&#160;are&#160;&#160;some&#160;&#160;example&#160;&#160;identifiers&#160;&#160;that&#160;&#160;contain&#160;&#160;leading&#160;&#160;or&#160;&#160;trailing&#160;&#160;punctuation<br/>characters:<br/>
$files &#160; &#160; &#160; &#160; &#160;# A global variable<br/>@data &#160; &#160; &#160; &#160; &#160; # An instance variable<br/>@@counter &#160; &#160; &#160; # A class variable<br/>empty? &#160; &#160; &#160; &#160; &#160;# A Boolean-valued method or predicate<br/>sort! &#160; &#160; &#160; &#160; &#160; # An in-place alternative to the regular sort method<br/>timeout= &#160; &#160; &#160; &#160;# A method invoked by assignment<br/>
A&#160;number&#160;of&#160;Ruby’s&#160;operators&#160;are&#160;implemented&#160;as&#160;methods,&#160;so&#160;that&#160;classes&#160;can&#160;redefine<br/>them&#160;for&#160;their&#160;own&#160;purposes.&#160;It&#160;is&#160;therefore&#160;possible&#160;to&#160;use&#160;certain&#160;operators&#160;as&#160;method<br/>names&#160;as&#160;well.&#160;In&#160;this&#160;context,&#160;the&#160;punctuation&#160;character&#160;or&#160;characters&#160;of&#160;the&#160;operator<br/>are&#160;&#160;treated&#160;&#160;as&#160;&#160;identifiers&#160;&#160;rather&#160;&#160;than&#160;&#160;operators.&#160;&#160;See&#160;&#160;<a href="Rubys.html#114">§4.6&#160;&#160;</a>for&#160;&#160;more&#160;&#160;about&#160;&#160;Ruby’s<br/>operators.<br/>
<b>2.1.5 &#160;Keywords<br/></b>The&#160;following&#160;keywords&#160;have&#160;special&#160;meaning&#160;in&#160;Ruby&#160;and&#160;are&#160;treated&#160;specially&#160;by&#160;the<br/>Ruby parser:<br/>
__LINE__ &#160; &#160; &#160;case &#160; &#160; &#160; &#160; ensure &#160; &#160; &#160; not &#160; &#160; &#160; &#160; &#160;then<br/>__ENCODING__ &#160;class &#160; &#160; &#160; &#160;false &#160; &#160; &#160; &#160;or &#160; &#160; &#160; &#160; &#160; true<br/>__FILE__ &#160; &#160; &#160;def &#160; &#160; &#160; &#160; &#160;for &#160; &#160; &#160; &#160; &#160;redo &#160; &#160; &#160; &#160; undef<br/>BEGIN &#160; &#160; &#160; &#160; defined? &#160; &#160; if &#160; &#160; &#160; &#160; &#160; rescue &#160; &#160; &#160; unless<br/>END &#160; &#160; &#160; &#160; &#160; do &#160; &#160; &#160; &#160; &#160; in &#160; &#160; &#160; &#160; &#160; retry &#160; &#160; &#160; &#160;until<br/>alias &#160; &#160; &#160; &#160; else &#160; &#160; &#160; &#160; module &#160; &#160; &#160; return &#160; &#160; &#160; when<br/>and &#160; &#160; &#160; &#160; &#160; elsif &#160; &#160; &#160; &#160;next &#160; &#160; &#160; &#160; self &#160; &#160; &#160; &#160; while<br/>begin &#160; &#160; &#160; &#160; end &#160; &#160; &#160; &#160; &#160;nil &#160; &#160; &#160; &#160; &#160;super &#160; &#160; &#160; &#160;yield<br/>break<br/>
<b>30&#160;|&#160;Chapter 2:</b> <b>The Structure and Execution of Ruby Programs</b><br/>
<hr/>
<a name=45></a>In&#160;addition&#160;to&#160;those&#160;keywords,&#160;there&#160;are&#160;three&#160;keyword-like&#160;tokens&#160;that&#160;are&#160;treated<br/>specially by the Ruby parser when they appear at the beginning of a line:<br/>
=begin &#160; &#160;=end &#160; &#160; &#160;__END__<br/>
As we’ve seen,&#160;=begin&#160;and&#160;=end&#160;at the beginning of a line delimit multiline comments.<br/>And&#160;the&#160;token&#160;__END__&#160;marks&#160;the&#160;end&#160;of&#160;the&#160;program&#160;(and&#160;the&#160;beginning&#160;of&#160;a&#160;data<br/>section) if it appears on a line by itself with no leading or trailing whitespace.<br/>In&#160;most&#160;languages,&#160;these&#160;words&#160;would&#160;be&#160;called&#160;“reserved&#160;words”&#160;and&#160;they&#160;would&#160;be<br/>never&#160;allowed&#160;as&#160;identifiers.&#160;The&#160;Ruby&#160;parser&#160;is&#160;flexible&#160;and&#160;does&#160;not&#160;complain&#160;if&#160;you<br/>prefix&#160;these&#160;keywords&#160;with&#160;@,&#160;@@,&#160;or&#160;$&#160;prefixes&#160;and&#160;use&#160;them&#160;as&#160;instance,&#160;class,&#160;or&#160;global<br/>variable&#160;names.&#160;Also,&#160;you&#160;can&#160;use&#160;these&#160;keywords&#160;as&#160;method&#160;names,&#160;with&#160;the&#160;caveat<br/>that&#160;the&#160;method&#160;must&#160;always&#160;be&#160;explicitly&#160;invoked&#160;through&#160;an&#160;object.&#160;Note,&#160;however,<br/>that&#160;using&#160;these&#160;keywords&#160;in&#160;identifiers&#160;will&#160;result&#160;in&#160;confusing&#160;code.&#160;The&#160;best&#160;practice<br/>is to treat these keywords as reserved.<br/>Many&#160;important&#160;features&#160;of&#160;the&#160;Ruby&#160;language&#160;are&#160;actually&#160;implemented&#160;as&#160;methods<br/>of&#160;the&#160;Kernel,&#160;Module,&#160;Class,&#160;and&#160;Object&#160;classes.&#160;It&#160;is&#160;good&#160;practice,&#160;therefore,&#160;to&#160;treat<br/>the following identifiers as reserved words as well:<br/>
# These are methods that appear to be statements or keywords<br/>at_exit &#160; &#160; &#160; &#160;catch &#160; &#160; &#160; &#160; &#160;private &#160; &#160; &#160; &#160;require<br/>attr &#160; &#160; &#160; &#160; &#160; include &#160; &#160; &#160; &#160;proc &#160; &#160; &#160; &#160; &#160; throw<br/>attr_accessor &#160;lambda &#160; &#160; &#160; &#160; protected<br/>attr_reader &#160; &#160;load &#160; &#160; &#160; &#160; &#160; public<br/>attr_writer &#160; &#160;loop &#160; &#160; &#160; &#160; &#160; raise<br/>
# These are commonly used global functions<br/>Array &#160; &#160; &#160; &#160; &#160;chomp! &#160; &#160; &#160; &#160; gsub! &#160; &#160; &#160; &#160; &#160;select<br/>Float &#160; &#160; &#160; &#160; &#160;chop &#160; &#160; &#160; &#160; &#160; iterator? &#160; &#160; &#160;sleep<br/>Integer &#160; &#160; &#160; &#160;chop! &#160; &#160; &#160; &#160; &#160;load &#160; &#160; &#160; &#160; &#160; split<br/>String &#160; &#160; &#160; &#160; eval &#160; &#160; &#160; &#160; &#160; open &#160; &#160; &#160; &#160; &#160; sprintf<br/>URI &#160; &#160; &#160; &#160; &#160; &#160;exec &#160; &#160; &#160; &#160; &#160; p &#160; &#160; &#160; &#160; &#160; &#160; &#160;srand<br/>abort &#160; &#160; &#160; &#160; &#160;exit &#160; &#160; &#160; &#160; &#160; print &#160; &#160; &#160; &#160; &#160;sub<br/>autoload &#160; &#160; &#160; exit! &#160; &#160; &#160; &#160; &#160;printf &#160; &#160; &#160; &#160; sub!<br/>autoload? &#160; &#160; &#160;fail &#160; &#160; &#160; &#160; &#160; putc &#160; &#160; &#160; &#160; &#160; syscall<br/>binding &#160; &#160; &#160; &#160;fork &#160; &#160; &#160; &#160; &#160; puts &#160; &#160; &#160; &#160; &#160; system<br/>block_given? &#160; format &#160; &#160; &#160; &#160; rand &#160; &#160; &#160; &#160; &#160; test<br/>callcc &#160; &#160; &#160; &#160; getc &#160; &#160; &#160; &#160; &#160; readline &#160; &#160; &#160; trap<br/>caller &#160; &#160; &#160; &#160; gets &#160; &#160; &#160; &#160; &#160; readlines &#160; &#160; &#160;warn<br/>chomp &#160; &#160; &#160; &#160; &#160;gsub &#160; &#160; &#160; &#160; &#160; scan<br/>
# These are commonly used object methods<br/>allocate &#160; &#160; &#160; freeze &#160; &#160; &#160; &#160; kind_of? &#160; &#160; &#160; superclass<br/>clone &#160; &#160; &#160; &#160; &#160;frozen? &#160; &#160; &#160; &#160;method &#160; &#160; &#160; &#160; taint<br/>display &#160; &#160; &#160; &#160;hash &#160; &#160; &#160; &#160; &#160; methods &#160; &#160; &#160; &#160;tainted?<br/>dup &#160; &#160; &#160; &#160; &#160; &#160;id &#160; &#160; &#160; &#160; &#160; &#160; new &#160; &#160; &#160; &#160; &#160; &#160;to_a<br/>enum_for &#160; &#160; &#160; inherited &#160; &#160; &#160;nil? &#160; &#160; &#160; &#160; &#160; to_enum<br/>eql? &#160; &#160; &#160; &#160; &#160; inspect &#160; &#160; &#160; &#160;object_id &#160; &#160; &#160;to_s<br/>equal? &#160; &#160; &#160; &#160; instance_of? &#160; respond_to? &#160; &#160;untaint<br/>extend &#160; &#160; &#160; &#160; is_a? &#160; &#160; &#160; &#160; &#160;send &#160; &#160; &#160; &#160; &#160;&#160;<br/>
<b>2.1 &#160;Lexical Structure&#160;|&#160;31</b><br/>
<hr/>
<a name=46></a><b>2.1.6 &#160;Whitespace<br/></b>Spaces,&#160;tabs,&#160;and&#160;newlines&#160;are&#160;not&#160;tokens&#160;themselves&#160;but&#160;are&#160;used&#160;to&#160;separate&#160;tokens<br/>that&#160;would&#160;otherwise&#160;merge&#160;into&#160;a&#160;single&#160;token.&#160;Aside&#160;from&#160;this&#160;basic&#160;token-separating<br/>function,&#160;most&#160;whitespace&#160;is&#160;ignored&#160;by&#160;the&#160;Ruby&#160;interpreter&#160;and&#160;is&#160;simply&#160;used&#160;to<br/>format&#160;programs&#160;so&#160;that&#160;they&#160;are&#160;easy&#160;to&#160;read&#160;and&#160;understand.&#160;Not&#160;all&#160;whitespace&#160;is<br/>ignored,&#160;however.&#160;Some&#160;is&#160;required,&#160;and&#160;some&#160;whitespace&#160;is&#160;actually&#160;forbidden.&#160;Ruby’s<br/>grammar&#160;is&#160;expressive&#160;but&#160;complex,&#160;and&#160;there&#160;are&#160;a&#160;few&#160;cases&#160;in&#160;which&#160;inserting&#160;or<br/>removing&#160;whitespace&#160;can&#160;change&#160;the&#160;meaning&#160;of&#160;a&#160;program.&#160;Although&#160;these&#160;cases&#160;do<br/>not often arise, it is important to know about them.<br/>
<b>2.1.6.1 &#160;Newlines as statement terminators<br/></b>The&#160;most&#160;common&#160;form&#160;of&#160;whitespace&#160;dependency&#160;has&#160;to&#160;do&#160;with&#160;newlines&#160;as&#160;state-<br/>ment&#160;terminators.&#160;In&#160;languages&#160;like&#160;C&#160;and&#160;Java,&#160;every&#160;statement&#160;must&#160;be&#160;terminated<br/>with&#160;a&#160;semicolon.&#160;You&#160;can&#160;use&#160;semicolons&#160;to&#160;terminate&#160;statements&#160;in&#160;Ruby,&#160;too,&#160;but<br/>this&#160;is&#160;only&#160;required&#160;if&#160;you&#160;put&#160;more&#160;than&#160;one&#160;statement&#160;on&#160;the&#160;same&#160;line.&#160;Convention<br/>dictates that semicolons be omitted elsewhere.<br/>Without&#160;explicit&#160;semicolons,&#160;the&#160;Ruby&#160;interpreter&#160;must&#160;figure&#160;out&#160;on&#160;its&#160;own&#160;where<br/>statements&#160;end.&#160;If&#160;the&#160;Ruby&#160;code&#160;on&#160;a&#160;line&#160;is&#160;a&#160;syntactically&#160;complete&#160;statement,&#160;Ruby<br/>uses&#160;the&#160;newline&#160;as&#160;the&#160;statement&#160;terminator.&#160;If&#160;the&#160;statement&#160;is&#160;not&#160;complete,&#160;then<br/>Ruby&#160;&#160;continues&#160;&#160;parsing&#160;&#160;the&#160;&#160;statement&#160;&#160;on&#160;&#160;the&#160;&#160;next&#160;&#160;line.&#160;&#160;(In&#160;&#160;Ruby&#160;&#160;1.9,&#160;&#160;there&#160;&#160;is&#160;&#160;one<br/>exception, which is described later in this section.)<br/>This&#160;is&#160;no&#160;problem&#160;if&#160;all&#160;your&#160;statements&#160;fit&#160;on&#160;a&#160;single&#160;line.&#160;When&#160;they&#160;don’t,&#160;however,<br/>you&#160;must&#160;take&#160;care&#160;that&#160;you&#160;break&#160;the&#160;line&#160;in&#160;such&#160;a&#160;way&#160;that&#160;the&#160;Ruby&#160;interpreter<br/>cannot&#160;interpret&#160;the&#160;first&#160;line&#160;as&#160;a&#160;statement&#160;of&#160;its&#160;own.&#160;This&#160;is&#160;where&#160;the&#160;whitespace<br/>dependency&#160;lies:&#160;your&#160;program&#160;may&#160;behave&#160;differently&#160;depending&#160;on&#160;where&#160;you&#160;insert<br/>a&#160;newline.&#160;For&#160;example,&#160;the&#160;following&#160;code&#160;adds&#160;x&#160;and&#160;y&#160;and&#160;assigns&#160;the&#160;sum&#160;to&#160;total:<br/>
total = x + &#160; &#160; # Incomplete expression, parsing continues<br/>&#160; y<br/>
But this code assigns&#160;x&#160;to&#160;total, and then evaluates&#160;y, doing nothing with it:<br/>
total = x &#160;# This is a complete expression<br/>&#160; + y &#160; &#160; &#160;# A useless but complete expression<br/>
As&#160;another&#160;example,&#160;consider&#160;the&#160;return&#160;and&#160;break&#160;statements.&#160;These&#160;statements&#160;may<br/>optionally&#160;be&#160;followed&#160;by&#160;an&#160;expression&#160;that&#160;provides&#160;a&#160;return&#160;value.&#160;A&#160;newline&#160;between<br/>the keyword and the expression will terminate the statement before the expression.<br/>You&#160;can&#160;safely&#160;insert&#160;a&#160;newline&#160;without&#160;fear&#160;of&#160;prematurely&#160;terminating&#160;your&#160;statement<br/>after&#160;an&#160;operator&#160;or&#160;after&#160;a&#160;period&#160;or&#160;comma&#160;in&#160;a&#160;method&#160;invocation,&#160;array&#160;literal,&#160;or<br/>hash literal.<br/>You&#160;can&#160;also&#160;escape&#160;a&#160;line&#160;break&#160;with&#160;a&#160;backslash,&#160;which&#160;prevents&#160;Ruby&#160;from&#160;auto-<br/>matically terminating the statement:<br/>
<b>32&#160;|&#160;Chapter 2:</b> <b>The Structure and Execution of Ruby Programs</b><br/>
<hr/>
<a name=47></a>var total = first_long_variable_name + second_long_variable_name \<br/>&#160; + third_long_variable_name # Note no statement terminator above<br/>
In&#160;Ruby&#160;1.9,&#160;the&#160;statement&#160;terminator&#160;rules&#160;change&#160;slightly.&#160;If&#160;the&#160;first&#160;nonspace&#160;char-<br/>acter&#160;on&#160;a&#160;line&#160;is&#160;a&#160;period,&#160;then&#160;the&#160;line&#160;is&#160;considered&#160;a&#160;continuation&#160;line,&#160;and&#160;the&#160;newline<br/>before&#160;it&#160;is&#160;not&#160;a&#160;statement&#160;terminator.&#160;Lines&#160;that&#160;start&#160;with&#160;periods&#160;are&#160;useful&#160;for&#160;the<br/>long&#160;method&#160;chains&#160;sometimes&#160;used&#160;with&#160;“fluent&#160;APIs,”&#160;in&#160;which&#160;each&#160;method&#160;invo-<br/>cation returns an object on which additional invocations can be made. For example:<br/>
animals = Array.new<br/>&#160; .push(&#34;dog&#34;) &#160; # Does not work in Ruby 1.8<br/>&#160; .push(&#34;cow&#34;)<br/>&#160; .push(&#34;cat&#34;)<br/>&#160; .sort<br/>
<b>2.1.6.2 &#160;Spaces and method invocations<br/></b>Ruby’s&#160;grammar&#160;allows&#160;the&#160;parentheses&#160;around&#160;method&#160;invocations&#160;to&#160;be&#160;omitted&#160;in<br/>certain&#160;circumstances.&#160;This&#160;allows&#160;Ruby&#160;methods&#160;to&#160;be&#160;used&#160;as&#160;if&#160;they&#160;were&#160;statements,<br/>which&#160;is&#160;an&#160;important&#160;part&#160;of&#160;Ruby’s&#160;elegance.&#160;Unfortunately,&#160;however,&#160;it&#160;opens&#160;up&#160;a<br/>pernicious&#160;whitespace&#160;dependency.&#160;Consider&#160;the&#160;following&#160;two&#160;lines,&#160;which&#160;differ&#160;only<br/>by a single space:<br/>
f(3+2)+1<br/>f (3+2)+1<br/>
The&#160;first&#160;line&#160;passes&#160;the&#160;value&#160;5&#160;to&#160;the&#160;function&#160;f&#160;and&#160;then&#160;adds&#160;1&#160;to&#160;the&#160;result.&#160;Since<br/>the&#160;second&#160;line&#160;has&#160;a&#160;space&#160;after&#160;the&#160;function&#160;name,&#160;Ruby&#160;assumes&#160;that&#160;the&#160;parentheses<br/>around&#160;the&#160;method&#160;call&#160;have&#160;been&#160;omitted.&#160;The&#160;parentheses&#160;that&#160;appear&#160;after&#160;the&#160;space<br/>are&#160;used&#160;to&#160;group&#160;a&#160;subexpression,&#160;but&#160;the&#160;entire&#160;expression&#160;(3+2)+1&#160;is&#160;used&#160;as&#160;the<br/>method&#160;argument.&#160;If&#160;warnings&#160;are&#160;enabled&#160;(with&#160;-w),&#160;Ruby&#160;issues&#160;a&#160;warning&#160;whenever<br/>it sees ambiguous code like this.<br/>The solution to this whitespace dependency is straightforward:<br/>
•&#160;Never put a space between a method name and the opening parenthesis.<br/>•&#160;If&#160;&#160;the&#160;&#160;first&#160;&#160;argument&#160;&#160;to&#160;&#160;a&#160;&#160;method&#160;&#160;begins&#160;&#160;with&#160;&#160;an&#160;&#160;open&#160;&#160;parenthesis,&#160;&#160;always&#160;&#160;use<br/>
parentheses in the method invocation. For example, write&#160;f((3+2)+1).<br/>
•&#160;Always&#160;run&#160;the&#160;Ruby&#160;interpreter&#160;with&#160;the&#160;-w&#160;option&#160;so&#160;it&#160;will&#160;warn&#160;you&#160;if&#160;you&#160;forget<br/>
either of the rules above!<br/>
<b>2.2 &#160;Syntactic Structure<br/></b>So&#160;far,&#160;we’ve&#160;discussed&#160;the&#160;tokens&#160;of&#160;a&#160;Ruby&#160;program&#160;and&#160;the&#160;characters&#160;that&#160;make<br/>them&#160;up.&#160;Now&#160;we&#160;move&#160;on&#160;to&#160;briefly&#160;describe&#160;how&#160;those&#160;lexical&#160;tokens&#160;combine&#160;into<br/>the&#160;larger&#160;syntactic&#160;structures&#160;of&#160;a&#160;Ruby&#160;program.&#160;This&#160;section&#160;describes&#160;the&#160;syntax&#160;of<br/>Ruby programs, from the simplest expressions to the largest modules. This section is,<br/>in effect, a roadmap to the chapters that follow.<br/>
<b>2.2 &#160;Syntactic Structure&#160;|&#160;33</b><br/>
<hr/>
<a name=48></a>The&#160;basic&#160;unit&#160;of&#160;syntax&#160;in&#160;Ruby&#160;is&#160;the&#160;<i>expression</i>.&#160;The&#160;Ruby&#160;interpreter&#160;<i>evaluates</i>&#160;ex-<br/>pressions,&#160;producing&#160;values.&#160;The&#160;simplest&#160;expressions&#160;are&#160;<i>primary expressions</i>, which<br/>represent&#160;values&#160;directly.&#160;Number&#160;and&#160;string&#160;literals,&#160;described&#160;earlier&#160;in&#160;this&#160;chapter,<br/>are primary expressions. Other primary expressions include certain keywords such as<br/>true,&#160;false,&#160;nil, and&#160;self.&#160;Variable&#160;references&#160;are&#160;also&#160;primary&#160;expressions;&#160;they&#160;eval-<br/>uate to the value of the variable.<br/>More complex values can be written as compound expressions:<br/>
[1,2,3] &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# An Array literal<br/>{1=&gt;&#34;one&#34;, 2=&gt;&#34;two&#34;} &#160; # A Hash literal<br/>1..3 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # A Range literal<br/>
Operators&#160;are&#160;used&#160;to&#160;perform&#160;computations&#160;on&#160;values,&#160;and&#160;compound&#160;expressions<br/>are built by combining simpler subexpressions with operators:<br/>
1 &#160; &#160; &#160; &#160; # A primary expression<br/>x &#160; &#160; &#160; &#160; # Another primary expression<br/>x = 1 &#160; &#160; # An assignment expression<br/>x = x + 1 # An expression with two operators<br/>
<a href="Rubys.html#99">Chapter&#160;&#160;4&#160;&#160;</a>covers&#160;&#160;operators&#160;&#160;and&#160;&#160;expressions,&#160;&#160;including&#160;&#160;variables&#160;&#160;and&#160;&#160;assignment<br/>expressions.<br/>Expressions&#160;can&#160;be&#160;combined&#160;with&#160;Ruby’s&#160;keywords&#160;to&#160;create&#160;<i>statements</i>,&#160;such&#160;as&#160;the<br/>if&#160;statement&#160;for&#160;conditionally&#160;executing&#160;code&#160;and&#160;the&#160;while&#160;statement&#160;for&#160;repeatedly<br/>executing code:<br/>
if x &lt; 10 then &#160; # If this expression is true<br/>&#160; x = x + 1 &#160; &#160; &#160;# Then execute this statement<br/>end &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Marks the end of the conditional<br/>
while x &lt; 10 do &#160;# While this expression is true...<br/>&#160; print x &#160; &#160; &#160; &#160;# Execute this statement<br/>&#160; x = x + 1 &#160; &#160; &#160;# Then execute this statement<br/>end &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Marks the end of the loop<br/>
In&#160;Ruby,&#160;these&#160;statements&#160;are&#160;technically&#160;expressions,&#160;but&#160;there&#160;is&#160;still&#160;a&#160;useful&#160;distinc-<br/>tion&#160;between&#160;expressions&#160;that&#160;affect&#160;the&#160;control&#160;flow&#160;of&#160;a&#160;program&#160;and&#160;those&#160;that&#160;do<br/><a href="Rubys.html#131">not. Chapter 5 explains Ruby’s control structures.<br/></a>In&#160;all&#160;but&#160;the&#160;most&#160;trivial&#160;programs,&#160;we&#160;usually&#160;need&#160;to&#160;group&#160;expressions&#160;and&#160;state-<br/>ments&#160;into&#160;parameterized&#160;units&#160;so&#160;that&#160;they&#160;can&#160;be&#160;executed&#160;repeatedly&#160;and&#160;operate&#160;on<br/>varying inputs. You may know these parameterized units as functions, procedures, or<br/>subroutines.&#160;Since&#160;Ruby&#160;is&#160;an&#160;object-oriented&#160;language,&#160;they&#160;are&#160;called&#160;<i>methods</i>.&#160;Meth-<br/>ods,&#160;along&#160;with&#160;related&#160;structures&#160;called&#160;<i>procs</i>&#160;and&#160;<i>lambdas</i>,&#160;are&#160;the&#160;topic&#160;<a href="Rubys.html#189">of&#160;Chapter 6.<br/></a>Finally,&#160;groups&#160;of&#160;methods&#160;that&#160;are&#160;designed&#160;to&#160;interoperate&#160;can&#160;be&#160;combined&#160;into<br/><i>classes</i>,&#160;and&#160;groups&#160;of&#160;related&#160;classes&#160;and&#160;methods&#160;that&#160;are&#160;independent&#160;of&#160;those&#160;classes<br/>can be organized into&#160;<i>modules</i><a href="Rubys.html#227">. Classes and modules are the topic of Chapter 7.</a><br/>
<b>34&#160;|&#160;Chapter 2:</b> <b>The Structure and Execution of Ruby Programs</b><br/>
<hr/>
<a name=49></a><b>2.2.1 &#160;Block Structure in Ruby<br/></b>Ruby&#160;programs&#160;have&#160;a&#160;block&#160;structure.&#160;Module,&#160;class,&#160;and&#160;method&#160;definitions,&#160;and<br/>most&#160;of&#160;Ruby’s&#160;statements,&#160;include&#160;blocks&#160;of&#160;nested&#160;code.&#160;These&#160;blocks&#160;are&#160;delimited<br/>by&#160;keywords&#160;or&#160;punctuation&#160;and,&#160;by&#160;convention,&#160;are&#160;indented&#160;two&#160;spaces&#160;relative&#160;to<br/>the&#160;delimiters.&#160;There&#160;are&#160;two&#160;kinds&#160;of&#160;blocks&#160;in&#160;Ruby&#160;programs.&#160;One&#160;kind&#160;is&#160;formally<br/>called&#160;a&#160;“block.”&#160;These&#160;blocks&#160;are&#160;the&#160;chunks&#160;of&#160;code&#160;associated&#160;with&#160;or&#160;passed&#160;to<br/>iterator methods:<br/>
3.times { print &#34;Ruby! &#34; }<br/>
In&#160;this&#160;code,&#160;the&#160;curly&#160;braces&#160;and&#160;the&#160;code&#160;inside&#160;them&#160;are&#160;the&#160;block&#160;associated&#160;with<br/>the&#160;iterator&#160;method&#160;invocation&#160;3.times.&#160;Formal&#160;blocks&#160;of&#160;this&#160;kind&#160;may&#160;be&#160;delimited<br/>with curly braces, or they may be delimited with the keywords&#160;do&#160;and&#160;end:<br/>
1.upto(10) do |x|<br/>&#160; print x<br/>end<br/>
do&#160;and&#160;end&#160;delimiters&#160;are&#160;usually&#160;used&#160;when&#160;the&#160;block&#160;is&#160;written&#160;on&#160;more&#160;than&#160;one&#160;line.<br/>Note&#160;the&#160;two-space&#160;indentation&#160;of&#160;the&#160;code&#160;within&#160;the&#160;block.&#160;Blocks&#160;are&#160;covered&#160;<a href="Rubys.html#154">in&#160;§5.4.<br/></a>To&#160;avoid&#160;ambiguity&#160;with&#160;these&#160;true&#160;blocks,&#160;we&#160;can&#160;call&#160;the&#160;other&#160;kind&#160;of&#160;block&#160;a&#160;<i>body<br/></i>(in&#160;practice,&#160;however,&#160;the&#160;term&#160;“block”&#160;is&#160;often&#160;used&#160;for&#160;both).&#160;A&#160;body&#160;is&#160;just&#160;the&#160;list<br/>of&#160;&#160;statements&#160;&#160;that&#160;&#160;comprise&#160;&#160;the&#160;&#160;body&#160;&#160;of&#160;&#160;a&#160;&#160;class&#160;&#160;definition,&#160;&#160;a&#160;&#160;method&#160;&#160;definition,&#160;&#160;a<br/>while&#160;loop,&#160;or&#160;whatever.&#160;Bodies&#160;are&#160;never&#160;delimited&#160;with&#160;curly&#160;braces&#160;in&#160;Ruby—key-<br/>words&#160;usually&#160;serve&#160;as&#160;the&#160;delimiters&#160;instead.&#160;The&#160;specific&#160;syntax&#160;for&#160;statement&#160;bodies,<br/>method&#160;bodies,&#160;and&#160;class&#160;and&#160;module&#160;bodies&#160;are&#160;documented&#160;in&#160;<a href="Rubys.html#131">Chapters&#160;5,&#160;</a><a href="Rubys.html#189">6, and&#160;</a><a href="Rubys.html#227">7.<br/></a>Bodies&#160;and&#160;blocks&#160;can&#160;be&#160;nested&#160;within&#160;each&#160;other,&#160;and&#160;Ruby&#160;programs&#160;typically&#160;have<br/>several&#160;levels&#160;of&#160;nested&#160;code,&#160;made&#160;readable&#160;by&#160;their&#160;relative&#160;indentation.&#160;Here&#160;is&#160;a<br/>
&#160;<br/>
schematic example:<br/>
module Stats &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# A module<br/>&#160; class Dataset &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # A class in the module<br/>&#160; &#160; def initialize(filename) &#160; &#160; &#160; &#160; &#160;# A method in the class<br/>&#160; &#160; &#160; IO.foreach(filename) do |line| &#160;# A block in the method<br/>&#160; &#160; &#160; &#160; if line[0,1] == &#34;#&#34; &#160; &#160; &#160; &#160; &#160; # An if statement in the block<br/>&#160; &#160; &#160; &#160; &#160; next &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# A simple statement in the if<br/>&#160; &#160; &#160; &#160; end &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # End the if body<br/>&#160; &#160; &#160; end &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # End the block<br/>&#160; &#160; end &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # End the method body<br/>&#160; end &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # End the class body<br/>end &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # End the module body<br/>
<b>2.3 &#160;File Structure<br/></b>There&#160;are&#160;only&#160;a&#160;few&#160;rules&#160;about&#160;how&#160;a&#160;file&#160;of&#160;Ruby&#160;code&#160;must&#160;be&#160;structured.&#160;These<br/>rules&#160;are&#160;related&#160;to&#160;the&#160;deployment&#160;of&#160;Ruby&#160;programs&#160;and&#160;are&#160;not&#160;directly&#160;relevant&#160;to<br/>the language itself.<br/>
<b>2.3 &#160;File Structure&#160;|&#160;35</b><br/>
<hr/>
<a name=50></a>First,&#160;if&#160;a&#160;Ruby&#160;program&#160;contains&#160;a&#160;“shebang”&#160;comment,&#160;to&#160;tell&#160;the&#160;(Unix-like)&#160;operating<br/>system how to execute it, that comment must appear on the first line.<br/>Second,&#160;if&#160;a&#160;Ruby&#160;program&#160;contains&#160;a&#160;“coding”&#160;comment&#160;(as&#160;described&#160;<a href="Rubys.html#51">in&#160;§2.4.1),&#160;</a>that<br/>comment&#160;must&#160;appear&#160;on&#160;the&#160;first&#160;line&#160;or&#160;on&#160;the&#160;second&#160;line&#160;if&#160;the&#160;first&#160;line&#160;is&#160;a&#160;shebang.<br/>Third,&#160;if&#160;a&#160;file&#160;contains&#160;a&#160;line&#160;that&#160;consists&#160;of&#160;the&#160;single&#160;token&#160;__END__&#160;with&#160;no&#160;whitespace<br/>before&#160;or&#160;after,&#160;then&#160;the&#160;Ruby&#160;interpreter&#160;stops&#160;processing&#160;the&#160;file&#160;at&#160;that&#160;point.&#160;The<br/>remainder&#160;of&#160;the&#160;file&#160;may&#160;contain&#160;arbitrary&#160;data&#160;that&#160;the&#160;program&#160;can&#160;read&#160;using&#160;the<br/>IO&#160;stream object&#160;DATA<a href="Rubys.html#403">. (See Chapter 10 and §9.7 for more about this global constant.)</a><br/>
Ruby&#160;programs&#160;are&#160;not&#160;required&#160;to&#160;fit&#160;in&#160;a&#160;single&#160;file.&#160;Many&#160;programs&#160;load&#160;additional<br/>Ruby&#160;code&#160;from&#160;external&#160;libraries,&#160;for&#160;example.&#160;Programs&#160;use&#160;require&#160;to&#160;load&#160;code&#160;from<br/>another file.&#160;require&#160;searches&#160;for&#160;specified&#160;modules&#160;of&#160;code&#160;against&#160;a&#160;search&#160;path,&#160;and<br/><a href="Rubys.html#266">prevents any given module from being loaded more than once. See §7.6 for details.<br/></a>The following code illustrates each of these points of Ruby file structure:<br/>
#!/usr/bin/ruby -w &#160; &#160; &#160; &#160; &#160;<i>shebang comment<br/></i># -*- coding: utf-8 -*- &#160; &#160;&#160;<i>coding comment<br/></i>require 'socket' &#160; &#160; &#160; &#160; &#160; &#160;<i>load networking library</i><br/>
&#160; ... &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;&#160;<i>program code goes here</i><br/>
__END__ &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;&#160;<i>mark end of code<br/></i>&#160; ... &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;&#160;<i>program data goes here</i><br/>
<b>2.4 &#160;Program Encoding<br/></b>At the lowest level, a Ruby program is simply a sequence of characters. Ruby’s lexical<br/>rules&#160;are&#160;defined&#160;using&#160;characters&#160;of&#160;the&#160;ASCII&#160;character&#160;set.&#160;Comments&#160;begin&#160;with&#160;the<br/>#&#160;character&#160;(ASCII&#160;code&#160;35),&#160;for&#160;example,&#160;and&#160;allowed&#160;whitespace&#160;characters&#160;are&#160;hor-<br/>izontal&#160;tab&#160;(ASCII&#160;9),&#160;newline&#160;(10),&#160;vertical&#160;tab&#160;(11),&#160;form&#160;feed&#160;(12),&#160;carriage&#160;return<br/>(13),&#160;and&#160;space&#160;(32).&#160;All&#160;Ruby&#160;keywords&#160;are&#160;written&#160;using&#160;ASCII&#160;characters,&#160;and&#160;all<br/>operators and other punctuation are drawn from the ASCII character set.<br/>By&#160;default,&#160;the&#160;Ruby&#160;interpreter&#160;assumes&#160;that&#160;Ruby&#160;source&#160;code&#160;is&#160;encoded&#160;in&#160;ASCII.<br/>This&#160;is&#160;not&#160;required,&#160;however;&#160;the&#160;interpreter&#160;can&#160;also&#160;process&#160;files&#160;that&#160;use&#160;other&#160;en-<br/>codings,&#160;as&#160;long&#160;as&#160;those&#160;encodings&#160;can&#160;represent&#160;the&#160;full&#160;set&#160;of&#160;ASCII&#160;characters.&#160;In<br/>order&#160;for&#160;the&#160;Ruby&#160;interpreter&#160;to&#160;be&#160;able&#160;to&#160;interpret&#160;the&#160;bytes&#160;of&#160;a&#160;source&#160;file&#160;as&#160;char-<br/>acters,&#160;it&#160;must&#160;know&#160;what&#160;encoding&#160;to&#160;use.&#160;Ruby&#160;files&#160;can&#160;identify&#160;their&#160;own&#160;encodings<br/>or you can tell the interpreter how they are encoded. Doing so is explained shortly.<br/>The&#160;Ruby&#160;interpreter&#160;is&#160;actually&#160;quite&#160;flexible&#160;about&#160;the&#160;characters&#160;that&#160;appear&#160;in&#160;a<br/>Ruby&#160;program.&#160;Certain&#160;ASCII&#160;characters&#160;have&#160;specific&#160;meanings,&#160;and&#160;certain&#160;ASCII<br/>characters&#160;are&#160;not&#160;allowed&#160;in&#160;identifiers,&#160;but&#160;beyond&#160;that,&#160;a&#160;Ruby&#160;program&#160;may&#160;contain<br/>any&#160;characters&#160;allowed&#160;by&#160;the&#160;encoding.&#160;We&#160;explained&#160;earlier&#160;that&#160;identifiers&#160;may&#160;con-<br/>tain characters outside of the ASCII character set. The same is true for comments and<br/>string&#160;and&#160;regular&#160;expression&#160;literals:&#160;they&#160;may&#160;contain&#160;any&#160;characters&#160;other&#160;than&#160;the<br/>
<b>36&#160;|&#160;Chapter 2:</b> <b>The Structure and Execution of Ruby Programs</b><br/>
<hr/>
<a name=51></a>delimiter&#160;character&#160;that&#160;marks&#160;the&#160;end&#160;of&#160;the&#160;comment&#160;or&#160;literal.&#160;In&#160;ASCII-encoded<br/>files,&#160;strings&#160;may&#160;include&#160;arbitrary&#160;bytes,&#160;including&#160;those&#160;that&#160;represent&#160;nonprinting<br/>control&#160;&#160;characters.&#160;&#160;(Using&#160;&#160;raw&#160;&#160;bytes&#160;&#160;like&#160;&#160;this&#160;&#160;is&#160;&#160;not&#160;&#160;recommended,&#160;&#160;however;&#160;&#160;Ruby<br/>string&#160;literals&#160;support&#160;escape&#160;sequences&#160;so&#160;that&#160;arbitrary&#160;characters&#160;can&#160;be&#160;included&#160;by<br/>numeric&#160;code&#160;instead.)&#160;If&#160;the&#160;file&#160;is&#160;written&#160;using&#160;the&#160;UTF-8&#160;encoding,&#160;then&#160;comments,<br/>strings,&#160;and&#160;regular&#160;expressions&#160;may&#160;include&#160;arbitrary&#160;Unicode&#160;characters.&#160;If&#160;the&#160;file&#160;is<br/>encoded&#160;using&#160;the&#160;Japanese&#160;SJIS&#160;or&#160;EUC&#160;encodings,&#160;then&#160;strings&#160;may&#160;include&#160;Kanji<br/>characters.<br/>
<b>2.4.1 &#160;Specifying Program Encoding<br/></b>By&#160;default,&#160;the&#160;Ruby&#160;interpreter&#160;assumes&#160;that&#160;programs&#160;are&#160;encoded&#160;in&#160;ASCII.&#160;In&#160;Ruby<br/>1.8,&#160;you&#160;can&#160;specify&#160;a&#160;different&#160;encoding&#160;with&#160;the&#160;-K&#160;command-line&#160;option.&#160;To&#160;run&#160;a<br/>Ruby&#160;program&#160;that&#160;includes&#160;Unicode&#160;characters&#160;encoded&#160;in&#160;UTF-8,&#160;invoke&#160;the&#160;inter-<br/>preter&#160;with&#160;the&#160;-Ku&#160;option.&#160;Programs&#160;that&#160;include&#160;Japanese&#160;characters&#160;in&#160;EUC-JP&#160;or<br/>SJIS encodings can be run with the&#160;-Ke&#160;and&#160;-Ks&#160;options.<br/>Ruby&#160;1.9&#160;also&#160;supports&#160;the&#160;-K&#160;option,&#160;but&#160;it&#160;is&#160;no&#160;longer&#160;the&#160;preferred&#160;way&#160;to&#160;specify<br/>the&#160;encoding&#160;of&#160;a&#160;program&#160;file.&#160;Rather&#160;than&#160;have&#160;the&#160;user&#160;of&#160;a&#160;script&#160;specify&#160;the&#160;encoding<br/>when&#160;they&#160;invoke&#160;Ruby,&#160;the&#160;author&#160;of&#160;the&#160;script&#160;can&#160;specify&#160;the&#160;encoding&#160;of&#160;the&#160;script<br/>by placing a special “coding comment” at the start of the file.*&#160;&#160;For example:<br/>
# coding: utf-8<br/>
The&#160;comment&#160;must&#160;be&#160;written&#160;entirely&#160;in&#160;ASCII,&#160;and&#160;must&#160;include&#160;the&#160;string&#160;coding<br/>followed&#160;by&#160;a&#160;colon&#160;or&#160;equals&#160;sign&#160;and&#160;the&#160;name&#160;of&#160;the&#160;desired&#160;encoding&#160;(which&#160;cannot<br/>include&#160;spaces&#160;or&#160;punctuation&#160;other&#160;than&#160;hyphen&#160;and&#160;underscore).&#160;Whitespace&#160;is&#160;al-<br/>lowed&#160;on&#160;either&#160;side&#160;of&#160;the&#160;colon&#160;or&#160;equals&#160;sign,&#160;and&#160;the&#160;string&#160;coding&#160;may&#160;have&#160;any<br/>prefix,&#160;such&#160;as&#160;en&#160;to&#160;spell&#160;encoding.&#160;The&#160;entire&#160;comment,&#160;including&#160;coding&#160;and&#160;the<br/>encoding&#160;name,&#160;is&#160;case-insensitive&#160;and&#160;can&#160;be&#160;written&#160;with&#160;upper-&#160;or&#160;lowercase&#160;letters.<br/>Encoding&#160;comments&#160;are&#160;usually&#160;written&#160;so&#160;that&#160;they&#160;also&#160;inform&#160;a&#160;text&#160;editor&#160;of&#160;the&#160;file<br/>encoding. Emacs users might write:<br/>
# -*- coding: utf-8 -*-<br/>
And vi users can write:<br/>
# vi: set fileencoding=utf-8 :<br/>
An&#160;encoding&#160;comment&#160;like&#160;this&#160;one&#160;is&#160;usually&#160;only&#160;valid&#160;on&#160;the&#160;first&#160;line&#160;of&#160;the&#160;file.&#160;It<br/>may&#160;appear&#160;on&#160;the&#160;second&#160;line,&#160;however,&#160;if&#160;the&#160;first&#160;line&#160;is&#160;a&#160;shebang&#160;comment&#160;(which<br/>makes a script executable on Unix-like operating systems):<br/>
#!/usr/bin/ruby -w<br/># coding: utf-8<br/>
*&#160;Ruby follows Python’s conventions in this; see&#160;<a href="http://www.python.org/dev/peps/pep-0263/"><i>http://www.python.org/dev/peps/pep-0263/</i>.</a><br/>
<b>2.4 &#160;Program Encoding&#160;|&#160;37</b><br/>
<hr/>
<a name=52></a>Encoding&#160;names&#160;are&#160;not&#160;case-sensitive&#160;and&#160;may&#160;be&#160;written&#160;in&#160;uppercase,&#160;lowercase,&#160;or<br/>a&#160;mix.&#160;Ruby&#160;1.9&#160;supports&#160;at&#160;least&#160;the&#160;following&#160;source&#160;encodings:&#160;ASCII-8BIT&#160;(also<br/>known&#160;&#160;as&#160;&#160;BINARY),&#160;&#160;US-ASCII&#160;&#160;(7-bit&#160;&#160;ASCII),&#160;&#160;the&#160;&#160;European&#160;&#160;encodings&#160;&#160;ISO-8859-1<br/>through&#160;&#160;ISO-8859-15,&#160;&#160;the&#160;&#160;Unicode&#160;&#160;encoding&#160;&#160;UTF-8,&#160;&#160;and&#160;&#160;the&#160;&#160;Japanese&#160;&#160;encodings<br/>SHIFT_JIS (also known as SJIS) and EUC-JP. Your build or distribution of Ruby may<br/>support additional encodings as well.<br/>As&#160;a&#160;special&#160;case,&#160;UTF-8-encoded&#160;files&#160;identify&#160;their&#160;encoding&#160;if&#160;the&#160;first&#160;three&#160;bytes&#160;of<br/>the&#160;file&#160;are&#160;0xEF&#160;0xBB&#160;0xBF.&#160;These&#160;bytes&#160;are&#160;known&#160;as&#160;the&#160;BOM&#160;or&#160;“Byte&#160;Order&#160;Mark”<br/>and&#160;are&#160;optional&#160;in&#160;UTF-8-encoded&#160;files.&#160;(Certain&#160;Windows&#160;programs&#160;add&#160;these&#160;bytes<br/>when saving Unicode files.)<br/>In&#160;Ruby&#160;1.9,&#160;the&#160;language&#160;keyword&#160;__ENCODING__&#160;(there&#160;are&#160;two&#160;underscores&#160;at&#160;the&#160;<br/>beginning&#160;and&#160;at&#160;the&#160;end)&#160;evaluates&#160;to&#160;the&#160;source&#160;encoding&#160;of&#160;the&#160;currently&#160;executing<br/>code.&#160;&#160;The&#160;&#160;resulting&#160;&#160;value&#160;&#160;is&#160;&#160;an&#160;&#160;Encoding&#160;&#160;object.&#160;&#160;(See&#160;&#160;<a href="Rubys.html#76">§3.2.6.2&#160;&#160;</a>for&#160;&#160;more&#160;&#160;on&#160;&#160;the<br/>Encoding&#160;class.)<br/>
<b>2.4.2 &#160;Source, External, and Internal Encodings<br/></b>In&#160;Ruby&#160;1.9,&#160;it&#160;is&#160;important&#160;to&#160;understand&#160;the&#160;difference&#160;between&#160;the&#160;<i>source encoding<br/></i>of&#160;a&#160;single&#160;Ruby&#160;file&#160;and&#160;the&#160;<i>default&#160;external</i>&#160;and&#160;<i>default&#160;internal</i>&#160;encodings&#160;of&#160;the&#160;entire<br/>Ruby&#160;process.&#160;The&#160;source&#160;encoding&#160;is&#160;what&#160;we&#160;described&#160;earlier:&#160;it&#160;tells&#160;the&#160;Ruby&#160;in-<br/>terpreter&#160;how&#160;to&#160;read&#160;characters&#160;in&#160;a&#160;script.&#160;Source&#160;encodings&#160;are&#160;typically&#160;set&#160;with<br/>coding&#160;comments.&#160;A&#160;Ruby&#160;program&#160;may&#160;consist&#160;of&#160;more&#160;than&#160;one&#160;file,&#160;and&#160;different<br/>files&#160;may&#160;have&#160;different&#160;source&#160;encodings.&#160;The&#160;source&#160;encoding&#160;of&#160;a&#160;file&#160;affects&#160;the<br/>encoding&#160;of&#160;the&#160;string&#160;literals&#160;in&#160;that&#160;file.&#160;For&#160;more&#160;about&#160;the&#160;encoding&#160;of&#160;strings,&#160;see<br/><a href="Rubys.html#72">§3.2.6.<br/></a>The&#160;default&#160;external&#160;encoding&#160;is&#160;something&#160;different:&#160;this&#160;is&#160;the&#160;encoding&#160;that&#160;Ruby<br/>uses&#160;by&#160;default&#160;when&#160;reading&#160;from&#160;files&#160;and&#160;streams.&#160;The&#160;default&#160;external&#160;encoding&#160;is<br/>global&#160;to&#160;the&#160;Ruby&#160;process&#160;and&#160;does&#160;not&#160;change&#160;from&#160;file&#160;to&#160;file.&#160;Normally,&#160;the&#160;default<br/>external&#160;encoding&#160;is&#160;set&#160;based&#160;on&#160;the&#160;locale&#160;that&#160;your&#160;computer&#160;is&#160;configured&#160;to.&#160;But<br/>you&#160;can&#160;also&#160;explicitly&#160;specify&#160;the&#160;default&#160;external&#160;encoding&#160;with&#160;command-line&#160;op-<br/>tions,&#160;&#160;as&#160;&#160;we’ll&#160;&#160;describe&#160;&#160;shortly.&#160;&#160;The&#160;&#160;default&#160;&#160;external&#160;&#160;encoding&#160;&#160;does&#160;&#160;not&#160;&#160;affect&#160;&#160;the<br/><a href="Rubys.html#373">encoding of string literals, but it is quite important for I/O, as we’ll see in §9.7.2.<br/></a>When a Ruby program reads text from a file or network socket, it normally leaves the<br/>text&#160;in&#160;its&#160;native&#160;encoding.&#160;If&#160;you&#160;prefer&#160;to&#160;have&#160;all&#160;text&#160;automatically&#160;transcoded&#160;to&#160;a<br/>single&#160;common&#160;encoding,&#160;you&#160;can&#160;specify&#160;a&#160;default&#160;internal&#160;encoding&#160;using&#160;the&#160;com-<br/><a href="Rubys.html#373">mand-line options described below. See §9.7.2 for more details.<br/></a>We&#160;described&#160;the&#160;-K&#160;interpreter&#160;option&#160;earlier&#160;as&#160;a&#160;way&#160;to&#160;set&#160;the&#160;source&#160;encoding.&#160;In<br/>fact,&#160;what&#160;this&#160;option&#160;really&#160;does&#160;is&#160;set&#160;the&#160;default&#160;external&#160;encoding&#160;of&#160;the&#160;process&#160;and<br/>then uses that encoding as the default source encoding.<br/>In&#160;Ruby&#160;1.9,&#160;the&#160;-K&#160;option&#160;exists&#160;for&#160;compatibility&#160;with&#160;Ruby&#160;1.8&#160;but&#160;is&#160;not&#160;the&#160;preferred<br/>way&#160;to&#160;set&#160;the&#160;default&#160;external&#160;encoding.&#160;Two&#160;new&#160;options,&#160;-E&#160;and&#160;--encoding, allow<br/>
<b>38&#160;|&#160;Chapter 2:</b> <b>The Structure and Execution of Ruby Programs</b><br/>
<hr/>
<a name=53></a>you&#160;to&#160;set&#160;both&#160;the&#160;default&#160;external&#160;and&#160;the&#160;default&#160;internal&#160;encoding&#160;and&#160;to&#160;specify&#160;an<br/>encoding by its full name rather than by a one-character abbreviation. For example:<br/>
ruby -E utf-8 &#160; &#160; &#160; &#160; &#160; &#160;# Default external encoding name follows -E<br/>ruby -Eutf-8 &#160; &#160; &#160; &#160; &#160; &#160; # The space is optional<br/>ruby -E utf-8:binary &#160; &#160; # Specify external and internal encodings<br/>ruby -E :sjis &#160; &#160; &#160; &#160; &#160; &#160;# Specify default internal encoding only<br/>ruby --encoding utf-8 &#160; &#160;# --encoding is just like -E<br/>ruby --encoding=utf-8 &#160; &#160;# Or use an equals sign with --encoding<br/>
The&#160;&#160;-U&#160;&#160;(for&#160;&#160;Unicode)&#160;&#160;option&#160;&#160;specifies&#160;&#160;a&#160;&#160;default&#160;&#160;internal&#160;&#160;encoding&#160;&#160;of&#160;&#160;UTF-8.&#160;&#160;It&#160;&#160;is&#160;&#160;a<br/>shortcut&#160;for&#160;-E:utf-8.&#160;See&#160;<a href="Rubys.html#404">§10.1&#160;</a>for&#160;complete&#160;details&#160;on&#160;these&#160;interpreter&#160;command-<br/>line options.<br/>You&#160;&#160;can&#160;&#160;query&#160;&#160;the&#160;&#160;default&#160;&#160;external&#160;&#160;and&#160;&#160;default&#160;&#160;internal&#160;&#160;encodings&#160;&#160;with<br/>Encoding.default_external&#160;and&#160;Encoding.default_internal.&#160;These&#160;&#160;class&#160;methods&#160;re-<br/>turn&#160;an&#160;Encoding&#160;object.&#160;Use&#160;Encoding.locale_charmap&#160;to&#160;obtain&#160;the&#160;name&#160;(as&#160;&#160;a&#160;string)<br/>of&#160;the&#160;character&#160;encoding&#160;derived&#160;from&#160;the&#160;locale.&#160;This&#160;method&#160;is&#160;always&#160;based&#160;on&#160;the<br/>locale&#160;setting&#160;and&#160;ignores&#160;command-line&#160;options&#160;that&#160;override&#160;the&#160;default&#160;external&#160;en-<br/>coding.<br/>
<b>2.5 &#160;Program Execution<br/></b>Ruby&#160;is&#160;a&#160;scripting&#160;language.&#160;This&#160;means&#160;that&#160;Ruby&#160;programs&#160;are&#160;simply&#160;lists,&#160;or&#160;scripts,<br/>of&#160;statements&#160;to&#160;be&#160;executed.&#160;By&#160;default,&#160;these&#160;statements&#160;are&#160;executed&#160;sequentially,&#160;in<br/>the&#160;order&#160;they&#160;appear.&#160;Ruby’s&#160;control&#160;structures&#160;(described&#160;in&#160;<a href="Rubys.html#131">Chapter&#160;5)&#160;</a>alter&#160;this<br/>default&#160;execution&#160;order&#160;and&#160;allow&#160;statements&#160;to&#160;be&#160;executed&#160;conditionally&#160;or&#160;repeat-<br/>edly, for example.<br/>Programmers&#160;who&#160;are&#160;used&#160;to&#160;traditional&#160;static&#160;compiled&#160;languages&#160;like&#160;C&#160;or&#160;Java&#160;may<br/>find&#160;this&#160;slightly&#160;confusing.&#160;There&#160;is&#160;no&#160;special&#160;main&#160;method&#160;in&#160;Ruby&#160;from&#160;which&#160;exe-<br/>cution&#160;begins.&#160;The&#160;Ruby&#160;interpreter&#160;is&#160;given&#160;a&#160;script&#160;of&#160;statements&#160;to&#160;execute,&#160;and&#160;it<br/>begins executing at the first line and continues to the last line.<br/>(Actually,&#160;that&#160;last&#160;statement&#160;is&#160;not&#160;quite&#160;true.&#160;The&#160;Ruby&#160;interpreter&#160;first&#160;scans&#160;the&#160;file&#160;<br/>for&#160;BEGIN&#160;statements,&#160;and&#160;executes&#160;the&#160;code&#160;in&#160;their&#160;bodies.&#160;Then&#160;it&#160;goes&#160;back&#160;to&#160;line&#160;1<br/><a href="Rubys.html#179">and starts executing sequentially. See §5.7 for more on&#160;</a>BEGIN.)<br/>Another&#160;difference&#160;between&#160;Ruby&#160;and&#160;compiled&#160;languages&#160;has&#160;to&#160;do&#160;with&#160;module,&#160;class,<br/>and method definitions. In compiled languages, these are syntactic structures that are<br/>processed&#160;by&#160;the&#160;compiler.&#160;In&#160;Ruby,&#160;they&#160;are&#160;statements&#160;like&#160;any&#160;other.&#160;When&#160;the&#160;Ruby<br/>interpreter&#160;encounters&#160;a&#160;class&#160;definition,&#160;it&#160;executes&#160;it,&#160;causing&#160;a&#160;new&#160;class&#160;to&#160;come&#160;into<br/>existence.&#160;&#160;Similarly,&#160;&#160;when&#160;&#160;the&#160;&#160;Ruby&#160;&#160;interpreter&#160;&#160;encounters&#160;&#160;a&#160;&#160;method&#160;&#160;definition,&#160;&#160;it<br/>executes&#160;it,&#160;causing&#160;a&#160;new&#160;method&#160;to&#160;be&#160;defined.&#160;Later&#160;in&#160;the&#160;program,&#160;the&#160;interpreter<br/>will probably encounter and execute a method invocation expression for the method,<br/>and this invocation will cause the statements in the method body to be executed.<br/>
<b>2.5 &#160;Program Execution&#160;|&#160;39</b><br/>
<hr/>
<a name=54></a>The&#160;Ruby&#160;interpreter&#160;is&#160;invoked&#160;from&#160;the&#160;command&#160;line&#160;and&#160;given&#160;a&#160;script&#160;to&#160;execute.<br/>Very&#160;simple&#160;one-line&#160;scripts&#160;are&#160;sometimes&#160;written&#160;directly&#160;on&#160;the&#160;command&#160;line.&#160;More<br/>commonly,&#160;however,&#160;the&#160;name&#160;of&#160;the&#160;file&#160;containing&#160;the&#160;script&#160;is&#160;specified.&#160;The&#160;Ruby<br/>interpreter&#160;reads&#160;the&#160;file&#160;and&#160;executes&#160;the&#160;script.&#160;It&#160;first&#160;executes&#160;any&#160;BEGIN&#160;blocks.&#160;Then<br/>it starts at the first line of the file and continues until one of the following happens:<br/>
•&#160;It executes a statement that causes the Ruby program to terminate.<br/>•&#160;It reaches the end of the file.<br/>•&#160;It reads a line that marks the logical end of the file with the token&#160;__END__.<br/>
Before&#160;it&#160;quits,&#160;the&#160;Ruby&#160;interpreter&#160;typically&#160;(unless&#160;the&#160;&#160;exit!&#160;method&#160;was&#160;called)<br/>executes&#160;the&#160;bodies&#160;of&#160;any&#160;END&#160;statements&#160;it&#160;has&#160;encountered&#160;and&#160;any&#160;other&#160;“shutdown<br/>hook” code registered with the&#160;at_exit&#160;function.<br/>
<b>40&#160;|&#160;Chapter 2:</b> <b>The Structure and Execution of Ruby Programs</b><br/>
<hr/>
<a name=55></a><img src="Ruby-55_1.jpg"/><br/>
<b>CHAPTER&#160;3</b><br/>
<b>Datatypes and Objects</b><br/>
<b>41</b><br/>
<hr/>
<a name=56></a><img src="Ruby-56_1.png"/><br/>
In&#160;order&#160;to&#160;understand&#160;a&#160;programming&#160;language,&#160;you&#160;have&#160;to&#160;know&#160;what&#160;kinds&#160;of&#160;data<br/>it&#160;can&#160;manipulate&#160;and&#160;what&#160;it&#160;can&#160;do&#160;with&#160;that&#160;data.&#160;This&#160;chapter&#160;is&#160;about&#160;the&#160;values<br/>manipulated&#160;by&#160;Ruby&#160;programs.&#160;It&#160;begins&#160;with&#160;comprehensive&#160;coverage&#160;of&#160;numeric&#160;and<br/>textual&#160;values.&#160;Next,&#160;it&#160;explains&#160;arrays&#160;and&#160;hashes—two&#160;important&#160;data&#160;structures&#160;that<br/>are&#160;a&#160;fundamental&#160;part&#160;of&#160;Ruby.&#160;The&#160;chapter&#160;then&#160;moves&#160;on&#160;to&#160;explain&#160;ranges,&#160;symbols,<br/>and&#160;the&#160;special&#160;values&#160;true,&#160;false,&#160;and&#160;nil.&#160;All&#160;Ruby&#160;values&#160;are&#160;objects,&#160;and&#160;this&#160;chapter<br/>concludes with detailed coverage of the features that all objects share.<br/>The&#160;classes&#160;described&#160;in&#160;this&#160;chapter&#160;are&#160;the&#160;fundamental&#160;datatypes&#160;of&#160;the&#160;Ruby&#160;lan-<br/>guage.&#160;This&#160;chapter&#160;explains&#160;the&#160;basic&#160;behavior&#160;of&#160;those&#160;types:&#160;how&#160;literal&#160;values&#160;are<br/>written&#160;in&#160;a&#160;program,&#160;how&#160;integer&#160;and&#160;floating-point&#160;arithmetic&#160;work,&#160;how&#160;textual&#160;data<br/>is&#160;encoded,&#160;how&#160;values&#160;can&#160;serve&#160;as&#160;hash&#160;keys,&#160;and&#160;so&#160;on.&#160;Although&#160;we&#160;cover&#160;numbers,<br/>strings,&#160;arrays,&#160;and&#160;hashes&#160;here,&#160;this&#160;chapter&#160;makes&#160;no&#160;attempt&#160;to&#160;explain&#160;the&#160;APIs<br/>defined&#160;by&#160;those&#160;types.&#160;Instead,&#160;<a href="Rubys.html#317">Chapter 9</a>&#160;demonstrates&#160;those&#160;APIs&#160;by&#160;example,&#160;and<br/>it also covers many other important (but nonfundamental) classes.<br/>
<b>3.1 &#160;Numbers<br/></b>Ruby&#160;includes&#160;five&#160;built-in&#160;classes&#160;for&#160;representing&#160;numbers,&#160;and&#160;the&#160;standard&#160;library<br/>includes&#160;three&#160;more&#160;numeric&#160;classes&#160;that&#160;are&#160;sometimes&#160;useful.&#160;<a href="Rubys.html#56">Figure&#160;3-1&#160;</a>shows&#160;the<br/>class hierarchy.<br/>
<i>Figure 3-1. Numeric class hierarchy</i><br/>
All&#160;&#160;number&#160;&#160;objects&#160;&#160;in&#160;&#160;Ruby&#160;&#160;are&#160;&#160;instances&#160;&#160;of&#160;&#160;Numeric.&#160;&#160;All&#160;&#160;integers&#160;&#160;are&#160;&#160;instances&#160;&#160;of<br/>Integer.&#160;&#160;If&#160;&#160;an&#160;&#160;integer&#160;&#160;value&#160;&#160;fits&#160;&#160;within&#160;&#160;31&#160;&#160;bits&#160;&#160;(on&#160;&#160;most&#160;&#160;implementations),&#160;&#160;it&#160;&#160;is&#160;&#160;an<br/>instance of&#160;Fixnum. Otherwise,&#160;it&#160;is&#160;a&#160;Bignum.&#160;Bignum&#160;objects&#160;represent&#160;integers&#160;of&#160;arbi-<br/>trary&#160;size,&#160;and&#160;if&#160;the&#160;result&#160;of&#160;an&#160;operation&#160;on&#160;Fixnum&#160;operands&#160;is&#160;too&#160;big&#160;to&#160;fit&#160;in&#160;a<br/>Fixnum,&#160;that&#160;result&#160;is&#160;transparently&#160;converted&#160;to&#160;a&#160;Bignum.&#160;Similarly,&#160;if&#160;the&#160;result&#160;of&#160;an<br/>operation&#160;&#160;on&#160;&#160;Bignum&#160;&#160;objects&#160;&#160;falls&#160;&#160;within&#160;&#160;the&#160;&#160;range&#160;&#160;of&#160;&#160;Fixnum,&#160;&#160;then&#160;&#160;the&#160;&#160;result&#160;&#160;is&#160;&#160;a<br/>Fixnum.&#160;Real&#160;numbers&#160;are&#160;approximated&#160;in&#160;Ruby&#160;with&#160;the&#160;Float&#160;class,&#160;which&#160;uses&#160;the<br/>native floating-point representation of the platform.<br/>
<b>42&#160;|&#160;Chapter 3:</b> <b>Datatypes and Objects</b><br/>
<hr/>
<a name=57></a>The&#160;Complex&#160;class&#160;represents&#160;complex&#160;numbers,&#160;of&#160;course.&#160;&#160;BigDecimal&#160;represents real<br/>numbers&#160;with&#160;arbitrary&#160;precision,&#160;using&#160;a&#160;decimal&#160;representation&#160;rather&#160;than&#160;a&#160;binary<br/>representation. And&#160;Rational&#160;represents&#160;rational&#160;numbers:&#160;one&#160;integer&#160;divided&#160;by&#160;an-<br/>other.&#160;In&#160;Ruby&#160;1.8&#160;these&#160;classes&#160;are&#160;in&#160;the&#160;standard&#160;library.&#160;In&#160;Ruby&#160;1.9,&#160;Complex&#160;and<br/>Rational&#160;are built-in.<br/>
All numeric objects are&#160;<i>immutable</i>;&#160;there&#160;are&#160;no&#160;methods&#160;that&#160;allow&#160;you&#160;to&#160;change&#160;the<br/>value&#160;held&#160;by&#160;the&#160;object.&#160;If&#160;you&#160;pass&#160;a&#160;reference&#160;to&#160;a&#160;numeric&#160;object&#160;to&#160;a&#160;method,&#160;you<br/>need&#160;not&#160;worry&#160;that&#160;the&#160;method&#160;will&#160;modify&#160;the&#160;object.&#160;Fixnum&#160;objects&#160;are&#160;commonly<br/>used,&#160;and&#160;Ruby&#160;implementations&#160;typically&#160;treat&#160;them&#160;as&#160;immediate&#160;values&#160;rather&#160;than<br/>as&#160;references.&#160;Because&#160;numbers&#160;are&#160;immutable,&#160;however,&#160;there&#160;is&#160;really&#160;no&#160;way&#160;to&#160;tell<br/>the difference.<br/>
<b>3.1.1 &#160;Integer Literals<br/></b>An integer literal is simply a sequence of digits:<br/>
0<br/>123<br/>12345678901234567890<br/>
If&#160;&#160;the&#160;&#160;integer&#160;&#160;values&#160;&#160;fit&#160;&#160;within&#160;&#160;the&#160;&#160;range&#160;&#160;of&#160;&#160;the&#160;&#160;Fixnum&#160;&#160;class,&#160;&#160;the&#160;&#160;value&#160;&#160;is&#160;&#160;a&#160;&#160;Fixnum.<br/>Otherwise,&#160;it&#160;is&#160;a&#160;Bignum,&#160;which&#160;supports&#160;integers&#160;of&#160;any&#160;size.&#160;Underscores&#160;may&#160;be<br/>inserted&#160;into&#160;integer&#160;literals&#160;(though&#160;not&#160;at&#160;the&#160;beginning&#160;or&#160;end),&#160;and&#160;this&#160;feature&#160;is<br/>sometimes used as a thousands separator:<br/>
1_000_000_000 &#160; &#160; # One billion (or 1,000 million in the UK)<br/>
If&#160;an&#160;integer&#160;literal&#160;begins&#160;with&#160;zero&#160;and&#160;has&#160;more&#160;than&#160;one&#160;digit,&#160;then&#160;it&#160;is&#160;interpreted<br/>in&#160;some&#160;base&#160;other&#160;than&#160;base&#160;10.&#160;Numbers&#160;beginning&#160;with&#160;0x&#160;or&#160;0X&#160;are&#160;hexadecimal<br/>(base&#160;16)&#160;and&#160;use&#160;the&#160;letters&#160;a&#160;through&#160;f&#160;(or&#160;A&#160;through&#160;F)&#160;as&#160;digits&#160;for&#160;10&#160;through&#160;15.<br/>Numbers&#160;beginning&#160;0b&#160;or&#160;0B&#160;are&#160;binary&#160;(base&#160;2)&#160;and&#160;may&#160;only&#160;include&#160;digits&#160;0&#160;and&#160;1.<br/>Numbers&#160;&#160;beginning&#160;&#160;with&#160;&#160;0&#160;&#160;and&#160;&#160;no&#160;&#160;subsequent&#160;&#160;letter&#160;&#160;are&#160;&#160;octal&#160;&#160;(base&#160;&#160;8)&#160;&#160;and&#160;&#160;should<br/>consist of digits between&#160;0&#160;and&#160;7. Examples:<br/>
0377 &#160; &#160; &#160; &#160; &#160; # Octal representation of 255<br/>0b1111_1111 &#160; &#160;# Binary representation of 255<br/>0xFF &#160; &#160; &#160; &#160; &#160; # Hexadecimal representation of 255<br/>
To&#160;&#160;represent&#160;&#160;a&#160;&#160;negative&#160;&#160;number,&#160;&#160;simply&#160;&#160;begin&#160;&#160;an&#160;&#160;integer&#160;&#160;literal&#160;&#160;with&#160;&#160;a&#160;&#160;minus&#160;&#160;sign.<br/>Literals&#160;may&#160;also&#160;begin&#160;with&#160;a&#160;plus&#160;sign,&#160;although&#160;this&#160;never&#160;changes&#160;the&#160;meaning&#160;of<br/>the literal.<br/>
<b>3.1.2 &#160;Floating-Point Literals<br/></b>A&#160;floating-point&#160;literal&#160;is&#160;an&#160;optional&#160;sign&#160;followed&#160;by&#160;one&#160;or&#160;more&#160;decimal&#160;digits,&#160;a<br/>decimal&#160;point&#160;(the&#160;.&#160;character),&#160;one&#160;or&#160;more&#160;additional&#160;digits,&#160;and&#160;an&#160;optional&#160;expo-<br/>nent.&#160;An&#160;exponent&#160;begins&#160;with&#160;the&#160;letter&#160;e&#160;or&#160;E,&#160;and&#160;is&#160;followed&#160;by&#160;an&#160;optional&#160;sign&#160;and<br/>one&#160;or&#160;more&#160;decimal&#160;digits.&#160;As&#160;with&#160;integer&#160;literals,&#160;underscores&#160;may&#160;be&#160;used&#160;within<br/>
<b>3.1 &#160;Numbers&#160;|&#160;43</b><br/>
<hr/>
<a name=58></a>floating-point&#160;literals.&#160;Unlike&#160;integer&#160;literals,&#160;it&#160;is&#160;not&#160;possible&#160;to&#160;express&#160;floating-point<br/>values&#160;in&#160;any&#160;radix&#160;other&#160;than&#160;base&#160;10.&#160;Here&#160;are&#160;some&#160;examples&#160;of&#160;floating-point&#160;literals:<br/>
0.0 &#160; &#160; &#160;<br/>-3.14<br/>6.02e23 &#160; &#160; &#160; # This means 6.02 × 1023<br/>1_000_000.01 &#160;# One million and a little bit more<br/>
Ruby&#160;requires&#160;that&#160;digits&#160;appear&#160;before&#160;and&#160;after&#160;the&#160;decimal&#160;point.&#160;You&#160;cannot&#160;simply<br/>write&#160;.1,&#160;for&#160;example;&#160;you&#160;must&#160;explicitly&#160;write&#160;0.1.&#160;This&#160;is&#160;necessary&#160;to&#160;avoid&#160;ambiguity<br/>in Ruby’s complex grammar. Ruby differs from many other languages in this way.<br/>
<b>3.1.3 &#160;Arithmetic in Ruby<br/></b>All&#160;numeric&#160;types&#160;in&#160;Ruby&#160;define&#160;standard&#160;+,&#160;–,&#160;*,&#160;and&#160;/&#160;operators&#160;for&#160;addition,&#160;sub-<br/>traction,&#160;multiplication,&#160;and&#160;division.&#160;When&#160;an&#160;integer&#160;result&#160;is&#160;too&#160;large&#160;for&#160;a&#160;Fixnum,&#160;<br/>Ruby&#160;automatically&#160;converts&#160;to&#160;a&#160;Bignum,&#160;and&#160;as&#160;a&#160;result,&#160;integer&#160;arithmetic&#160;in&#160;Ruby<br/>never&#160;overflows&#160;as&#160;it&#160;does&#160;in&#160;many&#160;other&#160;languages.&#160;Floating-point&#160;numbers&#160;(at&#160;least<br/>on&#160;platforms&#160;that&#160;use&#160;the&#160;standard&#160;IEEE-754&#160;floating-point&#160;representation)&#160;overflow<br/>to special positive or negative infinity values, and underflow to zero.<br/>The&#160;division&#160;operator&#160;depends&#160;on&#160;the&#160;class&#160;of&#160;the&#160;operands:&#160;if both operands are inte-<br/>gers,&#160;then&#160;truncating&#160;integer&#160;division&#160;is&#160;performed.&#160;If&#160;either&#160;operand&#160;is&#160;a&#160;Float,&#160;then<br/>floating-point&#160;division&#160;is&#160;performed.&#160;There&#160;are&#160;also&#160;three&#160;division&#160;methods:&#160;div&#160;per-<br/>forms&#160;&#160;integer&#160;&#160;division,&#160;&#160;fdiv&#160;&#160;performs&#160;&#160;floating-point&#160;&#160;division,&#160;&#160;and&#160;&#160;quo&#160;&#160;returns&#160;&#160;a<br/>Rational&#160;&#160;when&#160;&#160;possible,&#160;&#160;and&#160;&#160;otherwise&#160;&#160;returns&#160;&#160;a&#160;&#160;Float&#160;&#160;(this&#160;&#160;requires&#160;&#160;the&#160;&#160;“rational”<br/>module in Ruby 1.8):<br/>
[5/2, 5.0/2, 5/2.0] &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; [2, 2.5, 2.5]<br/>[5.0.div(2), 5.0.fdiv(2), 5.quo(2)] # =&gt; [2, 2.5, Rational(5,2)]<br/>
&#160;<br/>
Integer&#160;division&#160;by&#160;zero&#160;causes&#160;a&#160;ZeroDivisionError&#160;to be thrown. Floating-point divi-<br/>sion&#160;by&#160;zero&#160;does&#160;not&#160;cause&#160;an&#160;error;&#160;it&#160;simply&#160;returns&#160;the&#160;value&#160;Infinity. The case of<br/>0.0/0.0&#160;&#160;is&#160;&#160;special;&#160;&#160;on&#160;&#160;most&#160;&#160;modern&#160;&#160;hardware,&#160;&#160;and&#160;&#160;with&#160;&#160;most&#160;&#160;operating&#160;&#160;systems,&#160;&#160;it<br/>evaluates to another special floating-point value known as NaN, or Not-a-Number.<br/>The&#160;modulo&#160;(%)&#160;operator&#160;&#160;(and&#160;the&#160;synonymous&#160;modulo&#160;method)&#160;compute&#160;the&#160;&#160;remain-<br/>der&#160;after&#160;integer&#160;division.&#160;They&#160;can&#160;also&#160;be&#160;used&#160;with&#160;Float&#160;and&#160;Rational&#160;operands.&#160;The<br/>divmod&#160;method returns both quotient and modulo :<br/>
x = 5%2 &#160; &#160; &#160; &#160; &#160; # =&gt; 1: quotient is 2, with 1 left over<br/>q,r = 10.divmod 3 # =&gt; [3,1]: quotient is 3, remainder is 1<br/>
Ruby uses the&#160;**&#160;operator &#160;for exponentiation. Exponents need not be integers:<br/>
x**4 &#160; &#160; &#160; &#160; &#160;# This is the same thing as x*x*x*x<br/>x**-1 &#160; &#160; &#160; &#160; # The same thing as 1/x<br/>x**(1/3.0) &#160; &#160;# The cube root of x. Use Math.cbrt in Ruby 1.9<br/>x**(1/4) &#160; &#160; &#160;# Oops! Integer division means this is x**0, which is always 1<br/>x**(1.0/4.0) &#160;# This is the fourth-root of x<br/>
<b>44&#160;|&#160;Chapter 3:</b> <b>Datatypes and Objects</b><br/>
<hr/>
<a name=59></a>When&#160;multiple&#160;exponentiations&#160;are&#160;combined&#160;into&#160;a&#160;single&#160;expression,&#160;they&#160;are&#160;eval-<br/>uated from right to left. Thus,&#160;4**3**2&#160;is the same as&#160;4**9, not&#160;64**2.<br/>Exponentiation&#160;can&#160;result&#160;in&#160;very&#160;large&#160;values.&#160;Remember&#160;that&#160;integers&#160;can&#160;become<br/>arbitrarily&#160;large,&#160;but&#160;Float&#160;objects&#160;cannot&#160;represent&#160;numbers&#160;larger&#160;than&#160;Float::MAX.<br/>Thus,&#160;&#160;the&#160;&#160;expression&#160;&#160;10**1000&#160;&#160;yields&#160;&#160;an&#160;&#160;exact&#160;&#160;integer&#160;&#160;result,&#160;&#160;but&#160;&#160;the&#160;&#160;expression<br/>9.9**1000&#160;overflows to the&#160;Float&#160;value&#160;Infinity.<br/>
Fixnum&#160;and&#160;Bignum&#160;values&#160;support the standard&#160;bit-manipulation operators—~,&#160;&amp;,&#160;|,&#160;^,<br/>&gt;&gt;,&#160;&#160;and&#160;&#160;&lt;&lt;—that&#160;&#160;are&#160;&#160;common&#160;&#160;in&#160;&#160;C,&#160;&#160;Java,&#160;&#160;and&#160;&#160;many&#160;&#160;other&#160;&#160;languages.&#160;&#160;(See&#160;&#160;<a href="Rubys.html#114">§4.6&#160;&#160;</a>for<br/>details.)&#160;In&#160;addition,&#160;integer&#160;values&#160;can&#160;also&#160;be&#160;indexed&#160;like&#160;arrays&#160;to&#160;query&#160;(but&#160;not<br/>set) individual bits. The index 0 returns the least significant bit:<br/>
even = (x[0] == 0) &#160;# A number is even if the least-significant bit is 0<br/>
<b>Division, Modulo, and Negative Numbers</b><br/>
When&#160;one&#160;(but&#160;not&#160;both)&#160;of&#160;the&#160;operands&#160;is&#160;negative,&#160;Ruby&#160;performs&#160;the&#160;integer&#160;division<br/>and&#160;modulo&#160;operations&#160;differently&#160;than&#160;languages&#160;like&#160;C,&#160;C++,&#160;and&#160;Java&#160;do&#160;(but&#160;the<br/>same&#160;as&#160;the&#160;languages&#160;Python&#160;and&#160;Tcl).&#160;Consider&#160;the&#160;quotient&#160;-7/3.&#160;Ruby&#160;rounds&#160;to-<br/>ward&#160;&#160;negative&#160;&#160;infinity&#160;&#160;and&#160;&#160;returns&#160;&#160;–3.&#160;&#160;C&#160;&#160;and&#160;&#160;related&#160;&#160;languages&#160;&#160;round&#160;&#160;toward&#160;&#160;zero<br/>instead and return&#160;–2. In Ruby,&#160;-a/b&#160;equals&#160;a/-b&#160;but may not equal&#160;-(a/b).<br/>
Ruby’s&#160;definition&#160;of&#160;the&#160;modulo&#160;operation&#160;also&#160;differs&#160;from&#160;that&#160;of&#160;C&#160;and&#160;Java.&#160;In&#160;Ruby,<br/>–7%3&#160;is&#160;2.&#160;In&#160;C&#160;and&#160;Java,&#160;the&#160;result&#160;is&#160;-1&#160;instead.&#160;The&#160;magnitude&#160;of&#160;the&#160;result&#160;differs,<br/>because&#160;the&#160;quotient&#160;differed.&#160;But&#160;the&#160;sign&#160;of&#160;the&#160;result&#160;differs,&#160;too.&#160;In&#160;Ruby,&#160;the&#160;sign<br/>of&#160;the&#160;result&#160;is&#160;always&#160;the&#160;sign&#160;of&#160;the&#160;second&#160;operand.&#160;In&#160;C&#160;and&#160;Java,&#160;the&#160;sign&#160;of&#160;the<br/>result&#160;is&#160;always&#160;the&#160;sign&#160;of&#160;the&#160;first&#160;operand.&#160;(Ruby’s&#160;&#160;remainder&#160;method&#160;behaves&#160;like<br/>the C modulo operator.)<br/>
<b>3.1.4 &#160;Binary Floating-Point and Rounding Errors<br/></b>Most&#160;computer&#160;hardware&#160;and&#160;most&#160;computer&#160;languages&#160;(including&#160;Ruby)&#160;approximate<br/>real&#160;numbers&#160;using&#160;a&#160;floating-point&#160;representation&#160;like&#160;Ruby’s&#160;Float&#160;class.&#160;For&#160;hardware<br/>efficiency,&#160;most&#160;floating-point&#160;representations&#160;are&#160;binary&#160;representations,&#160;which&#160;can<br/>exactly&#160;represent&#160;fractions&#160;like&#160;1/2,&#160;1/4,&#160;and&#160;1/1024.&#160;Unfortunately,&#160;the&#160;fractions&#160;we<br/>use&#160;most&#160;commonly&#160;(especially&#160;when&#160;performing&#160;financial&#160;calculations)&#160;are&#160;1/10,&#160;1/100,<br/>1/1000,&#160;and&#160;so&#160;on.&#160;Binary&#160;floating-point&#160;representations&#160;cannot&#160;exactly&#160;represent&#160;num-<br/>bers as simple as&#160;0.1.<br/>
Float&#160;objects have plenty of precision and can approximate&#160;0.1&#160;very well, but the fact<br/>that&#160;&#160;this&#160;&#160;number&#160;&#160;cannot&#160;&#160;be&#160;&#160;represented&#160;&#160;exactly&#160;&#160;leads&#160;&#160;to&#160;&#160;problems.&#160;&#160;Consider&#160;&#160;the<br/>following simple Ruby expression:<br/>
0.4 - 0.3 == 0.1 &#160; &#160;# Evaluates to false in most implementations<br/>
Because&#160;of&#160;rounding&#160;error,&#160;the&#160;difference&#160;between&#160;the&#160;approximations&#160;of&#160;0.4&#160;and&#160;0.3<br/>is&#160;not&#160;quite&#160;the&#160;same&#160;as&#160;the&#160;approximation&#160;of&#160;0.1.&#160;This&#160;problem&#160;is&#160;not&#160;specific&#160;to&#160;Ruby:<br/>
<b>3.1 &#160;Numbers&#160;|&#160;45</b><br/>
<hr/>
<a name=60></a>C,&#160;Java,&#160;JavaScript,&#160;and&#160;all&#160;languages&#160;that&#160;use&#160;IEEE-754&#160;floating-point&#160;numbers&#160;suffer<br/>from it as well.<br/>One&#160;solution&#160;to&#160;this&#160;problem&#160;is&#160;to&#160;use&#160;a&#160;decimal&#160;representation&#160;of&#160;real&#160;numbers&#160;rather<br/>than&#160;a&#160;binary&#160;representation.&#160;The&#160;BigDecimal&#160;class&#160;from&#160;Ruby’s&#160;standard&#160;library&#160;is&#160;one<br/>such&#160;representation.&#160;Arithmetic&#160;on&#160;BigDecimal&#160;objects&#160;is&#160;many&#160;times&#160;slower&#160;than&#160;arith-<br/>metic&#160;on&#160;Float&#160;values.&#160;It&#160;is&#160;fast&#160;enough&#160;for&#160;typical&#160;financial&#160;calculations,&#160;but&#160;not&#160;for<br/>scientific&#160;&#160;number&#160;&#160;crunching.&#160;&#160;<a href="Rubys.html#337">§9.3.3&#160;&#160;</a>includes&#160;&#160;a&#160;&#160;short&#160;&#160;example&#160;&#160;of&#160;&#160;the&#160;&#160;use&#160;&#160;of&#160;&#160;the<br/>BigDecimal&#160;library.<br/>
<b>3.2 &#160;Text<br/></b>Text&#160;is&#160;represented&#160;in&#160;Ruby&#160;by&#160;objects&#160;of&#160;the&#160;String&#160;class.&#160;Strings&#160;are&#160;mutable&#160;objects,<br/>and&#160;the&#160;String&#160;class&#160;defines&#160;a&#160;powerful&#160;set&#160;of&#160;operators&#160;and&#160;methods&#160;for&#160;extracting<br/>substrings,&#160;inserting&#160;and&#160;deleting&#160;text,&#160;searching,&#160;replacing,&#160;and&#160;so&#160;on.&#160;Ruby&#160;provides<br/>a&#160;number&#160;of&#160;ways&#160;to&#160;express&#160;string&#160;literals&#160;in&#160;your&#160;programs,&#160;and&#160;some&#160;of&#160;them&#160;support<br/>a&#160;powerful&#160;string&#160;interpolation&#160;syntax&#160;by&#160;which&#160;the&#160;values&#160;of&#160;arbitrary&#160;Ruby&#160;expressions<br/>can&#160;&#160;be&#160;&#160;substituted&#160;&#160;into&#160;&#160;string&#160;&#160;literals.&#160;&#160;The&#160;&#160;sections&#160;&#160;that&#160;&#160;follow&#160;&#160;explain&#160;&#160;string&#160;&#160;and<br/><a href="Rubys.html#318">character literals and string operators. The full string API is covered in §9.1.<br/></a>Textual&#160;patterns&#160;are&#160;represented&#160;in&#160;Ruby as&#160;Regexp&#160;objects,&#160;and&#160;Ruby&#160;defines&#160;a&#160;syntax<br/>for&#160;including&#160;regular&#160;expressions&#160;literally&#160;in&#160;your&#160;programs.&#160;The&#160;code&#160;/[a-z]\d+/, for<br/>example,&#160;represents&#160;a&#160;single&#160;lowercase&#160;letter&#160;followed&#160;by&#160;one&#160;or&#160;more&#160;digits.&#160;Regular<br/>expressions&#160;are&#160;a&#160;commonly&#160;used&#160;feature&#160;of&#160;Ruby,&#160;but&#160;regexps&#160;are&#160;not&#160;a&#160;fundamental<br/>datatype&#160;in&#160;the&#160;way&#160;that&#160;numbers,&#160;strings,&#160;and&#160;arrays&#160;are.&#160;<a href="Rubys.html#324">See&#160;§9.2 for documentation<br/></a>of regular expression syntax and the&#160;Regexp&#160;API.<br/>
<b>Text in Ruby 1.8 and Ruby 1.9</b><br/>
The&#160;biggest&#160;change&#160;between&#160;Ruby&#160;1.8&#160;and&#160;Ruby&#160;1.9&#160;is&#160;that&#160;1.9&#160;offers&#160;comprehensive<br/>built-in&#160;support&#160;for&#160;Unicode&#160;and&#160;other&#160;multibyte&#160;text&#160;representations.&#160;The&#160;ramifica-<br/>tions&#160;&#160;of&#160;&#160;this&#160;&#160;change&#160;&#160;are&#160;&#160;extensive&#160;&#160;and&#160;&#160;will&#160;&#160;be&#160;&#160;mentioned&#160;&#160;throughout&#160;&#160;this&#160;&#160;section,<br/><a href="Rubys.html#72">especially in §3.2.6.</a><br/>
<b>3.2.1 &#160;String Literals<br/></b>Ruby provides quite a few ways to embed strings literally into your programs.<br/>
<b>3.2.1.1 &#160;Single-quoted string literals<br/></b>The&#160;simplest&#160;string&#160;literals&#160;are&#160;enclosed&#160;in&#160;single&#160;quotes&#160;(the&#160;apostrophe&#160;character).<br/>The text within the quote marks is the value of the string:<br/>
'This is a simple Ruby string literal'<br/>
<b>46&#160;|&#160;Chapter 3:</b> <b>Datatypes and Objects</b><br/>
<hr/>
<a name=61></a>If&#160;you&#160;need&#160;to&#160;place&#160;an&#160;apostrophe&#160;within&#160;a&#160;single-quoted&#160;string&#160;literal,&#160;precede&#160;it&#160;with<br/>a backslash so that the Ruby interpreter does not think that it terminates the string:<br/>
'Won\'t you read O\'Reilly\'s book?'<br/>
The&#160;backslash&#160;also&#160;works&#160;to&#160;escape&#160;another&#160;backslash,&#160;so&#160;that&#160;the&#160;second&#160;backslash&#160;is<br/>not&#160;itself&#160;interpreted&#160;as&#160;an&#160;escape&#160;character.&#160;Here&#160;are&#160;some&#160;situations&#160;in&#160;which&#160;you<br/>need to use a double backslash:<br/>
'This string literal ends with a single backslash: \\'<br/>'This is a backslash-quote: \\\''<br/>'Two backslashes: \\\\'<br/>
In&#160;single-quoted&#160;strings,&#160;a&#160;backslash&#160;is&#160;not&#160;special&#160;if&#160;the&#160;character&#160;that&#160;follows&#160;it&#160;is<br/>anything&#160;other&#160;than&#160;a&#160;quote&#160;or&#160;a&#160;backslash.&#160;Most&#160;of&#160;the&#160;time,&#160;therefore,&#160;backslashes<br/>need&#160;not&#160;be&#160;doubled&#160;(although&#160;they&#160;can&#160;be)&#160;in&#160;string&#160;literals.&#160;For&#160;example,&#160;the&#160;following<br/>two string literals are equal:<br/>
'a\b' == 'a\\b'<br/>
Single-quoted&#160;strings&#160;may&#160;extend&#160;over&#160;multiple&#160;lines,&#160;and&#160;the&#160;resulting&#160;string&#160;literal<br/>includes&#160;&#160;the&#160;&#160;newline&#160;&#160;characters.&#160;&#160;It&#160;&#160;is&#160;&#160;not&#160;&#160;possible&#160;&#160;to&#160;&#160;escape&#160;&#160;the&#160;&#160;newlines&#160;&#160;with&#160;&#160;a<br/>backslash:<br/>
'This is a long string literal \<br/>that includes a backslash and a newline'<br/>
If&#160;you&#160;want&#160;to&#160;break&#160;a&#160;long&#160;single-quoted&#160;string&#160;literal&#160;across&#160;multiple&#160;lines&#160;without<br/>embedding&#160;newlines&#160;in&#160;it,&#160;simply&#160;break&#160;it&#160;into&#160;multiple&#160;adjacent&#160;string&#160;literals;&#160;the&#160;Ruby<br/>interpreter&#160;will&#160;concatenate&#160;them&#160;during&#160;the&#160;parsing&#160;process.&#160;Remember,&#160;though,&#160;that<br/>you&#160;must&#160;escape&#160;the&#160;newlines&#160;(see&#160;<a href="Rubys.html#39">Chapter&#160;2)&#160;</a>between&#160;the&#160;literals&#160;so&#160;that&#160;Ruby&#160;does<br/>not interpret the newline as a statement terminator:<br/>
message =&#160;<br/>'These three literals are '\<br/>'concatenated into one by the interpreter. '\<br/>'The resulting string contains no newlines.'<br/>
<b>3.2.1.2 &#160;Double-quoted string literals<br/></b>String&#160;literals&#160;delimited&#160;by&#160;double&#160;quotation&#160;marks&#160;are&#160;much&#160;more&#160;flexible&#160;than&#160;single-<br/>quoted&#160;literals.&#160;Double-quoted&#160;literals&#160;support&#160;quite&#160;a&#160;few&#160;backslash&#160;escape&#160;sequences,<br/>such as&#160;\n&#160;for&#160;newline,&#160;\t&#160;for&#160;tab, and&#160;\&#34;&#160;for&#160;a&#160;quotation&#160;mark&#160;that&#160;does&#160;not&#160;terminate<br/>the string:<br/>
&#34;\t\&#34;This quote begins with a tab and ends with a newline\&#34;\n&#34;<br/>&#34;\\&#34; &#160;# A single backslash<br/>
In&#160;&#160;Ruby&#160;&#160;1.9,&#160;&#160;the&#160;&#160;\u&#160;&#160;escape&#160;&#160;embeds&#160;&#160;arbitrary&#160;&#160;Unicode&#160;&#160;characters,&#160;&#160;specified&#160;&#160;by&#160;&#160;their<br/>codepoint, into a double-quoted string. This escape sequence is complex enough that<br/>we’ll&#160;describe&#160;it&#160;in&#160;its&#160;own&#160;section&#160;(see&#160;<a href="Rubys.html#64">§3.2.1.3).&#160;</a>Many&#160;of&#160;the&#160;other&#160;backslash&#160;escape<br/>sequences&#160;are&#160;obscure&#160;and&#160;are&#160;used&#160;for&#160;encoding&#160;binary&#160;data&#160;into&#160;strings.&#160;The&#160;complete<br/><a href="Rubys.html#63">list of escape sequences is shown in Table 3-1.</a><br/>
<b>3.2 &#160;Text&#160;|&#160;47</b><br/>
<hr/>
<a name=62></a>More&#160;&#160;powerfully,&#160;&#160;double-quoted&#160;&#160;string&#160;&#160;literals&#160;&#160;may&#160;&#160;also&#160;&#160;include&#160;&#160;arbitrary&#160;&#160;Ruby<br/>expressions.&#160;When&#160;the&#160;string&#160;is&#160;created,&#160;the&#160;expression&#160;is&#160;evaluated,&#160;converted&#160;to&#160;a<br/>string,&#160;and&#160;inserted&#160;into&#160;the&#160;string&#160;in&#160;place&#160;of&#160;the&#160;expression&#160;text&#160;itself.&#160;This&#160;substitution<br/>of&#160;an&#160;expression&#160;with&#160;its&#160;value&#160;is&#160;known&#160;in&#160;Ruby&#160;as&#160;“string&#160;interpolation.”&#160;Expressions<br/>within&#160;&#160;double-quoted&#160;&#160;strings&#160;&#160;begin&#160;&#160;with&#160;&#160;the&#160;&#160;#&#160;&#160;character&#160;&#160;and&#160;&#160;are&#160;&#160;enclosed&#160;&#160;within<br/>curly braces:<br/>
&#34;360 degrees=#{2*Math::PI} radians&#34; # &#34;360 degrees=6.28318530717959 radians&#34;<br/>
When&#160;the&#160;expression&#160;to&#160;be&#160;interpolated&#160;into&#160;the&#160;string&#160;literal&#160;is&#160;simply&#160;a&#160;reference&#160;to&#160;a<br/>global, instance, or class variable, then the curly braces may be omitted:<br/>
$salutation = 'hello' &#160; &#160; # Define a global variable<br/>&#34;#$salutation world&#34; &#160; &#160; &#160;# Use it in a double-quoted string<br/>
Use&#160;a&#160;backslash&#160;to&#160;escape&#160;the&#160;#&#160;character&#160;if&#160;you&#160;do&#160;not&#160;want&#160;it&#160;to&#160;be&#160;treated&#160;specially.<br/>Note that this only needs to be done if the character after&#160;#&#160;is&#160;{,&#160;$, or&#160;@:<br/>
&#34;My phone #: 555-1234&#34; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# No escape needed<br/>&#34;Use \#{ to interpolate expressions&#34; &#160;# Escape #{ with backslash<br/>
<b>String Interpolation with sprintf</b><br/>
C&#160;programmers&#160;may&#160;be&#160;happy&#160;to&#160;know&#160;that&#160;Ruby&#160;also&#160;supports&#160;printf&#160;and&#160;sprintf*<br/>functions for interpolating formatted values into strings:<br/>
sprintf(&#34;pi is about %.4f&#34;, Math::PI) # Returns &#34;pi is about 3.1416&#34;<br/>
The&#160;advantage&#160;of&#160;this&#160;style&#160;of&#160;interpolation&#160;is&#160;that&#160;the&#160;format&#160;string&#160;can&#160;specify&#160;options,<br/>such&#160;as&#160;the&#160;number&#160;of&#160;decimal&#160;places&#160;to&#160;display&#160;in&#160;a&#160;Float. In true Ruby style, there is<br/>even&#160;an&#160;operator&#160;form&#160;of&#160;the&#160;sprintf&#160;method:&#160;simply&#160;use&#160;a&#160;%&#160;operator&#160;between&#160;a&#160;format<br/>string and the arguments to be interpolated into it:<br/>
&#34;pi is about %.4f&#34; % Math::PI # Same as example above<br/>&#34;%s: %f&#34; % [&#34;pi&#34;, Math::PI] &#160; # Array on righthand side for multiple args<br/>
Double-quoted&#160;string&#160;literals&#160;may&#160;span&#160;multiple&#160;lines,&#160;and&#160;line&#160;terminators&#160;become<br/>part of the string literal, unless escaped with a backslash:<br/>
&#34;This string literal<br/>has two lines \<br/>but is written on three&#34;<br/>
You&#160;may&#160;prefer&#160;to&#160;explicitly&#160;encode&#160;the&#160;line&#160;terminators&#160;in&#160;your&#160;strings—in&#160;order&#160;to<br/>enforce&#160;network&#160;CRLF&#160;(Carriage&#160;Return&#160;Line&#160;Feed)&#160;line&#160;terminators,&#160;as&#160;used&#160;in&#160;the<br/>HTTP&#160;protocol,&#160;for&#160;example.&#160;To&#160;do&#160;this,&#160;write&#160;all&#160;your&#160;string&#160;literals&#160;on&#160;a&#160;single&#160;line<br/>and&#160;explicitly&#160;include&#160;the&#160;line&#160;endings&#160;with&#160;the&#160;\r&#160;and&#160;\n&#160;escape&#160;sequences.&#160;Remember<br/>that&#160;adjacent&#160;string&#160;literals&#160;are&#160;automatically&#160;concatenated,&#160;but&#160;if&#160;they&#160;are&#160;written&#160;on<br/><i>separate</i>&#160;lines, the newline between them must be escaped:<br/>
*&#160;Use&#160;<i>ri</i>&#160;to learn more:&#160;ri Kernel.sprintf<br/>
<b>48&#160;|&#160;Chapter 3:</b> <b>Datatypes and Objects</b><br/>
<hr/>
<a name=63></a>&#34;This string has three lines.\r\n&#34; \<br/>&#34;It is written as three adjacent literals\r\n&#34; \<br/>&#34;separated by escaped newlines\r\n&#34;<br/>
<i>Table 3-1. Backslash escapes in double-quoted strings</i><br/>
<b>Escape sequence</b><br/>
<b>Meaning</b><br/>
\&#160;<i>x</i><br/>
A backslash before any character&#160;<i>x</i>&#160;is equivalent to the character&#160;<i>x</i>&#160;by itself, unless&#160;<i>x</i>&#160;is a line terminator<br/>or one of the special characters&#160;abcefnrstuvxCM01234567. This syntax is useful to escape the<br/>special meaning of the&#160;\,&#160;#, and&#160;&#34;&#160;characters.<br/>
\a<br/>
The BEL character (ASCII code 7). Rings the console bell. Equivalent to&#160;\C-g&#160;or&#160;\007.<br/>
\b<br/>
The Backspace character (ASCII code 8). Equivalent to&#160;\C-h&#160;or&#160;\010.<br/>
\e<br/>
The ESC character (ASCII code 27). Equivalent to&#160;\033.<br/>
\f<br/>
The Form Feed character (ASCII code 12). Equivalent to&#160;\C-l&#160;and&#160;\014.<br/>
\n<br/>
The Newline character (ASCII code 10). Equivalent to&#160;\C-j&#160;and&#160;\012.<br/>
\r<br/>
The Carriage Return character (ASCII code 13). Equivalent to&#160;\C-m&#160;and&#160;\015.<br/>
\s<br/>
The Space character (ASCII code 32).<br/>
\t<br/>
The TAB character (ASCII code 9). Equivalent to&#160;\C-i&#160;and&#160;\011.<br/>
\u&#160;<i>nnnn</i><br/>
The Unicode codepoint&#160;<i>nnnn</i>, where each&#160;<i>n</i>&#160;is one hexadecimal digit. Leading zeros may not be dropped;<br/>all four digits are required in this form of the&#160;\u&#160;escape. Supported in Ruby 1.9 and later.<br/>
\u{&#160;<i>hexdigits</i>&#160;}<br/>
The Unicode codepoint(s) specified by&#160;<i>hexdigits</i>. See the description of this escape in the main text.<br/>Ruby 1.9 and later.<br/>
\v<br/>
The vertical tab character (ASCII code 11). Equivalent to&#160;\C-k&#160;and&#160;\013.<br/>
\&#160;<i>nnn</i><br/>
The byte&#160;<i>nnn</i>, where&#160;<i>nnn</i>&#160;is three octal digits between 000 and 377.<br/>
\&#160;<i>nn</i><br/>
Same as&#160;\0<i>nn</i>, where&#160;<i>nn</i>&#160;is two octal digits between 00 and 77.<br/>
\&#160;<i>n</i><br/>
Same as&#160;\00<i>n</i>, where&#160;<i>n</i>&#160;is an octal digit between 0 and 7.<br/>
\x&#160;<i>nn</i><br/>
The byte&#160;<i>nn</i>, where&#160;<i>nn</i>&#160;is two hexadecimal digits between 00 and FF. (Both lowercase and uppercase<br/>letters are allowed as hexadecimal digits.)<br/>
\x&#160;<i>n</i><br/>
Same as&#160;\x0<i>n</i>, where&#160;<i>n</i>&#160;is a hexadecimal digit between 0 and F (or f).<br/>
\c&#160;<i>x</i><br/>
Shorthand for&#160;\C-<i>x</i>.<br/>
\C-&#160;<i>x</i><br/>
The character whose character code is formed by zeroing the sixth and seventh bits of&#160;<i>x</i>, retaining the<br/>high-order bit and the five low bits.&#160;<i>x</i>&#160;can be any character, but this sequence is usually used to represent<br/>control characters Control-A through Control-Z (ASCII codes 1 through 26). Because of the layout of the<br/>ASCII table, you can use either lowercase or uppercase letters for&#160;<i>x</i>. Note that&#160;\c<i>x</i>&#160;is shorthand.&#160;<i>x</i>&#160;can<br/>be any single character or an escape other than&#160;\C&#160;\u,&#160;\x, or&#160;\<i>nnn</i>.<br/>
\M-&#160;<i>x</i><br/>
The character whose character code is formed by setting the high bit of the code of&#160;<i>x</i>. This is used to<br/>represent “meta” characters, which are not technically part of the ASCII character set.&#160;<i>x</i>&#160;can be any single<br/>character or an escape other than&#160;\M&#160;\u,&#160;\x, or&#160;\<i>nnn</i>.&#160;\M&#160;can be combined with&#160;\C&#160;as in&#160;\M-\C-A.<br/>
\&#160;<i>eol</i><br/>
A backslash before a line terminator escapes the terminator. Neither the backslash nor the terminator<br/>appear in the string.<br/>
<b>3.2 &#160;Text&#160;|&#160;49</b><br/>
<hr/>
<a name=64></a><b>3.2.1.3 &#160;Unicode escapes<br/></b>In&#160;Ruby&#160;1.9,&#160;double-quoted&#160;strings&#160;can&#160;include&#160;arbitrary&#160;Unicode&#160;characters&#160;with&#160;\u<br/>escapes. In its simplest form,&#160;\u&#160;is followed by exactly four hexadecimal digits (letters<br/>can be upper- or lowercase), which represent a Unicode codepoint between 0000 and<br/>FFFF. For example:<br/>
&#34;\u00D7&#34; &#160; &#160; &#160; # =&gt; &#34;×&#34;: leading zeros cannot be dropped<br/>&#34;\u20ac&#34; &#160; &#160; &#160; # =&gt; &#34;€&#34;: lowercase letters are okay<br/>
A&#160;second&#160;form&#160;of&#160;the&#160;\u&#160;escape&#160;is&#160;followed&#160;by&#160;an&#160;open&#160;curly&#160;brace,&#160;one&#160;to&#160;six&#160;hexadec-<br/>imal&#160;digits,&#160;and&#160;a&#160;close&#160;curly&#160;brace.&#160;The&#160;digits&#160;between&#160;the&#160;braces&#160;can&#160;represent&#160;any<br/>Unicode&#160;codepoint&#160;between&#160;0&#160;and&#160;10FFFF,&#160;and&#160;leading&#160;zeros&#160;can&#160;be&#160;dropped&#160;in&#160;this<br/>form:<br/>
&#34;\u{A5}&#34; &#160; &#160; &#160;# =&gt; &#34;¥&#34;: same as &#34;\u00A5&#34;<br/>&#34;\u{3C0}&#34; &#160; &#160; # Greek lowercase pi: same as &#34;\u03C0&#34;<br/>&#34;\u{10ffff}&#34; &#160;# The largest Unicode codepoint<br/>
Finally,&#160;the&#160;\u{}&#160;form&#160;of&#160;this&#160;escape&#160;allows&#160;multiple&#160;codepoints&#160;to&#160;be&#160;embedded&#160;within<br/>a&#160;single&#160;escape.&#160;Simply&#160;place&#160;multiple&#160;runs&#160;of&#160;one&#160;to&#160;six&#160;hexadecimal&#160;digits,&#160;separated<br/>by&#160;a&#160;single&#160;space&#160;or&#160;tab&#160;character,&#160;within&#160;the&#160;curly&#160;braces.&#160;Spaces&#160;are&#160;not&#160;allowed&#160;after<br/>the opening curly brace or before the closing brace:<br/>
money = &#34;\u{20AC A3 A5}&#34; &#160;# =&gt; &#34;€£¥&#34;<br/>
Note that spaces within the curly braces do not encode spaces in the string itself. You<br/>can, however, encode the ASCII space character with Unicode codepoint 20:<br/>
money = &#34;\u{20AC 20 A3 20 A5}&#34; &#160;# =&gt; &#34;€ £ ¥&#34;<br/>
Strings&#160;that&#160;use&#160;the&#160;\u&#160;escape&#160;are&#160;encoded&#160;using&#160;the&#160;Unicode&#160;UTF-8&#160;encoding.&#160;(See<br/><a href="Rubys.html#72">§3.2.6 for more on the encoding of strings.)</a><br/>
\u&#160;escapes&#160;are&#160;usually,&#160;but&#160;not&#160;always,&#160;legal&#160;in&#160;strings.&#160;If&#160;the&#160;source&#160;file&#160;uses&#160;an&#160;encoding<br/>other&#160;than&#160;UTF-8,&#160;and&#160;a&#160;string&#160;contains&#160;multibyte&#160;characters&#160;in&#160;that&#160;encoding&#160;(literal<br/>characters,&#160;not&#160;characters&#160;created&#160;with&#160;escapes),&#160;then&#160;it&#160;is&#160;not&#160;legal&#160;to&#160;use&#160;\u&#160;in&#160;that<br/>string—it&#160;&#160;is&#160;&#160;just&#160;&#160;not&#160;&#160;possible&#160;&#160;for&#160;&#160;one&#160;&#160;string&#160;&#160;to&#160;&#160;encode&#160;&#160;characters&#160;&#160;in&#160;&#160;two&#160;&#160;different<br/>encodings.&#160;You&#160;can&#160;always&#160;use&#160;\u&#160;if&#160;the&#160;source&#160;encoding&#160;(see&#160;<a href="Rubys.html#51">§2.4.1)&#160;</a>is&#160;UTF-8.&#160;And<br/>you can always use&#160;\u&#160;in a string that only contains ASCII characters.<br/>
\u&#160;escapes&#160;may&#160;appear&#160;in&#160;double-quoted&#160;strings,&#160;and&#160;also&#160;in&#160;other&#160;forms&#160;of&#160;quoted&#160;text<br/>(described&#160;shortly)&#160;such&#160;as&#160;regular&#160;expressions,&#160;characters&#160;literals,&#160;%- and&#160;%Q-delimited<br/>strings,&#160;&#160;%W-delimited&#160;&#160;arrays,&#160;&#160;here&#160;&#160;documents,&#160;&#160;and&#160;&#160;backquote-delimited&#160;&#160;command<br/>strings.&#160;Java&#160;programmers&#160;should&#160;note&#160;that&#160;Ruby’s&#160;\u&#160;escape&#160;can&#160;only&#160;appear&#160;in&#160;quoted<br/>text, not in program identifiers.<br/>
<b>3.2.1.4 &#160;Arbitrary delimiters for string literals<br/></b>When&#160;working&#160;with&#160;text&#160;that&#160;contains&#160;apostrophes&#160;and&#160;quotation&#160;marks,&#160;it&#160;is&#160;awkward<br/>to&#160;use&#160;it&#160;as&#160;single-&#160;and&#160;double-quoted&#160;string&#160;literals.&#160;Ruby&#160;supports&#160;a&#160;generalized&#160;quot-<br/>ing&#160;syntax&#160;for&#160;string&#160;literals&#160;(and,&#160;as&#160;we’ll&#160;see&#160;later,&#160;for&#160;regular&#160;expression&#160;and&#160;array<br/>
<b>50&#160;|&#160;Chapter 3:</b> <b>Datatypes and Objects</b><br/>
<hr/>
<a name=65></a>literals&#160;as&#160;well).&#160;The&#160;sequence&#160;%q&#160;begins&#160;a&#160;string&#160;literal&#160;that&#160;follows&#160;single-quoted&#160;string<br/>rules,&#160;and&#160;the&#160;sequence&#160;%Q&#160;(or&#160;just&#160;%)&#160;introduces&#160;a&#160;literal&#160;that&#160;follows&#160;double-quoted<br/>string&#160;rules.&#160;The&#160;first&#160;character&#160;following&#160;q&#160;or&#160;Q&#160;is&#160;the&#160;delimiter&#160;character,&#160;and&#160;the&#160;string<br/>literal&#160;&#160;continues&#160;&#160;until&#160;&#160;a&#160;&#160;matching&#160;&#160;(unescaped)&#160;&#160;delimiter&#160;&#160;is&#160;&#160;found.&#160;&#160;If&#160;&#160;the&#160;&#160;opening<br/>delimiter&#160;is&#160;(,&#160;[,&#160;{,&#160;or&#160;&lt;,&#160;then&#160;the&#160;matching&#160;delimiter&#160;is&#160;),&#160;],&#160;},&#160;or&#160;&gt;.&#160;(Note&#160;that&#160;the&#160;backtick<br/>`&#160;and&#160;apostrophe&#160;'&#160;are&#160;not&#160;a&#160;matched&#160;pair.)&#160;Otherwise,&#160;the&#160;closing&#160;delimiter&#160;is&#160;the&#160;same<br/>as the opening delimiter. Here are some examples:<br/>
%q(Don't worry about escaping ' characters!)<br/>%Q|&#34;How are you?&#34;, he said|<br/>%-This string literal ends with a newline\n- &#160;# Q omitted in this one<br/>
If&#160;you&#160;find&#160;that&#160;you&#160;need&#160;to&#160;escape&#160;the&#160;delimiter&#160;character,&#160;you&#160;can&#160;use&#160;a&#160;backslash<br/>(even in the stricter&#160;%q&#160;form) or just choose a different delimiter:<br/>
%q_This string literal contains \_underscores\__<br/>%Q!Just use a _different_ delimiter\!!<br/>
If&#160;you&#160;use&#160;paired&#160;delimiters,&#160;you&#160;don’t&#160;need&#160;to&#160;escape&#160;those&#160;delimiters&#160;in&#160;your&#160;literals,<br/>as long as they appear in properly nested pairs:<br/>
# XML uses paired angle brackets:<br/>%&lt;&lt;book&gt;&lt;title&gt;Ruby in a Nutshell&lt;/title&gt;&lt;/book&gt;&gt; &#160;# This works<br/># Expressions use paired, nested parens:<br/>%((1+(2*3)) = #{(1+(2*3))}) &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# This works, too<br/>%(A mismatched paren \( must be escaped) &#160; &#160; &#160; &#160; &#160; # Escape needed here<br/>
<b>3.2.1.5 &#160;Here documents<br/></b>For&#160;long&#160;string&#160;literals,&#160;there&#160;may&#160;be&#160;no&#160;single&#160;character&#160;delimiter&#160;that&#160;can&#160;be&#160;used<br/>without&#160;worrying&#160;about&#160;remembering&#160;to&#160;escape&#160;characters&#160;within&#160;the&#160;literal.&#160;Ruby’s<br/>solution&#160;to&#160;this&#160;problem&#160;is&#160;to&#160;allow&#160;you&#160;to&#160;specify&#160;an&#160;arbitrary&#160;sequence&#160;of&#160;characters<br/>to&#160;serve&#160;as&#160;the&#160;delimiter&#160;for&#160;the&#160;string.&#160;This&#160;kind&#160;of&#160;literal&#160;is&#160;borrowed&#160;from&#160;Unix&#160;shell<br/>syntax&#160;and&#160;is&#160;historically&#160;known&#160;as&#160;a&#160;<i>here&#160;document</i>.&#160;(Because&#160;the&#160;document&#160;is&#160;right<br/>here in the source code rather than in an external file.)<br/>Here&#160;documents&#160;begin&#160;with&#160;&lt;&lt;&#160;or&#160;&lt;&lt;-.&#160;These&#160;are&#160;followed&#160;immediately&#160;(no&#160;space&#160;is<br/>allowed,&#160;to&#160;prevent&#160;ambiguity&#160;with&#160;the&#160;left-shift&#160;operator)&#160;by&#160;an&#160;identifier&#160;or&#160;string&#160;that<br/>specifies the ending delimiter. The text of the string literal begins on the next line and<br/>continues until the text of the delimiter appears on a line by itself. For example:<br/>
document = &lt;&lt;HERE &#160; &#160; &#160; &#160;# This is how we begin a here document<br/>This is a string literal.<br/>It has two lines and abruptly ends...<br/>HERE<br/>
The&#160;Ruby&#160;interpreter&#160;gets&#160;the&#160;contents&#160;of&#160;a&#160;string&#160;literal&#160;by&#160;reading&#160;a&#160;line&#160;at&#160;a&#160;time&#160;from<br/>its&#160;input.&#160;This&#160;does&#160;not&#160;mean,&#160;however,&#160;that&#160;the&#160;&lt;&lt;&#160;must&#160;be&#160;the&#160;last&#160;thing&#160;on&#160;its&#160;own<br/>line.&#160;In&#160;fact,&#160;after&#160;reading&#160;the&#160;content&#160;of&#160;a&#160;here&#160;document,&#160;the&#160;Ruby&#160;interpreter&#160;goes<br/>back&#160;&#160;to&#160;&#160;the&#160;&#160;line&#160;&#160;it&#160;&#160;was&#160;&#160;on&#160;&#160;and&#160;&#160;continues&#160;&#160;parsing&#160;&#160;it.&#160;&#160;The&#160;&#160;following&#160;&#160;Ruby&#160;&#160;code,&#160;&#160;for<br/>
<b>3.2 &#160;Text&#160;|&#160;51</b><br/>
<hr/>
<a name=66></a>example,&#160;creates&#160;a&#160;string&#160;by&#160;concatenating&#160;two&#160;here&#160;documents&#160;(and&#160;the&#160;newlines&#160;that<br/>terminate them) and a regular single-quoted string:<br/>
greeting = &lt;&lt;HERE + &lt;&lt;THERE + &#34;World&#34;<br/>Hello<br/>HERE<br/>There<br/>THERE<br/>
The&#160;&lt;&lt;HERE&#160;on&#160;line&#160;1&#160;causes&#160;the&#160;interpreter&#160;to&#160;read&#160;lines&#160;2&#160;and&#160;3.&#160;And&#160;the&#160;&lt;&lt;THERE&#160;causes<br/>the&#160;interpreter&#160;to&#160;read&#160;lines&#160;4&#160;and&#160;5.&#160;After&#160;these&#160;lines&#160;have&#160;been&#160;read,&#160;the&#160;three&#160;string<br/>literals are concatenated into one.<br/>The&#160;ending&#160;delimiter&#160;of&#160;a&#160;here&#160;document&#160;really&#160;must&#160;appear&#160;on&#160;a&#160;line&#160;by&#160;itself:&#160;no<br/>comment&#160;may&#160;follow&#160;the&#160;delimiter.&#160;If&#160;the&#160;here&#160;document&#160;begins&#160;with&#160;&lt;&lt;,&#160;then&#160;the&#160;de-<br/>limiter&#160;must&#160;start&#160;at&#160;the&#160;beginning&#160;of&#160;the&#160;line.&#160;If&#160;the&#160;literal&#160;begins&#160;with&#160;&lt;&lt;-&#160;instead,&#160;then<br/>the&#160;delimiter&#160;may&#160;have&#160;whitespace&#160;in&#160;front&#160;of&#160;it.&#160;The&#160;newline&#160;at&#160;the&#160;beginning&#160;of&#160;a&#160;here<br/>document&#160;is&#160;not&#160;part&#160;of&#160;the&#160;literal,&#160;but&#160;the&#160;newline&#160;at&#160;the&#160;end&#160;of&#160;the&#160;document&#160;is.<br/>Therefore,&#160;every&#160;here&#160;document&#160;ends&#160;with&#160;a&#160;line&#160;terminator,&#160;except&#160;for&#160;an&#160;empty&#160;here<br/>document, which is the same as&#160;&#34;&#34;:<br/>
empty = &lt;&lt;END<br/>END<br/>
If&#160;you&#160;use&#160;an&#160;unquoted&#160;identifier&#160;as&#160;the&#160;terminator,&#160;as&#160;in&#160;the&#160;previous&#160;examples,&#160;then<br/>the&#160;here&#160;document&#160;behaves&#160;like&#160;a&#160;double-quoted&#160;string&#160;for&#160;the&#160;purposes&#160;of&#160;interpreting<br/>backslash escapes and the&#160;#&#160;character. If you want to be very, very literal, allowing no<br/>escape&#160;&#160;characters&#160;&#160;whatsoever,&#160;&#160;place&#160;&#160;the&#160;&#160;delimiter&#160;&#160;in&#160;&#160;single&#160;&#160;quotes.&#160;&#160;Doing&#160;&#160;this&#160;&#160;also<br/>allows you to use spaces in your delimiter:<br/>
document = &lt;&lt;'THIS IS THE END, MY ONLY FRIEND, THE END'<br/>&#160; &#160; .<br/>&#160; &#160; . lots and lots of text goes here<br/>&#160; &#160; . with no escaping at all.<br/>&#160; &#160; .<br/>THIS IS THE END, MY ONLY FRIEND, THE END<br/>
The&#160;single&#160;quotes&#160;around&#160;the&#160;delimiter&#160;hint&#160;that&#160;this&#160;string&#160;literal&#160;is&#160;like&#160;a&#160;single-quoted<br/>string.&#160;In&#160;fact,&#160;this&#160;kind&#160;of&#160;here&#160;document&#160;is&#160;even&#160;stricter.&#160;Because&#160;the&#160;single&#160;quote&#160;is<br/>not&#160;a&#160;delimiter,&#160;there&#160;is&#160;never&#160;a&#160;need&#160;to&#160;escape&#160;a&#160;single&#160;quote&#160;with&#160;a&#160;backslash.&#160;And<br/>because&#160;the&#160;backslash&#160;is&#160;never&#160;needed&#160;as&#160;an&#160;escape&#160;character,&#160;there&#160;is&#160;never&#160;a&#160;need&#160;to<br/>escape&#160;the&#160;backslash&#160;itself.&#160;In&#160;this&#160;kind&#160;of&#160;here&#160;document,&#160;therefore,&#160;backslashes&#160;are<br/>simply part of the string literal.<br/>You&#160;may&#160;also&#160;use&#160;a&#160;double-quoted&#160;string&#160;literal&#160;as&#160;the&#160;delimiter&#160;for&#160;a&#160;here&#160;document.<br/>This&#160;is&#160;the&#160;same&#160;as&#160;using&#160;a&#160;single&#160;identifier,&#160;except&#160;that&#160;it&#160;allows&#160;spaces&#160;within&#160;the<br/>delimiter:<br/>
document = &lt;&lt;-&#34;# # #&#34; &#160; &#160;# This is the only place we can put a comment<br/>&lt;html&gt;&lt;head&gt;&lt;title&gt;#{title}&lt;/title&gt;&lt;/head&gt;<br/>&lt;body&gt;<br/>&lt;h1&gt;#{title}&lt;/h1&gt;<br/>
<b>52&#160;|&#160;Chapter 3:</b> <b>Datatypes and Objects</b><br/>
<hr/>
<a name=67></a>#{body}<br/>&lt;/body&gt;<br/>&lt;/html&gt;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# # #<br/>
Note&#160;that&#160;there&#160;is&#160;no&#160;way&#160;to&#160;include&#160;a&#160;comment&#160;within&#160;a&#160;here&#160;document&#160;except&#160;on&#160;the<br/>first&#160;line&#160;after&#160;the&#160;&lt;&lt;&#160;token&#160;and&#160;before&#160;the&#160;start&#160;of&#160;the&#160;literal.&#160;Of&#160;all&#160;the&#160;#&#160;characters in<br/>this&#160;code,&#160;one&#160;introduces&#160;a&#160;comment,&#160;three&#160;interpolate&#160;expressions&#160;into&#160;the&#160;literal,&#160;and<br/>the rest are the delimiter.<br/>
<b>3.2.1.6 &#160;Backtick command execution<br/></b>Ruby&#160;supports&#160;another&#160;syntax&#160;involving&#160;quotes&#160;and&#160;strings.&#160;When&#160;text&#160;is&#160;enclosed&#160;in<br/>backquotes&#160;(the&#160;`&#160;character,&#160;also&#160;known&#160;as&#160;backticks),&#160;that&#160;text&#160;is&#160;treated&#160;as&#160;a&#160;double-<br/>quoted&#160;&#160;string&#160;&#160;literal.&#160;&#160;The&#160;&#160;value&#160;&#160;of&#160;&#160;that&#160;&#160;literal&#160;&#160;is&#160;&#160;passed&#160;&#160;to&#160;&#160;the&#160;&#160;specially&#160;&#160;named<br/>Kernel.`&#160;method.&#160;This&#160;method&#160;executes&#160;the&#160;text&#160;as&#160;an&#160;operating&#160;system&#160;shell&#160;command<br/>and returns the command’s output as a string.<br/>Consider the following Ruby code:<br/>
`ls`<br/>
On&#160;a&#160;Unix&#160;system,&#160;these&#160;four&#160;characters&#160;yield&#160;a&#160;string&#160;that&#160;lists&#160;the&#160;names&#160;of&#160;the&#160;files<br/>in&#160;the&#160;current&#160;directory.&#160;This&#160;is&#160;highly&#160;platform-dependent,&#160;of&#160;course.&#160;A&#160;rough&#160;equiv-<br/>alent in Windows might be&#160;`dir`.<br/>Ruby&#160;supports&#160;a&#160;generalized&#160;quote&#160;syntax&#160;you&#160;can&#160;use&#160;in&#160;place&#160;of&#160;backticks.&#160;This&#160;is&#160;like<br/>the&#160;%Q&#160;syntax introduced earlier, but uses&#160;%x&#160;(for execute) instead:<br/>
%x[ls]<br/>
Note&#160;that&#160;the&#160;text&#160;within&#160;the&#160;backticks&#160;(or&#160;following&#160;%x)&#160;is&#160;processed&#160;like&#160;a&#160;double-<br/>quoted&#160;literal,&#160;which&#160;means&#160;that&#160;arbitrary&#160;Ruby&#160;expressions&#160;can&#160;be&#160;interpolated&#160;into<br/>the string. For example:<br/>
if windows<br/>&#160; listcmd = 'dir'<br/>else<br/>&#160; listcmd = 'ls'<br/>end<br/>listing = `#{listcmd}`<br/>
In a case like this, however, it is simpler just to invoke the backtick method directly:<br/>
listing = Kernel.`(listcmd) &#160;# irb doesn't support this legal syntax<br/>
<b>3.2.1.7 &#160;String literals and mutability<br/></b>Strings&#160;are&#160;mutable&#160;in&#160;Ruby.&#160;Therefore,&#160;the&#160;Ruby&#160;interpreter&#160;cannot&#160;use&#160;the&#160;same&#160;object<br/>to&#160;represent&#160;two&#160;identical&#160;string&#160;literals.&#160;(If&#160;you&#160;are&#160;a&#160;Java&#160;programmer,&#160;you&#160;may&#160;find<br/>this&#160;surprising.)&#160;Each&#160;time&#160;Ruby&#160;encounters&#160;a&#160;string&#160;literal,&#160;it&#160;creates&#160;a&#160;new&#160;object.&#160;If<br/>you&#160;include&#160;a&#160;literal&#160;within&#160;the&#160;body&#160;of&#160;a&#160;loop,&#160;Ruby&#160;will&#160;create&#160;a&#160;new&#160;object&#160;for&#160;each<br/>iteration. You can demonstrate this for yourself as follows:<br/>
<b>3.2 &#160;Text&#160;|&#160;53</b><br/>
<hr/>
<a name=68></a>10.times { puts &#34;test&#34;.object_id }<br/>
For efficiency, you should avoid using literals within loops.<br/>
<b>3.2.1.8 &#160;The String.new method<br/></b>In&#160;addition&#160;to&#160;all&#160;the&#160;string&#160;literal&#160;options&#160;described&#160;earlier,&#160;you&#160;can&#160;also&#160;create&#160;new<br/>strings with the&#160;String.new&#160;method. With no arguments, this method returns a newly<br/>created&#160;string&#160;with&#160;no&#160;characters.&#160;With&#160;a&#160;single&#160;string&#160;argument,&#160;it&#160;creates&#160;and&#160;returns<br/>a new&#160;String&#160;object that represents the same text as the argument object.<br/>
<b>3.2.2 &#160;Character Literals<br/></b>Single&#160;characters&#160;can&#160;be&#160;included&#160;literally&#160;in&#160;a&#160;Ruby&#160;program&#160;by&#160;preceding&#160;the&#160;character<br/>with a question mark. No quotation marks of any kind are used:<br/>
?A &#160; # Character literal for the ASCII character A<br/>?&#34; &#160; # Character literal for the double-quote character<br/>?? &#160; # Character literal for the question mark character<br/>
Although&#160;Ruby&#160;has&#160;a&#160;character&#160;literal&#160;syntax,&#160;it&#160;does&#160;not&#160;have&#160;a&#160;special&#160;class&#160;to&#160;represent<br/>single&#160;characters.&#160;Also,&#160;the&#160;interpretation&#160;of&#160;character&#160;literals&#160;has&#160;changed&#160;between<br/>Ruby&#160;1.8&#160;and&#160;Ruby&#160;1.9.&#160;In&#160;Ruby&#160;1.8,&#160;character&#160;literals&#160;evaluate&#160;to&#160;the&#160;integer&#160;encoding<br/>of&#160;the&#160;specified&#160;character.&#160;?A,&#160;for&#160;example,&#160;is&#160;the&#160;same&#160;as&#160;65&#160;because&#160;the&#160;ASCII&#160;encoding<br/>for&#160;the&#160;capital&#160;letter&#160;A&#160;is&#160;the&#160;integer&#160;65.&#160;In&#160;Ruby&#160;1.8,&#160;the&#160;character&#160;literal&#160;syntax&#160;only<br/>works with ASCII and single-byte characters.<br/>In&#160;Ruby&#160;1.9&#160;and&#160;later,&#160;characters&#160;are&#160;simply&#160;strings&#160;of&#160;length&#160;1.&#160;That&#160;is,&#160;the&#160;literal&#160;?A&#160;is<br/>the&#160;same&#160;as&#160;the&#160;literal&#160;'A',&#160;and&#160;there&#160;is&#160;really&#160;no&#160;need&#160;for&#160;this&#160;character&#160;literal&#160;syntax&#160;in<br/>new&#160;code.&#160;In&#160;Ruby&#160;1.9,&#160;the&#160;character&#160;literal&#160;syntax&#160;works&#160;with&#160;multibyte&#160;characters&#160;and<br/>can&#160;also&#160;be&#160;used&#160;with&#160;the&#160;\u&#160;Unicode&#160;escape&#160;(though&#160;not&#160;with&#160;the&#160;multicodepoint&#160;form<br/>\u{a b c}):<br/>
?\u20AC == ?€ &#160; &#160;# =&gt; true: Ruby 1.9 only<br/>?€ == &#34;\u20AC&#34; &#160; # =&gt; true<br/>
The&#160;character&#160;literal&#160;syntax&#160;can&#160;actually&#160;be&#160;used&#160;with&#160;any&#160;of&#160;the&#160;character&#160;escapes&#160;listed<br/><a href="Rubys.html#63">earlier in Table 3-1:</a><br/>
?\t &#160; &#160; &#160;# Character literal for the TAB character<br/>?\C-x &#160; &#160;# Character literal for Ctrl-X<br/>?\111 &#160; &#160;# Literal for character whose encoding is 0111 (octal)<br/>
<b>3.2.3 &#160;String Operators<br/></b>The&#160;String&#160;class&#160;defines&#160;several&#160;useful&#160;operators&#160;for&#160;manipulating&#160;strings&#160;of&#160;text.&#160;The<br/>+&#160;operator concatenates two strings and returns the result as a new&#160;String&#160;object:<br/>
planet = &#34;Earth&#34;<br/>&#34;Hello&#34; + &#34; &#34; + planet &#160; &#160;# Produces &#34;Hello Earth&#34;<br/>
<b>54&#160;|&#160;Chapter 3:</b> <b>Datatypes and Objects</b><br/>
<hr/>
<a name=69></a>Java&#160;&#160;programmers&#160;&#160;should&#160;&#160;note&#160;&#160;that&#160;&#160;the&#160;&#160;+&#160;&#160;operator&#160;&#160;does&#160;&#160;not&#160;&#160;convert&#160;&#160;its&#160;&#160;righthand<br/>operand to a string; you must do that yourself:<br/>
&#34;Hello planet #&#34; + planet_number.to_s &#160;# to_s converts to a string<br/>
Of&#160;course,&#160;in&#160;Ruby,&#160;string&#160;interpolation&#160;is&#160;usually&#160;simpler&#160;than&#160;string&#160;concatenation<br/>with&#160;+. With string interpolation, the call to&#160;to_s&#160;is done automatically:<br/>
&#34;Hello planet ##{planet_number}&#34;<br/>
The&#160;&#160;&lt;&lt;&#160;&#160;operator&#160;&#160;appends&#160;&#160;its&#160;&#160;second&#160;&#160;operand&#160;&#160;to&#160;&#160;its&#160;&#160;first,&#160;&#160;and&#160;&#160;should&#160;&#160;be&#160;&#160;familiar&#160;&#160;to<br/>C++&#160;programmers.&#160;This&#160;operator&#160;is&#160;very&#160;different&#160;from&#160;+;&#160;it&#160;alters&#160;the&#160;lefthand&#160;operand<br/>rather than creating and returning a new object:<br/>
greeting = &#34;Hello&#34;<br/>greeting &lt;&lt; &#34; &#34; &lt;&lt; &#34;World&#34;<br/>puts greeting &#160; # Outputs &#34;Hello World&#34;<br/>
Like&#160;+,&#160;the&#160;&lt;&lt;&#160;operator&#160;does&#160;no&#160;type&#160;conversion&#160;on&#160;the&#160;righthand&#160;operand.&#160;If&#160;the&#160;right-<br/>hand&#160;&#160;operand&#160;&#160;is&#160;&#160;an&#160;&#160;integer,&#160;&#160;however,&#160;&#160;it&#160;&#160;is&#160;&#160;taken&#160;&#160;to&#160;&#160;be&#160;&#160;a&#160;&#160;character&#160;&#160;code,&#160;&#160;and&#160;&#160;the<br/>corresponding&#160;character&#160;is&#160;appended.&#160;In&#160;Ruby&#160;1.8,&#160;only&#160;integers&#160;between&#160;0&#160;and&#160;255<br/>are&#160;allowed.&#160;In&#160;Ruby&#160;1.9,&#160;any&#160;integer&#160;that&#160;represents&#160;a&#160;valid&#160;codepoint&#160;in&#160;the&#160;string’s<br/>encoding can be used:<br/>
alphabet = &#34;A&#34;<br/>alphabet &lt;&lt; ?B &#160; # Alphabet is now &#34;AB&#34;<br/>alphabet &lt;&lt; 67 &#160; # And now it is &#34;ABC&#34;<br/>alphabet &lt;&lt; 256 &#160;# Error in Ruby 1.8: codes must be &gt;=0 and &lt; 256<br/>
The&#160;*&#160;operator&#160;expects&#160;an&#160;integer&#160;as&#160;its&#160;righthand&#160;operand.&#160;It&#160;returns&#160;a&#160;String&#160;that<br/>repeats&#160;the&#160;text&#160;specified&#160;on&#160;the&#160;lefthand&#160;side&#160;the&#160;number&#160;of&#160;times&#160;specified&#160;by&#160;the<br/>righthand side:<br/>
ellipsis = '.'*3 &#160; &#160;# Evaluates to '...'<br/>
If&#160;the&#160;lefthand&#160;side&#160;is&#160;a&#160;string&#160;literal,&#160;any&#160;interpolation&#160;is&#160;performed&#160;just&#160;once&#160;before&#160;the<br/>repetition&#160;is&#160;done.&#160;This&#160;means&#160;that&#160;the&#160;following&#160;too-clever&#160;code&#160;does&#160;not&#160;do&#160;what&#160;you<br/>might want it to:<br/>
a = 0;<br/>&#34;#{a=a+1} &#34; * 3 &#160; # Returns &#34;1 1 1 &#34;, not &#34;1 2 3 &#34;<br/>
String&#160;defines&#160;all&#160;the&#160;standard&#160;comparison&#160;operators.&#160;==&#160;and&#160;!=&#160;compare&#160;strings&#160;for<br/>equality&#160;and&#160;inequality.&#160;Two&#160;strings&#160;are&#160;equal&#160;if—and&#160;only&#160;if—they&#160;have&#160;the&#160;same<br/>length&#160;and&#160;all&#160;characters&#160;are&#160;equal.&#160;&lt;,&#160;&lt;=,&#160;&gt;,&#160;and&#160;&gt;=&#160;compare&#160;the&#160;relative&#160;order&#160;of&#160;strings<br/>by&#160;comparing&#160;the&#160;character&#160;codes&#160;of&#160;the&#160;characters&#160;that&#160;make&#160;up&#160;a&#160;string.&#160;If&#160;one&#160;string<br/>is&#160;a&#160;prefix&#160;of&#160;another,&#160;the&#160;shorter&#160;string&#160;is&#160;less&#160;than&#160;the&#160;longer&#160;string.&#160;Comparison&#160;is<br/>based&#160;strictly&#160;on&#160;character&#160;codes.&#160;No&#160;normalization&#160;is&#160;done,&#160;and&#160;natural&#160;language&#160;col-<br/>lation order (if it differs from the numeric sequence of character codes) is ignored.<br/>String&#160;comparison&#160;is&#160;case-sensitive.*&#160;&#160;Remember&#160;that&#160;in&#160;ASCII,&#160;the&#160;uppercase&#160;letters&#160;all<br/>have lower codes than the lowercase letters. This means, for example, that&#160;&#34;Z&#34; &lt; &#34;a&#34;.<br/>For&#160;&#160;case-insensitive&#160;&#160;comparison&#160;&#160;of&#160;&#160;ASCII&#160;&#160;characters,&#160;&#160;use&#160;&#160;the&#160;&#160;casecmp&#160;&#160;method&#160;&#160;(see<br/>
<b>3.2 &#160;Text&#160;|&#160;55</b><br/>
<hr/>
<a name=70></a><a href="Rubys.html#318">§9.1)&#160;</a>or&#160;convert&#160;your&#160;strings&#160;to&#160;the&#160;same&#160;case&#160;with&#160;downcase&#160;or&#160;upcase&#160;methods&#160;before<br/>comparing&#160;them.&#160;(Keep&#160;in&#160;mind&#160;that&#160;Ruby’s&#160;knowledge&#160;of&#160;upper-&#160;and&#160;lowercase&#160;letters<br/>is limited to the ASCII character set.)<br/>
<b>3.2.4 &#160;Accessing Characters and Substrings<br/></b>Perhaps&#160;the&#160;most&#160;important&#160;operator&#160;supported&#160;by&#160;String&#160;is&#160;the&#160;square-bracket&#160;array-<br/>index&#160;operator&#160;[],&#160;which&#160;is&#160;used&#160;for&#160;extracting&#160;or&#160;altering&#160;portions&#160;of&#160;a&#160;string.&#160;This<br/>operator&#160;is&#160;quite&#160;flexible&#160;and&#160;can&#160;be&#160;used&#160;with&#160;a&#160;number&#160;of&#160;different&#160;operand&#160;types.&#160;It<br/>can&#160;&#160;also&#160;&#160;be&#160;&#160;used&#160;&#160;on&#160;&#160;the&#160;&#160;lefthand&#160;&#160;side&#160;&#160;of&#160;&#160;an&#160;&#160;assignment,&#160;&#160;as&#160;&#160;a&#160;&#160;way&#160;&#160;of&#160;&#160;altering&#160;&#160;string<br/>content.<br/>In&#160;Ruby&#160;1.8,&#160;a&#160;string&#160;is&#160;like&#160;an&#160;array&#160;of&#160;bytes&#160;or&#160;8-bit&#160;character&#160;codes.&#160;The&#160;length&#160;of&#160;this<br/>array&#160;is&#160;given&#160;by&#160;the&#160;length&#160;or&#160;size&#160;method,&#160;and&#160;you&#160;get&#160;or&#160;set&#160;elements&#160;of&#160;the&#160;array<br/>simply by specifying the character number within square brackets:<br/>
s = 'hello'; &#160; # Ruby 1.8<br/>s[0] &#160; &#160; &#160; &#160; &#160; # 104: the ASCII character code for the first character 'h'<br/>s[s.length-1] &#160;# 111: the character code of the last character 'o'<br/>s[-1] &#160; &#160; &#160; &#160; &#160;# 111: another way of accessing the last character<br/>s[-2] &#160; &#160; &#160; &#160; &#160;# 108: the second-to-last character<br/>s[-s.length] &#160; # 104: another way of accessing the first character<br/>s[s.length] &#160; &#160;# nil: there is no character at that index<br/>
Notice&#160;that&#160;negative&#160;array&#160;indexes&#160;specify&#160;a&#160;1-based&#160;position&#160;from&#160;the&#160;end&#160;of&#160;the&#160;string.<br/>Also&#160;notice&#160;that&#160;Ruby&#160;does&#160;not&#160;throw&#160;an&#160;exception&#160;if&#160;you&#160;try&#160;to&#160;access&#160;a&#160;character<br/>beyond the end of the string; it simply returns&#160;nil&#160;instead.<br/>Ruby&#160;1.9&#160;returns&#160;single-character&#160;strings&#160;rather&#160;than&#160;character&#160;codes&#160;when&#160;you&#160;index<br/>a&#160;single&#160;character.&#160;Keep&#160;in&#160;mind&#160;that&#160;when&#160;working&#160;with&#160;multibyte&#160;strings,&#160;with&#160;char-<br/>acters&#160;encoded&#160;using&#160;variable&#160;numbers&#160;of&#160;bytes,&#160;random&#160;access&#160;to&#160;characters&#160;is&#160;less<br/>efficient than access to the underlying bytes:<br/>
s = 'hello'; &#160; # Ruby 1.9<br/>s[0] &#160; &#160; &#160; &#160; &#160; # 'h': the first character of the string, as a string<br/>s[s.length-1] &#160;# 'o': the last character 'o'<br/>s[-1] &#160; &#160; &#160; &#160; &#160;# 'o': another way of accessing the last character<br/>s[-2] &#160; &#160; &#160; &#160; &#160;# 'l': the second-to-last character<br/>s[-s.length] &#160; # 'h': another way of accessing the first character<br/>s[s.length] &#160; &#160;# nil: there is no character at that index<br/>
To&#160;alter&#160;individual&#160;characters&#160;of&#160;a&#160;string,&#160;simply&#160;use&#160;brackets&#160;on&#160;the&#160;lefthand&#160;side&#160;of<br/>an assignment expression. In Ruby 1.8, the righthand side may be an ASCII character<br/>code&#160;or&#160;a&#160;string.&#160;In&#160;Ruby&#160;1.9,&#160;the&#160;righthand&#160;side&#160;must&#160;be&#160;a&#160;string.&#160;You&#160;can&#160;use&#160;character<br/>literals in either version of the language:<br/>
*&#160;In&#160;&#160;Ruby&#160;&#160;1.8,&#160;&#160;setting&#160;&#160;the&#160;&#160;deprecated&#160;&#160;global&#160;&#160;variable&#160;&#160;$=&#160;&#160;to&#160;&#160;true&#160;&#160;makes&#160;&#160;the&#160;&#160;==,&#160;&#160;&lt;,&#160;&#160;and&#160;&#160;related&#160;&#160;comparison<br/>
operators&#160;&#160;perform&#160;&#160;case-insensitive&#160;&#160;comparisons.&#160;&#160;You&#160;&#160;should&#160;&#160;not&#160;&#160;do&#160;&#160;this,&#160;&#160;however;&#160;&#160;setting&#160;&#160;this&#160;&#160;variable<br/>produces&#160;a&#160;warning&#160;message,&#160;even&#160;if&#160;the&#160;Ruby&#160;interpreter&#160;is&#160;invoked&#160;without&#160;the&#160;-w&#160;flag.&#160;And&#160;in&#160;Ruby&#160;1.9,<br/>$=&#160;is no longer supported.<br/>
<b>56&#160;|&#160;Chapter 3:</b> <b>Datatypes and Objects</b><br/>
<hr/>
<a name=71></a>s[0] = ?H &#160; &#160; &#160; &#160;# Replace first character with a capital H<br/>s[-1] = ?O &#160; &#160; &#160; # Replace last character with a capital O<br/>s[s.length] = ?! # ERROR! Can't assign beyond the end of the string<br/>
The&#160;righthand&#160;side&#160;of&#160;an&#160;assignment&#160;statement&#160;like&#160;this&#160;need&#160;not&#160;be&#160;a&#160;character&#160;code:<br/>it may be any string, including a multicharacter string or the empty string. Again, this<br/>works in both Ruby 1.8 and Ruby 1.9:<br/>
s = &#34;hello&#34; &#160; &#160; &#160;# Begin with a greeting<br/>s[-1] = &#34;&#34; &#160; &#160; &#160; # Delete the last character; s is now &#34;hell&#34;<br/>s[-1] = &#34;p!&#34; &#160; &#160; # Change new last character and add one; s is now &#34;help!&#34;<br/>
More&#160;often&#160;than&#160;not,&#160;you&#160;want&#160;to&#160;retrieve&#160;substrings&#160;from&#160;a&#160;string&#160;rather&#160;than&#160;individual<br/>character&#160;codes.&#160;To&#160;do&#160;this,&#160;use&#160;two&#160;comma-separated&#160;operands&#160;between&#160;the&#160;square<br/>brackets.&#160;The&#160;first&#160;operand&#160;specifies&#160;an&#160;index&#160;(which&#160;may&#160;be&#160;negative),&#160;and&#160;the&#160;second<br/>specifies&#160;a&#160;length&#160;(which&#160;must&#160;be&#160;nonnegative).&#160;The&#160;result&#160;is&#160;the&#160;substring&#160;that&#160;begins<br/>at the specified index and continues for the specified number of characters:<br/>
s = &#34;hello&#34;<br/>s[0,2] &#160; &#160; &#160; &#160; &#160;# &#34;he&#34;<br/>s[-1,1] &#160; &#160; &#160; &#160; # &#34;o&#34;: returns a string, not the character code ?o<br/>s[0,0] &#160; &#160; &#160; &#160; &#160;# &#34;&#34;: a zero-length substring is always empty<br/>s[0,10] &#160; &#160; &#160; &#160; # &#34;hello&#34;: returns all the characters that are available<br/>s[s.length,1] &#160; # &#34;&#34;: there is an empty string immediately beyond the end<br/>s[s.length+1,1] # nil: it is an error to read past that<br/>s[0,-1] &#160; &#160; &#160; &#160; # nil: negative lengths don't make any sense<br/>
If&#160;you&#160;assign&#160;a&#160;string&#160;to&#160;a&#160;string&#160;indexed&#160;like&#160;this,&#160;you&#160;replace&#160;the&#160;specified&#160;substring<br/>with&#160;the&#160;new&#160;string.&#160;If&#160;the&#160;righthand&#160;side&#160;is&#160;the&#160;empty&#160;string,&#160;this&#160;is&#160;a&#160;deletion,&#160;and&#160;if<br/>the lefthand side has zero-length, this is an insertion:<br/>
s = &#34;hello&#34;<br/>s[0,1] = &#34;H&#34; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Replace first letter with a capital letter<br/>s[s.length,0] = &#34; world&#34; &#160;# Append by assigning beyond the end of the string<br/>s[5,0] = &#34;,&#34; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Insert a comma, without deleting anything<br/>s[5,6] = &#34;&#34; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Delete with no insertion; s == &#34;Hellod&#34;<br/>
Another&#160;way&#160;to&#160;extract,&#160;insert,&#160;delete,&#160;or&#160;replace&#160;a&#160;substring&#160;is&#160;by&#160;indexing&#160;a&#160;string<br/>with&#160;a&#160;Range&#160;object.&#160;We’ll&#160;explain&#160;ranges&#160;in&#160;detail&#160;<a href="Rubys.html#82">in&#160;§3.5&#160;</a>later.&#160;For&#160;our&#160;purposes&#160;here,<br/>a&#160;Range&#160;is&#160;two&#160;integers&#160;separated&#160;by&#160;dots.&#160;When&#160;a&#160;Range&#160;is&#160;used&#160;to&#160;index&#160;a&#160;string,&#160;the<br/>return value is the substring whose characters fall within the&#160;Range:<br/>
s = &#34;hello&#34;<br/>s[2..3] &#160; &#160; &#160; &#160; &#160; # &#34;ll&#34;: characters 2 and 3<br/>s[-3..-1] &#160; &#160; &#160; &#160; # &#34;llo&#34;: negative indexes work, too<br/>s[0..0] &#160; &#160; &#160; &#160; &#160; # &#34;h&#34;: this Range includes one character index<br/>s[0...0] &#160; &#160; &#160; &#160; &#160;# &#34;&#34;: this Range is empty<br/>s[2..1] &#160; &#160; &#160; &#160; &#160; # &#34;&#34;: this Range is also empty<br/>s[7..10] &#160; &#160; &#160; &#160; &#160;# nil: this Range is outside the string bounds<br/>s[-2..-1] = &#34;p!&#34; &#160; &#160; # Replacement: s becomes &#34;help!&#34;<br/>s[0...0] = &#34;Please &#34; # Insertion: s becomes &#34;Please help!&#34;<br/>s[6..10] = &#34;&#34; &#160; &#160; &#160; &#160;# Deletion: s becomes &#34;Please!&#34;<br/>
<b>3.2 &#160;Text&#160;|&#160;57</b><br/>
<hr/>
<a name=72></a>Don’t&#160;confuse&#160;string&#160;indexing&#160;with&#160;two&#160;comma-separated&#160;integers&#160;with&#160;this&#160;form&#160;that<br/>uses&#160;a&#160;single&#160;Range&#160;object.&#160;Although&#160;both&#160;involve&#160;two&#160;integers,&#160;there&#160;is&#160;an&#160;important<br/>difference:&#160;the&#160;form&#160;with&#160;the&#160;comma&#160;specifies&#160;an&#160;index&#160;and&#160;a&#160;length;&#160;the&#160;form&#160;that&#160;uses<br/>a&#160;Range&#160;object specifies two indexes.<br/>It&#160;is&#160;also&#160;possible&#160;to&#160;index&#160;a&#160;string&#160;with&#160;a&#160;string.&#160;When&#160;you&#160;do&#160;this,&#160;the&#160;return&#160;value&#160;is<br/>the&#160;first&#160;substring&#160;of&#160;the&#160;target&#160;string&#160;that&#160;matches&#160;the&#160;index&#160;string,&#160;or&#160;nil,&#160;if&#160;no&#160;match<br/>is&#160;found.&#160;This&#160;form&#160;of&#160;string&#160;indexing&#160;is&#160;really&#160;only&#160;useful&#160;on&#160;the&#160;lefthand&#160;side&#160;of&#160;an<br/>assignment&#160;statement&#160;when&#160;you&#160;want&#160;to&#160;replace&#160;the&#160;matched&#160;string&#160;with&#160;some&#160;other<br/>string:<br/>
s = &#34;hello&#34; &#160; &#160; &#160; # Start with the word &#34;hello&#34;<br/>while(s[&#34;l&#34;]) &#160; &#160; # While the string contains the substring &#34;l&#34;<br/>&#160; s[&#34;l&#34;] = &#34;L&#34;; &#160; # Replace first occurrence of &#34;l&#34; with &#34;L&#34;<br/>end &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Now we have &#34;heLLo&#34;<br/>
Finally, you can index a string using a regular expression. (Regular expression objects<br/>are&#160;covered&#160;in&#160;<a href="Rubys.html#324">§9.2.)&#160;</a>The&#160;result&#160;is&#160;the&#160;first&#160;substring&#160;of&#160;the&#160;string&#160;that&#160;matches&#160;the<br/>pattern,&#160;&#160;and&#160;&#160;again,&#160;&#160;this&#160;&#160;form&#160;&#160;of&#160;&#160;string&#160;&#160;indexing&#160;&#160;is&#160;&#160;most&#160;&#160;useful&#160;&#160;when&#160;&#160;used&#160;&#160;on&#160;&#160;the<br/>lefthand side of an assignment:<br/>
s[/[aeiou]/] = '*' &#160; &#160; &#160;# Replace first vowel with an asterisk<br/>
<b>3.2.5 &#160;Iterating Strings<br/></b>In&#160;Ruby 1.8,&#160;the&#160;String&#160;class defines an&#160;each&#160;method that&#160;iterates a string line-by-line.<br/>The&#160;String&#160;class&#160;includes&#160;the&#160;methods&#160;of&#160;the&#160;Enumerable&#160;module,&#160;and&#160;they&#160;can&#160;be&#160;used<br/>to&#160;process&#160;the&#160;lines&#160;of&#160;a&#160;string.&#160;You&#160;can&#160;use&#160;the&#160;each_byte&#160;iterator&#160;in&#160;Ruby&#160;1.8&#160;to&#160;iterate<br/>through&#160;the&#160;bytes&#160;of&#160;a&#160;string,&#160;but&#160;there&#160;is&#160;little&#160;advantage&#160;to&#160;using&#160;each_byte&#160;over&#160;the<br/>[]&#160;operator because random access to bytes is as quick as sequential access in 1.8.<br/>
The&#160;situation&#160;is&#160;quite&#160;different&#160;in&#160;Ruby&#160;1.9,&#160;which&#160;removes&#160;the&#160;each&#160;method,&#160;and&#160;in<br/>which&#160;the&#160;String&#160;class&#160;is&#160;no&#160;longer&#160;Enumerable.&#160;In&#160;place&#160;of&#160;each,&#160;Ruby&#160;1.9&#160;defines&#160;three<br/>clearly&#160;named&#160;string&#160;iterators:&#160;each_byte&#160;iterates&#160;sequentially&#160;through&#160;the&#160;individual<br/>bytes&#160;that&#160;comprise&#160;a&#160;string;&#160;each_char&#160;iterates&#160;the&#160;characters;&#160;and&#160;each_line&#160;iterates<br/>the&#160;lines.&#160;If&#160;you&#160;want&#160;to&#160;process&#160;a&#160;string&#160;character-by-character,&#160;it&#160;may&#160;be&#160;more&#160;efficient<br/>to use&#160;each_char&#160;than to use the&#160;[]&#160;operator and character indexes:<br/>
s = &#34;¥1000&#34;<br/>s.each_char {|x| print &#34;#{x} &#34; } &#160; &#160; &#160; &#160; # Prints &#34;¥ 1 0 0 0&#34;. Ruby 1.9&#160;<br/>0.upto(s.size-1) {|i| print &#34;#{s[i]} &#34;} &#160;# Inefficient with multibyte chars<br/>
<b>3.2.6 &#160;String Encodings and Multibyte Characters<br/></b>Strings are fundamentally different in Ruby 1.8 and Ruby 1.9:<br/>
•&#160;In&#160;Ruby&#160;1.8,&#160;strings&#160;are&#160;a&#160;sequence&#160;of&#160;bytes.&#160;When&#160;strings&#160;are&#160;used&#160;to&#160;represent<br/>
text&#160;(instead&#160;of&#160;binary&#160;data),&#160;each&#160;byte&#160;of&#160;the&#160;string&#160;is&#160;assumed&#160;to&#160;represent&#160;a&#160;single<br/>
<b>58&#160;|&#160;Chapter 3:</b> <b>Datatypes and Objects</b><br/>
<hr/>
<a name=73></a>ASCII&#160;character.&#160;In&#160;1.8,&#160;the&#160;individual&#160;elements&#160;of&#160;a&#160;string&#160;are&#160;not&#160;characters,&#160;but<br/>numbers—the actual byte value or character encoding.<br/>
•&#160;In&#160;Ruby&#160;1.9,&#160;on&#160;the&#160;other&#160;hand,&#160;strings&#160;are&#160;true&#160;sequences&#160;of&#160;characters,&#160;and&#160;those<br/>
characters&#160;need&#160;not&#160;be&#160;confined&#160;to&#160;the&#160;ASCII&#160;character&#160;set.&#160;In&#160;1.9,&#160;the&#160;individual<br/>elements&#160;of&#160;a&#160;string&#160;are&#160;characters—represented&#160;as&#160;strings&#160;of&#160;length&#160;1—rather&#160;than<br/>integer&#160;&#160;character&#160;&#160;codes.&#160;&#160;Every&#160;&#160;string&#160;&#160;has&#160;&#160;an&#160;&#160;encoding&#160;&#160;that&#160;&#160;specifies&#160;&#160;the&#160;&#160;corre-<br/>spondence&#160;between&#160;the&#160;bytes&#160;in&#160;the&#160;string&#160;and&#160;the&#160;characters&#160;those&#160;bytes&#160;represent.<br/>Encodings&#160;such&#160;as&#160;the&#160;UTF-8&#160;encoding&#160;of&#160;Unicode&#160;characters&#160;use&#160;variable&#160;numbers<br/>of&#160;bytes&#160;for&#160;each&#160;character,&#160;and&#160;there&#160;is&#160;no&#160;longer&#160;a&#160;1-to-1&#160;(nor&#160;even&#160;a&#160;2-to-1)<br/>correspondence between bytes and characters.<br/>
The&#160;subsections&#160;that&#160;follow&#160;explain&#160;the&#160;encoding-related&#160;features&#160;of&#160;strings&#160;in&#160;Ruby<br/>1.9,&#160;and&#160;also&#160;demonstrate&#160;rudimentary&#160;support&#160;for&#160;multibyte&#160;characters&#160;in&#160;Ruby&#160;1.8<br/>using the&#160;jcode&#160;library.<br/>
<b>3.2.6.1 &#160;Multibyte characters in Ruby 1.9<br/></b>The&#160;String&#160;class&#160;has&#160;been&#160;rewritten&#160;in&#160;Ruby&#160;1.9&#160;to&#160;be&#160;aware&#160;of&#160;and&#160;properly&#160;handle<br/>multibyte&#160;characters.&#160;Although&#160;multibyte&#160;support&#160;is&#160;the&#160;biggest&#160;change&#160;in&#160;Ruby&#160;1.9,&#160;it<br/>is&#160;not&#160;a&#160;highly&#160;visible&#160;change:&#160;code&#160;that&#160;uses&#160;multibyte&#160;strings&#160;just&#160;works.&#160;It&#160;is&#160;worth<br/>understanding why it works, however, and this section explains the details.<br/>If&#160;a&#160;string&#160;contains&#160;multibyte&#160;characters,&#160;then&#160;the&#160;number&#160;of&#160;bytes&#160;does&#160;not&#160;correspond<br/>to&#160;&#160;the&#160;&#160;number&#160;&#160;of&#160;&#160;characters.&#160;&#160;In&#160;&#160;Ruby&#160;&#160;1.9,&#160;&#160;the&#160;&#160;length&#160;&#160;and&#160;&#160;size&#160;&#160;methods&#160;&#160;return&#160;&#160;the<br/>number&#160;of&#160;characters&#160;in&#160;a&#160;string,&#160;and&#160;the&#160;new&#160;bytesize&#160;method&#160;returns&#160;the&#160;number&#160;of<br/>bytes.&#160;The&#160;[]&#160;and&#160;[]=&#160;operators&#160;allow&#160;you&#160;to&#160;query&#160;and&#160;set&#160;the&#160;characters&#160;of&#160;a&#160;string,<br/>and&#160;the&#160;new&#160;methods&#160;getbyte&#160;and&#160;&#160;setbyte&#160;allow&#160;you&#160;to&#160;query&#160;and&#160;set&#160;individual&#160;bytes<br/>(though you should not often need to do this):<br/>
&#160;<br/>
# -*- coding: utf-8 -*- &#160; # Specify Unicode UTF-8 characters<br/>
# This is a string literal containing a multibyte multiplication character<br/>s = &#34;2×2=4&#34;<br/>
# The string contains 6 bytes which encode 5 characters<br/>s.bytesize &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; 6<br/>s.bytesize.times {|i| print s.getbyte(i), &#34; &#34;} # Prints &#34;50 195 151 50 61 52&#34;<br/>s.length &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; 5<br/>s.length.times { |i| print s[i], &#34; &#34;} &#160; &#160; &#160; &#160; &#160;# Prints &#34;2 × 2 = 4&#34;<br/>s.setbyte(5, s.getbyte(5)+1); &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# s is now &#34;2×2=5&#34;<br/>
Note that the first line in this code is a coding&#160;comment that sets the source encoding<br/>(see&#160;<a href="Rubys.html#51">§2.4.1)&#160;</a>to&#160;UTF-8.&#160;Without&#160;this&#160;comment,&#160;the&#160;Ruby&#160;interpreter&#160;would&#160;not&#160;know<br/>how&#160;to&#160;decode&#160;the&#160;sequence&#160;of&#160;bytes&#160;in&#160;the&#160;string&#160;literal&#160;into&#160;a&#160;sequence&#160;of&#160;characters.<br/>When&#160;a&#160;string&#160;contains&#160;characters&#160;encoded&#160;with&#160;varying&#160;numbers&#160;of&#160;bytes,&#160;it&#160;is&#160;no<br/>longer&#160;possible&#160;to&#160;map&#160;directly&#160;from&#160;character&#160;index&#160;to&#160;byte&#160;offset&#160;in&#160;the&#160;string.&#160;In&#160;the<br/>string&#160;above,&#160;for&#160;example,&#160;the&#160;second&#160;character&#160;begins&#160;at&#160;the&#160;second&#160;byte.&#160;But&#160;the&#160;third<br/>character&#160;begins&#160;at&#160;the&#160;fourth&#160;byte.&#160;This&#160;means&#160;that&#160;you&#160;cannot&#160;assume&#160;that&#160;random<br/>
<b>3.2 &#160;Text&#160;|&#160;59</b><br/>
<hr/>
<a name=74></a>access&#160;to&#160;arbitrary&#160;characters&#160;within&#160;a&#160;string&#160;is&#160;a&#160;fast&#160;operation.&#160;When&#160;you&#160;use&#160;the&#160;[]<br/>operator,&#160;as&#160;we&#160;did&#160;in&#160;the&#160;code&#160;above,&#160;to&#160;access&#160;a&#160;character&#160;or&#160;substring&#160;within&#160;a&#160;mul-<br/>tibyte&#160;string,&#160;the&#160;Ruby&#160;implementation&#160;must&#160;internally&#160;iterate&#160;sequentially&#160;through&#160;the<br/>string&#160;to&#160;find&#160;the&#160;desired&#160;character&#160;index.&#160;In&#160;general,&#160;therefore,&#160;you&#160;should&#160;try&#160;to&#160;do<br/>your&#160;&#160;string&#160;&#160;processing&#160;&#160;using&#160;&#160;sequential&#160;&#160;algorithms&#160;&#160;when&#160;&#160;possible.&#160;&#160;That&#160;&#160;is:&#160;&#160;use&#160;&#160;the<br/>each_char&#160;iterator&#160;when&#160;possible&#160;instead&#160;of&#160;repeated&#160;calls&#160;to&#160;the&#160;[]&#160;operator.&#160;On&#160;the<br/>other&#160;hand,&#160;it&#160;is&#160;usually&#160;not&#160;necessary&#160;to&#160;worry&#160;too&#160;much&#160;about&#160;this.&#160;Ruby&#160;implemen-<br/>tations&#160;optimize&#160;the&#160;cases&#160;that&#160;can&#160;be&#160;optimized,&#160;and&#160;if&#160;a&#160;string&#160;consists&#160;entirely&#160;of&#160;1-<br/>byte&#160;&#160;characters,&#160;&#160;random&#160;&#160;access&#160;&#160;to&#160;&#160;those&#160;&#160;characters&#160;&#160;will&#160;&#160;be&#160;&#160;efficient.&#160;&#160;If&#160;&#160;you&#160;&#160;want&#160;&#160;to<br/>attempt your own optimizations, you can use the instance method&#160;ascii_only?&#160;to de-<br/>termine whether a string consists entirely of 7-bit ASCII characters.<br/>The&#160;Ruby&#160;1.9&#160;String&#160;class&#160;defines&#160;an&#160;encoding&#160;method&#160;that&#160;returns&#160;the&#160;encoding&#160;of&#160;a<br/>string (the return value is an&#160;Encoding&#160;object, which is described below):<br/>
# -*- coding: utf-8 -*-<br/>s = &#34;2×2=4&#34; &#160; &#160; # Note multibyte multiplication character<br/>s.encoding &#160; &#160; &#160;# =&gt; &lt;Encoding: UTF-8&gt;<br/>
The&#160;encoding&#160;of&#160;string&#160;literals&#160;is&#160;always&#160;the&#160;same&#160;as&#160;the&#160;source&#160;encoding&#160;of&#160;the&#160;file,<br/>except&#160;that&#160;literals&#160;that&#160;contain&#160;\u&#160;escapes&#160;are&#160;always&#160;encoded&#160;in&#160;UTF-8,&#160;regardless&#160;of<br/>the source encoding.<br/>
<b>ASCII and BINARY encodings</b><br/>
The&#160;“ASCII-8BIT”&#160;encoding&#160;shown&#160;earlier&#160;is&#160;Ruby&#160;1.9’s&#160;name&#160;for&#160;the&#160;legacy&#160;encoding<br/>used&#160;by&#160;Ruby&#160;1.8;&#160;it&#160;is&#160;the&#160;ASCII&#160;character&#160;set&#160;with&#160;no&#160;restrictions&#160;on&#160;the&#160;use&#160;of&#160;non-<br/>printing&#160;and&#160;control&#160;characters.&#160;In&#160;this&#160;encoding,&#160;one&#160;byte&#160;always&#160;equals&#160;one&#160;character,<br/>and strings can hold binary data or character data.<br/>
Certain&#160;Ruby&#160;1.9&#160;methods&#160;require&#160;you&#160;to&#160;specify&#160;an&#160;encoding&#160;name&#160;(or&#160;Encoding&#160;object<br/>—see&#160;&#160;below).&#160;&#160;You&#160;&#160;can&#160;&#160;specify&#160;&#160;this&#160;&#160;ASCII&#160;&#160;encoding&#160;&#160;as&#160;&#160;“ASCII-8BIT”&#160;&#160;or&#160;&#160;by&#160;&#160;its&#160;&#160;alias<br/>“BINARY”.&#160;&#160;This&#160;&#160;may&#160;&#160;seem&#160;&#160;surprising,&#160;&#160;but&#160;&#160;it’s&#160;&#160;true:&#160;&#160;as&#160;&#160;far&#160;&#160;as&#160;&#160;Ruby&#160;&#160;is&#160;&#160;concerned,&#160;&#160;a<br/>sequence&#160;of&#160;bytes&#160;with&#160;no&#160;encoding&#160;(“BINARY”)&#160;is&#160;the&#160;same&#160;as&#160;a&#160;sequence&#160;of&#160;8-bit<br/>ASCII characters.<br/>
Ruby&#160;1.9&#160;also&#160;supports&#160;an&#160;encoding&#160;named&#160;“US-ASCII”,&#160;which&#160;is&#160;true&#160;7-bit&#160;ASCII;&#160;it<br/>differs&#160;from&#160;ASCII-8BIT&#160;in&#160;that&#160;it&#160;does&#160;not&#160;allow&#160;any&#160;bytes&#160;with&#160;their&#160;8th&#160;bit&#160;set.&#160;The<br/>encoding name “ASCII” is an alias for “US-ASCII”.<br/>
Certain&#160;string&#160;operations,&#160;such&#160;as&#160;concatenation&#160;and&#160;pattern&#160;matching,&#160;require&#160;that<br/>two&#160;strings&#160;(or&#160;a&#160;string&#160;and&#160;a&#160;regular&#160;expression)&#160;have&#160;compatible&#160;encodings.&#160;If&#160;you<br/>concatenate&#160;an&#160;ASCII&#160;string&#160;with&#160;a&#160;UTF-8&#160;string,&#160;for&#160;example,&#160;you&#160;obtain&#160;a&#160;UTF-8<br/>string.&#160;It&#160;is&#160;not&#160;possible,&#160;however,&#160;to&#160;concatenate&#160;a&#160;UTF-8&#160;string&#160;and&#160;an&#160;SJIS&#160;string:&#160;the<br/>encodings&#160;are&#160;not&#160;compatible,&#160;and&#160;an&#160;exception&#160;will&#160;be&#160;raised.&#160;You&#160;can&#160;test&#160;whether<br/>two&#160;strings&#160;(or&#160;a&#160;string&#160;and&#160;a&#160;regular&#160;expression)&#160;have&#160;compatible&#160;encodings&#160;by&#160;using<br/>the&#160;&#160;class&#160;&#160;method&#160;&#160;Encoding.compatible?.&#160;&#160;If&#160;&#160;the&#160;&#160;encodings&#160;&#160;of&#160;&#160;the&#160;&#160;two&#160;&#160;arguments&#160;&#160;are<br/>
<b>60&#160;|&#160;Chapter 3:</b> <b>Datatypes and Objects</b><br/>
<hr/>
<a name=75></a>compatible,&#160;it&#160;returns&#160;the&#160;one&#160;that&#160;is&#160;the&#160;superset&#160;of&#160;the&#160;other.&#160;If&#160;the&#160;encodings&#160;are<br/>incompatible, it returns&#160;nil.<br/>You&#160;can&#160;explicitly&#160;set&#160;the&#160;encoding&#160;of&#160;a&#160;string&#160;with&#160;force_encoding.&#160;This&#160;is&#160;useful&#160;if&#160;you<br/>have&#160;a&#160;string&#160;of&#160;bytes&#160;(read&#160;from&#160;an&#160;I/O&#160;stream,&#160;perhaps)&#160;and&#160;want&#160;to&#160;tell&#160;Ruby&#160;how<br/>they&#160;should&#160;be&#160;interpreted&#160;as&#160;characters.&#160;Or,&#160;if&#160;you&#160;have&#160;a&#160;string&#160;of&#160;multibyte&#160;characters,<br/>but you want to index individual bytes with&#160;[]:<br/>
text = stream.readline.force_encoding(&#34;utf-8&#34;)<br/>bytes = text.dup.force_encoding(&#34;binary&#34;)<br/>
force_encoding&#160;does&#160;not&#160;make&#160;a&#160;copy&#160;of&#160;its&#160;receiver;&#160;it&#160;modifies&#160;the&#160;encoding&#160;of&#160;the<br/>string&#160;and&#160;returns&#160;the&#160;string.&#160;This&#160;method&#160;does&#160;not&#160;do&#160;any&#160;character&#160;conversion—the<br/>underlying&#160;bytes&#160;of&#160;the&#160;string&#160;are&#160;not&#160;changed,&#160;only&#160;Ruby’s&#160;interpretation&#160;of&#160;them&#160;is<br/>changed.&#160;&#160;The&#160;&#160;argument&#160;&#160;to&#160;&#160;force_encoding&#160;&#160;can&#160;&#160;be&#160;&#160;the&#160;&#160;name&#160;&#160;of&#160;&#160;an&#160;&#160;encoding&#160;&#160;or&#160;&#160;an<br/>Encoding&#160;object.<br/>
force_encoding&#160;does&#160;no&#160;validation;&#160;it&#160;does&#160;not&#160;check&#160;that&#160;the&#160;underlying&#160;bytes&#160;of&#160;the<br/>string&#160;&#160;represent&#160;&#160;a&#160;&#160;valid&#160;&#160;sequence&#160;&#160;of&#160;&#160;characters&#160;&#160;in&#160;&#160;the&#160;&#160;specified&#160;&#160;encoding.&#160;&#160;Use<br/>valid_encoding?&#160;to&#160;perform&#160;validation.&#160;This&#160;&#160;instance&#160;method&#160;takes&#160;no&#160;arguments&#160;and<br/>checks&#160;whether&#160;the&#160;bytes&#160;of&#160;a&#160;string&#160;can&#160;be&#160;interpreted&#160;as&#160;a&#160;valid&#160;sequence&#160;of&#160;characters<br/>using the string’s encoding:<br/>
s = &#34;\xa4&#34;.force_encoding(&#34;utf-8&#34;) &#160;# This is not a valid UTF-8 string<br/>s.valid_encoding? &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; false<br/>
The&#160;encode&#160;method&#160;(and&#160;the&#160;mutating&#160;encode!&#160;variant)&#160;of&#160;a&#160;string&#160;is&#160;quite&#160;different&#160;from<br/>force_encoding.&#160;It&#160;returns&#160;a&#160;string&#160;that&#160;represents&#160;the&#160;same&#160;sequence&#160;of&#160;characters&#160;as<br/>its&#160;receiver,&#160;but&#160;using&#160;a&#160;different&#160;encoding.&#160;In&#160;order&#160;to&#160;change&#160;the&#160;encoding&#160;of—or<br/><i>transcode</i>—a&#160;string&#160;like&#160;this,&#160;the&#160;encode&#160;method&#160;must&#160;alter&#160;the&#160;underlying&#160;bytes&#160;that<br/>make up the string. Here is an example:<br/>
# -*- coding: utf-8 -*-<br/>euro1 = &#34;\u20AC&#34; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Start with the Unicode Euro character<br/>puts euro1 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Prints &#34;€&#34;<br/>euro1.encoding &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; &lt;Encoding:UTF-8&gt;<br/>euro1.bytesize &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; 3<br/>
euro2 = euro1.encode(&#34;iso-8859-15&#34;) &#160;# Transcode to Latin-15<br/>puts euro2.inspect &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Prints &#34;\xA4&#34;<br/>euro2.encoding &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; &lt;Encoding:iso-8859-15&gt;<br/>euro2.bytesize &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; 1<br/>
euro3 = euro2.encode(&#34;utf-8&#34;) &#160; &#160; &#160; &#160;# Transcode back to UTF-8<br/>euro1 == euro3 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; true<br/>
Note&#160;that&#160;you&#160;should&#160;not&#160;often&#160;need&#160;to&#160;use&#160;the&#160;encode&#160;method.&#160;The&#160;most&#160;common&#160;time<br/>to&#160;transcode&#160;strings&#160;is&#160;before&#160;writing&#160;them&#160;to&#160;a&#160;file&#160;or&#160;sending&#160;them&#160;across&#160;a&#160;network<br/>connection.&#160;And,&#160;as&#160;we’ll&#160;see&#160;in&#160;<a href="Rubys.html#373">§9.7.2,&#160;</a>Ruby’s&#160;I/O&#160;stream&#160;classes&#160;support&#160;the&#160;auto-<br/>matic transcoding of text when it is written out.<br/>
<b>3.2 &#160;Text&#160;|&#160;61</b><br/>
<hr/>
<a name=76></a>If&#160;the&#160;string&#160;that&#160;you&#160;are&#160;calling&#160;encode&#160;on&#160;consists&#160;of&#160;unencoded&#160;bytes,&#160;you&#160;need&#160;to<br/>specify&#160;the&#160;encoding&#160;by&#160;which&#160;to&#160;interpret&#160;those&#160;bytes&#160;before&#160;transcoding&#160;them&#160;to&#160;an-<br/>other&#160;encoding.&#160;Do&#160;this&#160;by&#160;passing&#160;two&#160;arguments&#160;to&#160;encode.&#160;The&#160;first&#160;argument&#160;is&#160;the<br/>desired&#160;encoding,&#160;and&#160;the&#160;second&#160;argument&#160;is&#160;the&#160;current&#160;encoding&#160;of&#160;the&#160;string.&#160;For<br/>example:<br/>
# Interpret a byte as an iso-8859-15 codepoint, and transcode to UTF-8<br/>byte = &#34;\xA4&#34;<br/>char = byte.encode(&#34;utf-8&#34;, &#34;iso-8859-15&#34;)<br/>
That is, the following two lines of code have the same effect:<br/>
text = bytes.encode(to, from)<br/>text = bytes.dup.force_encoding(from).encode(to)<br/>
If&#160;you&#160;call&#160;encode&#160;with&#160;no&#160;arguments,&#160;it&#160;transcodes&#160;its&#160;receiver&#160;to&#160;the&#160;default&#160;internal<br/>encoding,&#160;if&#160;one&#160;has&#160;been&#160;set&#160;with&#160;the&#160;-E&#160;or&#160;-U&#160;interpreter&#160;options&#160;<a href="Rubys.html#406">(see&#160;§10.1.3). This<br/></a>allows&#160;library&#160;modules&#160;(for&#160;example)&#160;to&#160;transcode&#160;their&#160;public&#160;string&#160;constants&#160;to&#160;a<br/>common encoding for interoperability.<br/>Character&#160;encodings&#160;differ&#160;not&#160;only&#160;in&#160;their&#160;mapping&#160;from&#160;bytes&#160;to&#160;characters,&#160;but&#160;in<br/>the&#160;set&#160;of&#160;characters&#160;that&#160;they&#160;can&#160;represent.&#160;Unicode&#160;(also&#160;known&#160;as&#160;UCS—the&#160;Uni-<br/>versal&#160;Character&#160;Set)&#160;tries&#160;to&#160;allow&#160;all&#160;characters,&#160;but&#160;character&#160;encodings&#160;not&#160;based&#160;on<br/>Unicode&#160;can&#160;only&#160;represent&#160;a&#160;subset&#160;of&#160;characters.&#160;It&#160;is&#160;not&#160;possible,&#160;therefore,&#160;to&#160;trans-<br/>code&#160;all&#160;UTF-8&#160;strings&#160;to&#160;EUC-JP&#160;(for&#160;example);&#160;Unicode&#160;characters&#160;that&#160;are&#160;neither<br/>Latin nor Japanese cannot be translated.<br/>If&#160;the&#160;encode&#160;or&#160;encode!&#160;method&#160;encounters&#160;a&#160;character&#160;that&#160;it&#160;cannot&#160;transcode,&#160;it&#160;raises<br/>an exception:<br/>
&#34;\u20AC&#34;.encode(&#34;iso-8859-1&#34;) # No euro sign in Latin-1, so raise exception<br/>
encode&#160;and&#160;encode!&#160;accept&#160;a&#160;hash&#160;of&#160;transcoding&#160;options&#160;as&#160;their&#160;final&#160;argument.&#160;At&#160;the<br/>time&#160;of&#160;this&#160;writing,&#160;the&#160;only&#160;defined&#160;option&#160;name&#160;is&#160;:invalid,&#160;and&#160;the&#160;only&#160;defined<br/>value&#160;for&#160;that&#160;key&#160;is&#160;:ignore.&#160;“ri&#160;String.encode”&#160;will&#160;give&#160;details&#160;when&#160;more&#160;options&#160;are<br/>implemented.<br/>
<b>3.2.6.2 &#160;The Encoding class<br/></b>The&#160;Encoding&#160;class&#160;of&#160;Ruby&#160;1.9&#160;represents&#160;a&#160;character&#160;encoding.&#160;Encoding&#160;objects&#160;act<br/>as&#160;opaque&#160;identifiers&#160;for&#160;an&#160;encoding&#160;and&#160;do&#160;not&#160;have&#160;many&#160;methods&#160;of&#160;their&#160;own.&#160;The<br/>name&#160;&#160;method&#160;&#160;returns&#160;&#160;the&#160;&#160;name&#160;&#160;of&#160;&#160;an&#160;&#160;encoding.&#160;&#160;to_s&#160;&#160;is&#160;&#160;a&#160;&#160;synonym&#160;&#160;for&#160;&#160;name,&#160;&#160;and<br/>inspect&#160;converts an&#160;Encoding&#160;object to a string in a more verbose way than&#160;name&#160;does.<br/>
Ruby&#160;defines&#160;a&#160;constant&#160;for&#160;each&#160;of&#160;the&#160;built-in&#160;encodings&#160;it&#160;supports,&#160;and&#160;these&#160;are&#160;the<br/>easiest&#160;way&#160;to&#160;specify&#160;a&#160;hardcoded&#160;encoding&#160;in&#160;your&#160;program.&#160;The&#160;predefined&#160;constants<br/>include at least the following:<br/>
Encoding::ASCII_8BIT &#160; &#160; # Also ::BINARY<br/>Encoding::UTF_8 &#160; &#160; &#160; &#160; &#160;# UTF-8-encoded Unicode characters<br/>Encoding::EUC_JP &#160; &#160; &#160; &#160; # EUC-encoded Japanese<br/>Encoding::SHIFT_JIS &#160; &#160; &#160;# Japanese: also ::SJIS, ::WINDOWS_31J, ::CP932<br/>
<b>62&#160;|&#160;Chapter 3:</b> <b>Datatypes and Objects</b><br/>
<hr/>
<a name=77></a>Note&#160;that&#160;because&#160;these&#160;are&#160;constants,&#160;they&#160;must&#160;be&#160;written&#160;in&#160;uppercase,&#160;and&#160;hyphens<br/>in&#160;the&#160;encoding&#160;names&#160;must&#160;be&#160;converted&#160;to&#160;underscores.&#160;Ruby&#160;1.9&#160;also&#160;supports&#160;the<br/>US-ASCII&#160;encoding,&#160;the&#160;European&#160;encodings&#160;ISO-8859-1&#160;through&#160;ISO-8859-15,&#160;and<br/>the Unicode UTF-16 and UTF-32 encodings in big-endian and little-endian variants.<br/>If&#160;&#160;you&#160;&#160;have&#160;&#160;an&#160;&#160;encoding&#160;&#160;name&#160;&#160;as&#160;&#160;a&#160;&#160;string&#160;&#160;and&#160;&#160;want&#160;&#160;to&#160;&#160;obtain&#160;&#160;the&#160;&#160;corresponding<br/>Encoding&#160;object, use the&#160;Encoding.find&#160;factory method:&#160;<br/>
encoding = Encoding.find(&#34;utf-8&#34;)<br/>
Using&#160;Encoding.find&#160;causes&#160;the&#160;named&#160;encoding&#160;to&#160;be&#160;dynamically&#160;loaded,&#160;if&#160;necessary.<br/>Encoding.find&#160;accepts&#160;encoding&#160;names&#160;that&#160;are&#160;in&#160;either&#160;upper-&#160;or&#160;lowercase.&#160;Call&#160;the<br/>name&#160;method of an&#160;Encoding&#160;to obtain the name of the encoding as a string.<br/>
Encoding.list&#160;returns&#160;an&#160;array&#160;of&#160;all&#160;available&#160;encoding&#160;objects.&#160;Encoding.name_list&#160;<br/>returns&#160;an&#160;array&#160;of&#160;the&#160;names&#160;(as&#160;strings)&#160;of&#160;all&#160;available&#160;encodings.&#160;Many&#160;encodings<br/>have&#160;more&#160;than&#160;one&#160;name&#160;in&#160;common&#160;use,&#160;and&#160;Encoding.aliases&#160;returns&#160;a&#160;hash&#160;that<br/>maps&#160;encoding&#160;aliases&#160;to&#160;the&#160;official&#160;encoding&#160;names&#160;for&#160;which&#160;they&#160;are&#160;synonyms.&#160;The<br/>array&#160;returned&#160;by&#160;Encoding.name_list&#160;includes&#160;the&#160;aliases&#160;in&#160;the&#160;Encoding.aliases&#160;hash.<br/>Use&#160;&#160;Encoding.default_external&#160;&#160;and&#160;&#160;Encoding.default_internal&#160;&#160;to&#160;&#160;obtain&#160;&#160;the<br/>Encoding&#160;objects&#160;that&#160;represent&#160;the&#160;default&#160;external&#160;and&#160;default&#160;internal&#160;encodings&#160;(see<br/><a href="Rubys.html#52">§2.4.2).&#160;</a>To&#160;obtain&#160;the&#160;encoding&#160;for&#160;the&#160;current&#160;locale,&#160;call&#160;Encoding.locale_charmap<br/>and pass the resulting string to&#160;Encoding.find.<br/>Most&#160;methods&#160;that&#160;expect&#160;an&#160;Encoding&#160;object&#160;will&#160;also&#160;accept&#160;a&#160;case-insensitive&#160;encod-<br/>ing&#160;name&#160;(such&#160;as&#160;ascii,&#160;binary,&#160;utf-8,&#160;euc-jp,&#160;or&#160;sjis)&#160;in&#160;place&#160;of&#160;an&#160;Encoding&#160;object.<br/>
<b>3.2.6.3 &#160;Multibyte characters in Ruby 1.8<br/></b>Normally,&#160;Ruby&#160;1.8&#160;treats&#160;all&#160;strings&#160;as&#160;sequences&#160;of&#160;8-bit&#160;bytes.&#160;There&#160;is&#160;rudimentary<br/>support&#160;for&#160;multibyte&#160;characters&#160;(using&#160;the&#160;UTF-8,&#160;EUC,&#160;or&#160;SJIS&#160;encodings)&#160;in&#160;the<br/>jcode&#160;module of the standard library.<br/>
To use this library, require the&#160;jcode&#160;module, and set the global&#160;$KCODE&#160;variable to the<br/>encoding&#160;that&#160;your&#160;multibyte&#160;characters&#160;use.&#160;(Alternatively,&#160;use&#160;the&#160;-K&#160;command-line<br/>option&#160;when&#160;you&#160;start&#160;the&#160;Ruby&#160;interpreter.)&#160;The&#160;jcode&#160;library&#160;defines&#160;a&#160;new&#160;jlength<br/>method for&#160;String&#160;objects:&#160;it&#160;returns&#160;the&#160;length&#160;of&#160;the&#160;string&#160;in&#160;characters&#160;rather&#160;than<br/>in&#160;bytes.&#160;The&#160;existing&#160;1.8&#160;length&#160;and&#160;size&#160;methods&#160;are&#160;unchanged—they&#160;return&#160;the<br/>string length in bytes.<br/>The&#160;jcode&#160;library&#160;does&#160;not&#160;modify&#160;the&#160;array&#160;indexing&#160;operator&#160;on&#160;strings,&#160;and&#160;does&#160;not<br/>allow&#160;random&#160;access&#160;to&#160;the&#160;characters&#160;that&#160;comprise&#160;a&#160;multibyte&#160;string.&#160;But&#160;it&#160;does<br/>define&#160;a&#160;new&#160;iterator&#160;named&#160;each_char,&#160;which&#160;works&#160;like&#160;the&#160;standard&#160;each_byte&#160;but<br/>passes&#160;each&#160;character&#160;of&#160;the&#160;string&#160;(as&#160;a&#160;string&#160;instead&#160;of&#160;as&#160;a&#160;character&#160;code)&#160;to&#160;the<br/>block of code you supply:<br/>
$KCODE = &#34;u&#34; &#160; &#160; &#160; &#160;# Specify Unicode UTF-8, or start Ruby with -Ku option<br/>require &#34;jcode&#34; &#160; &#160; # Load multibyte character support<br/>
<b>3.2 &#160;Text&#160;|&#160;63</b><br/>
<hr/>
<a name=78></a>mb = &#34;2\303\2272=4&#34; # This is &#34;2×2=4&#34; with a Unicode multiplication sign<br/>mb.length &#160; &#160; &#160; &#160; &#160; # =&gt; 6: there are 6 bytes in this string<br/>mb.jlength &#160; &#160; &#160; &#160; &#160;# =&gt; 5: but only 5 characters<br/>mb.mbchar? &#160; &#160; &#160; &#160; &#160;# =&gt; 1: position of the first multibyte char, or nil<br/>mb.each_byte do |c| # Iterate through the bytes of the string.<br/>&#160; print c, &#34; &#34; &#160; &#160; &#160;# c is Fixnum<br/>end &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Outputs &#34;50 195 151 50 61 52 &#34;<br/>mb.each_char do |c| # Iterate through the characters of the string<br/>&#160; print c, &#34; &#34; &#160; &#160; &#160;# c is a String with jlength 1 and variable length<br/>end &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Outputs &#34;2 × 2 = 4 &#34;<br/>
The&#160;jcode&#160;library&#160;also&#160;modifies&#160;several&#160;existing&#160;String&#160;methods,&#160;such&#160;as&#160;chop,&#160;delete,<br/>and&#160;tr, to work with multibyte strings.<br/>
<b>3.3 &#160;Arrays<br/></b>An array is a sequence of values that allows values to be accessed by their position,&#160;or<br/><i>index</i>,&#160;in&#160;the&#160;sequence.&#160;In&#160;Ruby,&#160;the&#160;first&#160;value&#160;in&#160;an&#160;array&#160;has&#160;index&#160;0.&#160;The&#160;size&#160;and<br/>length&#160;methods&#160;return&#160;the&#160;number&#160;of&#160;elements&#160;in&#160;an&#160;array.&#160;The&#160;last&#160;element&#160;of&#160;the&#160;array<br/>is&#160;at&#160;index&#160;size-1.&#160;Negative&#160;index&#160;values&#160;count&#160;from&#160;the&#160;end&#160;of&#160;the&#160;array,&#160;so&#160;the&#160;last<br/>element&#160;of&#160;an&#160;array&#160;can&#160;also&#160;be&#160;accessed&#160;with&#160;an&#160;index&#160;of&#160;–1.&#160;The&#160;second-to-last&#160;has&#160;an<br/>index&#160;of&#160;–2,&#160;and&#160;so&#160;on.&#160;If&#160;you&#160;attempt&#160;to&#160;read&#160;an&#160;element&#160;beyond&#160;the&#160;end&#160;of&#160;an&#160;array<br/>(with&#160;an&#160;index&#160;&gt;=&#160;size)&#160;or&#160;before&#160;the&#160;beginning&#160;of&#160;an&#160;array&#160;(with&#160;an&#160;index&#160;&lt;&#160;-size),<br/>Ruby simply returns&#160;nil&#160;and does not throw an exception.<br/>Ruby’s&#160;arrays&#160;are&#160;untyped&#160;and&#160;mutable.&#160;The&#160;elements&#160;of&#160;an&#160;array&#160;need&#160;not&#160;all&#160;be&#160;of&#160;the<br/>same&#160;class,&#160;and&#160;they&#160;can&#160;be&#160;changed&#160;at&#160;any&#160;time.&#160;Furthermore,&#160;arrays&#160;are&#160;dynamically<br/>resizeable;&#160;you&#160;can&#160;append&#160;elements&#160;to&#160;them&#160;and&#160;they&#160;grow&#160;as&#160;needed.&#160;If&#160;you&#160;assign&#160;a<br/>value&#160;to&#160;an&#160;element&#160;beyond&#160;the&#160;end&#160;of&#160;the&#160;array,&#160;the&#160;array&#160;is&#160;automatically&#160;extended<br/>with&#160;nil&#160;elements.&#160;(It&#160;is&#160;an&#160;error,&#160;however,&#160;to&#160;assign&#160;a&#160;value&#160;to&#160;an&#160;element&#160;before&#160;the<br/>beginning of an array.)<br/>An array literal is a comma-separated list of values, enclosed in square brackets:<br/>
[1, 2, 3] &#160; &#160; &#160; &#160; # An array that holds three Fixnum objects<br/>[-10...0, 0..10,] # An array of two ranges; trailing commas are allowed<br/>[[1,2],[3,4],[5]] # An array of nested arrays<br/>[x+y, x-y, x*y] &#160; # Array elements can be arbitrary expressions<br/>[] &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# The empty array has size 0<br/>
Ruby&#160;includes&#160;a&#160;special-case&#160;syntax&#160;for&#160;expressing&#160;array&#160;literals&#160;whose&#160;elements&#160;are<br/>short strings without spaces:<br/>
words = %w[this is a test] &#160;# Same as: ['this', 'is', 'a', 'test']<br/>open = %w| ( [ { &lt; | &#160; &#160; &#160; &#160;# Same as: ['(', '[', '{', '&lt;']<br/>white = %W(\s \t \r \n) &#160; &#160; # Same as: [&#34;\s&#34;, &#34;\t&#34;, &#34;\r&#34;, &#34;\n&#34;]<br/>
%w&#160;and&#160;%W&#160;introduce&#160;an&#160;array&#160;literal,&#160;much&#160;like&#160;%q&#160;and&#160;%Q&#160;introduce&#160;a&#160;String&#160;literal.&#160;In<br/>particular,&#160;the&#160;delimiter&#160;rules&#160;for&#160;%w&#160;and&#160;%W&#160;are&#160;the&#160;same&#160;as&#160;for&#160;%q&#160;and&#160;%Q.&#160;Within&#160;the<br/>delimiters,&#160;no&#160;quotation&#160;marks&#160;are&#160;required&#160;around&#160;the&#160;array&#160;element&#160;strings,&#160;and&#160;no<br/>
<b>64&#160;|&#160;Chapter 3:</b> <b>Datatypes and Objects</b><br/>
<hr/>
<a name=79></a>commas&#160;&#160;are&#160;&#160;required&#160;&#160;between&#160;&#160;the&#160;&#160;elements.&#160;&#160;Array&#160;&#160;elements&#160;&#160;are&#160;&#160;delimited&#160;&#160;by<br/>whitespace.<br/>You&#160;can&#160;also&#160;create&#160;arrays&#160;with&#160;the&#160;Array.new&#160;constructor,&#160;and&#160;this&#160;provides&#160;options<br/>for programmatically initializing the array elements:<br/>
empty = Array.new &#160; &#160; &#160; # []: returns a new empty array<br/>nils = Array.new(3) &#160; &#160; # [nil, nil, nil]: new array with 3 nil elements<br/>zeros = Array.new(4, 0) # [0, 0, 0, 0]: new array with 4 0 elements<br/>copy = Array.new(nils) &#160;# Make a new copy of an existing array<br/>count = Array.new(3) {|i| i+1} &#160;# [1,2,3]: 3 elements computed from index<br/>
To obtain the value of an array element, use a single integer within square brackets:<br/>
a = [0, 1, 4, 9, 16] &#160; # Array holds the squares of the indexes<br/>a[0] &#160; &#160; &#160; &#160;# First element is 0<br/>a[-1] &#160; &#160; &#160; # Last element is 16<br/>a[-2] &#160; &#160; &#160; # Second to last element is 9<br/>a[a.size-1] # Another way to query the last element<br/>a[-a.size] &#160;# Another way to query the first element<br/>a[8] &#160; &#160; &#160; &#160;# Querying beyond the end returns nil<br/>a[-8] &#160; &#160; &#160; # Querying before the start returns nil, too<br/>
All&#160;of&#160;the&#160;expressions&#160;above,&#160;except&#160;for&#160;the&#160;last,&#160;can&#160;also&#160;be&#160;used&#160;on&#160;the&#160;lefthand&#160;side<br/>of an assignment:<br/>
a[0] = &#34;zero&#34; &#160; # a is [&#34;zero&#34;, 1, 4, 9, 16]<br/>a[-1] = 1..16 &#160; # a is [&#34;zero&#34;, 1, 4, 9, 1..16]<br/>a[8] = 64 &#160; &#160; &#160; # a is [&#34;zero&#34;, 1, 4, 9, 1..16, nil, nil, nil, 64]<br/>a[-10] = 100 &#160; &#160;# Error: can't assign before the start of an array<br/>
Like&#160;strings,&#160;arrays&#160;can&#160;also&#160;be&#160;indexed&#160;with&#160;two&#160;integers&#160;that&#160;represent&#160;a&#160;starting&#160;index<br/>and&#160;a&#160;number&#160;of&#160;elements,&#160;or&#160;a&#160;Range&#160;object.&#160;In&#160;either&#160;case,&#160;the&#160;expression&#160;returns&#160;the<br/>specified subarray:<br/>
a = ('a'..'e').to_a &#160; # Range converted to ['a', 'b', 'c', 'd', 'e']<br/>a[0,0] &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# []: this subarray has zero elements<br/>a[1,1] &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# ['b']: a one-element array<br/>a[-2,2] &#160; &#160; &#160; &#160; &#160; &#160; &#160; # ['d','e']: the last two elements of the array<br/>a[0..2] &#160; &#160; &#160; &#160; &#160; &#160; &#160; # ['a', 'b', 'c']: the first three elements<br/>a[-2..-1] &#160; &#160; &#160; &#160; &#160; &#160; # ['d','e']: the last two elements of the array<br/>a[0...-1] &#160; &#160; &#160; &#160; &#160; &#160; # ['a', 'b', 'c', 'd']: all but the last element<br/>
When&#160;used&#160;on&#160;the&#160;lefthand&#160;side&#160;of&#160;an&#160;assignment,&#160;a&#160;subarray&#160;can&#160;be&#160;replaced&#160;by&#160;the<br/>elements&#160;of&#160;the&#160;array&#160;on&#160;the&#160;righthand&#160;side.&#160;This&#160;basic&#160;operation&#160;works&#160;for&#160;insertions<br/>and deletions as well:<br/>
a[0,2] = ['A', 'B'] &#160; &#160; &#160;# a becomes ['A', 'B', 'c', 'd', 'e']<br/>a[2...5]=['C', 'D', 'E'] # a becomes ['A', 'B', 'C', 'D', 'E']<br/>a[0,0] = [1,2,3] &#160; &#160; &#160; &#160; # Insert elements at the beginning of a<br/>a[0..2] = [] &#160; &#160; &#160; &#160; &#160; &#160; # Delete those elements<br/>a[-1,1] = ['Z'] &#160; &#160; &#160; &#160; &#160;# Replace last element with another<br/>a[-1,1] = 'Z' &#160; &#160; &#160; &#160; &#160; &#160;# For single elements, the array is optional<br/>a[-2,2] = nil &#160;# Delete last 2 elements in 1.8; replace with nil in 1.9<br/>
<b>3.3 &#160;Arrays&#160;|&#160;65</b><br/>
<hr/>
<a name=80></a>In&#160;addition&#160;to&#160;the&#160;square&#160;bracket&#160;operator&#160;for&#160;indexing&#160;an&#160;array,&#160;the&#160;Array&#160;class&#160;defines<br/>a number of other useful operators. Use&#160;+&#160;to concatenate two arrays:<br/>
a = [1, 2, 3] + [4, 5] &#160; &#160;# [1, 2, 3, 4, 5]<br/>a = a + [[6, 7, 8]] &#160; &#160; &#160; # [1, 2, 3, 4, 5, [6, 7, 8]]<br/>a = a + 9 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Error: righthand side must be an array<br/>
The&#160;+&#160;operator&#160;creates&#160;a&#160;new&#160;array&#160;that&#160;contains&#160;the&#160;elements&#160;of&#160;both&#160;its&#160;operands.&#160;Use<br/>&lt;&lt;&#160;to append an element to the end of an existing array, and use&#160;concat&#160;to append the<br/>elements of an array:<br/>
a = [] &#160; &#160; &#160; &#160; # Start with an empty array<br/>a &lt;&lt; 1 &#160; &#160; &#160; &#160; # a is [1]<br/>a &lt;&lt; 2 &lt;&lt; 3 &#160; &#160;# a is [1, 2, 3]<br/>a &lt;&lt; [4,5,6] &#160; # a is [1, 2, 3, [4, 5, 6]]<br/>a.concat [7,8] # a is [1, 2, 3, [4, 5, 6], 7, 8]<br/>
The&#160;-&#160;operator&#160;subtracts&#160;one&#160;array&#160;from&#160;another.&#160;It&#160;begins&#160;by&#160;making&#160;a&#160;copy&#160;of&#160;its<br/>lefthand&#160;array,&#160;and&#160;then&#160;removes&#160;any&#160;elements&#160;from&#160;that&#160;copy&#160;if&#160;they&#160;appear&#160;anywhere<br/>in the righthand array:<br/>
['a', 'b', 'c', 'b', 'a'] - ['b', 'c', 'd'] &#160; &#160;# ['a', 'a']<br/>
Like the&#160;String&#160;class,&#160;Array&#160;also uses the multiplication operator for repetition:<br/>
a = [0] * 8 &#160; &#160;# [0, 0, 0, 0, 0, 0, 0, 0]<br/>
The&#160;Array&#160;class&#160;borrows&#160;the&#160;Boolean&#160;operators&#160;|&#160;and&#160;&amp;&#160;and&#160;uses&#160;them&#160;for&#160;union&#160;and<br/>intersection.&#160;|&#160;concatenates&#160;its&#160;arguments&#160;and&#160;then&#160;removes&#160;all&#160;duplicate&#160;elements&#160;from<br/>the&#160;result.&#160;&amp;&#160;returns&#160;an&#160;array&#160;that&#160;holds&#160;elements&#160;that&#160;appear&#160;in&#160;both&#160;of&#160;the&#160;operand<br/>arrays. The returned array does not contain any duplicate elements:<br/>
a = [1, 1, 2, 2, 3, 3, 4]<br/>b = [5, 5, 4, 4, 3, 3, 2]<br/>a | b &#160; &#160;# [1, 2, 3, 4, 5]: duplicates are removed<br/>b | a &#160; &#160;# [5, 4, 3, 2, 1]: elements are the same, but order is different<br/>a &amp; b &#160; &#160;# [2, 3, 4]<br/>b &amp; a &#160; &#160;# [4, 3, 2]<br/>
Note&#160;that&#160;these&#160;operators&#160;are&#160;not&#160;transitive:&#160;a|b&#160;is not the same as&#160;b|a, for example. If<br/>you ignore the ordering of the elements, however, and consider the arrays to be unor-<br/>dered&#160;sets,&#160;then&#160;these&#160;operators&#160;make&#160;more&#160;sense.&#160;Note&#160;also&#160;that&#160;the&#160;algorithm&#160;by&#160;which<br/>union&#160;and&#160;intersection&#160;are&#160;performed&#160;is&#160;not&#160;specified,&#160;and&#160;there&#160;are&#160;no&#160;guarantees&#160;about<br/>the order of the elements in the returned arrays.<br/>The&#160;Array&#160;class&#160;defines&#160;quite&#160;a&#160;few&#160;useful&#160;methods.&#160;The&#160;only&#160;one&#160;we’ll&#160;discuss&#160;here&#160;is<br/>the&#160;each&#160;iterator, used for looping through the elements of an array:<br/>
a = ('A'..'Z').to_a &#160; &#160;# Begin with an array of letters<br/>a.each {|x| print x } &#160;# Print the alphabet, one letter at a time<br/>
Other&#160;Array&#160;methods&#160;you&#160;may&#160;want&#160;to&#160;look&#160;up&#160;include&#160;clear,&#160;compact!,&#160;delete_if,<br/>each_index,&#160;&#160;empty?,&#160;&#160;fill,&#160;&#160;flatten!,&#160;&#160;include?,&#160;&#160;index,&#160;&#160;join,&#160;&#160;pop,&#160;&#160;push,&#160;&#160;reverse,<br/>reverse_each,&#160;rindex,&#160;shift,&#160;sort,&#160;sort!,&#160;uniq!, and&#160;unshift.<br/>
<b>66&#160;|&#160;Chapter 3:</b> <b>Datatypes and Objects</b><br/>
<hr/>
<a name=81></a>We’ll&#160;see&#160;arrays&#160;again&#160;when&#160;we&#160;consider&#160;parallel&#160;assignment&#160;in&#160;<a href="Rubys.html#111">§4.5.5&#160;</a>and&#160;method<br/><a href="Rubys.html#189">invocation in Chapter 6. And we’ll explore the&#160;</a>Array<a href="Rubys.html#348">&#160;API in detail in §9.5.2.</a><br/>
<b>3.4 &#160;Hashes<br/></b>A&#160;<i>hash</i>&#160;is&#160;a&#160;data&#160;structure&#160;that&#160;maintains&#160;a&#160;set&#160;of&#160;objects&#160;known&#160;as&#160;<i>keys</i>,&#160;and&#160;associates<br/>a&#160;value&#160;with&#160;each&#160;key.&#160;Hashes&#160;are&#160;also&#160;known&#160;as&#160;<i>maps</i>&#160;because&#160;they&#160;map&#160;keys&#160;to&#160;values.<br/>They&#160;are&#160;sometimes&#160;called&#160;<i>associative&#160;arrays</i>&#160;because&#160;they&#160;associate&#160;values&#160;with&#160;each<br/>of&#160;the&#160;keys,&#160;and&#160;can&#160;be&#160;thought&#160;of&#160;as&#160;arrays&#160;in&#160;which&#160;the&#160;array&#160;index&#160;can&#160;be&#160;any&#160;object<br/>instead of an integer. An example makes this clearer:<br/>
# This hash will map the names of digits to the digits themselves<br/>numbers = Hash.new &#160; &#160; # Create a new, empty, hash object<br/>numbers[&#34;one&#34;] = 1 &#160; &#160; # Map the String &#34;one&#34; to the Fixnum 1<br/>numbers[&#34;two&#34;] = 2 &#160; &#160; # Note that we are using array notation here<br/>numbers[&#34;three&#34;] = 3<br/>
sum = numbers[&#34;one&#34;] + numbers[&#34;two&#34;] &#160;# Retrieve values like this<br/>
This&#160;introduction&#160;to&#160;hashes&#160;documents&#160;Ruby’s&#160;hash&#160;literal&#160;syntax&#160;and&#160;explains&#160;the<br/>requirements&#160;for&#160;an&#160;object&#160;to&#160;be&#160;used&#160;as&#160;a&#160;hash&#160;key.&#160;More&#160;information&#160;on&#160;the&#160;API<br/>defined by the&#160;Hash<a href="Rubys.html#355">&#160;class is provided in §9.5.3.</a><br/>
<b>3.4.1 &#160;Hash Literals<br/></b>A hash literal&#160;is&#160;written&#160;as&#160;a&#160;comma-separated&#160;list&#160;of&#160;key/value&#160;pairs,&#160;enclosed&#160;within<br/>curly&#160;&#160;braces.&#160;&#160;Keys&#160;&#160;and&#160;&#160;values&#160;&#160;are&#160;&#160;separated&#160;&#160;with&#160;&#160;a&#160;&#160;two-character&#160;&#160;“arrow”:&#160;&#160;=&gt;.&#160;&#160;The<br/>Hash&#160;object created earlier could also be created with the following literal:<br/>
numbers = { &#34;one&#34; =&gt; 1, &#34;two&#34; =&gt; 2, &#34;three&#34; =&gt; 3 }<br/>
In general,&#160;Symbol&#160;objects work more efficiently as hash keys than strings do:<br/>
numbers = { :one =&gt; 1, :two =&gt; 2, :three =&gt; 3 }<br/>
Symbols&#160;are&#160;immutable&#160;interned&#160;strings,&#160;written&#160;as&#160;colon-prefixed&#160;identifiers;&#160;they&#160;are<br/><a href="Rubys.html#84">explained in more detail in §3.6 later in this chapter.<br/></a>Ruby&#160;1.8&#160;allows&#160;commas&#160;in&#160;place&#160;of&#160;arrows,&#160;but&#160;this&#160;deprecated&#160;syntax&#160;is&#160;no&#160;longer<br/>supported in Ruby 1.9:<br/>
numbers = { :one, 1, :two, 2, :three, 3 } # Same, but harder to read<br/>
Both&#160;Ruby&#160;1.8&#160;and&#160;Ruby&#160;1.9&#160;allow&#160;a&#160;single&#160;trailing&#160;comma&#160;at&#160;the&#160;end&#160;of&#160;the&#160;key/value<br/>list:<br/>
numbers = { :one =&gt; 1, :two =&gt; 2, } # Extra comma ignored<br/>
Ruby&#160;1.9&#160;supports&#160;a&#160;very&#160;useful&#160;and&#160;succinct&#160;hash&#160;literal&#160;syntax&#160;when&#160;the&#160;keys&#160;are<br/>symbols.&#160;In&#160;this&#160;case,&#160;the&#160;colon&#160;moves&#160;to&#160;the&#160;end&#160;of&#160;the&#160;hash&#160;key&#160;and&#160;replaces&#160;the&#160;arrow:*<br/>
numbers = { one: 1, two: 2, three: 3 }<br/>
<b>3.4 &#160;Hashes&#160;|&#160;67</b><br/>
<hr/>
<a name=82></a>Note that there may not be any space between the hash key identifier and the colon.<br/>
<b>3.4.2 &#160;Hash Codes, Equality, and Mutable Keys<br/></b>Ruby’s&#160;hashes&#160;are&#160;implemented,&#160;unsurprisingly,&#160;with&#160;a&#160;data&#160;structure&#160;known&#160;as&#160;a&#160;<i>hash<br/>table</i>.&#160;Objects&#160;used&#160;as&#160;keys&#160;in&#160;a&#160;hash&#160;must&#160;have&#160;a&#160;method&#160;named&#160;hash&#160;that&#160;returns&#160;a<br/>Fixnum&#160;<i>hashcode</i>&#160;for&#160;the&#160;key.&#160;If&#160;two&#160;keys&#160;are&#160;equal,&#160;they&#160;must&#160;have&#160;the&#160;same&#160;hashcode.<br/>Unequal&#160;keys&#160;may&#160;also&#160;have&#160;the&#160;same&#160;hashcode,&#160;but&#160;hash&#160;tables&#160;are&#160;most&#160;efficient&#160;when<br/>duplicate hashcodes are rare.<br/>The&#160;Hash&#160;class&#160;compares&#160;keys&#160;for&#160;equality&#160;with&#160;the&#160;eql?&#160;method.&#160;For&#160;most&#160;Ruby&#160;classes,<br/>eql?&#160;works&#160;like&#160;the&#160;==&#160;operator&#160;(see&#160;<a href="Rubys.html#90">§3.8.5&#160;</a>for&#160;details).&#160;If&#160;you&#160;define&#160;a&#160;new&#160;class&#160;that<br/>overrides&#160;the&#160;eql?&#160;method,&#160;you&#160;must&#160;also&#160;override&#160;the&#160;hash&#160;method,&#160;or&#160;else&#160;instances<br/>of&#160;your&#160;class&#160;will&#160;not&#160;work&#160;as&#160;keys&#160;in&#160;a&#160;hash.&#160;(We’ll&#160;see&#160;examples&#160;of&#160;writing&#160;a&#160;hash<br/><a href="Rubys.html#227">method in Chapter 7.)<br/></a>If&#160;you&#160;define&#160;a&#160;class&#160;and&#160;do&#160;not&#160;override&#160;eql?,&#160;then&#160;instances&#160;of&#160;that&#160;class&#160;are&#160;compared<br/>for&#160;object&#160;identity&#160;when&#160;used&#160;as&#160;hash&#160;keys.&#160;Two&#160;distinct&#160;instances&#160;of&#160;your&#160;class&#160;are<br/>distinct&#160;hash&#160;keys&#160;even&#160;if&#160;they&#160;represent&#160;the&#160;same&#160;content.&#160;In&#160;this&#160;case,&#160;the&#160;default<br/>hash&#160;method is appropriate: it returns the unique&#160;object_id&#160;of the object.<br/>
Note&#160;that&#160;mutable&#160;objects&#160;are&#160;problematic&#160;as&#160;hash&#160;keys.&#160;Changing&#160;the&#160;content&#160;of&#160;an<br/>object&#160;typically&#160;changes&#160;its&#160;hashcode.&#160;If&#160;you&#160;use&#160;an&#160;object&#160;as&#160;a&#160;key&#160;and&#160;then&#160;alter&#160;that<br/>object,&#160;&#160;the&#160;&#160;internal&#160;&#160;hash&#160;&#160;table&#160;&#160;becomes&#160;&#160;corrupted,&#160;&#160;and&#160;&#160;the&#160;&#160;hash&#160;&#160;no&#160;&#160;longer&#160;&#160;works<br/>correctly.<br/>Because&#160;strings&#160;are&#160;mutable&#160;but&#160;commonly&#160;used&#160;hash&#160;keys,&#160;Ruby&#160;treats&#160;them&#160;as&#160;a&#160;special<br/>case&#160;and&#160;makes&#160;private&#160;copies&#160;of&#160;all&#160;strings&#160;used&#160;as&#160;keys.&#160;This&#160;is&#160;the&#160;only&#160;special&#160;case,<br/>however;&#160;you&#160;must&#160;be&#160;very&#160;cautious&#160;when&#160;using&#160;any&#160;other&#160;mutable&#160;object&#160;as&#160;a&#160;hash<br/>key.&#160;Consider&#160;making&#160;a&#160;private&#160;copy&#160;or&#160;calling&#160;the&#160;freeze&#160;method.&#160;If&#160;you&#160;must&#160;use<br/>mutable hash keys, call the&#160;rehash&#160;method of the&#160;Hash&#160;every time you mutate a key.<br/>
<b>3.5 &#160;Ranges<br/></b>A&#160;Range&#160;object&#160;represents&#160;the&#160;values&#160;between&#160;a&#160;start&#160;value&#160;and&#160;an&#160;end&#160;value.&#160;Range<br/>literals&#160;are&#160;written&#160;by&#160;placing&#160;two&#160;or&#160;three&#160;dots&#160;between&#160;the&#160;start&#160;and&#160;end&#160;value.&#160;If&#160;two<br/>dots&#160;are&#160;used,&#160;then&#160;the&#160;range&#160;is&#160;<i>inclusive</i>&#160;and&#160;the&#160;end&#160;value&#160;is&#160;part&#160;of&#160;the&#160;range.&#160;If&#160;three<br/>dots are used, then the range is&#160;<i>exclusive</i>&#160;and the end value is not part of the range:<br/>
1..10 &#160; &#160; &#160;# The integers 1 through 10, including 10<br/>1.0...10.0 # The numbers between 1.0 and 10.0, excluding 10.0 itself<br/>
Test&#160;whether&#160;a&#160;value&#160;is&#160;included&#160;in&#160;a&#160;range&#160;with&#160;the&#160;include?&#160;method&#160;(but&#160;see&#160;below<br/>for a discussion of alternatives):<br/>
*&#160;The result is a syntax much like that used by JavaScript objects.<br/>
<b>68&#160;|&#160;Chapter 3:</b> <b>Datatypes and Objects</b><br/>
<hr/>
<a name=83></a>cold_war = 1945..1989<br/>cold_war.include? birthdate.year<br/>
Implicit&#160;in&#160;the&#160;definition&#160;of&#160;a&#160;range&#160;is&#160;the&#160;notion&#160;of&#160;ordering.&#160;If&#160;a&#160;range&#160;is&#160;the&#160;values<br/>between&#160;two&#160;endpoints,&#160;there&#160;obviously&#160;must&#160;be&#160;some&#160;way&#160;to&#160;compare&#160;values&#160;to&#160;those<br/>endpoints.&#160;In&#160;Ruby,&#160;this&#160;is&#160;done&#160;with&#160;the&#160;comparison&#160;operator&#160;&lt;=&gt;,&#160;which&#160;compares<br/>its&#160;two&#160;operands&#160;and&#160;evaluates&#160;to&#160;–1,&#160;0,&#160;or&#160;1,&#160;depending&#160;on&#160;their&#160;relative&#160;order&#160;(or<br/>equality).&#160;Classes&#160;such&#160;as&#160;numbers&#160;and&#160;strings&#160;that&#160;have&#160;an&#160;ordering&#160;define&#160;the&#160;&lt;=&gt;<br/>operator.&#160;A&#160;value&#160;can&#160;only&#160;be&#160;used&#160;as&#160;a&#160;range&#160;endpoint&#160;if&#160;it&#160;responds&#160;to&#160;this&#160;operator.<br/>The&#160;endpoints&#160;of&#160;a&#160;range&#160;and&#160;the&#160;values&#160;“in”&#160;the&#160;range&#160;are&#160;typically&#160;all&#160;of&#160;the&#160;same&#160;class.<br/>Technically,&#160;however,&#160;any&#160;value&#160;that&#160;is&#160;compatible&#160;with&#160;the&#160;&lt;=&gt;&#160;operators&#160;of&#160;the&#160;range<br/>endpoints can be considered a member of the range.<br/>The&#160;primary&#160;purpose&#160;for&#160;ranges&#160;is&#160;comparison:&#160;to&#160;be&#160;able&#160;to&#160;determine&#160;whether&#160;a&#160;value<br/>is&#160;in&#160;or&#160;out&#160;of&#160;the&#160;range.&#160;An&#160;important&#160;secondary&#160;purpose&#160;is&#160;iteration:&#160;if&#160;the&#160;class&#160;of&#160;the<br/>endpoints of a range defines&#160;a&#160;succ&#160;method (for successor), then there is a discrete set<br/>of range members, and they can be iterated with&#160;each,&#160;step, and&#160;Enumerable&#160;methods.<br/>Consider the range&#160;'a'..'c', for example:<br/>
r = 'a'..'c'<br/>r.each {|l| print &#34;[#{l}]&#34;} &#160; &#160; # Prints &#34;[a][b][c]&#34;<br/>r.step(2) { |l| print &#34;[#{l}]&#34;} # Prints &#34;[a][c]&#34;<br/>r.to_a &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; ['a','b','c']: Enumerable defines to_a<br/>
The&#160;reason&#160;this&#160;works&#160;is&#160;that&#160;the&#160;String&#160;class&#160;defines&#160;a&#160;succ&#160;method&#160;and&#160;'a'.succ&#160;is<br/>'b'&#160;and&#160;'b'.succ&#160;is&#160;'c'.&#160;Ranges&#160;that&#160;can&#160;be&#160;iterated&#160;like&#160;this&#160;are&#160;<i>discrete</i>&#160;ranges.&#160;Ranges<br/>whose&#160;endpoints&#160;do&#160;not&#160;define&#160;a&#160;succ&#160;method&#160;cannot&#160;be&#160;iterated,&#160;and&#160;so&#160;they&#160;can&#160;be<br/>called&#160;<i>continuous</i>.&#160;Note&#160;that&#160;ranges&#160;with&#160;integer&#160;endpoints&#160;are&#160;discrete,&#160;but&#160;floating-<br/>point numbers as endpoints are continuous.<br/>Ranges&#160;with&#160;integer&#160;endpoints&#160;are&#160;the&#160;most&#160;commonly&#160;used&#160;in&#160;typical&#160;Ruby&#160;programs.<br/>
&#160;<br/>
Because&#160;they&#160;are&#160;discrete,&#160;integer&#160;ranges&#160;can&#160;be&#160;used&#160;to&#160;index&#160;strings&#160;and&#160;arrays.&#160;They<br/>are also a convenient way to represent an enumerable collection of ascending values.<br/>Notice&#160;that&#160;the&#160;code&#160;assigns&#160;a&#160;range&#160;literal&#160;to&#160;a&#160;variable,&#160;and&#160;then&#160;invokes&#160;methods&#160;on<br/>the&#160;range&#160;through&#160;the&#160;variable.&#160;If&#160;you&#160;want&#160;to&#160;invoke&#160;a&#160;method&#160;directly&#160;on&#160;a&#160;range<br/>literal,&#160;you&#160;must&#160;parenthesize&#160;the&#160;literal,&#160;or&#160;the&#160;method&#160;invocation&#160;is&#160;actually&#160;on&#160;the<br/>endpoint of the range rather than on the&#160;Range&#160;object itself:<br/>
1..3.to_a &#160; &#160;# Tries to call to_a on the number 3<br/>(1..3).to_a &#160;# =&gt; [1,2,3]<br/>
<b>3.5.1 &#160;Testing Membership in a Range<br/></b>The&#160;Range&#160;class&#160;defines&#160;methods&#160;for&#160;determining&#160;whether&#160;an&#160;arbitrary&#160;value&#160;is&#160;a&#160;member<br/>of&#160;(i.e.,&#160;is&#160;included&#160;in)&#160;a&#160;range.&#160;Before&#160;going&#160;into&#160;detail&#160;on&#160;these&#160;methods,&#160;it&#160;is&#160;necessary<br/>to&#160;explain&#160;that&#160;range&#160;membership&#160;can&#160;be&#160;defined&#160;in&#160;two&#160;different&#160;ways&#160;that&#160;are&#160;related<br/>to&#160;the&#160;difference&#160;between&#160;continuous&#160;and&#160;discrete&#160;ranges.&#160;A&#160;value&#160;x&#160;is&#160;a&#160;member&#160;of&#160;the<br/>range&#160;begin..end&#160;by the first definition if:<br/>
<b>3.5 &#160;Ranges&#160;|&#160;69</b><br/>
<hr/>
<a name=84></a>begin &lt;= x &lt;= end<br/>
And&#160;x&#160;is a member of the range&#160;begin...end&#160;(with three dots) if:<br/>
begin &lt;= x &lt; end<br/>
All&#160;range&#160;endpoint&#160;values&#160;must&#160;implement&#160;the&#160;&lt;=&gt;&#160;operator,&#160;so&#160;this&#160;definition&#160;of&#160;mem-<br/>bership&#160;works&#160;for&#160;any&#160;Range&#160;object&#160;and&#160;does&#160;not&#160;require&#160;the&#160;endpoints&#160;to&#160;implement<br/>the&#160;succ&#160;method. We’ll call this the continuous membership test.<br/>The&#160;second&#160;definition&#160;of&#160;membership—discrete&#160;membership—does&#160;depend&#160;on&#160;succ.<br/>It&#160;treats&#160;a&#160;Range&#160;begin..end&#160;as&#160;a&#160;set&#160;that&#160;includes&#160;begin,&#160;begin.succ,&#160;begin.succ.succ,<br/>and&#160;so&#160;on.&#160;By&#160;this&#160;definition,&#160;range&#160;membership&#160;is&#160;set&#160;membership,&#160;and&#160;a&#160;value&#160;x&#160;is<br/>included&#160;in&#160;a&#160;range&#160;only&#160;if&#160;it&#160;is&#160;a&#160;value&#160;returned&#160;by&#160;one&#160;of&#160;the&#160;succ&#160;invocations.&#160;Note<br/>that&#160;testing&#160;for&#160;discrete&#160;membership&#160;is&#160;potentially&#160;a&#160;much&#160;more&#160;expensive&#160;operation<br/>than testing for continuous membership.<br/>With&#160;that&#160;as&#160;background,&#160;we&#160;can&#160;describe&#160;the&#160;Range&#160;methods&#160;for&#160;testing&#160;membership.<br/>Ruby&#160;1.8&#160;supports&#160;two&#160;methods,&#160;include?&#160;and&#160;member?. They are&#160;synonyms, and both<br/>use the continuous membership test:<br/>
r = 0...100 &#160; &#160; &#160;# The range of integers 0 through 99<br/>r.member? 50 &#160; &#160; # =&gt; true: 50 is a member of the range<br/>r.include? 100 &#160; # =&gt; false: 100 is excluded from the range<br/>r.include? 99.9 &#160;# =&gt; true: 99.9 is less than 100<br/>
The&#160;situation&#160;is&#160;different&#160;in&#160;Ruby&#160;1.9.&#160;That&#160;version&#160;of&#160;the&#160;language&#160;introduces&#160;a&#160;new&#160;<br/>method,&#160;cover?,&#160;which&#160;works&#160;like&#160;include?&#160;and&#160;member?&#160;do&#160;in&#160;Ruby&#160;1.8:&#160;it&#160;always&#160;uses<br/>the&#160;continuous&#160;membership&#160;test.&#160;include?&#160;and&#160;member?&#160;are&#160;still&#160;synonyms&#160;in&#160;Ruby&#160;1.9.<br/>If&#160;the&#160;endpoints&#160;of&#160;the&#160;range&#160;are&#160;numbers,&#160;these&#160;methods&#160;use&#160;the&#160;continuous&#160;mem-<br/>bership&#160;test,&#160;just&#160;as&#160;they&#160;did&#160;in&#160;Ruby&#160;1.8.&#160;If&#160;the&#160;endpoints&#160;are&#160;not&#160;numeric,&#160;however,<br/>they&#160;instead&#160;use&#160;the&#160;discrete&#160;membership&#160;test.&#160;We&#160;can&#160;illustrate&#160;these&#160;changes&#160;with&#160;a<br/>discrete&#160;range&#160;of&#160;strings&#160;(you&#160;may&#160;want&#160;to&#160;use&#160;<i>ri</i>&#160;to&#160;understand&#160;how&#160;String.succ&#160;works):<br/>
triples = &#34;AAA&#34;..&#34;ZZZ&#34;<br/>triples.include? &#34;ABC&#34; &#160; &#160; &#160; &#160;# true; fast in 1.8 and slow in 1.9<br/>triples.include? &#34;ABCD&#34; &#160; &#160; &#160; # true in 1.8, false in 1.9<br/>triples.cover? &#160; &#34;ABCD&#34; &#160; &#160; &#160; # true and fast in 1.9<br/>triples.to_a.include? &#34;ABCD&#34; &#160;# false and slow in 1.8 and 1.9<br/>
In practice, most ranges have numeric endpoints, and the&#160;Range&#160;API changes between<br/>Ruby 1.8 and 1.9 have little impact.<br/>
<b>3.6 &#160;Symbols<br/></b>A&#160;typical&#160;implementation&#160;of&#160;a&#160;Ruby&#160;interpreter&#160;maintains&#160;a&#160;symbol&#160;table&#160;in&#160;which&#160;it<br/>stores&#160;the&#160;names&#160;of&#160;all&#160;the&#160;classes,&#160;methods,&#160;and&#160;variables&#160;it&#160;knows&#160;about.&#160;This&#160;allows<br/>such&#160;an&#160;interpreter&#160;to&#160;avoid&#160;most&#160;string&#160;comparisons:&#160;it&#160;refers&#160;to&#160;method&#160;names&#160;(for<br/>example)&#160;by&#160;their&#160;position&#160;in&#160;this&#160;symbol&#160;table.&#160;This&#160;turns&#160;a&#160;relatively&#160;expensive&#160;string<br/>operation into a relatively cheap integer operation.<br/>
<b>70&#160;|&#160;Chapter 3:</b> <b>Datatypes and Objects</b><br/>
<hr/>
<a name=85></a>These&#160;symbols&#160;are&#160;not&#160;purely&#160;internal&#160;to&#160;the&#160;interpreter;&#160;they&#160;can&#160;also&#160;be&#160;used&#160;by&#160;Ruby<br/>programs.&#160;A&#160;Symbol&#160;object&#160;refers&#160;to&#160;a&#160;symbol.&#160;A&#160;symbol&#160;literal&#160;is&#160;written&#160;by&#160;prefixing<br/>an identifier or string with a colon:<br/>
:symbol &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # A Symbol literal<br/>:&#34;symbol&#34; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # The same literal<br/>:'another long symbol' &#160; &#160;# Quotes are useful for symbols with spaces<br/>s = &#34;string&#34;<br/>sym = :&#34;#{s}&#34; &#160; &#160; &#160; &#160; &#160; &#160; # The Symbol :string<br/>
Symbols&#160;also&#160;have&#160;a&#160;%s&#160;literal&#160;syntax&#160;that&#160;allows&#160;arbitrary&#160;delimiters&#160;in&#160;the&#160;same&#160;way<br/>that&#160;%q&#160;and&#160;%Q&#160;can be used for string literals:<br/>
%s[&#34;] &#160; &#160; # Same as :'&#34;'<br/>
Symbols&#160;&#160;are&#160;&#160;often&#160;&#160;used&#160;&#160;to&#160;&#160;refer&#160;&#160;to&#160;&#160;method&#160;&#160;names&#160;&#160;in&#160;&#160;reflective&#160;&#160;code.&#160;&#160;For&#160;&#160;example,<br/>suppose we want to know if some object has an&#160;each&#160;method:<br/>
o.respond_to? :each<br/>
Here’s&#160;another&#160;example.&#160;It&#160;tests&#160;whether&#160;a&#160;given&#160;object&#160;responds&#160;to&#160;a&#160;specified&#160;method,<br/>and, if so, invokes that method:<br/>
name = :size<br/>if o.respond_to? name<br/>&#160; o.send(name)<br/>end<br/>
You&#160;can&#160;convert&#160;a&#160;String&#160;to&#160;a&#160;Symbol&#160;using&#160;the&#160;intern&#160;or&#160;to_sym&#160;methods.&#160;And&#160;you&#160;can<br/>convert a&#160;Symbol&#160;back into a&#160;String&#160;with the&#160;to_s&#160;method or its alias&#160;id2name:<br/>
str = &#34;string&#34; &#160; &#160; # Begin with a string<br/>sym = str.intern &#160; # Convert to a symbol<br/>sym = str.to_sym &#160; # Another way to do the same thing<br/>str = sym.to_s &#160; &#160; # Convert back to a string<br/>str = sym.id2name &#160;# Another way to do it<br/>
Two&#160;strings&#160;may&#160;hold&#160;the&#160;same&#160;content&#160;and&#160;yet&#160;be&#160;completely&#160;distinct&#160;objects.&#160;This&#160;is<br/>never&#160;the&#160;case&#160;with&#160;symbols.&#160;Two&#160;strings&#160;with&#160;the&#160;same&#160;content&#160;will&#160;both&#160;convert&#160;to<br/>exactly&#160;the&#160;same&#160;Symbol&#160;object.&#160;Two&#160;distinct&#160;Symbol&#160;objects&#160;will&#160;always&#160;have&#160;different<br/>content.<br/>Whenever&#160;you&#160;write&#160;code&#160;that&#160;uses&#160;strings&#160;not&#160;for&#160;their&#160;textual&#160;content&#160;but&#160;as&#160;a&#160;kind<br/>of&#160;unique&#160;identifier,&#160;consider&#160;using&#160;symbols&#160;instead.&#160;Rather&#160;than&#160;writing&#160;a&#160;method&#160;that<br/>expects&#160;an&#160;argument&#160;to&#160;be&#160;either&#160;the&#160;string&#160;“AM”&#160;or&#160;“PM”,&#160;for&#160;example,&#160;you&#160;could<br/>write&#160;it&#160;to&#160;expect&#160;the&#160;symbol&#160;:AM&#160;or&#160;the&#160;symbol&#160;:PM.&#160;Comparing&#160;two&#160;Symbol&#160;objects for<br/>equality&#160;is&#160;much&#160;faster&#160;than&#160;comparing&#160;two&#160;strings&#160;for&#160;equality.&#160;For&#160;this&#160;reason,&#160;symbols<br/>are generally preferred to strings as hash keys.<br/>In&#160;Ruby&#160;1.9,&#160;the&#160;Symbol&#160;class&#160;defines&#160;a&#160;number&#160;of&#160;String&#160;methods,&#160;such&#160;as&#160;length,<br/>size,&#160;the&#160;comparison&#160;operators,&#160;and&#160;even&#160;the&#160;[]&#160;and&#160;=~&#160;operators.&#160;This&#160;makes&#160;symbols<br/>somewhat&#160;interchangeable&#160;with&#160;strings&#160;and&#160;allows&#160;their&#160;use&#160;as&#160;a&#160;kind&#160;of&#160;immutable<br/>(and not garbage-collected) string.<br/>
<b>3.6 &#160;Symbols&#160;|&#160;71</b><br/>
<hr/>
<a name=86></a><b>3.7 &#160;True, False, and Nil<br/></b>We&#160;saw&#160;in&#160;<a href="Rubys.html#44">§2.1.5 that</a>&#160;true,&#160;false,&#160;and&#160;nil&#160;are&#160;keywords&#160;in&#160;Ruby.&#160;true&#160;and&#160;false&#160;are<br/>the&#160;two&#160;Boolean&#160;values,&#160;and&#160;they&#160;represent&#160;truth&#160;and&#160;falsehood,&#160;yes&#160;and&#160;no,&#160;on&#160;and<br/>off.&#160;nil&#160;is a special value reserved to indicate the absence of value.<br/>Each&#160;of&#160;these&#160;keywords&#160;evaluates&#160;to&#160;a&#160;special&#160;object.&#160;true&#160;evaluates&#160;to&#160;an&#160;object&#160;that&#160;is<br/>a&#160;singleton&#160;instance&#160;of&#160;TrueClass.&#160;Likewise,&#160;false&#160;and&#160;nil&#160;are&#160;singleton&#160;instances&#160;of<br/>FalseClass&#160;and&#160;NilClass.&#160;Note&#160;that&#160;there&#160;is&#160;no&#160;Boolean&#160;class&#160;in&#160;Ruby.&#160;TrueClass&#160;and<br/>FalseClass&#160;both have&#160;Object&#160;as their superclass.<br/>
If&#160;you&#160;want&#160;to&#160;check&#160;whether&#160;a&#160;value&#160;is&#160;nil,&#160;you&#160;can&#160;simply&#160;compare&#160;it&#160;to&#160;nil,&#160;or&#160;use<br/>the method&#160;nil?:<br/>
o == nil &#160; # Is o nil?<br/>o.nil? &#160; &#160; # Another way to test<br/>
Note that&#160;true,&#160;false, and&#160;nil&#160;refer&#160;to&#160;objects,&#160;not&#160;numbers.&#160;false&#160;and&#160;nil&#160;are&#160;not&#160;the<br/>same&#160;thing&#160;as&#160;0,&#160;and&#160;true&#160;is&#160;not&#160;the&#160;same&#160;thing&#160;as&#160;1.&#160;When&#160;Ruby&#160;requires&#160;a&#160;Boolean<br/>value,&#160;nil&#160;behaves like&#160;false,&#160;and&#160;any&#160;value&#160;other&#160;than&#160;nil&#160;or&#160;false&#160;behaves like&#160;true.<br/>
<b>3.8 &#160;Objects<br/></b>Ruby&#160;is&#160;a&#160;very&#160;pure&#160;object-oriented&#160;language:&#160;all&#160;values&#160;are&#160;objects,&#160;and&#160;there&#160;is&#160;no<br/>distinction&#160;between&#160;primitive&#160;types&#160;and&#160;object&#160;types&#160;as&#160;there&#160;are&#160;in&#160;many&#160;other&#160;lan-<br/>guages.&#160;In&#160;Ruby,&#160;all&#160;objects&#160;inherit&#160;from&#160;a&#160;class&#160;named&#160;Object&#160;and&#160;share&#160;the&#160;methods<br/>defined&#160;by&#160;that&#160;class.&#160;This&#160;section&#160;explains&#160;the&#160;common&#160;features&#160;of&#160;all&#160;objects&#160;in&#160;Ruby.<br/>It is dense in parts, but it’s required reading; the information here is fundamental.<br/>
<b>3.8.1 &#160;Object References<br/></b>When&#160;we&#160;work&#160;with&#160;objects&#160;in&#160;Ruby,&#160;we&#160;are&#160;really&#160;working&#160;with&#160;object&#160;<i>references</i>. It<br/>is not the object itself we manipulate but a reference to it.*&#160;&#160;When we assign a value to<br/>a&#160;variable,&#160;we&#160;are&#160;not&#160;copying&#160;an&#160;object&#160;“into”&#160;that&#160;variable;&#160;we&#160;are&#160;merely&#160;storing&#160;a<br/>reference to an object into that variable. Some code makes this clear:<br/>
s = &#34;Ruby&#34; # Create a String object. Store a reference to it in s.<br/>t = s &#160; &#160; &#160;# Copy the reference to t. s and t both refer to the same object.<br/>t[-1] = &#34;&#34; # Modify the object through the reference in t.<br/>print s &#160; &#160;# Access the modified object through s. Prints &#34;Rub&#34;.&#160;<br/>t = &#34;Java&#34; # t now refers to a different object.<br/>print s,t &#160;# Prints &#34;RubJava&#34;.<br/>
*&#160;If&#160;you&#160;are&#160;familiar&#160;with&#160;C&#160;or&#160;C++,&#160;you&#160;can&#160;think&#160;of&#160;a&#160;reference&#160;as&#160;a&#160;pointer:&#160;the&#160;address&#160;of&#160;the&#160;object&#160;in<br/>
memory.&#160;&#160;Ruby&#160;&#160;does&#160;&#160;not&#160;&#160;use&#160;&#160;pointers,&#160;&#160;however.&#160;&#160;References&#160;&#160;in&#160;&#160;Ruby&#160;&#160;are&#160;&#160;opaque&#160;&#160;and&#160;&#160;internal&#160;&#160;to&#160;&#160;the<br/>implementation.&#160;There&#160;is&#160;no&#160;way&#160;to&#160;take&#160;the&#160;address&#160;of&#160;a&#160;value,&#160;dereference&#160;a&#160;value,&#160;or&#160;do&#160;pointer&#160;arithmetic.<br/>
<b>72&#160;|&#160;Chapter 3:</b> <b>Datatypes and Objects</b><br/>
<hr/>
<a name=87></a>When&#160;you&#160;pass&#160;an&#160;object&#160;to&#160;a&#160;method&#160;in&#160;Ruby,&#160;it&#160;is&#160;an&#160;object&#160;reference&#160;that&#160;is&#160;passed<br/>to&#160;the&#160;method.&#160;It&#160;is&#160;not&#160;the&#160;object&#160;itself,&#160;and&#160;it&#160;is&#160;not&#160;a&#160;reference&#160;to&#160;the&#160;reference&#160;to&#160;the<br/>object.&#160;Another&#160;way&#160;to&#160;say&#160;this&#160;is&#160;that&#160;method&#160;arguments&#160;are&#160;passed&#160;<i>by&#160;value</i>&#160;rather<br/>than&#160;<i>by reference</i>, but that the values passed are object references.<br/>Because&#160;object&#160;references&#160;are&#160;passed&#160;to&#160;methods,&#160;methods&#160;can&#160;use&#160;those&#160;references&#160;to<br/>modify&#160;the&#160;underlying&#160;object.&#160;These&#160;modifications&#160;are&#160;then&#160;visible&#160;when&#160;the&#160;method<br/>returns.<br/>
<b>3.8.1.1 &#160;Immediate values<br/></b>We’ve&#160;said&#160;that&#160;all&#160;values&#160;in&#160;Ruby&#160;are&#160;objects&#160;and&#160;all&#160;objects&#160;are&#160;manipulated&#160;by&#160;ref-<br/>erence.&#160;&#160;In&#160;&#160;the&#160;&#160;reference&#160;&#160;implementation,&#160;&#160;however,&#160;&#160;Fixnum&#160;&#160;and&#160;&#160;Symbol&#160;&#160;objects&#160;&#160;are<br/>actually&#160;&#160;“immediate&#160;&#160;values”&#160;&#160;rather&#160;&#160;than&#160;&#160;references.&#160;&#160;Neither&#160;&#160;of&#160;&#160;these&#160;&#160;classes&#160;&#160;have<br/>mutator&#160;methods,&#160;so&#160;Fixnum&#160;and&#160;Symbol&#160;objects&#160;are&#160;immutable,&#160;which&#160;means&#160;that&#160;there<br/>is really no way to tell that they are manipulated by value rather than by reference.<br/>The&#160;existence&#160;of&#160;immediate&#160;values&#160;should&#160;be&#160;considered&#160;an&#160;implementation&#160;detail.&#160;The<br/>only&#160;practical&#160;difference&#160;between&#160;immediate&#160;values&#160;and&#160;reference&#160;values&#160;is&#160;that&#160;imme-<br/>diate&#160;values&#160;cannot&#160;have&#160;singleton&#160;methods&#160;defined&#160;on&#160;them.&#160;(Singleton&#160;methods&#160;are<br/><a href="Rubys.html#193">explained in §6.1.4.)</a><br/>
<b>3.8.2 &#160;Object Lifetime<br/></b>The&#160;built-in&#160;Ruby&#160;classes&#160;described&#160;in&#160;this&#160;chapter&#160;have&#160;literal&#160;syntaxes,&#160;and&#160;instances<br/>of&#160;these&#160;classes&#160;are&#160;created&#160;simply&#160;by&#160;including&#160;their&#160;values&#160;literally&#160;in&#160;your&#160;code.&#160;Ob-<br/>jects&#160;of&#160;other&#160;classes&#160;need&#160;to&#160;be&#160;explicitly&#160;created,&#160;and&#160;this&#160;is&#160;most&#160;often&#160;done&#160;with&#160;a<br/>method named&#160;new:<br/>
myObject = myClass.new<br/>
new&#160;is&#160;a&#160;method&#160;of&#160;the&#160;Class&#160;class.&#160;It&#160;allocates&#160;memory&#160;to&#160;hold&#160;the&#160;new&#160;object,&#160;then&#160;it<br/>initializes&#160;the&#160;state&#160;of&#160;that&#160;newly&#160;allocated&#160;“empty”&#160;object&#160;by&#160;invoking&#160;its&#160;initialize<br/>method.&#160;The&#160;arguments&#160;to&#160;new&#160;are&#160;passed&#160;directly&#160;on&#160;to&#160;initialize.&#160;Most&#160;classes&#160;define<br/>an&#160;initialize&#160;method to perform whatever initialization is necessary for instances.<br/>The&#160;new&#160;and&#160;initialize&#160;methods&#160;provide&#160;the&#160;default&#160;technique&#160;for&#160;creating&#160;new&#160;classes,<br/>but&#160;classes&#160;may&#160;also&#160;define&#160;other&#160;methods,&#160;known&#160;as&#160;“factory&#160;methods,”&#160;that&#160;return<br/>instances. We’ll learn more about&#160;new,&#160;initialize<a href="Rubys.html#255">, and factory methods in §7.4.<br/></a>Ruby&#160;objects&#160;never&#160;need&#160;to&#160;be&#160;explicitly&#160;deallocated,&#160;as&#160;they&#160;do&#160;in&#160;languages&#160;like&#160;C&#160;and<br/>C++.&#160;Ruby&#160;uses&#160;a&#160;technique&#160;called&#160;<i>garbage collection</i>&#160;to&#160;automatically destroy objects<br/>that&#160;are&#160;no&#160;longer&#160;needed.&#160;An&#160;object&#160;becomes&#160;a&#160;candidate&#160;for&#160;garbage&#160;collection&#160;when<br/>it&#160;is&#160;<i>unreachable</i>—when&#160;there&#160;are&#160;no&#160;remaining&#160;references&#160;to&#160;the&#160;object&#160;except&#160;from<br/>other unreachable objects.<br/>The&#160;fact&#160;that&#160;Ruby&#160;uses&#160;garbage&#160;collection&#160;means&#160;that&#160;Ruby&#160;programs&#160;are&#160;less&#160;suscep-<br/>tible&#160;to&#160;memory&#160;leaks&#160;than&#160;programs&#160;written&#160;in&#160;languages&#160;that&#160;require&#160;objects&#160;and<br/>
<b>3.8 &#160;Objects&#160;|&#160;73</b><br/>
<hr/>
<a name=88></a>memory&#160;to&#160;be&#160;explicitly&#160;deallocated&#160;and&#160;freed.&#160;But&#160;garbage&#160;collection&#160;does&#160;not&#160;mean<br/>that&#160;memory&#160;leaks&#160;are&#160;impossible:&#160;any&#160;code&#160;that&#160;creates&#160;long-lived&#160;references&#160;to&#160;objects<br/>that&#160;would&#160;otherwise&#160;be&#160;short-lived&#160;can&#160;be&#160;a&#160;source&#160;of&#160;memory&#160;leaks.&#160;Consider&#160;a&#160;hash<br/>used&#160;&#160;as&#160;&#160;a&#160;&#160;cache.&#160;&#160;If&#160;&#160;the&#160;&#160;cache&#160;&#160;is&#160;&#160;not&#160;&#160;pruned&#160;&#160;using&#160;&#160;some&#160;&#160;kind&#160;&#160;of&#160;&#160;least-recently-used<br/>algorithm,&#160;then&#160;cached&#160;objects&#160;will&#160;remain&#160;reachable&#160;as&#160;long&#160;as&#160;the&#160;hash&#160;itself&#160;is&#160;reach-<br/>able.&#160;If&#160;the&#160;hash&#160;is&#160;referenced&#160;through&#160;a&#160;global&#160;variable,&#160;then&#160;it&#160;will&#160;be&#160;reachable&#160;as&#160;long<br/>as the Ruby interpreter is running.<br/>
<b>3.8.3 &#160;Object Identity<br/></b>Every object has an object&#160;identifier, a&#160;Fixnum,&#160;that you can obtain with the&#160;object_id<br/>method.&#160;The&#160;value&#160;returned&#160;by&#160;this&#160;method&#160;is&#160;constant&#160;and&#160;unique&#160;for&#160;the&#160;lifetime&#160;of<br/>the&#160;object.&#160;While&#160;the&#160;object&#160;is&#160;accessible,&#160;it&#160;will&#160;always&#160;have&#160;the&#160;same&#160;ID,&#160;and&#160;no&#160;other<br/>object will share that ID.<br/>The&#160;method&#160;id&#160;is&#160;a&#160;deprecated&#160;synonym&#160;for&#160;object_id.&#160;Ruby&#160;1.8&#160;issues&#160;a&#160;warning&#160;if<br/>you use it, and it has been removed in Ruby 1.9.<br/>
__id__&#160;is&#160;a&#160;valid&#160;synonym&#160;for&#160;object_id.&#160;It&#160;exists&#160;as&#160;a&#160;fallback,&#160;so&#160;you&#160;can&#160;access&#160;an<br/>object’s ID even if the&#160;object_id&#160;method has been undefined or overridden.<br/>The&#160;Object&#160;class implements the&#160;hash&#160;method to simply return an object’s ID.<br/>
<b>3.8.4 &#160;Object Class and Object Type<br/></b>There&#160;are&#160;several&#160;ways&#160;to&#160;determine&#160;the&#160;class&#160;of&#160;an&#160;object&#160;in&#160;Ruby.&#160;The&#160;simplest&#160;is<br/>simply to ask for it:<br/>
o = &#34;test&#34; &#160;# This is a value<br/>o.class &#160; &#160; # Returns an object representing the String class<br/>
If&#160;you&#160;are&#160;interested&#160;in&#160;the&#160;class&#160;hierarchy&#160;of&#160;an&#160;object,&#160;you&#160;can&#160;ask&#160;any&#160;class&#160;what&#160;its<br/>superclass is:<br/>
o.class &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # String: o is a String object<br/>o.class.superclass &#160; &#160; &#160; &#160; &#160; &#160;# Object: superclass of String is Object<br/>o.class.superclass.superclass # nil: Object has no superclass<br/>
In Ruby 1.9,&#160;Object&#160;is no longer the true root of the class hierarchy:<br/>
# Ruby 1.9 only<br/>Object.superclass &#160; &#160; &#160; &#160; &#160; &#160; # BasicObject: Object has a superclass in 1.9<br/>BasicObject.superclass &#160; &#160; &#160; &#160;# nil: BasicObject has no superclass<br/>
<a href="Rubys.html#248">See §7.3 for more on&#160;</a>BasicObject.<br/>So&#160;&#160;a&#160;&#160;particularly&#160;&#160;straightforward&#160;&#160;way&#160;&#160;to&#160;&#160;check&#160;&#160;the&#160;&#160;class&#160;&#160;of&#160;&#160;an&#160;&#160;object&#160;&#160;is&#160;&#160;by&#160;&#160;direct<br/>comparison:<br/>
o.class == String &#160; &#160; &#160; # true if o is a String<br/>
The&#160;instance_of?&#160;method does the same thing and is a little more elegant:<br/>
<b>74&#160;|&#160;Chapter 3:</b> <b>Datatypes and Objects</b><br/>
<hr/>
<a name=89></a>o.instance_of? String &#160; # true if o is a String<br/>
Usually&#160;when&#160;we&#160;test&#160;the&#160;class&#160;of&#160;an&#160;object,&#160;we&#160;would&#160;also&#160;like&#160;to&#160;know&#160;if&#160;the&#160;object&#160;is<br/>an&#160;instance&#160;of&#160;any&#160;subclass&#160;of&#160;that&#160;class.&#160;To&#160;test&#160;this,&#160;use&#160;the&#160;&#160;is_a?&#160;method,&#160;or&#160;its<br/>synonym&#160;kind_of?:<br/>
x = 1 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# This is the value we're working with<br/>x.instance_of? Fixnum &#160; &#160;# true: is an instance of Fixnum<br/>x.instance_of? Numeric &#160; # false: instance_of? doesn't check inheritance<br/>x.is_a? Fixnum &#160; &#160; &#160; &#160; &#160; # true: x is a Fixnum<br/>x.is_a? Integer &#160; &#160; &#160; &#160; &#160;# true: x is an Integer<br/>x.is_a? Numeric &#160; &#160; &#160; &#160; &#160;# true: x is a Numeric<br/>x.is_a? Comparable &#160; &#160; &#160; # true: works with mixin modules, too<br/>x.is_a? Object &#160; &#160; &#160; &#160; &#160; # true for any value of x<br/>
The&#160;Class&#160;class&#160;defines&#160;the&#160;===&#160;operator&#160;in&#160;such&#160;a&#160;way&#160;that&#160;it&#160;can&#160;be&#160;used&#160;in&#160;place&#160;of<br/>is_a?:<br/>
Numeric === x &#160; &#160; &#160; &#160; &#160; &#160;# true: x is_a Numeric&#160;<br/>
This&#160;&#160;idiom&#160;&#160;is&#160;&#160;unique&#160;&#160;to&#160;&#160;Ruby&#160;&#160;and&#160;&#160;is&#160;&#160;probably&#160;&#160;less&#160;&#160;readable&#160;&#160;than&#160;&#160;using&#160;&#160;the&#160;&#160;more<br/>traditional&#160;is_a?&#160;method.<br/>Every&#160;object&#160;has&#160;a&#160;well-defined&#160;class&#160;in&#160;Ruby,&#160;and&#160;that&#160;class&#160;never&#160;changes&#160;during&#160;the<br/>lifetime&#160;of&#160;the&#160;object.&#160;An&#160;object’s&#160;<i>type</i>,&#160;on&#160;the&#160;other&#160;hand,&#160;is&#160;more&#160;fluid.&#160;The&#160;type&#160;of&#160;an<br/>object&#160;is&#160;related&#160;to&#160;its&#160;class,&#160;but&#160;the&#160;class&#160;is&#160;only&#160;part&#160;of&#160;an&#160;object’s&#160;type.&#160;When&#160;we&#160;talk<br/>about the type of an object, we mean the set of behaviors that characterize the object.<br/>Another way to put it is that the type of an object is the set of methods it can respond<br/>to.&#160;(This&#160;definition&#160;becomes&#160;recursive&#160;because&#160;it&#160;is&#160;not&#160;just&#160;the&#160;name&#160;of&#160;the&#160;methods<br/>that matter, but also the types of arguments that those methods can accept.)<br/>In&#160;Ruby&#160;programming,&#160;we&#160;often&#160;don’t&#160;care&#160;about&#160;the&#160;class&#160;of&#160;an&#160;object,&#160;we&#160;just&#160;want<br/>to&#160;know&#160;whether&#160;we&#160;can&#160;invoke&#160;some&#160;method&#160;on&#160;it.&#160;Consider,&#160;for&#160;example,&#160;the&#160;&lt;&lt;<br/>operator.&#160;Arrays,&#160;strings,&#160;files,&#160;and&#160;other&#160;I/O-related&#160;classes&#160;define&#160;this&#160;as&#160;an&#160;append<br/>operator.&#160;If&#160;we&#160;are&#160;writing&#160;a&#160;method&#160;that&#160;produces&#160;textual&#160;output,&#160;we&#160;might&#160;write&#160;it<br/>generically&#160;to&#160;use&#160;this&#160;operator.&#160;Then&#160;our&#160;method&#160;can&#160;be&#160;invoked&#160;with&#160;any&#160;argument<br/>that&#160;implements&#160;&lt;&lt;.&#160;We&#160;don’t&#160;care&#160;about&#160;the&#160;class&#160;of&#160;the&#160;argument,&#160;just&#160;that&#160;we&#160;can<br/>append to it. We can test for this with the&#160;respond_to?&#160;method:<br/>
o.respond_to? :&#34;&lt;&lt;&#34; &#160;# true if o has an &lt;&lt; operator<br/>
The&#160;shortcoming&#160;of&#160;this&#160;approach&#160;is&#160;that&#160;it&#160;only&#160;checks&#160;the&#160;name&#160;of&#160;a&#160;method,&#160;not&#160;the<br/>arguments&#160;for&#160;that&#160;method.&#160;For&#160;example,&#160;Fixnum&#160;and&#160;Bignum&#160;implement&#160;&lt;&lt;&#160;as&#160;a&#160;left-shift<br/>operator&#160;and&#160;expect&#160;the&#160;argument&#160;to&#160;be&#160;a&#160;number&#160;instead&#160;of&#160;a&#160;string.&#160;Integer&#160;objects<br/>appear&#160;to&#160;be&#160;“appendable”&#160;when&#160;we&#160;use&#160;a&#160;respond_to?&#160;test,&#160;but&#160;they&#160;produce&#160;an&#160;error<br/>when&#160;our&#160;code&#160;appends&#160;a&#160;string.&#160;There&#160;is&#160;no&#160;general&#160;solution&#160;to&#160;this&#160;problem,&#160;but&#160;an<br/>ad-hoc&#160;remedy,&#160;in&#160;this&#160;case,&#160;is&#160;to&#160;explicitly&#160;rule&#160;out&#160;Numeric&#160;objects&#160;with&#160;the&#160;is_a?<br/>method:<br/>
o.respond_to? :&#34;&lt;&lt;&#34; and not o.is_a? Numeric&#160;<br/>
<b>3.8 &#160;Objects&#160;|&#160;75</b><br/>
<hr/>
<a name=90></a>Another&#160;example&#160;of&#160;the&#160;type-versus-class&#160;distinction&#160;is&#160;the&#160;StringIO&#160;class&#160;(from&#160;Ruby’s<br/>standard&#160;library).&#160;StringIO&#160;enables&#160;reading&#160;from&#160;and&#160;writing&#160;to&#160;string&#160;objects&#160;as&#160;if&#160;they<br/>were&#160;IO&#160;objects.&#160;StringIO&#160;mimics&#160;the&#160;IO&#160;API—StringIO&#160;objects&#160;define&#160;the&#160;same&#160;methods<br/>that&#160;IO&#160;objects&#160;do.&#160;But&#160;StringIO&#160;is&#160;not&#160;a&#160;subclass&#160;of&#160;IO.&#160;If&#160;you&#160;write&#160;a&#160;method&#160;that&#160;expects<br/>a&#160;stream&#160;argument,&#160;and&#160;test&#160;the&#160;class&#160;of&#160;the&#160;argument&#160;with&#160;is_a? IO,&#160;then&#160;your&#160;method<br/>won’t work with&#160;StringIO&#160;arguments.<br/>Focusing on types rather than classes leads to a programming style known in Ruby&#160;as<br/><a href="Rubys.html#227">“duck typing.” We’ll see duck typing examples in Chapter 7.</a><br/>
<b>3.8.5 &#160;Object Equality<br/></b>Ruby&#160;&#160;has&#160;&#160;a&#160;&#160;surprising&#160;&#160;number&#160;&#160;of&#160;&#160;ways&#160;&#160;to&#160;&#160;compare&#160;&#160;objects&#160;&#160;for&#160;&#160;equality,&#160;&#160;and&#160;&#160;it&#160;&#160;is<br/>important to understand how they work, so you know when to use each method.<br/>
<b>3.8.5.1 &#160;The equal? method<br/></b>The&#160;equal?&#160;method&#160;is&#160;defined&#160;by&#160;Object&#160;to&#160;test&#160;whether&#160;two&#160;values&#160;refer&#160;to&#160;exactly&#160;the<br/>same object. For any two distinct objects, this method always returns&#160;false:<br/>
a = &#34;Ruby&#34; &#160; &#160; &#160; # One reference to one String object<br/>b = c = &#34;Ruby&#34; &#160; # Two references to another String object<br/>a.equal?(b) &#160; &#160; &#160;# false: a and b are different objects<br/>b.equal?(c) &#160; &#160; &#160;# true: b and c refer to the same object<br/>
By convention, subclasses never override the&#160;equal?&#160;method.<br/>Another&#160;way&#160;to&#160;determine&#160;if&#160;two&#160;objects&#160;are,&#160;in&#160;fact,&#160;the&#160;same&#160;object&#160;is&#160;to&#160;check&#160;their<br/>object_id:<br/>
a.object_id == b.object_id &#160; # Works like a.equal?(b)<br/>
<b>3.8.5.2 &#160;The == operator<br/></b>The&#160;==&#160;operator&#160;is&#160;the&#160;most&#160;common&#160;way&#160;to&#160;test&#160;for&#160;equality.&#160;In&#160;the&#160;Object&#160;class,&#160;it&#160;is<br/>simply&#160;a&#160;synonym&#160;for&#160;equal?,&#160;and&#160;it&#160;tests&#160;whether&#160;two&#160;object&#160;references&#160;are&#160;identical.<br/>Most&#160;classes&#160;redefine&#160;this&#160;operator&#160;to&#160;allow&#160;distinct&#160;instances&#160;to&#160;be&#160;tested&#160;for&#160;equality:<br/>
a = &#34;Ruby&#34; &#160; &#160;# One String object<br/>b = &#34;Ruby&#34; &#160; &#160;# A different String object with the same content<br/>a.equal?(b) &#160; # false: a and b do not refer to the same object<br/>a == b &#160; &#160; &#160; &#160;# true: but these two distinct objects have equal values<br/>
Note&#160;that&#160;the&#160;single&#160;equals&#160;sign&#160;in&#160;this&#160;code&#160;is&#160;the&#160;assignment&#160;operator.&#160;It&#160;takes&#160;two<br/>equals&#160;signs&#160;to&#160;test&#160;for&#160;equality&#160;in&#160;Ruby&#160;(this&#160;is&#160;a&#160;convention&#160;that&#160;Ruby&#160;shares&#160;with<br/>many other programming languages).<br/>Most&#160;standard&#160;Ruby&#160;classes&#160;define&#160;the&#160;==&#160;operator&#160;to&#160;implement&#160;a&#160;reasonable&#160;definition<br/>of&#160;equality.&#160;This&#160;includes&#160;the&#160;Array&#160;and&#160;Hash&#160;classes.&#160;Two&#160;arrays&#160;are&#160;equal&#160;according<br/>to&#160;==&#160;if&#160;they&#160;have&#160;the&#160;same&#160;number&#160;of&#160;elements,&#160;and&#160;if&#160;their&#160;corresponding&#160;elements<br/>are&#160;all&#160;equal&#160;according&#160;to&#160;==.&#160;Two&#160;hashes&#160;are&#160;==&#160;if&#160;they&#160;contain&#160;the&#160;same&#160;number&#160;of<br/>
<b>76&#160;|&#160;Chapter 3:</b> <b>Datatypes and Objects</b><br/>
<hr/>
<a name=91></a>key/value&#160;pairs,&#160;and&#160;if&#160;the&#160;keys&#160;and&#160;values&#160;are&#160;themselves&#160;equal.&#160;(Values&#160;are&#160;compared<br/>with&#160;the&#160;==&#160;operator,&#160;but&#160;hash&#160;keys&#160;are&#160;compared&#160;with&#160;the&#160;eql?&#160;method,&#160;described&#160;later<br/>in this chapter.)<br/>
<b>Equality for Java Programmers</b><br/>
If&#160;you&#160;are&#160;a&#160;Java&#160;programmer,&#160;you&#160;are&#160;used&#160;to&#160;using&#160;the&#160;==&#160;operator&#160;to&#160;test&#160;if&#160;two&#160;objects<br/>are the same object, and you are used to using the&#160;equals&#160;method to test whether two<br/>distinct&#160;objects&#160;have&#160;the&#160;same&#160;value.&#160;Ruby’s&#160;convention&#160;is&#160;just&#160;about&#160;the&#160;opposite&#160;of<br/>Java’s.<br/>
The&#160;Numeric&#160;classes&#160;perform&#160;simple&#160;type&#160;conversions&#160;in&#160;their&#160;==&#160;operators,&#160;so&#160;that&#160;(for<br/>example) the&#160;Fixnum&#160;1&#160;and the&#160;Float&#160;1.0&#160;compare as equal. The&#160;==&#160;operator of classes,<br/>such&#160;as&#160;String&#160;and&#160;Array,&#160;normally&#160;requires&#160;both&#160;operands&#160;to&#160;be&#160;of&#160;the&#160;same&#160;class.&#160;If<br/>the&#160;righthand&#160;operand&#160;defines&#160;a&#160;to_str&#160;or&#160;to_ary&#160;conversion&#160;function&#160;<a href="Rubys.html#93">(see&#160;§3.8.7),&#160;</a>then<br/>these operators invoke the&#160;==&#160;operator&#160;defined&#160;by&#160;the&#160;righthand&#160;operand,&#160;and&#160;let&#160;that<br/>object&#160;decide&#160;whether&#160;it&#160;is&#160;equal&#160;to&#160;the&#160;lefthand&#160;string&#160;or&#160;array.&#160;Thus,&#160;it&#160;is&#160;possible<br/>(though&#160;&#160;not&#160;&#160;common)&#160;&#160;to&#160;&#160;define&#160;&#160;classes&#160;&#160;with&#160;&#160;string-like&#160;&#160;or&#160;&#160;array-like&#160;&#160;comparison<br/>behavior.<br/>
!=&#160;(“not-equal”)&#160;is&#160;used&#160;in&#160;Ruby&#160;to&#160;test&#160;for&#160;inequality.&#160;When&#160;Ruby&#160;sees&#160;!=,&#160;it&#160;simply<br/>uses the&#160;==&#160;operator&#160;and&#160;then&#160;inverts&#160;the&#160;result.&#160;This&#160;means&#160;that&#160;a&#160;class&#160;only&#160;needs&#160;to<br/>define&#160;the&#160;==&#160;operator&#160;to&#160;define&#160;its&#160;own&#160;notion&#160;of&#160;equality.&#160;Ruby&#160;gives&#160;you&#160;the&#160;!=&#160;op-<br/>erator&#160;&#160;for&#160;&#160;free.&#160;&#160;In&#160;&#160;Ruby&#160;&#160;1.9,&#160;&#160;however,&#160;&#160;classes&#160;&#160;can&#160;&#160;explicitly&#160;&#160;define&#160;&#160;their&#160;&#160;own&#160;&#160;!=<br/>operators.<br/>
<b>3.8.5.3 &#160;The eql? method<br/></b>The&#160;eql?&#160;method&#160;is&#160;defined&#160;by&#160;Object&#160;as&#160;a&#160;synonym&#160;for&#160;equal?.&#160;Classes&#160;that&#160;override&#160;it<br/>typically use it as a strict version of&#160;==&#160;that does no type conversion. For example:<br/>
1 == 1.0 &#160; &#160;# true: Fixnum and Float objects can be ==<br/>1.eql?(1.0) # false: but they are never eql!<br/>
The&#160;Hash&#160;class&#160;uses&#160;eql?&#160;to&#160;check&#160;whether&#160;two&#160;hash&#160;keys&#160;are&#160;equal.&#160;If&#160;two&#160;objects&#160;are<br/>eql?,&#160;their&#160;hash&#160;methods&#160;must&#160;also&#160;return&#160;the&#160;same&#160;value.&#160;Typically,&#160;if&#160;you&#160;create&#160;a&#160;class<br/>and&#160;define&#160;the&#160;==&#160;operator,&#160;you&#160;can&#160;simply&#160;write&#160;a&#160;hash&#160;method&#160;and&#160;define&#160;eql?&#160;to use<br/>==.<br/>
<b>3.8.5.4 &#160;The === operator<br/></b>The&#160;===&#160;operator&#160;is&#160;commonly&#160;called&#160;the&#160;“case&#160;equality”&#160;operator&#160;and&#160;is&#160;used&#160;to&#160;test<br/>whether&#160;the&#160;target&#160;value&#160;of&#160;a&#160;case&#160;statement&#160;matches&#160;any&#160;of&#160;the&#160;when&#160;clauses&#160;of&#160;that<br/>statement. (The&#160;case<a href="Rubys.html#131">&#160;statement is a multiway branch and is explained in Chapter 5.)</a><br/>
Object&#160;defines&#160;a&#160;default&#160;===&#160;operator&#160;so&#160;that&#160;it&#160;invokes&#160;the&#160;==&#160;operator.&#160;For&#160;many&#160;classes,<br/>therefore,&#160;case&#160;equality&#160;is&#160;the&#160;same&#160;as&#160;==&#160;equality.&#160;But&#160;certain&#160;key&#160;classes&#160;define&#160;===<br/>
<b>3.8 &#160;Objects&#160;|&#160;77</b><br/>
<hr/>
<a name=92></a>differently, and in these cases it is more of a membership or matching operator.&#160;Range<br/>defines&#160;===&#160;to&#160;test&#160;whether&#160;a&#160;value&#160;falls&#160;within&#160;the&#160;range.&#160;Regexp&#160;defines&#160;===&#160;to&#160;test<br/>whether&#160;a&#160;string&#160;matches&#160;the&#160;regular&#160;expression.&#160;And&#160;Class&#160;defines&#160;===&#160;to&#160;test&#160;whether<br/>an&#160;object&#160;is&#160;an&#160;instance&#160;of&#160;that&#160;class.&#160;In&#160;Ruby&#160;1.9,&#160;Symbol&#160;defines&#160;===&#160;to&#160;return&#160;true&#160;if<br/>the&#160;righthand&#160;operand&#160;is&#160;the&#160;same&#160;symbol&#160;as&#160;the&#160;left&#160;or&#160;if&#160;it&#160;is&#160;a&#160;string&#160;holding&#160;the&#160;same<br/>text. Examples:<br/>
(1..10) === 5 &#160; &#160;# true: 5 is in the range 1..10<br/>/\d+/ === &#34;123&#34; &#160;# true: the string matches the regular expression<br/>String === &#34;s&#34; &#160; # true: &#34;s&#34; is an instance of the class String<br/>:s === &#34;s&#34; &#160; &#160; &#160; # true in Ruby 1.9<br/>
It&#160;is&#160;uncommon&#160;to&#160;see&#160;the&#160;===&#160;operator&#160;used&#160;explicitly&#160;like&#160;this.&#160;More&#160;commonly,&#160;its<br/>use is simply implicit in a&#160;case&#160;statement.<br/>
<b>3.8.5.5 &#160;The =~ operator<br/></b>The&#160;=~&#160;operator&#160;is&#160;defined&#160;by&#160;String&#160;and&#160;Regexp&#160;(and&#160;Symbol&#160;in&#160;Ruby&#160;1.9)&#160;to&#160;perform<br/>pattern&#160;matching,&#160;and&#160;it&#160;isn’t&#160;really&#160;an&#160;equality&#160;operator&#160;at&#160;all.&#160;But&#160;it&#160;does&#160;have&#160;an&#160;equals<br/>sign&#160;in&#160;it,&#160;so&#160;it&#160;is&#160;listed&#160;here&#160;for&#160;completeness.&#160;Object&#160;defines&#160;a&#160;no-op&#160;version&#160;of&#160;=~&#160;that<br/>always&#160;returns&#160;false.&#160;You&#160;can&#160;define&#160;this&#160;operator&#160;in&#160;your&#160;own&#160;class,&#160;if&#160;that&#160;class&#160;defines<br/>some&#160;kind&#160;of&#160;pattern-matching&#160;operation&#160;or&#160;has&#160;a&#160;notion&#160;of&#160;approximate&#160;equality,&#160;for<br/>example.&#160;!~&#160;is&#160;defined&#160;as&#160;the&#160;inverse&#160;of&#160;=~.&#160;It&#160;is&#160;definable&#160;in&#160;Ruby&#160;1.9&#160;but&#160;not&#160;in&#160;Ruby&#160;1.8.<br/>
<b>3.8.6 &#160;Object Order<br/></b>Practically&#160;every&#160;class&#160;can&#160;define&#160;a&#160;useful&#160;==&#160;method&#160;for&#160;testing&#160;its&#160;instances&#160;for&#160;equality.<br/>Some&#160;classes&#160;can&#160;also&#160;define&#160;an&#160;ordering.&#160;That&#160;is:&#160;for&#160;any&#160;two&#160;instances&#160;of&#160;such&#160;a&#160;class,<br/>the&#160;two&#160;instances&#160;must&#160;be&#160;equal,&#160;or&#160;one&#160;instance&#160;must&#160;be&#160;“less&#160;than”&#160;the&#160;other.&#160;Num-<br/>bers&#160;are&#160;the&#160;most&#160;obvious&#160;classes&#160;for&#160;which&#160;such&#160;an&#160;ordering&#160;is&#160;defined.&#160;Strings&#160;are&#160;also<br/>ordered,&#160;according&#160;to&#160;the&#160;numeric&#160;ordering&#160;of&#160;the&#160;character&#160;codes&#160;that&#160;comprise&#160;the<br/>strings.&#160;(With&#160;the&#160;ASCII&#160;text,&#160;this&#160;is&#160;a&#160;rough&#160;kind&#160;of&#160;case-sensitive&#160;alphabetical&#160;order.)<br/>If a class defines an ordering, then instances of the class can be compared and sorted.<br/>In&#160;Ruby,&#160;classes&#160;define&#160;an&#160;ordering&#160;by&#160;implementing&#160;the&#160;&lt;=&gt;&#160;operator.&#160;This&#160;operator<br/>should return&#160;–1&#160;if&#160;its&#160;left&#160;operand&#160;is&#160;less&#160;than&#160;its&#160;right&#160;operand,&#160;0&#160;if&#160;the&#160;two&#160;operands<br/>are&#160;equal,&#160;and&#160;1&#160;if&#160;the&#160;left&#160;operand&#160;is&#160;greater&#160;than&#160;the&#160;right&#160;operand.&#160;If&#160;the&#160;two&#160;operands<br/>cannot&#160;&#160;be&#160;&#160;meaningfully&#160;&#160;compared&#160;&#160;(if&#160;&#160;the&#160;&#160;right&#160;&#160;operand&#160;&#160;is&#160;&#160;of&#160;&#160;a&#160;&#160;different&#160;&#160;class,&#160;&#160;for<br/>example), then the operator should return&#160;nil:<br/>
1 &lt;=&gt; 5 &#160; &#160; # -1<br/>5 &lt;=&gt; 5 &#160; &#160; # 0<br/>9 &lt;=&gt; 5 &#160; &#160; # 1<br/>&#34;1&#34; &lt;=&gt; 5 &#160; # nil: integers and strings are not comparable<br/>
The&#160;&lt;=&gt;&#160;operator&#160;is&#160;all&#160;that&#160;is&#160;needed&#160;to&#160;compare&#160;values.&#160;But&#160;it&#160;isn’t&#160;particularly&#160;intuitive.<br/>So&#160;classes&#160;that&#160;define&#160;this&#160;operator&#160;typically&#160;also&#160;include&#160;the&#160;Comparable&#160;module&#160;as&#160;a<br/>
<b>78&#160;|&#160;Chapter 3:</b> <b>Datatypes and Objects</b><br/>
<hr/>
<a name=93></a>mixin. (Modules and mixins are covered in&#160;<a href="Rubys.html#264">§7.5.2.) The&#160;</a>Comparable&#160;mixin defines the<br/>following operators in terms of&#160;&lt;=&gt;:<br/>
&lt;<br/>
Less than<br/>
&lt;=<br/>
Less than or equal<br/>
==<br/>
Equal<br/>
&gt;=<br/>
Greater than or equal<br/>
&gt;<br/>
Greater than<br/>
Comparable&#160;does&#160;not&#160;define&#160;the&#160;!=&#160;operator;&#160;Ruby&#160;automatically&#160;defines&#160;that&#160;operator<br/>as&#160;&#160;the&#160;&#160;negation&#160;&#160;of&#160;&#160;the&#160;&#160;==&#160;&#160;operator.&#160;&#160;In&#160;&#160;addition&#160;&#160;to&#160;&#160;these&#160;&#160;comparison&#160;&#160;operators,<br/>Comparable&#160;also defines a useful comparison method named&#160;between?:<br/>
1.between?(0,10) &#160;# true: 0 &lt;= 1 &lt;= 10<br/>
If&#160;the&#160;&lt;=&gt;&#160;operator&#160;returns&#160;nil,&#160;all&#160;the&#160;comparison&#160;operators&#160;derived&#160;from&#160;it&#160;return<br/>false. The special&#160;Float&#160;value&#160;NaN&#160;is an example:<br/>
nan = 0.0/0.0; &#160; &#160; # zero divided by zero is not-a-number<br/>nan &lt; 0 &#160; &#160; &#160; &#160; &#160; &#160;# false: it is not less than zero<br/>nan &gt; 0 &#160; &#160; &#160; &#160; &#160; &#160;# false: it is not greater than zero<br/>nan == 0 &#160; &#160; &#160; &#160; &#160; # false: it is not equal to zero<br/>nan == nan &#160; &#160; &#160; &#160; # false: it is not even equal to itself!<br/>nan.equal?(nan) &#160; &#160;# this is true, of course<br/>
Note&#160;that&#160;defining&#160;&lt;=&gt;&#160;and&#160;including&#160;the&#160;Comparable&#160;module&#160;defines&#160;a&#160;==&#160;operator for<br/>your&#160;class.&#160;Some&#160;classes&#160;define&#160;their&#160;own&#160;==&#160;operator,&#160;typically&#160;when&#160;they&#160;can&#160;imple-<br/>ment&#160;this&#160;more&#160;efficiently&#160;than&#160;an&#160;equality&#160;test&#160;based&#160;on&#160;&lt;=&gt;.&#160;It&#160;is&#160;possible&#160;to&#160;define<br/>classes&#160;that&#160;implement&#160;different&#160;notions&#160;of&#160;equality&#160;in&#160;their&#160;==&#160;and&#160;&lt;=&gt;&#160;operators.&#160;A<br/>
&#160;<br/>
class&#160;might&#160;do&#160;case-sensitive&#160;string&#160;comparisons&#160;for&#160;the&#160;==&#160;operator,&#160;for&#160;example,&#160;but<br/>then do case-insensitive comparisons for&#160;&lt;=&gt;, so that instances of the class would sort<br/>more&#160;naturally.&#160;In&#160;general,&#160;though,&#160;it&#160;is&#160;best&#160;if&#160;&lt;=&gt;&#160;returns&#160;0&#160;if&#160;and&#160;only&#160;if&#160;==&#160;returns&#160;true.<br/>
<b>3.8.7 &#160;Object Conversion<br/></b>Many&#160;Ruby&#160;classes&#160;define&#160;methods&#160;that&#160;return&#160;a&#160;representation&#160;of&#160;the&#160;object&#160;as&#160;a&#160;value<br/>of&#160;a&#160;different&#160;class.&#160;The&#160;to_s&#160;method,&#160;for&#160;obtaining&#160;a&#160;String&#160;representation&#160;of&#160;an&#160;object,<br/>is&#160;probably&#160;the&#160;most&#160;commonly&#160;implemented&#160;and&#160;best&#160;known&#160;of&#160;these&#160;methods.&#160;The<br/>subsections that follow describe various categories of conversions.<br/>
<b>3.8.7.1 &#160;Explicit conversions<br/></b>Classes&#160;define&#160;explicit&#160;conversion&#160;methods&#160;for&#160;use&#160;by&#160;application&#160;code&#160;that&#160;needs&#160;to<br/>convert&#160;a&#160;value&#160;to&#160;another&#160;representation.&#160;The&#160;most&#160;common&#160;methods&#160;in&#160;this&#160;category<br/>are&#160;&#160;to_s,&#160;&#160;to_i,&#160;&#160;to_f,&#160;&#160;and&#160;&#160;to_a&#160;&#160;to&#160;&#160;convert&#160;&#160;to&#160;&#160;String,&#160;&#160;Integer,&#160;&#160;Float,&#160;&#160;and&#160;&#160;Array,<br/>respectively.&#160;Ruby&#160;1.9&#160;adds&#160;to_c&#160;and&#160;to_r&#160;methods&#160;to&#160;convert&#160;to&#160;Complex&#160;and&#160;Rational.<br/>
<b>3.8 &#160;Objects&#160;|&#160;79</b><br/>
<hr/>
<a name=94></a>Built-in&#160;methods&#160;do&#160;not&#160;typically&#160;invoke&#160;these&#160;methods&#160;for&#160;you.&#160;If&#160;you&#160;invoke&#160;a&#160;method<br/>that&#160;expects&#160;a&#160;String&#160;and&#160;pass&#160;an&#160;object&#160;of&#160;some&#160;other&#160;kind,&#160;that&#160;method&#160;is&#160;not&#160;expected<br/>to&#160;convert&#160;the&#160;argument&#160;with&#160;to_s.&#160;(Values&#160;interpolated&#160;into&#160;double-quoted&#160;strings,<br/>however, are automatically converted with&#160;to_s.)<br/>
to_s&#160;is&#160;easily&#160;the&#160;most&#160;important&#160;of&#160;the&#160;conversion&#160;methods&#160;because&#160;string&#160;represen-<br/>tations&#160;of&#160;objects&#160;are&#160;so&#160;commonly&#160;used&#160;in&#160;user&#160;interfaces.&#160;An&#160;important&#160;alternative&#160;to<br/>to_s&#160;&#160;is&#160;&#160;the&#160;&#160;inspect&#160;&#160;method.&#160;&#160;to_s&#160;&#160;is&#160;&#160;generally&#160;&#160;intended&#160;&#160;to&#160;&#160;return&#160;&#160;a&#160;&#160;human-readable<br/>representation&#160;of&#160;the&#160;object,&#160;suitable&#160;for&#160;end&#160;users.&#160;inspect,&#160;on&#160;the&#160;other&#160;hand,&#160;is&#160;in-<br/>tended&#160;for&#160;debugging&#160;use,&#160;and&#160;should&#160;return&#160;a&#160;representation&#160;that&#160;is&#160;helpful&#160;to&#160;Ruby<br/>developers. The default&#160;inspect&#160;method, inherited from&#160;Object, simply calls&#160;to_s.<br/>
<b>3.8.7.2 &#160;Implicit conversions<br/></b>Sometimes a&#160;class&#160;has&#160;strong&#160;characteristics&#160;of&#160;some&#160;other&#160;class.&#160;The&#160;Ruby&#160;Exception<br/>class&#160;represents&#160;an&#160;error&#160;or&#160;unexpected&#160;condition&#160;in&#160;a&#160;program&#160;and&#160;encapsulates&#160;an<br/>error&#160;message.&#160;In&#160;Ruby&#160;1.8,&#160;Exception&#160;objects&#160;are&#160;not&#160;merely&#160;convertible&#160;to&#160;strings;&#160;they<br/>are&#160;string-like&#160;objects&#160;and&#160;can&#160;be&#160;treated&#160;as&#160;if&#160;they&#160;were&#160;strings&#160;in&#160;many&#160;contexts.*&#160;&#160;For<br/>example:<br/>
# Ruby 1.8 only<br/>e = Exception.new(&#34;not really an exception&#34;)<br/>msg = &#34;Error: &#34; + e &#160;# String concatenation with an Exception<br/>
Because&#160;Exception&#160;objects&#160;are&#160;string-like,&#160;they&#160;can&#160;be&#160;used&#160;with&#160;the&#160;string&#160;concatenation<br/>operator.&#160;&#160;This&#160;&#160;does&#160;&#160;not&#160;&#160;work&#160;&#160;with&#160;&#160;most&#160;&#160;other&#160;&#160;Ruby&#160;&#160;classes.&#160;&#160;The&#160;&#160;reason&#160;&#160;that<br/>Exception&#160;objects&#160;can&#160;behave&#160;like&#160;String&#160;objects&#160;is&#160;that,&#160;in&#160;Ruby&#160;1.8,&#160;Exception&#160;imple-<br/>ments&#160;the&#160;implicit&#160;conversion&#160;method&#160;to_str,&#160;and&#160;the&#160;+&#160;operator&#160;defined&#160;by&#160;String<br/>invokes this method on its righthand operand.<br/>Other implicit conversion methods are&#160;to_int&#160;for objects that want to be integer-like,<br/>to_ary&#160;for&#160;objects&#160;that&#160;want&#160;to&#160;be&#160;array-like,&#160;and&#160;to_hash&#160;for&#160;objects&#160;that&#160;want&#160;to&#160;be<br/>hash-like.&#160;&#160;Unfortunately,&#160;&#160;the&#160;&#160;circumstances&#160;&#160;under&#160;&#160;which&#160;&#160;these&#160;&#160;implicit&#160;&#160;conversion<br/>methods&#160;are&#160;called&#160;are&#160;not&#160;well&#160;documented.&#160;Among&#160;the&#160;built-in&#160;classes,&#160;these&#160;implicit<br/>conversion methods are not commonly implemented, either.<br/>We&#160;noted&#160;earlier&#160;in&#160;passing&#160;that&#160;the&#160;==&#160;operator&#160;can&#160;perform&#160;a&#160;weak&#160;kind&#160;of&#160;type&#160;con-<br/>version&#160;&#160;when&#160;&#160;testing&#160;&#160;for&#160;&#160;equality.&#160;&#160;The&#160;&#160;==&#160;&#160;operators&#160;&#160;defined&#160;&#160;by&#160;&#160;String,&#160;&#160;Array,&#160;&#160;and<br/>Hash&#160;check&#160;to&#160;see&#160;if&#160;the&#160;righthand&#160;operand&#160;is&#160;of&#160;the&#160;same&#160;class&#160;as&#160;the&#160;lefthand&#160;operand.<br/>If&#160;so,&#160;they&#160;compare&#160;them.&#160;If&#160;not,&#160;they&#160;check&#160;to&#160;see&#160;if&#160;the&#160;righthand&#160;operand&#160;has&#160;a&#160;to_str,<br/>to_ary,&#160;or&#160;to_hash&#160;method.&#160;They&#160;don’t&#160;invoke&#160;this&#160;method,&#160;but&#160;if&#160;it&#160;exists,&#160;they&#160;invoke<br/>the&#160;==&#160;method&#160;of&#160;the&#160;righthand&#160;operand&#160;and&#160;allow&#160;it&#160;to&#160;decide&#160;whether&#160;it&#160;is&#160;equal&#160;to<br/>the lefthand operand.<br/>
*&#160;Doing&#160;so&#160;is&#160;discouraged,&#160;however,&#160;and&#160;Ruby&#160;1.9&#160;no&#160;longer&#160;allows&#160;the&#160;implicit&#160;conversion&#160;of&#160;Exception&#160;to<br/>
String.<br/>
<b>80&#160;|&#160;Chapter 3:</b> <b>Datatypes and Objects</b><br/>
<hr/>
<a name=95></a>In&#160;Ruby&#160;1.9,&#160;the&#160;built-in&#160;classes&#160;String,&#160;Array,&#160;Hash,&#160;Regexp,&#160;and&#160;IO&#160;all&#160;define&#160;a&#160;class<br/>method&#160;named&#160;try_convert.&#160;These&#160;methods&#160;convert&#160;their&#160;argument&#160;if&#160;it&#160;defines&#160;an<br/>appropriate&#160;&#160;implicit&#160;&#160;conversion&#160;&#160;method,&#160;&#160;or&#160;&#160;they&#160;&#160;return&#160;&#160;nil&#160;&#160;otherwise.<br/>Array.try_convert(o)&#160;returns&#160;o.to_ary&#160;if&#160;o&#160;defines&#160;that&#160;method;&#160;otherwise,&#160;it&#160;returns<br/>nil.&#160;These&#160;try_convert&#160;methods&#160;are&#160;convenient&#160;if&#160;you&#160;want&#160;to&#160;write&#160;methods&#160;that&#160;allow<br/>implicit conversions on their arguments.<br/>
<b>3.8.7.3 &#160;Conversion functions<br/></b>The&#160;Kernel&#160;module&#160;defines&#160;four&#160;conversion&#160;methods&#160;that&#160;behave&#160;as&#160;global&#160;conversion<br/>functions.&#160;These&#160;functions—Array,&#160;Float,&#160;Integer,&#160;and&#160;String—have&#160;the&#160;same&#160;names<br/>as&#160;the&#160;classes&#160;that&#160;they&#160;convert&#160;to,&#160;and&#160;they&#160;are&#160;unusual&#160;in&#160;that&#160;they&#160;begin&#160;with&#160;a&#160;capital<br/>letter.<br/>The&#160;Array&#160;function&#160;attempts&#160;to&#160;convert&#160;its&#160;argument&#160;to&#160;an&#160;array&#160;by&#160;calling&#160;to_ary.&#160;If<br/>that&#160;method&#160;is&#160;not&#160;defined&#160;or&#160;returns&#160;nil,&#160;it&#160;tries&#160;the&#160;to_a&#160;method.&#160;If&#160;to_a&#160;is&#160;not&#160;defined<br/>or returns&#160;nil, the&#160;Array&#160;function&#160;simply&#160;returns&#160;a&#160;new&#160;array&#160;containing&#160;the&#160;argument<br/>as its single element.<br/>The&#160;Float&#160;function&#160;converts&#160;Numeric&#160;arguments&#160;to&#160;Float&#160;objects&#160;directly.&#160;For&#160;any&#160;non-<br/>Numeric&#160;value, it calls the&#160;to_f&#160;method.<br/>
The&#160;Integer&#160;function converts its argument to a&#160;Fixnum&#160;or&#160;Bignum. If the argument is a<br/>Numeric&#160;value,&#160;it&#160;is&#160;converted&#160;directly.&#160;Floating-point&#160;values&#160;are&#160;truncated&#160;rather&#160;than<br/>rounded.&#160;If&#160;the&#160;argument&#160;is&#160;a&#160;string,&#160;it&#160;looks&#160;for&#160;a&#160;radix&#160;indicator&#160;(a&#160;leading&#160;0&#160;for&#160;octal,<br/>0x&#160;&#160;for&#160;&#160;hexadecimal,&#160;&#160;or&#160;&#160;0b&#160;&#160;for&#160;&#160;binary)&#160;&#160;and&#160;&#160;converts&#160;&#160;the&#160;&#160;string&#160;&#160;accordingly.&#160;&#160;Unlike<br/>String.to_i&#160;it&#160;does&#160;not&#160;allow&#160;nonnumeric&#160;trailing&#160;characters.&#160;For&#160;any&#160;other&#160;kind&#160;of<br/>argument,&#160;the&#160;Integer&#160;function&#160;first&#160;attempts&#160;conversion&#160;with&#160;to_int&#160;and&#160;then&#160;with<br/>to_i.<br/>
Finally,&#160;&#160;the&#160;&#160;String&#160;&#160;function&#160;&#160;converts&#160;&#160;its&#160;&#160;argument&#160;&#160;to&#160;&#160;a&#160;&#160;string&#160;&#160;simply&#160;&#160;by&#160;&#160;calling&#160;&#160;its<br/>to_s&#160;method.<br/>
<b>3.8.7.4 &#160;Arithmetic operator type coercions<br/></b>Numeric&#160;types&#160;define&#160;a&#160;conversion&#160;method&#160;named&#160;coerce.&#160;The&#160;intent&#160;of&#160;this&#160;method<br/>is&#160;to&#160;convert&#160;the&#160;argument&#160;to&#160;the&#160;same&#160;type&#160;as&#160;the&#160;numeric&#160;object&#160;on&#160;which&#160;the&#160;method<br/>is&#160;&#160;invoked,&#160;&#160;or&#160;&#160;to&#160;&#160;convert&#160;&#160;both&#160;&#160;objects&#160;&#160;to&#160;&#160;some&#160;&#160;more&#160;&#160;general&#160;&#160;compatible&#160;&#160;type.&#160;&#160;The<br/>coerce&#160;method&#160;always&#160;returns&#160;an&#160;array&#160;that&#160;holds&#160;two&#160;numeric&#160;values&#160;of&#160;the&#160;same&#160;type.<br/>The&#160;first&#160;element&#160;of&#160;the&#160;array&#160;is&#160;the&#160;converted&#160;value&#160;of&#160;the&#160;argument&#160;to&#160;coerce.&#160;The<br/>second&#160;element&#160;of&#160;the&#160;returned&#160;array&#160;is&#160;the&#160;value&#160;(converted,&#160;if&#160;necessary)&#160;on&#160;which<br/>coerce&#160;was invoked:<br/>
1.1.coerce(1) &#160; &#160; &#160;# [1.0, 1.1]: coerce Fixnum to Float<br/>require &#34;rational&#34; # Use Rational numbers<br/>r = Rational(1,3) &#160;# One third as a Rational number<br/>r.coerce(2) &#160; &#160; &#160; &#160;# [Rational(2,1), Rational(1,3)]: Fixnum to Rational<br/>
<b>3.8 &#160;Objects&#160;|&#160;81</b><br/>
<hr/>
<a name=96></a>The&#160;&#160;coerce&#160;method&#160;is&#160;used&#160;by&#160;the&#160;arithmetic&#160;operators.&#160;The&#160;&#160;+&#160;operator&#160;defined&#160;by<br/>Fixnum&#160;doesn’t know about&#160;Rational&#160;numbers, for example, and if its righthand oper-<br/>and&#160;is&#160;a&#160;Rational&#160;value,&#160;it&#160;doesn’t&#160;know&#160;how&#160;to&#160;add&#160;it.&#160;coerce&#160;provides&#160;the&#160;solution.<br/>Numeric&#160;operators&#160;are&#160;written&#160;so&#160;that&#160;if&#160;they&#160;don’t&#160;know&#160;the&#160;type&#160;of&#160;the&#160;righthand<br/>operand,&#160;they&#160;invoke&#160;the&#160;coerce&#160;method&#160;of&#160;the&#160;righthand&#160;operand,&#160;passing&#160;the&#160;lefthand<br/>operand&#160;&#160;as&#160;&#160;an&#160;&#160;argument.&#160;&#160;Returning&#160;&#160;to&#160;&#160;our&#160;&#160;example&#160;&#160;of&#160;&#160;adding&#160;&#160;a&#160;&#160;Fixnum&#160;&#160;and&#160;&#160;a<br/>Rational,&#160;the&#160;coerce&#160;method&#160;of&#160;Rational&#160;returns&#160;an&#160;array&#160;of&#160;two&#160;Rational&#160;values.&#160;Now<br/>the&#160;+&#160;operator defined by&#160;Fixnum&#160;can simply invoke&#160;+&#160;on the values in the array.<br/>
<b>3.8.7.5 &#160;Boolean type conversions<br/></b>Boolean&#160;values&#160;deserve&#160;a&#160;special&#160;mention&#160;in&#160;the&#160;context&#160;of&#160;type&#160;conversion.&#160;Ruby&#160;is<br/>very&#160;strict&#160;with&#160;its&#160;Boolean&#160;values:&#160;true&#160;and&#160;false&#160;have&#160;to_s&#160;methods,&#160;which&#160;return<br/>“true”&#160;and&#160;“false”&#160;but&#160;define&#160;no&#160;other&#160;conversion&#160;methods.&#160;And&#160;there&#160;is&#160;no&#160;to_b&#160;method<br/>to convert other values to Booleans.<br/>In some languages,&#160;false&#160;is the same thing as&#160;0, or can be converted to and from&#160;0. In<br/>Ruby,&#160;the&#160;values&#160;true&#160;and&#160;false&#160;are&#160;their&#160;own&#160;distinct&#160;objects,&#160;and&#160;there&#160;are&#160;no&#160;implicit<br/>conversions&#160;that&#160;convert&#160;other&#160;values&#160;to&#160;true&#160;or&#160;false.&#160;This&#160;is&#160;only&#160;half&#160;the&#160;story,&#160;how-<br/>ever.&#160;Ruby’s&#160;Boolean&#160;operators&#160;and&#160;its&#160;conditional&#160;and&#160;looping&#160;constructs&#160;that&#160;use<br/>Boolean&#160;expressions&#160;can&#160;work&#160;with&#160;values&#160;other&#160;than&#160;true&#160;and&#160;false.&#160;The&#160;rule&#160;is&#160;simple:<br/>in&#160;&#160;Boolean&#160;&#160;expressions,&#160;&#160;any&#160;&#160;value&#160;&#160;other&#160;&#160;than&#160;&#160;false&#160;&#160;or&#160;&#160;nil&#160;&#160;behaves&#160;&#160;like&#160;&#160;(but&#160;&#160;is&#160;&#160;not<br/>converted to)&#160;true.&#160;nil, on the other hand behaves like&#160;false.<br/>Suppose you want to test whether the variable&#160;x&#160;is&#160;nil&#160;or not. In some languages, you<br/>must explicitly write a comparison expression that evaluates to&#160;true&#160;or&#160;false:<br/>
if x != nil &#160; # Expression &#34;x != nil&#34; returns true or false to the if<br/>&#160; puts x &#160; &#160; &#160;# Print x if it is defined<br/>end<br/>
This&#160;code&#160;works&#160;in&#160;Ruby,&#160;but&#160;it&#160;is&#160;more&#160;common&#160;simply&#160;to&#160;take&#160;advantage&#160;of&#160;the&#160;fact<br/>that all values other than&#160;nil&#160;and&#160;false&#160;behave like&#160;true:<br/>
if x &#160; &#160; &#160; # If x is non-nil<br/>&#160; puts x &#160; # Then print it<br/>end<br/>
It&#160;is&#160;important&#160;to&#160;remember&#160;that&#160;values&#160;like&#160;0,&#160;0.0,&#160;and&#160;the&#160;empty&#160;string&#160;&#34;&#34;&#160;behave&#160;like<br/>true&#160;in Ruby, which is surprising if you are used to languages like C or JavaScript.<br/>
<b>3.8.8 &#160;Copying Objects<br/></b>The&#160;Object&#160;class&#160;defines&#160;two&#160;closely&#160;related&#160;methods&#160;for&#160;copying&#160;objects.&#160;Both&#160;clone<br/>and&#160;dup&#160;return&#160;a&#160;shallow&#160;copy&#160;of&#160;the&#160;object&#160;on&#160;which&#160;they&#160;are&#160;invoked.&#160;If&#160;the&#160;copied<br/>object&#160;includes&#160;internal&#160;state&#160;that&#160;refers&#160;to&#160;other&#160;objects,&#160;only&#160;the&#160;object&#160;references&#160;are<br/>copied, not the referenced objects themselves.<br/>
<b>82&#160;|&#160;Chapter 3:</b> <b>Datatypes and Objects</b><br/>
<hr/>
<a name=97></a>If&#160;the&#160;object&#160;being&#160;copied&#160;defines&#160;an&#160;initialize_copy&#160;method,&#160;then&#160;clone&#160;and&#160;dup&#160;sim-<br/>ply&#160;allocate&#160;a&#160;new,&#160;empty&#160;instance&#160;of&#160;the&#160;class&#160;and&#160;invoke&#160;the&#160;initialize_copy&#160;method<br/>on&#160;this&#160;empty&#160;instance.&#160;The&#160;object&#160;to&#160;be&#160;copied&#160;is&#160;passed&#160;as&#160;an&#160;argument,&#160;and&#160;this<br/>“copy&#160;&#160;constructor”&#160;&#160;can&#160;&#160;initialize&#160;&#160;the&#160;&#160;copy&#160;&#160;however&#160;&#160;it&#160;&#160;desires.&#160;&#160;For&#160;&#160;example,&#160;&#160;the<br/>initialize_copy&#160;method&#160;could&#160;recursively&#160;copy&#160;the&#160;internal&#160;data&#160;of&#160;an&#160;object&#160;so&#160;that<br/>the resulting object is not a simple shallow copy of the original.<br/>Classes&#160;can&#160;also&#160;override&#160;the&#160;clone&#160;and&#160;dup&#160;methods&#160;directly&#160;to&#160;produce&#160;any&#160;kind&#160;of<br/>copy they desire.<br/>There&#160;are&#160;two&#160;important&#160;differences&#160;between&#160;the&#160;clone&#160;and&#160;dup&#160;methods&#160;defined&#160;by<br/>Object.&#160;&#160;First,&#160;&#160;clone&#160;&#160;copies&#160;&#160;both&#160;&#160;the&#160;&#160;frozen&#160;&#160;and&#160;&#160;tainted&#160;&#160;state&#160;&#160;(defined&#160;&#160;shortly)&#160;&#160;of&#160;&#160;an<br/>object,&#160;whereas&#160;dup&#160;only&#160;copies&#160;the&#160;tainted&#160;state;&#160;calling&#160;dup&#160;on&#160;a&#160;frozen&#160;object&#160;returns<br/>an unfrozen copy. Second,&#160;clone&#160;copies&#160;any&#160;singleton&#160;methods&#160;of&#160;the&#160;object,&#160;whereas<br/>dup&#160;does not.<br/>
<b>3.8.9 &#160;Marshaling Objects<br/></b>You can save&#160;the&#160;state&#160;of&#160;an&#160;object&#160;by&#160;passing&#160;it&#160;to&#160;the&#160;class&#160;method&#160;Marshal.dump.*&#160;&#160;If<br/>you&#160;pass&#160;an&#160;I/O&#160;stream&#160;object&#160;as&#160;the&#160;second&#160;argument,&#160;Marshal.dump&#160;writes&#160;the&#160;state<br/>of&#160;the&#160;object&#160;(and,&#160;recursively,&#160;any&#160;objects&#160;it&#160;references)&#160;to&#160;that&#160;stream.&#160;Otherwise,&#160;it<br/>simply returns the encoded state as a binary string.<br/>To&#160;restore&#160;a&#160;marshaled&#160;object,&#160;pass&#160;a&#160;string&#160;or&#160;an&#160;I/O&#160;stream&#160;containing&#160;the&#160;object&#160;to<br/>Marshal.load.<br/>
Marshaling&#160;an&#160;object&#160;is&#160;a&#160;very&#160;simple&#160;way&#160;to&#160;save&#160;its&#160;state&#160;for&#160;later&#160;use,&#160;and&#160;these&#160;meth-<br/>ods&#160;can&#160;be&#160;used&#160;to&#160;provide&#160;an&#160;automatic&#160;file&#160;format&#160;for&#160;Ruby&#160;programs.&#160;Note,&#160;however,<br/>that&#160;the&#160;binary&#160;format&#160;used&#160;by&#160;Marshal.dump&#160;and&#160;Marshal.load&#160;is&#160;version-dependent,<br/>and&#160;newer&#160;versions&#160;of&#160;Ruby&#160;are&#160;not&#160;guaranteed&#160;to&#160;be&#160;able&#160;to&#160;read&#160;marshaled&#160;objects<br/>written by older versions of Ruby.<br/>Another use for&#160;Marshal.dump&#160;and&#160;Marshal.load&#160;is to create deep copies of objects:<br/>
def deepcopy(o)<br/>&#160; Marshal.load(Marshal.dump(o))<br/>end<br/>
Note&#160;that&#160;files&#160;and&#160;I/O&#160;streams,&#160;as&#160;well&#160;as&#160;Method&#160;and&#160;Binding&#160;objects,&#160;are&#160;too&#160;dynamic<br/>to be marshaled; there would be no reliable way to restore their state.<br/>YAML&#160;&#160;(“YAML&#160;&#160;Ain’t&#160;&#160;Markup&#160;&#160;Language”)&#160;&#160;is&#160;&#160;a&#160;&#160;commonly&#160;&#160;used&#160;&#160;alternative&#160;&#160;to&#160;&#160;the<br/>Marshal&#160;module&#160;that&#160;dumps&#160;objects&#160;to&#160;(and&#160;loads&#160;objects&#160;from)&#160;a&#160;human-readable&#160;text<br/>format. It is in the standard library, and you must&#160;require 'yaml'&#160;to use it.<br/>
*&#160;The&#160;word&#160;“marshal”&#160;and&#160;its&#160;variants&#160;are&#160;sometimes&#160;spelled&#160;with&#160;two&#160;ls:&#160;marshall,&#160;marshalled,&#160;etc.&#160;If&#160;you&#160;spell<br/>
the word this way, you’ll need to remember that the name of the Ruby class has only a single l.<br/>
<b>3.8 &#160;Objects&#160;|&#160;83</b><br/>
<hr/>
<a name=98></a><b>3.8.10 &#160;Freezing Objects<br/></b>Any&#160;&#160;object&#160;&#160;may&#160;&#160;be&#160;&#160;<i>frozen</i>&#160;&#160;by&#160;&#160;calling&#160;&#160;its&#160;&#160;freeze&#160;&#160;method.&#160;&#160;A&#160;&#160;frozen&#160;&#160;object&#160;&#160;becomes<br/>immutable—none&#160;of&#160;its&#160;internal&#160;state&#160;may&#160;be&#160;changed,&#160;and&#160;an&#160;attempt&#160;to&#160;call&#160;any&#160;of<br/>its mutator methods fails:<br/>
s = &#34;ice&#34; &#160; &#160; &#160;# Strings are mutable objects<br/>s.freeze &#160; &#160; &#160; # Make this string immutable<br/>s.frozen? &#160; &#160; &#160;# true: it has been frozen<br/>s.upcase! &#160; &#160; &#160;# TypeError: can't modify frozen string<br/>s[0] = &#34;ni&#34; &#160; &#160;# TypeError: can't modify frozen string<br/>
Freezing a class object prevents the addition of any methods to that class.<br/>You&#160;can&#160;check&#160;whether&#160;an&#160;object&#160;is&#160;frozen&#160;with&#160;the&#160;frozen?&#160;method.&#160;Once&#160;frozen,&#160;there<br/>is&#160;no&#160;way&#160;to&#160;“thaw”&#160;an&#160;object.&#160;If&#160;you&#160;copy&#160;a&#160;frozen&#160;object&#160;with&#160;clone,&#160;the&#160;copy&#160;will&#160;also<br/>be frozen. If you copy a frozen object with&#160;dup, however, the copy will not be frozen.<br/>
<b>3.8.11 &#160;Tainted and Untrusted Objects<br/></b>Web applications&#160;must&#160;often&#160;keep&#160;track&#160;of&#160;data&#160;derived&#160;from&#160;untrusted&#160;user&#160;input&#160;to<br/>avoid&#160;SQL&#160;injection&#160;attacks&#160;and&#160;similar&#160;security&#160;risks.&#160;Ruby&#160;provides&#160;a&#160;simple&#160;solution<br/>to&#160;this&#160;problem:&#160;any&#160;object&#160;may&#160;be&#160;marked&#160;as&#160;tainted&#160;by&#160;calling&#160;its&#160;taint&#160;method.&#160;Once<br/>an&#160;object&#160;is&#160;tainted,&#160;any&#160;objects&#160;derived&#160;from&#160;it&#160;will&#160;also&#160;be&#160;tainted.&#160;The&#160;taint&#160;of&#160;an<br/>object can be tested with the&#160;tainted?&#160;method:<br/>
s = &#34;untrusted&#34; &#160; # Objects are normally untainted<br/>s.taint &#160; &#160; &#160; &#160; &#160; # Mark this untrusted object as tainted<br/>s.tainted? &#160; &#160; &#160; &#160;# true: it is tainted<br/>s.upcase.tainted? # true: derived objects are tainted<br/>s[3,4].tainted? &#160; # true: substrings are tainted<br/>
User&#160;input—such&#160;as&#160;command-line&#160;arguments,&#160;environment&#160;variables,&#160;and&#160;strings&#160;read<br/>with&#160;gets—are&#160;automatically&#160;tainted.&#160;When&#160;the&#160;global&#160;variable&#160;$SAFE&#160;is&#160;set&#160;to&#160;a&#160;value<br/>greater&#160;than&#160;zero,&#160;Ruby&#160;restricts&#160;various&#160;built-in&#160;methods&#160;so&#160;that&#160;they&#160;will&#160;not&#160;work<br/>with&#160;tainted&#160;data.&#160;Copies&#160;of&#160;tainted&#160;objects&#160;made&#160;with&#160;clone&#160;and&#160;dup&#160;remain&#160;tainted.<br/>A tainted object may be untainted with the&#160;untaint&#160;method. You should only do this,<br/>of&#160;course,&#160;if&#160;you&#160;have&#160;examined&#160;the&#160;object&#160;and&#160;are&#160;convinced&#160;that&#160;it&#160;presents&#160;no&#160;security<br/>risks.<br/>In&#160;&#160;Ruby&#160;&#160;1.9,&#160;&#160;objects&#160;&#160;can&#160;&#160;be&#160;&#160;untrusted&#160;&#160;in&#160;&#160;addition&#160;&#160;to&#160;&#160;being&#160;&#160;tainted.&#160;&#160;The&#160;&#160;methods<br/>untrusted?,&#160;untrust,&#160;and&#160;trust&#160;check&#160;and&#160;set&#160;the&#160;trustedness&#160;of&#160;an&#160;object.&#160;Untrusted<br/>code&#160;creates&#160;untrusted,&#160;tainted&#160;objects&#160;and&#160;is&#160;not&#160;allowed&#160;to&#160;modify&#160;trusted&#160;objects.<br/><a href="Rubys.html#423">See §10.5 for details on taint, trust, and&#160;</a>$SAFE.&#160;<br/>
<b>84&#160;|&#160;Chapter 3:</b> <b>Datatypes and Objects</b><br/>
<hr/>
<a name=99></a><img src="Ruby-99_1.jpg"/><br/>
<b>CHAPTER&#160;4</b><br/>
<b>Expressions and Operators</b><br/>
<b>85</b><br/>
<hr/>
<a name=100></a>An&#160;<i>expression</i>&#160;is&#160;a&#160;chunk&#160;of&#160;Ruby&#160;code&#160;that&#160;the&#160;Ruby&#160;interpreter&#160;can&#160;evaluate&#160;to&#160;produce<br/>a value. Here are some sample expressions:<br/>
2 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# A numeric literal<br/>x &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# A local variable reference<br/>Math.sqrt(2) &#160; &#160; &#160; # A method invocation<br/>x = Math.sqrt(2) &#160; # Assignment<br/>x*x &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Multiplication with the * operator<br/>
As&#160;you&#160;can&#160;see,&#160;primary&#160;expressions—such&#160;as&#160;literals,&#160;variable&#160;references,&#160;and&#160;method<br/>invocations—can&#160;&#160;be&#160;&#160;combined&#160;&#160;into&#160;&#160;larger&#160;&#160;expressions&#160;&#160;with&#160;&#160;<i>operators</i>,&#160;&#160;such&#160;&#160;as&#160;&#160;the<br/>assignment operator and the multiplication operator.<br/>Many&#160;programming&#160;languages&#160;distinguish&#160;between&#160;low-level&#160;expressions&#160;and&#160;higher-<br/>level&#160;<i>statements</i>,&#160;such&#160;as&#160;conditionals&#160;and&#160;loops.&#160;In&#160;these&#160;languages,&#160;statements&#160;control<br/>the&#160;flow&#160;of&#160;a&#160;program,&#160;but&#160;they&#160;do&#160;not&#160;have&#160;values.&#160;They&#160;are&#160;executed,&#160;rather&#160;than<br/>evaluated.&#160;In&#160;Ruby,&#160;there&#160;is&#160;no&#160;clear&#160;distinction&#160;between&#160;statements&#160;and&#160;expressions;<br/>everything&#160;in&#160;Ruby,&#160;including&#160;class&#160;and&#160;method&#160;definitions,&#160;can&#160;be&#160;evaluated&#160;as&#160;an<br/>expression&#160;and&#160;will&#160;return&#160;a&#160;value.&#160;It&#160;is&#160;still&#160;useful,&#160;however,&#160;to&#160;distinguish&#160;syntax&#160;typ-<br/>ically&#160;used&#160;as&#160;expressions&#160;from&#160;syntax&#160;typically&#160;used&#160;as&#160;statements.&#160;Ruby&#160;expressions<br/>that&#160;affect&#160;flow-of-control&#160;are&#160;documented&#160;<a href="Rubys.html#131">in&#160;Chapter 5.&#160;</a>Ruby&#160;expressions&#160;that&#160;define<br/><a href="Rubys.html#189">methods and classes are covered in Chapters 6 and 7.<br/></a>This&#160;&#160;chapter&#160;&#160;covers&#160;&#160;the&#160;&#160;simpler,&#160;&#160;more&#160;&#160;traditional&#160;&#160;sort&#160;&#160;of&#160;&#160;expressions.&#160;&#160;The&#160;&#160;simplest<br/>expressions&#160;are&#160;literal&#160;values,&#160;which&#160;we&#160;already&#160;documented&#160;<a href="Rubys.html#55">in&#160;Chapter&#160;3.&#160;</a>This&#160;chapter<br/>explains&#160;&#160;variable&#160;&#160;and&#160;&#160;constant&#160;&#160;references,&#160;&#160;method&#160;&#160;invocations,&#160;&#160;assignment,&#160;&#160;and<br/>compound expressions created by combining smaller expressions with operators.<br/>
<b>4.1 &#160;Literals and Keyword Literals<br/></b>Literals&#160;are&#160;values&#160;such&#160;as&#160;1.0,&#160;'hello world', and&#160;[]&#160;that&#160;are&#160;embedded&#160;directly&#160;into<br/><a href="Rubys.html#39">your program text. We introduced them in&#160;Chapter 2</a>&#160;and documented them in detail<br/><a href="Rubys.html#55">in Chapter 3.<br/></a>It&#160;is&#160;worth&#160;noting&#160;that&#160;many&#160;literals,&#160;such&#160;as&#160;numbers,&#160;are&#160;primary&#160;expressions—the<br/>simplest&#160;possible&#160;expressions&#160;not&#160;composed&#160;of&#160;simpler&#160;expressions.&#160;Other&#160;literals,&#160;such<br/>as&#160;array&#160;and&#160;hash&#160;literals&#160;and&#160;double-quoted&#160;strings&#160;that&#160;use&#160;interpolation,&#160;include<br/>subexpressions and are therefore not primary expressions.<br/>Certain&#160;&#160;Ruby&#160;&#160;keywords&#160;&#160;are&#160;&#160;primary&#160;&#160;expressions&#160;&#160;and&#160;&#160;can&#160;&#160;be&#160;&#160;considered&#160;&#160;<i>keyword<br/>literals</i>&#160;or specialized forms of variable reference:<br/>
nil<br/>
Evaluates to the&#160;nil&#160;value, of class&#160;NilClass.<br/>
true<br/>
Evaluates to the singleton instance of class&#160;TrueClass, an object that represents the Boolean value&#160;true.<br/>
false<br/>
Evaluates to the singleton instance of class&#160;FalseClass, an object that represents the Boolean value<br/>false.<br/>
self<br/>
<a href="Rubys.html#227">Evaluates to the current object. (See Chapter 7 for more about&#160;</a>self.)<br/>
<b>86&#160;|&#160;Chapter 4:</b> <b>Expressions and Operators</b><br/>
<hr/>
<a name=101></a>__FILE__<br/>
Evaluates to a string that names the file that the Ruby interpreter is executing. This can be useful in error<br/>messages.<br/>
__LINE__<br/>
Evaluates to an integer that specifies the line number within&#160;__FILE__&#160;of the current line of code.<br/>
__ENCODING__<br/>
Evaluates to an&#160;Encoding&#160;object that specifies the encoding of the current file. (Ruby 1.9 only.)<br/>
<b>4.2 &#160;Variable References<br/></b>A&#160;<i>variable</i>&#160;is&#160;simply&#160;a&#160;name&#160;for&#160;a&#160;value.&#160;Variables&#160;are&#160;created&#160;and&#160;values&#160;assigned&#160;to<br/>them&#160;by&#160;assignment&#160;expressions,&#160;which&#160;are&#160;covered&#160;later&#160;in&#160;this&#160;chapter.&#160;When&#160;the<br/>name&#160;of&#160;a&#160;variable&#160;appears&#160;in&#160;a&#160;program&#160;anywhere&#160;other&#160;than&#160;the&#160;lefthand&#160;side&#160;of&#160;an<br/>assignment,&#160;&#160;it&#160;&#160;is&#160;&#160;a&#160;&#160;variable&#160;&#160;reference&#160;&#160;expression&#160;&#160;and&#160;&#160;evaluates&#160;&#160;to&#160;&#160;the&#160;&#160;value&#160;&#160;of&#160;&#160;the<br/>variable:<br/>
one = 1.0 &#160; &#160; # This is an assignment expression<br/>one &#160; &#160; &#160; &#160; &#160; # This variable reference expression evaluates to 1.0<br/>
As&#160;explained&#160;in&#160;<a href="Rubys.html#39">Chapter 2,&#160;</a>there&#160;are&#160;four&#160;kinds&#160;of&#160;variables&#160;in&#160;Ruby,&#160;and&#160;lexical&#160;rules<br/>govern&#160;their&#160;names.&#160;Variables&#160;that&#160;begin&#160;with&#160;$&#160;are&#160;global&#160;variables,&#160;visible&#160;throughout<br/>a&#160;Ruby&#160;program.&#160;Variables&#160;that&#160;begin&#160;with&#160;@&#160;and&#160;@@&#160;are&#160;instance&#160;variables&#160;and&#160;class<br/>variables, used in object-oriented programming and explained in&#160;<a href="Rubys.html#227">Chapter 7. And var-<br/></a>iables whose names begin with an underscore or a lowercase letter are local variables,<br/>defined&#160;only&#160;within&#160;the&#160;current&#160;method&#160;or&#160;block.&#160;<a href="Rubys.html#156">(See&#160;§5.4.3&#160;</a>for&#160;more&#160;about&#160;the&#160;scope<br/>of local variables.)<br/>Variables&#160;always&#160;have&#160;simple,&#160;unqualified&#160;names.&#160;If&#160;a&#160;.&#160;or&#160;::&#160;appears&#160;in&#160;an&#160;expression,<br/>then&#160;that&#160;expression&#160;is&#160;either&#160;a&#160;reference&#160;to&#160;a&#160;constant&#160;or&#160;a&#160;method&#160;invocation.&#160;For<br/>example,&#160;Math::PI&#160;is&#160;a&#160;reference&#160;to&#160;a&#160;constant,&#160;and&#160;the&#160;expression&#160;item.price&#160;is&#160;an<br/>invocation of the method named&#160;price&#160;on the value held by the variable&#160;item.<br/>The&#160;Ruby&#160;interpreter&#160;predefines&#160;a&#160;number&#160;of&#160;global&#160;variables&#160;when&#160;it&#160;starts&#160;up.&#160;See<br/><a href="Rubys.html#403">Chapter 10 for a list of these variables.</a><br/>
<b>4.2.1 &#160;Uninitialized Variables<br/></b>In&#160;general,&#160;you&#160;should&#160;always&#160;assign&#160;a&#160;value&#160;to,&#160;or&#160;<i>initialize</i>,&#160;your&#160;variables&#160;before&#160;using<br/>them&#160;in&#160;expressions.&#160;In&#160;some&#160;circumstances,&#160;however,&#160;Ruby&#160;will&#160;allow&#160;you&#160;to&#160;use&#160;var-<br/>iables&#160;that&#160;have&#160;not&#160;yet&#160;been&#160;initialized.&#160;The&#160;rules&#160;are&#160;different&#160;for&#160;different&#160;kinds&#160;of<br/>variables:<br/>
<i>Class variables</i><br/>
Class&#160;variables&#160;must&#160;always&#160;have&#160;a&#160;value&#160;assigned&#160;to&#160;them&#160;before&#160;they&#160;are&#160;used.<br/>Ruby raises a&#160;NameError&#160;if&#160;you&#160;refer&#160;to&#160;a&#160;class&#160;variable&#160;to&#160;which&#160;no&#160;value&#160;has&#160;been<br/>assigned.<br/>
<b>4.2 &#160;Variable References&#160;|&#160;87</b><br/>
<hr/>
<a name=102></a><i>Instance variables</i><br/>
If you&#160;refer&#160;to&#160;an&#160;uninitialized&#160;instance&#160;variable,&#160;Ruby&#160;returns&#160;nil.&#160;It&#160;is&#160;considered<br/>bad&#160;programming&#160;to&#160;rely&#160;on&#160;this&#160;behavior,&#160;however.&#160;Ruby&#160;will&#160;issue&#160;a&#160;warning<br/>about the uninitialized variable if you run it with the&#160;-w&#160;option.<br/>
<i>Global variables</i><br/>
Uninitialized&#160;global&#160;variables&#160;are&#160;like&#160;uninitialized&#160;instance&#160;variables:&#160;they&#160;evaluate<br/>to&#160;nil, but cause a warning when Ruby is run with the&#160;-w&#160;flag.<br/>
<i>Local variables</i><br/>
This case&#160;is&#160;more&#160;complicated&#160;than&#160;the&#160;others&#160;because&#160;local&#160;variables&#160;don’t&#160;have<br/>a&#160;punctuation&#160;character&#160;as&#160;a&#160;prefix.&#160;This&#160;means&#160;that&#160;local&#160;variable&#160;references&#160;look<br/>just&#160;&#160;like&#160;&#160;method&#160;&#160;invocation&#160;&#160;expressions.&#160;&#160;If&#160;&#160;the&#160;&#160;Ruby&#160;&#160;interpreter&#160;&#160;has&#160;&#160;seen&#160;&#160;an<br/>assignment&#160;to&#160;a&#160;local&#160;variable,&#160;it&#160;knows&#160;it&#160;is&#160;a&#160;variable&#160;and&#160;not&#160;a&#160;method,&#160;and&#160;it<br/>can&#160;return&#160;the&#160;value&#160;of&#160;the&#160;variable.&#160;If&#160;there&#160;has&#160;been&#160;no&#160;assignment,&#160;then&#160;Ruby<br/>treats&#160;the&#160;expression&#160;as&#160;a&#160;method&#160;invocation.&#160;If&#160;no&#160;method&#160;by&#160;that&#160;name&#160;exists,<br/>Ruby raises a&#160;NameError.<br/>In&#160;general,&#160;therefore,&#160;attempting&#160;to&#160;use&#160;a&#160;local&#160;variable&#160;before&#160;it&#160;has&#160;been&#160;initialized<br/>results&#160;in&#160;an&#160;error.&#160;There&#160;is&#160;one&#160;quirk—a&#160;variable&#160;comes&#160;into&#160;existence&#160;when&#160;the<br/>Ruby&#160;interpreter&#160;sees&#160;an&#160;assignment&#160;expression&#160;for&#160;that&#160;variable.&#160;This&#160;is&#160;the&#160;case<br/>even if that assignment is not actually executed. A variable that exists but has not<br/>been assigned a value is given the default value&#160;nil. For example:<br/>
a = 0.0 if false &#160; &#160;# This assignment is never executed<br/>print a &#160; &#160; &#160; &#160; &#160; &#160; # Prints nil: the variable exists but is not assigned<br/>print b &#160; &#160; &#160; &#160; &#160; &#160; # NameError: no variable or method named b exists<br/>
<b>4.3 &#160;Constant References<br/></b>A&#160;constant&#160;in&#160;Ruby&#160;is&#160;like&#160;a&#160;variable,&#160;except&#160;that&#160;its&#160;value&#160;is&#160;supposed&#160;to&#160;remain&#160;constant<br/>for&#160;the&#160;duration&#160;of&#160;a&#160;program.&#160;The&#160;Ruby&#160;interpreter&#160;does&#160;not&#160;actually&#160;enforce&#160;the&#160;con-<br/>stancy&#160;of&#160;constants,&#160;but&#160;it&#160;does&#160;issue&#160;a&#160;warning&#160;if&#160;a&#160;program&#160;changes&#160;the&#160;value&#160;of&#160;a<br/>constant.&#160;Lexically,&#160;the&#160;names&#160;of&#160;constants&#160;look&#160;like&#160;the&#160;names&#160;of&#160;local&#160;variables,&#160;except<br/>that&#160;they&#160;begin&#160;with&#160;a&#160;capital&#160;letter.&#160;By&#160;convention,&#160;most&#160;constants&#160;are&#160;written&#160;in&#160;all<br/>uppercase&#160;&#160;with&#160;&#160;underscores&#160;&#160;to&#160;&#160;separate&#160;&#160;words,&#160;&#160;LIKE_THIS.&#160;&#160;Ruby&#160;&#160;class&#160;&#160;and&#160;&#160;module<br/>names&#160;are&#160;also&#160;constants,&#160;but&#160;they&#160;are&#160;conventionally&#160;written&#160;using&#160;initial&#160;capital&#160;letters<br/>and camel case,&#160;LikeThis.<br/>Although&#160;constants&#160;look&#160;like&#160;local&#160;variables&#160;with&#160;capital&#160;letters,&#160;they&#160;have&#160;the&#160;visibility<br/>of&#160;global&#160;variables:&#160;they&#160;can&#160;be&#160;used&#160;anywhere&#160;in&#160;a&#160;Ruby&#160;program&#160;without&#160;regard&#160;to<br/>scope.&#160;&#160;Unlike&#160;&#160;global&#160;&#160;variables,&#160;&#160;however,&#160;&#160;constants&#160;&#160;can&#160;&#160;be&#160;&#160;defined&#160;&#160;by&#160;&#160;classes&#160;&#160;and<br/>modules and can therefore have qualified names.<br/>A&#160;constant&#160;reference&#160;is&#160;an&#160;expression&#160;that&#160;evaluates&#160;to&#160;the&#160;value&#160;of&#160;the&#160;named&#160;constant.<br/>The&#160;simplest&#160;constant&#160;references&#160;are&#160;primary&#160;expressions—they&#160;consist&#160;simply&#160;of&#160;the<br/>name of the constant:<br/>
<b>88&#160;|&#160;Chapter 4:</b> <b>Expressions and Operators</b><br/>
<hr/>
<a name=103></a>CM_PER_INCH = 2.54 &#160;# Define a constant.<br/>CM_PER_INCH &#160; &#160; &#160; &#160; # Refer to the constant. Evaluates to 2.54.<br/>
In&#160;addition&#160;to&#160;simple&#160;references&#160;like&#160;this&#160;one,&#160;constant&#160;references&#160;can&#160;also&#160;be&#160;compound<br/>expressions.&#160;In&#160;this&#160;case,&#160;::&#160;is&#160;used&#160;to&#160;separate&#160;the&#160;name&#160;of&#160;the&#160;constant&#160;from&#160;the&#160;class<br/>or&#160;module&#160;in&#160;which&#160;it&#160;is&#160;defined.&#160;The&#160;lefthand&#160;side&#160;of&#160;the&#160;::&#160;may&#160;be&#160;an&#160;arbitrary&#160;ex-<br/>pression&#160;that&#160;evaluates&#160;to&#160;a&#160;class&#160;or&#160;module&#160;object.&#160;(Usually,&#160;however,&#160;this&#160;expression<br/>is&#160;a&#160;simple&#160;constant&#160;reference&#160;that&#160;just&#160;names&#160;the&#160;class&#160;or&#160;module.)&#160;The&#160;righthand&#160;side<br/>of the&#160;::&#160;is the name of a constant defined by the class or module. For example:<br/>
Conversions::CM_PER_INCH # Constant defined in the Conversions module<br/>modules[0]::NAME &#160; &#160; &#160; &#160; # Constant defined by an element of an array<br/>
Modules&#160;may&#160;be&#160;nested,&#160;which&#160;means&#160;that&#160;constants&#160;may&#160;be&#160;defined&#160;in&#160;nested&#160;name-<br/>spaces like this:<br/>
Conversions::Area::HECTARES_PER_ACRE<br/>
The&#160;lefthand&#160;side&#160;of&#160;the&#160;::&#160;may&#160;be&#160;omitted,&#160;in&#160;which&#160;case&#160;the&#160;constant&#160;is&#160;looked&#160;up&#160;in<br/>the global scope:<br/>
::ARGV &#160; &#160; &#160;# The global constant ARGV<br/>
Note&#160;that&#160;there&#160;is&#160;not&#160;actually&#160;a&#160;“global&#160;scope”&#160;for&#160;constants.&#160;Like&#160;global&#160;functions,<br/>global&#160;&#160;constants&#160;&#160;are&#160;&#160;defined&#160;&#160;(and&#160;&#160;looked&#160;&#160;up)&#160;&#160;within&#160;&#160;the&#160;&#160;Object&#160;&#160;class.&#160;&#160;The<br/>expression&#160;::ARGV, therefore, is simply shorthand for&#160;Object::ARGV.<br/>When&#160;a&#160;constant&#160;reference&#160;expression&#160;is&#160;qualified&#160;with&#160;a&#160;::,&#160;Ruby&#160;knows&#160;exactly&#160;where<br/>to&#160;look&#160;up&#160;the&#160;specified&#160;constant.&#160;When&#160;there&#160;is&#160;no&#160;qualifying&#160;::,&#160;however,&#160;the&#160;Ruby<br/>interpreter&#160;must&#160;search&#160;for&#160;an&#160;appropriate&#160;definition&#160;of&#160;the&#160;constant.&#160;It&#160;searches&#160;the<br/>lexically&#160;enclosing&#160;scope&#160;as&#160;well&#160;as&#160;the&#160;inheritance&#160;hierarchy&#160;of&#160;the&#160;enclosing&#160;class&#160;or<br/><a href="Rubys.html#275">module. Complete details are in §7.9.</a><br/>
&#160;<br/>
When&#160;Ruby&#160;evaluates&#160;a&#160;constant&#160;reference&#160;expression,&#160;it&#160;returns&#160;the&#160;value&#160;of&#160;the&#160;con-<br/>stant,&#160;or&#160;it&#160;raises&#160;a&#160;NameError&#160;exception&#160;if&#160;no&#160;constant&#160;by&#160;that&#160;name&#160;could&#160;be&#160;found.<br/>Note&#160;that&#160;constants&#160;do&#160;not&#160;exist&#160;until&#160;a&#160;value&#160;is&#160;actually&#160;assigned&#160;to&#160;them.&#160;This&#160;is&#160;unlike<br/>variables&#160;that&#160;can&#160;come&#160;into&#160;existence&#160;when&#160;the&#160;interpreter&#160;sees,&#160;but&#160;does&#160;not&#160;execute,<br/>an assignment.<br/>The&#160;Ruby&#160;interpreter&#160;predefines&#160;some&#160;constants&#160;when&#160;it&#160;starts&#160;up.&#160;See&#160;<a href="Rubys.html#403">Chapter 10</a>&#160;for<br/>a list.<br/>
<b>4.4 &#160;Method Invocations<br/></b>A method invocation expression has four parts:<br/>
•&#160;An&#160;arbitrary&#160;expression&#160;whose&#160;value&#160;is&#160;the&#160;object&#160;on&#160;which&#160;the&#160;method&#160;is&#160;invoked.<br/>
This&#160;expression&#160;is&#160;followed&#160;by&#160;.&#160;or&#160;::&#160;to&#160;separate&#160;it&#160;from&#160;the&#160;method&#160;name&#160;that<br/>follows.&#160;&#160;The&#160;&#160;expression&#160;&#160;and&#160;&#160;separator&#160;&#160;are&#160;&#160;optional;&#160;&#160;if&#160;&#160;omitted,&#160;&#160;the&#160;&#160;method&#160;&#160;is<br/>invoked on&#160;self.<br/>
<b>4.4 &#160;Method Invocations&#160;|&#160;89</b><br/>
<hr/>
<a name=104></a>•&#160;The&#160;name&#160;of&#160;the&#160;method&#160;being&#160;invoked.&#160;This&#160;is&#160;the&#160;only&#160;required&#160;piece&#160;of&#160;a&#160;method<br/>
invocation expression.<br/>
•&#160;The&#160;argument&#160;values&#160;being&#160;passed&#160;to&#160;the&#160;method.&#160;The&#160;list&#160;of&#160;arguments&#160;may&#160;be<br/>
enclosed&#160;in&#160;parentheses,&#160;but&#160;these&#160;are&#160;usually&#160;optional.&#160;(Optional&#160;and&#160;required<br/>parentheses&#160;are&#160;discussed&#160;in&#160;detail&#160;in&#160;<a href="Rubys.html#197">§6.3.)&#160;</a>If&#160;there&#160;is&#160;more&#160;than&#160;one&#160;argument,<br/>they&#160;are&#160;separated&#160;from&#160;each&#160;other&#160;with&#160;commas.&#160;The&#160;number&#160;and&#160;type&#160;of&#160;argu-<br/>ments&#160;&#160;required&#160;&#160;depend&#160;&#160;on&#160;&#160;the&#160;&#160;method&#160;&#160;definition.&#160;&#160;Some&#160;&#160;methods&#160;&#160;expect&#160;&#160;no<br/>arguments.<br/>
•&#160;An&#160;optional&#160;block&#160;of&#160;code&#160;delimited&#160;by&#160;curly&#160;braces&#160;or&#160;by&#160;a&#160;do/end&#160;pair.&#160;The&#160;method<br/>
may&#160;invoke&#160;this&#160;code&#160;using&#160;the&#160;yield&#160;keyword.&#160;This&#160;ability&#160;to&#160;associate&#160;arbitrary<br/>code&#160;with&#160;any&#160;method&#160;invocation&#160;is&#160;the&#160;basis&#160;for&#160;Ruby’s&#160;powerful&#160;iterator&#160;methods.<br/>We’ll&#160;learn&#160;much&#160;more&#160;about&#160;blocks&#160;associated&#160;with&#160;method&#160;invocations&#160;in&#160;<a href="Rubys.html#144">§5.3<br/></a><a href="Rubys.html#154">and §5.4.</a><br/>
A&#160;&#160;method&#160;&#160;name&#160;&#160;is&#160;&#160;usually&#160;&#160;separated&#160;&#160;from&#160;&#160;the&#160;&#160;object&#160;&#160;on&#160;&#160;which&#160;&#160;it&#160;&#160;is&#160;&#160;invoked&#160;&#160;with<br/>a&#160;..&#160;::&#160;is&#160;also&#160;allowed,&#160;but&#160;it&#160;is&#160;rarely&#160;used&#160;because&#160;it&#160;can&#160;make&#160;method&#160;invocations<br/>look more like constant reference expressions.<br/>When&#160;the&#160;Ruby&#160;interpreter&#160;has&#160;the&#160;name&#160;of&#160;a&#160;method&#160;and&#160;an&#160;object&#160;on&#160;which&#160;it&#160;is&#160;to<br/>be&#160;invoked,&#160;it&#160;finds&#160;the&#160;appropriate&#160;definition&#160;of&#160;that&#160;named&#160;method&#160;using&#160;a&#160;process<br/>known&#160;&#160;as&#160;&#160;“method&#160;&#160;lookup”&#160;&#160;or&#160;&#160;“method&#160;&#160;name&#160;&#160;resolution.”&#160;&#160;The&#160;&#160;details&#160;&#160;are&#160;&#160;not<br/><a href="Rubys.html#272">important here, but they are explained thoroughly in §7.8.<br/></a>The&#160;value&#160;of&#160;a&#160;method&#160;invocation&#160;expression&#160;is&#160;the&#160;value&#160;of&#160;the&#160;last&#160;evaluated&#160;expression<br/>in the body of the method. We’ll have more to say about method definitions, method<br/>invocations,&#160;and&#160;method&#160;return&#160;values&#160;<a href="Rubys.html#189">in&#160;Chapter&#160;6.&#160;</a>Here,&#160;however,&#160;are&#160;some&#160;examples<br/>of method invocations:<br/>
puts &#34;hello world&#34; &#160;# &#34;puts&#34; invoked on self, with one string arg<br/>Math.sqrt(2) &#160; &#160; &#160; &#160;# &#34;sqrt&#34; invoked on object Math with one arg<br/>message.length &#160; &#160; &#160;# &#34;length&#34; invoked on object message; no args<br/>a.each {|x| p x } &#160; # &#34;each&#34; invoked on object a, with an associated block<br/>
<b>Invoking Global Functions</b><br/>
Look again at this method invocation shown earlier:<br/>
puts &#34;hello world&#34;<br/>
This&#160;is&#160;an&#160;invocation&#160;of&#160;the&#160;Kernel&#160;method&#160;puts.&#160;Methods&#160;defined&#160;by&#160;Kernel&#160;are&#160;global<br/>functions,&#160;as&#160;are&#160;any&#160;methods&#160;defined&#160;at&#160;the&#160;top-level,&#160;outside&#160;of&#160;any&#160;classes.&#160;Global<br/>functions&#160;are&#160;defined&#160;as&#160;private&#160;methods&#160;of&#160;the&#160;Object&#160;class. We’ll learn about private<br/>methods&#160;in&#160;<a href="Rubys.html#227">Chapter&#160;7.&#160;</a>For&#160;now,&#160;you&#160;just&#160;need&#160;to&#160;know&#160;that&#160;private&#160;methods&#160;are&#160;not<br/>allowed&#160;to&#160;be&#160;explicitly&#160;invoked&#160;on&#160;a&#160;receiver&#160;object—they&#160;are&#160;always&#160;implicitly&#160;in-<br/>voked on&#160;self.&#160;self&#160;is&#160;always&#160;defined,&#160;and&#160;no&#160;matter&#160;what&#160;its&#160;value&#160;is,&#160;that&#160;value&#160;is&#160;an<br/>Object. Because global functions are methods of&#160;Object, these methods can always be<br/>invoked (implicitly) in any context, regardless of the value of&#160;self.<br/>
<b>90&#160;|&#160;Chapter 4:</b> <b>Expressions and Operators</b><br/>
<hr/>
<a name=105></a>One&#160;of&#160;the&#160;method&#160;invocation&#160;examples&#160;shown&#160;earlier&#160;was&#160;message.length.&#160;You&#160;may<br/>be&#160;tempted&#160;to&#160;think&#160;of&#160;it&#160;as&#160;a&#160;variable&#160;reference&#160;expression,&#160;evaluating&#160;to&#160;the&#160;value&#160;of<br/>the&#160;variable&#160;length&#160;in&#160;the&#160;object&#160;message.&#160;This&#160;is&#160;not&#160;the&#160;case,&#160;however.&#160;Ruby&#160;has&#160;a&#160;very<br/>pure&#160;object-oriented&#160;programming&#160;model:&#160;Ruby&#160;objects&#160;may&#160;encapsulate&#160;any&#160;number<br/>of internal instance variables, but they expose only methods to the outside world. Be-<br/>cause&#160;&#160;the&#160;&#160;length&#160;&#160;method&#160;&#160;expects&#160;&#160;no&#160;&#160;arguments&#160;&#160;and&#160;&#160;is&#160;&#160;invoked&#160;&#160;without&#160;&#160;optional<br/>parentheses,&#160;it&#160;looks&#160;like&#160;a&#160;variable&#160;reference.&#160;In&#160;fact,&#160;this&#160;is&#160;intentional.&#160;Methods&#160;like<br/>these&#160;are&#160;called&#160;attribute&#160;accessor&#160;methods,&#160;and&#160;we&#160;say&#160;that&#160;the&#160;message&#160;object&#160;has&#160;a<br/>length&#160;attribute.*&#160;&#160;As&#160;we’ll&#160;see,&#160;it&#160;is&#160;possible&#160;for&#160;the&#160;message&#160;object&#160;to&#160;define&#160;a&#160;method<br/>named&#160;length=.&#160;If&#160;this&#160;method&#160;expects&#160;a&#160;single&#160;argument,&#160;then&#160;it&#160;is&#160;an&#160;attribute&#160;setter<br/>method&#160;and&#160;Ruby&#160;invokes&#160;it&#160;in&#160;response&#160;to&#160;assignment.&#160;If&#160;such&#160;a&#160;method&#160;is&#160;defined,<br/>then these two lines of code would both invoke the same method:<br/>
message.length=(3) &#160; &#160;# Traditional method invocation<br/>message.length = 3 &#160; &#160;# Method invocation masquerading as assignment<br/>
Now consider the following line of code, assuming that the variable&#160;a&#160;holds an array:<br/>
a[0]<br/>
You&#160;might&#160;again&#160;think&#160;that&#160;this&#160;is&#160;a&#160;special&#160;kind&#160;of&#160;variable&#160;reference&#160;expression,&#160;where<br/>the&#160;variable&#160;in&#160;question&#160;is&#160;actually&#160;an&#160;array&#160;element.&#160;Again,&#160;however,&#160;this&#160;is&#160;method<br/>invocation. The Ruby interpreter converts the array access into this:<br/>
a.[](0)<br/>
The&#160;array&#160;access&#160;becomes&#160;an&#160;invocation&#160;of&#160;the&#160;method&#160;named&#160;[]&#160;on&#160;the&#160;array,&#160;with&#160;the<br/>array&#160;index&#160;as&#160;its&#160;argument.&#160;This&#160;array&#160;access&#160;syntax&#160;is&#160;not&#160;limited&#160;to&#160;arrays.&#160;Any&#160;object<br/>is&#160;allowed&#160;to&#160;define&#160;a&#160;method&#160;named&#160;[].&#160;When&#160;the&#160;object&#160;is&#160;“indexed”&#160;with&#160;square<br/>brackets,&#160;any&#160;values&#160;within&#160;the&#160;brackets&#160;will&#160;be&#160;passed&#160;to&#160;the&#160;method.&#160;If&#160;the&#160;[]&#160;method<br/>is&#160;&#160;written&#160;&#160;to&#160;&#160;expect&#160;&#160;three&#160;&#160;arguments,&#160;&#160;then&#160;&#160;you&#160;&#160;should&#160;&#160;put&#160;&#160;three&#160;&#160;comma-separated<br/>expressions within the square brackets.<br/>Assignment&#160;&#160;to&#160;&#160;arrays&#160;&#160;is&#160;&#160;also&#160;&#160;done&#160;&#160;via&#160;&#160;method&#160;&#160;invocation.&#160;&#160;If&#160;&#160;the&#160;&#160;object&#160;&#160;o&#160;&#160;defines&#160;&#160;a<br/>method&#160;named&#160;[]=,&#160;then&#160;the&#160;expression&#160;o[x]=y&#160;becomes&#160;o.[]=(x,y),&#160;and&#160;the&#160;expression<br/>o[x,y]=z&#160;becomes&#160;o.[]=(x,y,z).<br/>
We’ll&#160;see&#160;later&#160;in&#160;this&#160;chapter&#160;that&#160;many&#160;of&#160;Ruby’s&#160;operators&#160;are&#160;defined&#160;as&#160;methods,<br/>and&#160;expressions&#160;like&#160;x+y&#160;are&#160;evaluated&#160;as&#160;x.+(y),&#160;where&#160;the&#160;method&#160;name&#160;is&#160;+.&#160;The&#160;fact<br/>that&#160;many&#160;of&#160;Ruby’s&#160;operators&#160;are&#160;defined&#160;as&#160;methods&#160;means&#160;that&#160;you&#160;can&#160;redefine<br/>these operators in your own classes.<br/>Now let’s consider this very simple expression:<br/>
x<br/>
*&#160;This&#160;is&#160;not&#160;to&#160;say&#160;that&#160;every&#160;no-argument&#160;method&#160;is&#160;an&#160;attribute&#160;accessor.&#160;The&#160;sort&#160;method of an array, for<br/>
example, has no arguments, but it cannot be said to return an attribute value.<br/>
<b>4.4 &#160;Method Invocations&#160;|&#160;91</b><br/>
<hr/>
<a name=106></a>If&#160;a&#160;variable&#160;named&#160;x&#160;exists&#160;(that&#160;is,&#160;if&#160;the&#160;Ruby&#160;interpreter&#160;has&#160;seen&#160;an&#160;assignment&#160;to<br/>x),&#160;then&#160;this&#160;is&#160;a&#160;variable&#160;reference&#160;expression.&#160;If&#160;no&#160;such&#160;variable&#160;exists,&#160;then&#160;this&#160;is&#160;an<br/>invocation of the method&#160;x, with no arguments, on&#160;self.<br/>The&#160;Ruby-reserved&#160;word&#160;super&#160;is&#160;a&#160;special&#160;kind&#160;of&#160;method&#160;invocation&#160;expression.&#160;This<br/>keyword&#160;is&#160;used&#160;when&#160;creating&#160;a&#160;subclass&#160;of&#160;another&#160;class.&#160;By&#160;itself,&#160;super&#160;passes&#160;the<br/>arguments&#160;of&#160;the&#160;current&#160;method&#160;to&#160;the&#160;method&#160;with&#160;the&#160;same&#160;name&#160;in&#160;the&#160;superclass.<br/>It&#160;can&#160;also&#160;be&#160;used&#160;as&#160;if&#160;it&#160;were&#160;actually&#160;the&#160;name&#160;of&#160;a&#160;method&#160;and&#160;can&#160;be&#160;followed&#160;by<br/>an arbitrary argument list. The&#160;super<a href="Rubys.html#252">&#160;keyword is covered in detail in §7.3.3.</a><br/>
<b>4.5 &#160;Assignments<br/></b>An&#160;&#160;assignment&#160;&#160;expression&#160;&#160;specifies&#160;&#160;one&#160;&#160;or&#160;&#160;more&#160;&#160;values&#160;&#160;for&#160;&#160;one&#160;&#160;or&#160;&#160;more&#160;&#160;lvalues.<br/><i>lvalue</i>&#160;is&#160;the&#160;term&#160;for&#160;something&#160;that&#160;can&#160;appear&#160;on&#160;the&#160;lefthand&#160;side&#160;of&#160;an&#160;assignment<br/>operator.&#160;(Values&#160;on&#160;the&#160;righthand&#160;side&#160;of&#160;an&#160;assignment&#160;operator&#160;are&#160;sometimes&#160;called<br/><i>rvalues</i>&#160;by&#160;contrast.)&#160;Variables,&#160;constants,&#160;attributes,&#160;and&#160;array&#160;elements&#160;are&#160;lvalues&#160;in<br/>Ruby.&#160;The&#160;rules&#160;for&#160;and&#160;the&#160;meaning&#160;of&#160;assignment&#160;expressions&#160;are&#160;somewhat&#160;different<br/>for different kinds of lvalues, and each kind is described in detail in this section.<br/>There&#160;are&#160;three&#160;different&#160;forms&#160;of&#160;assignment&#160;expressions&#160;in&#160;Ruby.&#160;Simple&#160;assignment<br/>involves one lvalue, the&#160;=&#160;operator, and one rvalue. For example:<br/>
x = 1 &#160; &#160; # Set the lvalue x to the value 1<br/>
Abbreviated assignment is&#160;a&#160;shorthand&#160;expression&#160;that&#160;updates&#160;the&#160;value&#160;of&#160;a&#160;variable<br/>by&#160;applying&#160;some&#160;other&#160;operation&#160;(such&#160;as&#160;addition)&#160;to&#160;the&#160;current&#160;value&#160;of&#160;the&#160;variable.<br/>Abbreviated&#160;assignment&#160;uses&#160;assignment&#160;operators&#160;like&#160;+=&#160;and&#160;*=&#160;that&#160;combine&#160;binary<br/>operators with an equals sign:<br/>
x += 1 &#160; &#160;# Set the lvalue x to the value x + 1<br/>
Finally,&#160;parallel&#160;assignment&#160;is&#160;any&#160;assignment&#160;expression&#160;that&#160;has&#160;more&#160;than&#160;one&#160;lvalue<br/>or more than one rvalue. Here is a simple example:<br/>
x,y,z = 1,2,3 &#160; # Set x to 1, y to 2 and z to 3<br/>
Parallel&#160;assignment&#160;is&#160;more&#160;complicated&#160;when&#160;the&#160;number&#160;of&#160;lvalues&#160;is&#160;not&#160;the&#160;same<br/>as&#160;the&#160;number&#160;of&#160;rvalues&#160;or&#160;when&#160;there&#160;is&#160;an&#160;array&#160;on&#160;the&#160;right.&#160;Complete&#160;details&#160;follow.<br/>The&#160;value&#160;of&#160;an&#160;assignment&#160;expression&#160;is&#160;the&#160;value&#160;(or&#160;an&#160;array&#160;of&#160;the&#160;values)&#160;assigned.<br/>Also,&#160;the&#160;assignment&#160;operator&#160;is&#160;“right-associative”—if&#160;multiple&#160;assignments&#160;appear<br/>in&#160;a&#160;single&#160;expression,&#160;they&#160;are&#160;evaluated&#160;from&#160;right&#160;to&#160;left.&#160;This&#160;means&#160;that&#160;the&#160;assign-<br/>ment can be chained to assign the same value to multiple variables:<br/>
x = y = 0 &#160; # Set x and y to 0<br/>
Note&#160;that&#160;this&#160;is&#160;not&#160;a&#160;case&#160;of&#160;parallel&#160;assignment—it&#160;is&#160;two&#160;simple&#160;assignments,&#160;chained<br/>together:&#160;y&#160;is assigned the value&#160;0, and then&#160;x&#160;is assigned the value (also&#160;0) of that first<br/>assignment.<br/>
<b>92&#160;|&#160;Chapter 4:</b> <b>Expressions and Operators</b><br/>
<hr/>
<a name=107></a><b>Assignment and Side Effects</b><br/>
More&#160;important&#160;than&#160;the&#160;value&#160;of&#160;an&#160;assignment&#160;expression&#160;is&#160;the&#160;fact&#160;that&#160;assignments<br/>set&#160;the&#160;value&#160;of&#160;a&#160;variable&#160;(or&#160;other&#160;lvalue)&#160;and&#160;thereby&#160;affect&#160;program&#160;state.&#160;This&#160;effect<br/>on program state is called a&#160;<i>side effect</i>&#160;of the assignment.<br/>
Many&#160;expressions&#160;have&#160;no&#160;side&#160;effects&#160;and&#160;do&#160;not&#160;affect&#160;program&#160;state.&#160;They&#160;are&#160;<i>idem-<br/>potent</i>.&#160;This&#160;means&#160;that&#160;the&#160;expression&#160;may&#160;be&#160;evaluated&#160;over&#160;and&#160;over&#160;again&#160;and&#160;will<br/>return&#160;the&#160;same&#160;value&#160;each&#160;time.&#160;And&#160;it&#160;means&#160;that&#160;evaluating&#160;the&#160;expression&#160;has&#160;no<br/>effect&#160;on&#160;the&#160;value&#160;of&#160;other&#160;expressions.&#160;Here&#160;are&#160;some&#160;expressions&#160;without&#160;side&#160;effects:<br/>
x + y<br/>Math.sqrt(2)<br/>
It is important to understand that assignments are not idempotent:<br/>
x = 1 &#160; &#160; &#160; # Affects the value of other expressions that use x<br/>x += 1 &#160; &#160; &#160;# Returns a different value each time it is evaluated<br/>
Some&#160;methods,&#160;such&#160;as&#160;Math.sqrt,&#160;are&#160;idempotent:&#160;they&#160;can&#160;be&#160;invoked&#160;without&#160;side<br/>effects.&#160;Other&#160;methods&#160;are&#160;not,&#160;and&#160;this&#160;largely&#160;depends&#160;on&#160;whether&#160;those&#160;methods<br/>perform assignments to nonlocal variables.<br/>
<b>4.5.1 &#160;Assigning to Variables<br/></b>When&#160;we&#160;think&#160;of&#160;assignment,&#160;we&#160;usually&#160;think&#160;of&#160;variables,&#160;and&#160;indeed,&#160;these&#160;are&#160;the<br/>most&#160;common&#160;lvalues&#160;in&#160;assignment&#160;expressions.&#160;Recall&#160;that&#160;Ruby&#160;has&#160;four&#160;kinds&#160;of<br/>variables:&#160;local&#160;variables,&#160;global&#160;variables,&#160;instance&#160;variables,&#160;and&#160;class&#160;variables.&#160;These<br/>are&#160;distinguished&#160;from&#160;each&#160;other&#160;by&#160;the&#160;first&#160;character&#160;in&#160;the&#160;variable&#160;name.&#160;Assign-<br/>ment&#160;works&#160;the&#160;same&#160;for&#160;all&#160;four&#160;kinds&#160;of&#160;variables,&#160;so&#160;we&#160;do&#160;not&#160;need&#160;to&#160;distinguish<br/>between the types of variables here.<br/>Keep&#160;in&#160;mind&#160;that&#160;the&#160;instance&#160;variables&#160;of&#160;Ruby’s&#160;objects&#160;are&#160;never&#160;visible&#160;outside&#160;of<br/>the&#160;object,&#160;and&#160;variable&#160;names&#160;are&#160;never&#160;qualified&#160;with&#160;an&#160;object&#160;name.&#160;Consider&#160;this<br/>assignment:<br/>
point.x, point.y = 1, 2<br/>
The&#160;lvalues&#160;in&#160;this&#160;expression&#160;are&#160;not&#160;variables;&#160;they&#160;are&#160;attributes,&#160;and&#160;are&#160;explained<br/>shortly.<br/>Assignment&#160;to&#160;a&#160;variable&#160;works&#160;as&#160;you&#160;would&#160;expect:&#160;the&#160;variable&#160;is&#160;simply&#160;set&#160;to&#160;the<br/>specified&#160;value.&#160;The&#160;only&#160;wrinkle&#160;has&#160;to&#160;do&#160;with&#160;variable&#160;declaration&#160;and&#160;an&#160;ambiguity<br/>between&#160;local&#160;variable&#160;names&#160;and&#160;method&#160;names.&#160;Ruby&#160;has&#160;no&#160;syntax&#160;to&#160;explicitly<br/>declare&#160;a&#160;variable:&#160;variables&#160;simply&#160;come&#160;into&#160;existence&#160;when&#160;they&#160;are&#160;assigned.&#160;Also,<br/>local&#160;variable&#160;names&#160;and&#160;method&#160;names&#160;look&#160;the&#160;same—there&#160;is&#160;no&#160;prefix&#160;like&#160;$&#160;to<br/>distinguish&#160;them.&#160;Thus,&#160;a&#160;simple&#160;expression&#160;such&#160;as&#160;x&#160;could&#160;refer&#160;to&#160;a&#160;local&#160;variable<br/>named&#160;x&#160;or&#160;a&#160;method&#160;of&#160;self&#160;named&#160;x.&#160;To&#160;resolve&#160;this&#160;ambiguity,&#160;Ruby&#160;treats&#160;an&#160;iden-<br/>tifier&#160;as&#160;a&#160;local&#160;variable&#160;if&#160;it&#160;has&#160;seen&#160;any&#160;previous&#160;assignment&#160;to&#160;the&#160;variable.&#160;It&#160;does<br/>this even if that assignment was never executed. The following code demonstrates:<br/>
<b>4.5 &#160;Assignments&#160;|&#160;93</b><br/>
<hr/>
<a name=108></a>class Ambiguous<br/>&#160; def x; 1; end # A method named &#34;x&#34;. Always returns 1<br/>
&#160; def test<br/>&#160; &#160; puts x &#160; &#160; &#160;# No variable has been seen; refers to method above: prints 1<br/>
&#160; &#160; # The line below is never evaluated, because of the &#34;if false&#34; clause. But<br/>&#160; &#160; # the parser sees it and treats x as a variable for the rest of the method.<br/>&#160; &#160; x = 0 if false<br/>
&#160; &#160; puts x &#160; &#160;# x is a variable, but has never been assigned to: prints nil<br/>
&#160; &#160; x = 2 &#160; &#160; # This assignment does get evaluated<br/>&#160; &#160; puts x &#160; &#160;# So now this line prints 2<br/>&#160; end<br/>end<br/>
<b>4.5.2 &#160;Assigning to Constants<br/></b>Constants&#160;are&#160;different&#160;from&#160;variables&#160;in&#160;an&#160;obvious&#160;way:&#160;their&#160;values&#160;are&#160;intended&#160;to<br/>remain&#160;constant&#160;throughout&#160;the&#160;execution&#160;of&#160;a&#160;program.&#160;Therefore,&#160;there&#160;are&#160;some<br/>special rules for assignment to constants:<br/>
•&#160;Assignment&#160;to&#160;a&#160;constant&#160;that&#160;already&#160;exists&#160;causes&#160;Ruby&#160;to&#160;issue&#160;a&#160;warning.&#160;Ruby<br/>
does execute the assignment, however, which means that constants are not really<br/>constant.<br/>
•&#160;Assignment&#160;to&#160;constants&#160;is&#160;not&#160;allowed&#160;within&#160;the&#160;body&#160;of&#160;a&#160;method.&#160;Ruby&#160;assumes<br/>
that methods are intended to be invoked more than once; if you could assign to a<br/>constant&#160;in&#160;a&#160;method,&#160;that&#160;method&#160;would&#160;issue&#160;warnings&#160;on&#160;every&#160;invocation&#160;after<br/>the first. So, this is simply not allowed.<br/>
Unlike&#160;&#160;variables,&#160;&#160;constants&#160;&#160;do&#160;&#160;not&#160;&#160;come&#160;&#160;into&#160;&#160;existence&#160;&#160;until&#160;&#160;the&#160;&#160;Ruby&#160;&#160;interpreter<br/>actually&#160;&#160;executes&#160;&#160;the&#160;&#160;assignment&#160;&#160;expression.&#160;&#160;A&#160;&#160;nonevaluated&#160;&#160;expression&#160;&#160;like&#160;&#160;the<br/>following does&#160;<i>not</i>&#160;create a constant:<br/>
N = 100 if false<br/>
Note&#160;that&#160;this&#160;means&#160;a&#160;constant&#160;is&#160;never&#160;in&#160;an&#160;uninitialized&#160;state.&#160;If&#160;a&#160;constant&#160;exists,<br/>then&#160;it&#160;has&#160;a&#160;value&#160;assigned&#160;to&#160;it.&#160;A&#160;constant&#160;will&#160;only&#160;have&#160;the&#160;value&#160;nil&#160;if&#160;that&#160;is&#160;actually<br/>the value it was given.<br/>
<b>4.5.3 &#160;Assigning to Attributes and Array Elements<br/></b>Assignment&#160;to&#160;an&#160;attribute&#160;or&#160;array&#160;element&#160;is&#160;actually&#160;Ruby&#160;shorthand&#160;for&#160;method<br/>invocation.&#160;Suppose&#160;an&#160;object&#160;o&#160;has&#160;a&#160;method&#160;named&#160;m=:&#160;the&#160;method&#160;name&#160;has&#160;an&#160;equals<br/>sign&#160;as&#160;its&#160;last&#160;character.&#160;Then&#160;o.m&#160;can&#160;be&#160;used&#160;as&#160;an&#160;lvalue&#160;in&#160;an&#160;assignment&#160;expression.<br/>Suppose, furthermore, that the value&#160;v&#160;is assigned:<br/>
o.m = v<br/>
<b>94&#160;|&#160;Chapter 4:</b> <b>Expressions and Operators</b><br/>
<hr/>
<a name=109></a>The Ruby interpreter converts this assignment to the following method invocation:<br/>
o.m=(v) &#160;# If we omit the parens and add a space, this looks like assignment!<br/>
That is, it passes the value&#160;v&#160;to the method&#160;m=. That method can do whatever it wants<br/>with&#160;the&#160;value.&#160;Typically,&#160;it&#160;will&#160;check&#160;that&#160;the&#160;value&#160;is&#160;of&#160;the&#160;desired&#160;type&#160;and&#160;within<br/>the&#160;desired&#160;range,&#160;and&#160;it&#160;will&#160;then&#160;store&#160;it&#160;in&#160;an&#160;instance&#160;variable&#160;of&#160;the&#160;object.&#160;Methods<br/>like&#160;m=&#160;are&#160;usually&#160;accompanied&#160;by&#160;a&#160;method&#160;m,&#160;which&#160;simply&#160;returns&#160;the&#160;value&#160;most<br/>recently&#160;passed&#160;to&#160;m=.&#160;We&#160;say&#160;that&#160;m=&#160;is&#160;a&#160;<i>setter</i>&#160;method&#160;and&#160;m&#160;is&#160;a&#160;<i>getter</i>&#160;method.&#160;When<br/>an&#160;object&#160;has&#160;this&#160;pair&#160;of&#160;methods,&#160;we&#160;say&#160;that&#160;it&#160;has&#160;an&#160;attribute&#160;m.&#160;Attributes&#160;are<br/>sometimes&#160;called&#160;“properties”&#160;in&#160;other&#160;languages.&#160;We’ll&#160;learn&#160;more&#160;about&#160;attributes&#160;in<br/><a href="Rubys.html#231">Ruby in §7.1.5.<br/></a>Assigning&#160;values&#160;to&#160;array&#160;elements&#160;is&#160;also&#160;done&#160;by&#160;method&#160;invocation.&#160;If&#160;an&#160;object&#160;o<br/>defines&#160;a&#160;method&#160;named&#160;[]=&#160;(the&#160;method&#160;name&#160;is&#160;just&#160;those&#160;three&#160;punctuation&#160;char-<br/>acters)&#160;that&#160;expects&#160;two&#160;arguments,&#160;then&#160;the&#160;expression&#160;o[x] = y&#160;is&#160;actually&#160;executed&#160;as:<br/>
o.[]=(x,y)<br/>
If&#160;an&#160;object&#160;has&#160;a&#160;[]=&#160;method&#160;that&#160;expects&#160;three&#160;arguments,&#160;then&#160;it&#160;can&#160;be&#160;indexed&#160;with<br/>two&#160;values&#160;between&#160;the&#160;square&#160;brackets.&#160;The&#160;following&#160;two&#160;expressions&#160;are&#160;equivalent<br/>in this case:<br/>
o[x,y] = z<br/>o.[]=(x,y,z)<br/>
<b>4.5.4 &#160;Abbreviated Assignment<br/></b>Abbreviated assignment is&#160;a&#160;form&#160;of&#160;assignment&#160;that&#160;combines&#160;assignment&#160;with&#160;some<br/>other operation. It is used most commonly to increment variables:<br/>
x += 1<br/>
+=&#160;is&#160;not&#160;a&#160;real&#160;Ruby&#160;operator,&#160;and&#160;the&#160;expression&#160;above&#160;is&#160;simply&#160;an&#160;abbreviation&#160;for:<br/>
x = x + 1<br/>
Abbreviated&#160;assignment&#160;cannot&#160;be&#160;combined&#160;with&#160;parallel&#160;assignment:&#160;it&#160;only&#160;works<br/>when&#160;there&#160;is&#160;a&#160;single&#160;lvalue&#160;on&#160;the&#160;left&#160;and&#160;a&#160;single&#160;value&#160;on&#160;the&#160;right.&#160;It&#160;should&#160;not&#160;be<br/>used&#160;when&#160;the&#160;lvalue&#160;is&#160;a&#160;constant&#160;because&#160;it&#160;will&#160;reassign&#160;the&#160;constant&#160;and&#160;cause&#160;a<br/>warning.&#160;Abbreviated&#160;assignment&#160;can,&#160;however,&#160;be&#160;used&#160;when&#160;the&#160;lvalue&#160;is&#160;an&#160;attribute.<br/>The following two expressions are equivalent:<br/>
o.m += 1<br/>o.m=(o.m()+1)<br/>
Abbreviated&#160;assignment&#160;even&#160;works&#160;when&#160;the&#160;lvalue&#160;is&#160;an&#160;array&#160;element.&#160;These&#160;two<br/>expressions are equivalent:<br/>
o[x] -= 2<br/>o.[]=(x, o.[](x) - 2)<br/>
<b>4.5 &#160;Assignments&#160;|&#160;95</b><br/>
<hr/>
<a name=110></a>Note that this code uses&#160;-=&#160;instead of&#160;+=. As you might expect, the&#160;-=&#160;pseudooperator<br/>subtracts its rvalue from its lvalue.<br/>In&#160;&#160;addition&#160;&#160;to&#160;&#160;+=&#160;&#160;and&#160;&#160;-=,&#160;&#160;there&#160;&#160;are&#160;&#160;11&#160;&#160;other&#160;&#160;pseudooperators&#160;&#160;that&#160;&#160;can&#160;&#160;be&#160;&#160;used&#160;&#160;for<br/>abbreviated&#160;assignment.&#160;They&#160;are&#160;listed&#160;in&#160;<a href="Rubys.html#110">Table 4-1</a>.&#160;Note&#160;that&#160;these&#160;are&#160;not&#160;true&#160;op-<br/>erators&#160;themselves,&#160;they&#160;are&#160;simply&#160;shorthand&#160;for&#160;expressions&#160;that&#160;use&#160;other&#160;operators.<br/>The&#160;meanings&#160;of&#160;those&#160;other&#160;operators&#160;are&#160;described&#160;in&#160;detail&#160;later&#160;in&#160;this&#160;chapter.&#160;Also,<br/>as&#160;we’ll&#160;see&#160;later,&#160;many&#160;of&#160;these&#160;other&#160;operators&#160;are&#160;defined&#160;as&#160;methods.&#160;If&#160;a&#160;class&#160;defines<br/>a&#160;&#160;method&#160;&#160;named&#160;&#160;+,&#160;&#160;for&#160;&#160;example,&#160;&#160;then&#160;&#160;that&#160;&#160;changes&#160;&#160;the&#160;&#160;meaning&#160;&#160;of&#160;&#160;abbreviated<br/>assignment with&#160;+=&#160;for all instances of that class.<br/>
<i>Table 4-1. Abbreviated assignment pseudooperators</i><br/>
<b>Assignment</b><br/>
<b>Expansion</b><br/>
x += y<br/>
x = x + y<br/>
x -= y<br/>
x = x - y<br/>
x *= y<br/>
x = x * y<br/>
x /= y<br/>
x = x / y<br/>
x %= y<br/>
x = x % y<br/>
x **= y<br/>
x = x ** y<br/>
x &amp;&amp;= y<br/>
x = x &amp;&amp; y<br/>
x ||= y<br/>
x = x || y<br/>
x &amp;= y<br/>
x = x &amp; y<br/>
x |= y<br/>
x = x | y<br/>
x ^= y<br/>
x = x ^ y<br/>
x &lt;&lt;= y<br/>
x = x &lt;&lt; y<br/>
x &gt;&gt;= y<br/>
x = x &gt;&gt; y<br/>
<b>The ||= Idiom</b><br/>
As&#160;noted&#160;at&#160;the&#160;beginning&#160;of&#160;this&#160;section,&#160;the&#160;most&#160;common&#160;use&#160;of&#160;abbreviated&#160;assign-<br/>ment&#160;is&#160;to&#160;increment&#160;a&#160;variable&#160;with&#160;+=.&#160;Variables&#160;are&#160;also&#160;commonly&#160;decremented&#160;with<br/>-=.&#160;&#160;The&#160;&#160;other&#160;&#160;pseudooperators&#160;&#160;are&#160;&#160;much&#160;&#160;less&#160;&#160;commonly&#160;&#160;used.&#160;&#160;One&#160;&#160;idiom&#160;&#160;is&#160;&#160;worth<br/>knowing&#160;about,&#160;however.&#160;Suppose&#160;you&#160;are&#160;writing&#160;a&#160;method&#160;that&#160;computes&#160;some&#160;val-<br/>ues,&#160;appends&#160;them&#160;to&#160;an&#160;array,&#160;and&#160;returns&#160;the&#160;array.&#160;You&#160;want&#160;to&#160;allow&#160;the&#160;user&#160;to<br/>specify&#160;the&#160;array&#160;that&#160;the&#160;results&#160;should&#160;be&#160;appended&#160;to.&#160;But&#160;if&#160;the&#160;user&#160;does&#160;not&#160;specify<br/>the array, you want to create a new, empty array. You might use this line:<br/>
results ||= []<br/>
Think about this for a moment. It expands to:<br/>
results = results || []<br/>
<b>96&#160;|&#160;Chapter 4:</b> <b>Expressions and Operators</b><br/>
<hr/>
<a name=111></a>If&#160;you&#160;know&#160;the&#160;||&#160;operator&#160;from&#160;other&#160;languages,&#160;or&#160;if&#160;you’ve&#160;read&#160;ahead&#160;to&#160;learn&#160;about<br/>||&#160;in&#160;Ruby,&#160;then&#160;you&#160;know&#160;that&#160;the&#160;righthand&#160;side&#160;of&#160;this&#160;assignment&#160;evaluates&#160;to&#160;the<br/>value of&#160;results,&#160;unless&#160;that&#160;is&#160;nil&#160;or&#160;false.&#160;In&#160;that&#160;case,&#160;it&#160;evaluates&#160;to&#160;a&#160;new,&#160;empty<br/>array.&#160;&#160;This&#160;&#160;means&#160;&#160;that&#160;&#160;the&#160;&#160;abbreviated&#160;&#160;assignment&#160;&#160;shown&#160;&#160;here&#160;&#160;leaves&#160;&#160;results<br/>unchanged, unless it is&#160;nil&#160;or&#160;false, in which case it assigns a new array.<br/>
The&#160;abbreviated&#160;assignment&#160;operator&#160;||=&#160;actually&#160;behaves&#160;slightly&#160;differently&#160;than&#160;the<br/>expansion&#160;shown&#160;here.&#160;If&#160;the&#160;lvalue&#160;of&#160;||=&#160;is&#160;not&#160;nil&#160;or&#160;false,&#160;no&#160;assignment&#160;is&#160;actually<br/>performed.&#160;If&#160;the&#160;lvalue&#160;is&#160;an&#160;attribute&#160;or&#160;array&#160;element,&#160;the&#160;setter&#160;method&#160;that&#160;performs<br/>assignment is not invoked.<br/>
<b>4.5.5 &#160;Parallel Assignment<br/></b>Parallel&#160;assignment&#160;is&#160;any&#160;assignment&#160;expression&#160;that&#160;has&#160;more&#160;than&#160;one&#160;lvalue,&#160;more<br/>than&#160;one&#160;rvalue,&#160;or&#160;both.&#160;Multiple&#160;lvalues&#160;and&#160;multiple&#160;rvalues&#160;are&#160;separated&#160;from&#160;each<br/>other&#160;with&#160;commas.&#160;lvalues&#160;and&#160;rvalues&#160;may&#160;be&#160;prefixed&#160;with&#160;*,&#160;which&#160;is&#160;sometimes<br/>called&#160;&#160;the&#160;&#160;<i>splat&#160;&#160;operator</i>,&#160;&#160;though&#160;&#160;it&#160;&#160;is&#160;&#160;not&#160;&#160;a&#160;&#160;true&#160;&#160;operator.&#160;&#160;The&#160;&#160;meaning&#160;&#160;of&#160;&#160;*&#160;&#160;is<br/>explained later in this section.<br/>Most&#160;parallel&#160;assignment&#160;expressions&#160;are&#160;straightforward,&#160;and&#160;it&#160;is&#160;obvious&#160;what&#160;they<br/>mean.&#160;&#160;There&#160;&#160;are&#160;&#160;some&#160;&#160;complicated&#160;&#160;cases,&#160;&#160;however,&#160;&#160;and&#160;&#160;the&#160;&#160;following&#160;&#160;subsections<br/>explain all the possibilities.<br/>
<b>4.5.5.1 &#160;Same number of lvalues and rvalues<br/></b>Parallel&#160;assignment&#160;is&#160;at&#160;its&#160;simplest&#160;when&#160;there&#160;are&#160;the&#160;same&#160;number&#160;of&#160;lvalues&#160;and<br/>rvalues:<br/>
x, y, z = 1, 2, 3 &#160; # x=1; y=2; z=3<br/>
In&#160;this&#160;case,&#160;the&#160;first&#160;rvalue&#160;is&#160;assigned&#160;to&#160;the&#160;first&#160;lvalue;&#160;the&#160;second&#160;rvalue&#160;is&#160;assigned<br/>to the second lvalue; and so on.<br/>These&#160;assignments&#160;are&#160;effectively&#160;performed&#160;in&#160;parallel,&#160;not&#160;sequentially.&#160;For&#160;example,<br/>the following two lines are not the same:<br/>
x,y = y,x &#160; &#160; # Parallel: swap the value of two variables<br/>x = y; y = x &#160;# Sequential: both variables have same value<br/>
<b>4.5.5.2 &#160;One lvalue, multiple rvalues<br/></b>When&#160;there&#160;is&#160;a&#160;single&#160;lvalue&#160;and&#160;more&#160;than&#160;one&#160;rvalue,&#160;Ruby&#160;creates&#160;an&#160;array&#160;to&#160;hold<br/>the rvalues and assigns that array to the lvalue:<br/>
x = 1, 2, 3 &#160; &#160; &#160;# x = [1,2,3]<br/>
You&#160;can&#160;place&#160;an&#160;*&#160;before&#160;the&#160;lvalue&#160;without&#160;changing&#160;the&#160;meaning&#160;or&#160;the&#160;return&#160;value<br/>of this assignment.<br/>
<b>4.5 &#160;Assignments&#160;|&#160;97</b><br/>
<hr/>
<a name=112></a>If&#160;you&#160;want&#160;to&#160;prevent&#160;the&#160;multiple&#160;rvalues&#160;from&#160;being&#160;combined&#160;into&#160;a&#160;single&#160;array,<br/>follow&#160;the&#160;lvalue&#160;with&#160;a&#160;comma.&#160;Even&#160;with&#160;no&#160;lvalue&#160;after&#160;that&#160;comma,&#160;this&#160;makes&#160;Ruby<br/>behave as if there were multiple lvalues:<br/>
x, = 1, 2, 3 &#160; &#160; # x = 1; other values are discarded<br/>
<b>4.5.5.3 &#160;Multiple lvalues, single array rvalue<br/></b>When&#160;there&#160;are&#160;multiple&#160;lvalues&#160;and&#160;only&#160;a&#160;single&#160;rvalue,&#160;Ruby&#160;attempts&#160;to&#160;expand&#160;the<br/>rvalue&#160;into&#160;a&#160;list&#160;of&#160;values&#160;to&#160;assign.&#160;If&#160;the&#160;rvalue&#160;is&#160;an&#160;array,&#160;Ruby&#160;expands&#160;the&#160;array&#160;so<br/>that&#160;each&#160;element&#160;becomes&#160;its&#160;own&#160;rvalue.&#160;If&#160;the&#160;rvalue&#160;is&#160;not&#160;an&#160;array&#160;but&#160;implements<br/>a&#160;to_ary&#160;method, Ruby invokes that method and then expands the array it returns:<br/>
x, y, z = [1, 2, 3] &#160;# Same as x,y,z = 1,2,3<br/>
The&#160;parallel&#160;assignment&#160;has&#160;been&#160;transformed&#160;so&#160;that&#160;there&#160;are&#160;multiple&#160;lvalues&#160;and<br/>zero&#160;(if&#160;the&#160;expanded&#160;array&#160;was&#160;empty)&#160;or&#160;more&#160;rvalues.&#160;If&#160;the&#160;number&#160;of&#160;lvalues&#160;and<br/>rvalues&#160;are&#160;the&#160;same,&#160;then&#160;assignment&#160;occurs&#160;as&#160;described&#160;earlier&#160;in&#160;<a href="Rubys.html#111">§4.5.5.1.&#160;</a>If&#160;the<br/><a href="Rubys.html#112">numbers are different, then assignment occurs as described next in §4.5.5.4.<br/></a>We&#160;can&#160;use&#160;the&#160;trailing-comma&#160;trick&#160;described&#160;above&#160;to&#160;transform&#160;an&#160;ordinary&#160;non-<br/>parallel&#160;assignment&#160;into&#160;a&#160;parallel&#160;assignment&#160;that&#160;automatically&#160;unpacks&#160;an&#160;array&#160;on<br/>the right:<br/>
x = [1,2] &#160; &#160;# x becomes [1,2]: this is not parallel assignment<br/>x, = [1,2] &#160; # x becomes 1: the trailing comma makes it parallel<br/>
<b>4.5.5.4 &#160;Different numbers of lvalues and rvalues<br/></b>If&#160;there&#160;are&#160;more&#160;lvalues&#160;than&#160;rvalues,&#160;and&#160;no&#160;splat&#160;operator&#160;is&#160;involved,&#160;then&#160;the&#160;first<br/>rvalue&#160;is&#160;assigned&#160;to&#160;the&#160;first&#160;lvalue,&#160;the&#160;second&#160;rvalue&#160;is&#160;assigned&#160;to&#160;the&#160;second&#160;lvalue,<br/>and&#160;so&#160;on,&#160;until&#160;all&#160;the&#160;rvalues&#160;have&#160;been&#160;assigned.&#160;Next,&#160;each&#160;of&#160;the&#160;remaining&#160;lvalues<br/>is assigned&#160;nil, overwriting any existing value for that lvalue:<br/>
x, y, z = 1, 2 &#160;# x=1; y=2; z=nil<br/>
If&#160;there&#160;are&#160;more&#160;rvalues&#160;than&#160;lvalues,&#160;and&#160;no&#160;splat&#160;operator&#160;is&#160;involved,&#160;then&#160;rvalues<br/>are&#160;assigned—in&#160;order—to&#160;each&#160;of&#160;the&#160;lvalues,&#160;and&#160;the&#160;remaining&#160;rvalues&#160;are&#160;discarded:<br/>
x, y = 1, 2, 3 # x=1; y=2; 3 is not assigned anywhere<br/>
<b>4.5.5.5 &#160;The splat operator<br/></b>When&#160;an&#160;rvalue&#160;is&#160;preceded&#160;by&#160;an&#160;asterisk,&#160;it&#160;means&#160;that&#160;that&#160;value&#160;is&#160;an&#160;array&#160;(or&#160;an<br/>array-like&#160;&#160;object)&#160;&#160;and&#160;&#160;that&#160;&#160;its&#160;&#160;elements&#160;&#160;should&#160;&#160;each&#160;&#160;be&#160;&#160;rvalues.&#160;&#160;The&#160;&#160;array&#160;&#160;elements<br/>replace&#160;the&#160;array&#160;in&#160;the&#160;original&#160;rvalue&#160;list,&#160;and&#160;assignment&#160;proceeds&#160;as&#160;described&#160;above:<br/>
x, y, z = 1, *[2,3] &#160;# Same as x,y,z = 1,2,3<br/>
In Ruby 1.8,&#160;a splat may&#160;only&#160;appear&#160;before&#160;the&#160;last&#160;rvalue&#160;in&#160;an&#160;assignment.&#160;In&#160;Ruby<br/>1.9,&#160;the&#160;list&#160;of&#160;rvalues&#160;in&#160;a&#160;parallel&#160;assignment&#160;may&#160;have&#160;any&#160;number&#160;of&#160;splats,&#160;and&#160;they<br/>
<b>98&#160;|&#160;Chapter 4:</b> <b>Expressions and Operators</b><br/>
<hr/>
<a name=113></a>may&#160;appear&#160;at&#160;any&#160;position&#160;in&#160;the&#160;list.&#160;It&#160;is&#160;not&#160;legal,&#160;however,&#160;in&#160;either&#160;version&#160;of&#160;the<br/>language, to attempt a “double splat” on a nested array:<br/>
x,y = **[[1,2]] &#160; # SyntaxError!<br/>
Array,&#160;range&#160;and&#160;hash&#160;rvalues&#160;can&#160;be&#160;splatted.&#160;In&#160;general,&#160;any&#160;rvalue&#160;that&#160;defines&#160;a<br/>to_a&#160;method&#160;can&#160;be&#160;prefixed&#160;with&#160;a&#160;splat.&#160;Any&#160;Enumerable&#160;object, including enumera-<br/>tors&#160;<a href="Rubys.html#149">(see&#160;§5.3.4)&#160;</a>can&#160;be&#160;splatted,&#160;for&#160;example.&#160;When&#160;a&#160;splat&#160;is&#160;applied&#160;to&#160;an&#160;object&#160;that<br/>does&#160;not&#160;define&#160;a&#160;to_a&#160;method,&#160;no&#160;expansion&#160;is&#160;performed&#160;and&#160;the&#160;splat&#160;evaluates&#160;to<br/>the object itself.<br/>When&#160;an&#160;lvalue&#160;is&#160;preceded&#160;by&#160;an&#160;asterisk,&#160;it&#160;means&#160;that&#160;all&#160;extra&#160;rvalues&#160;should&#160;be<br/>placed&#160;into&#160;an&#160;array&#160;and&#160;assigned&#160;to&#160;this&#160;lvalue.&#160;The&#160;value&#160;assigned&#160;to&#160;that&#160;lvalue&#160;is<br/>always an array, and it may have zero, one, or more elements:<br/>
x,*y = 1, 2, 3 &#160;# x=1; y=[2,3]<br/>x,*y = 1, 2 &#160; &#160; # x=1; y=[2]<br/>x,*y = 1 &#160; &#160; &#160; &#160;# x=1; y=[]<br/>
In&#160;Ruby&#160;1.8,&#160;a&#160;splat&#160;may&#160;only&#160;precede&#160;the&#160;last&#160;lvalue&#160;in&#160;the&#160;list.&#160;In&#160;Ruby&#160;1.9,&#160;the&#160;lefthand<br/>side of a parallel assignment may include one splat operator, but it may appear at any<br/>position in the list:<br/>
# Ruby 1.9 only<br/>*x,y = 1, 2, 3 &#160;# x=[1,2]; y=3<br/>*x,y = 1, 2 &#160; &#160; # x=[1]; y=2<br/>*x,y = 1 &#160; &#160; &#160; &#160;# x=[]; y=1<br/>
Note that splats may appear on both sides of a parallel assignment expression:<br/>
x, y, *z = 1, *[2,3,4] &#160;# x=1; y=2; z=[3,4].<br/>
Finally,&#160;recall&#160;that&#160;earlier&#160;we&#160;described&#160;two&#160;simple&#160;cases&#160;of&#160;parallel&#160;assignment&#160;in&#160;which<br/>there&#160;is&#160;a&#160;single&#160;lvalue&#160;or&#160;a&#160;single&#160;rvalue.&#160;Note&#160;that&#160;both&#160;of&#160;these&#160;cases&#160;behave&#160;as&#160;if&#160;there<br/>is&#160;a&#160;splat&#160;before&#160;the&#160;single&#160;lvalue&#160;or&#160;rvalue.&#160;Explicitly&#160;including&#160;a&#160;splat&#160;in&#160;these&#160;cases<br/>has no additional effect.<br/>
<b>4.5.5.6 &#160;Parentheses in parallel assignment<br/></b>One&#160;of&#160;the&#160;least-understood&#160;features&#160;of&#160;parallel&#160;assignment&#160;is&#160;that&#160;the&#160;lefthand&#160;side&#160;can<br/>use&#160;parentheses&#160;for&#160;“subassignment.”&#160;If&#160;a&#160;group&#160;of&#160;two&#160;or&#160;more&#160;lvalues&#160;is&#160;enclosed&#160;in<br/>parentheses,&#160;then&#160;it&#160;is&#160;initially&#160;treated&#160;as&#160;a&#160;single&#160;lvalue.&#160;Once&#160;the&#160;corresponding&#160;rvalue<br/>has&#160;been&#160;determined,&#160;the&#160;rules&#160;of&#160;parallel&#160;assignment&#160;are&#160;applied&#160;recursively—that<br/>rvalue&#160;&#160;is&#160;&#160;assigned&#160;&#160;to&#160;&#160;the&#160;&#160;group&#160;&#160;of&#160;&#160;lvalues&#160;&#160;that&#160;&#160;was&#160;&#160;in&#160;&#160;parentheses.&#160;&#160;Consider&#160;&#160;the<br/>following assignment:<br/>
x,(y,z) = a, b<br/>
This is effectively two assignments executed at the same time:<br/>
x = a<br/>y,z = b<br/>
<b>4.5 &#160;Assignments&#160;|&#160;99</b><br/>
<hr/>
<a name=114></a>But&#160;note&#160;that&#160;the&#160;second&#160;assignment&#160;is&#160;itself&#160;a&#160;parallel&#160;assignment.&#160;Because&#160;we&#160;used<br/>parentheses&#160;on&#160;the&#160;lefthand&#160;side,&#160;a&#160;recursive&#160;parallel&#160;assignment&#160;is&#160;performed.&#160;In&#160;order<br/>for it to work,&#160;b&#160;must be a splattable object such as an array or enumerator.<br/>Here&#160;are&#160;some&#160;concrete&#160;examples&#160;that&#160;should&#160;make&#160;this&#160;clearer.&#160;Note&#160;that&#160;parentheses<br/>on the left act to “unpack” one level of nested array on the right:<br/>
x,y,z = 1,[2,3] &#160; &#160; &#160; &#160; &#160; &#160; # No parens: x=1;y=[2,3];z=nil<br/>x,(y,z) = 1,[2,3] &#160; &#160; &#160; &#160; &#160; # Parens: x=1;y=2;z=3<br/>
a,b,c,d = [1,[2,[3,4]]] &#160; &#160; # No parens: a=1;b=[2,[3,4]];c=d=nil<br/>a,(b,(c,d)) = [1,[2,[3,4]]] # Parens: a=1;b=2;c=3;d=4<br/>
<b>4.5.5.7 &#160;The value of parallel assignment<br/></b>The&#160;return&#160;value&#160;of&#160;a&#160;parallel&#160;assignment&#160;expression&#160;is&#160;the&#160;array&#160;of&#160;rvalues&#160;(after&#160;being<br/>augmented by any splat operators).<br/>
<b>Parallel Assignment and Method Invocation</b><br/>
As&#160;an&#160;aside,&#160;note&#160;that&#160;if&#160;a&#160;parallel&#160;assignment&#160;is&#160;prefixed&#160;with&#160;the&#160;name&#160;of&#160;a&#160;method,<br/>the Ruby interpreter will interpret the commas as method argument separators rather<br/>than&#160;as&#160;lvalue&#160;and&#160;rvalue&#160;separators.&#160;If&#160;you&#160;want&#160;to&#160;test&#160;the&#160;return&#160;value&#160;of&#160;a&#160;parallel<br/>assignment, you might write the following code to print it out:<br/>
puts x,y=1,2<br/>
This&#160;doesn’t&#160;do&#160;what&#160;you&#160;want,&#160;however;&#160;Ruby&#160;thinks&#160;you’re&#160;invoking&#160;the&#160;puts&#160;method<br/>with&#160;three&#160;arguments:&#160;x,&#160;y=1,&#160;and&#160;2.&#160;Next,&#160;you&#160;might&#160;try&#160;putting&#160;the&#160;parallel&#160;assignment<br/>within parentheses for grouping:<br/>
puts (x,y=1,2)<br/>
&#160;<br/>
This&#160;doesn’t&#160;work,&#160;either;&#160;the&#160;parentheses&#160;are&#160;interpreted&#160;as&#160;part&#160;of&#160;the&#160;method&#160;invo-<br/>cation&#160;(though&#160;Ruby&#160;complains&#160;about&#160;the&#160;space&#160;between&#160;the&#160;method&#160;name&#160;and&#160;the<br/>opening&#160;parenthesis).&#160;To&#160;actually&#160;accomplish&#160;what&#160;you&#160;want,&#160;you&#160;must&#160;use&#160;nested<br/>parentheses:<br/>
puts((x,y=1,2))<br/>
This&#160;is&#160;one&#160;of&#160;those&#160;strange&#160;corner&#160;cases&#160;in&#160;the&#160;Ruby&#160;grammar&#160;that&#160;comes&#160;as&#160;part&#160;of&#160;the<br/>expressiveness of the grammar. Fortunately, the need for syntax like this rarely arises.<br/>
<b>4.6 &#160;Operators<br/></b>An&#160;&#160;<i>operator</i>&#160;&#160;is&#160;&#160;a&#160;&#160;token&#160;&#160;in&#160;&#160;the&#160;&#160;Ruby&#160;&#160;language&#160;&#160;that&#160;&#160;represents&#160;&#160;an&#160;&#160;operation&#160;&#160;(such&#160;&#160;as<br/>addition&#160;or&#160;comparison)&#160;to&#160;be&#160;performed&#160;on&#160;one&#160;or&#160;more&#160;operands.&#160;The&#160;operands&#160;are<br/>expressions, and operators allow us to combine these operand expressions into larger<br/>expressions.&#160;The&#160;numeric&#160;literal&#160;2&#160;and&#160;the&#160;operator&#160;+,&#160;for&#160;example,&#160;can&#160;be&#160;combined<br/>into&#160;the&#160;expression&#160;2+2.&#160;And&#160;the&#160;following&#160;expression&#160;combines&#160;a&#160;numeric&#160;literal,&#160;a<br/>
<b>100&#160;|&#160;Chapter 4:</b> <b>Expressions and Operators</b><br/>
<hr/>
<a name=115></a>method&#160;invocation&#160;expression,&#160;and&#160;a&#160;variable&#160;reference&#160;expression&#160;with&#160;the&#160;multipli-<br/>cation operator and the less-than operator:<br/>
2 * Math.sqrt(2) &lt; limit<br/>
<a href="Rubys.html#116">Table 4-2&#160;</a>later&#160;in&#160;this&#160;section&#160;summarizes&#160;each&#160;of&#160;Ruby’s&#160;operators,&#160;and&#160;the&#160;sections<br/>that&#160;follow&#160;describe&#160;each&#160;one&#160;in&#160;detail.&#160;To&#160;fully&#160;understand&#160;operators,&#160;however,&#160;you<br/>need to understand operator arity, precedence, and associativity.<br/>The&#160;<i>arity</i>&#160;of&#160;an&#160;operator&#160;is&#160;the&#160;number&#160;of&#160;operands&#160;it&#160;operates&#160;on.&#160;Unary&#160;operators<br/>expect a single operand. Binary operators expect two operands. Ternary operators<br/>(there&#160;is&#160;only&#160;one&#160;of&#160;these)&#160;expect&#160;three&#160;operands.&#160;The&#160;arity&#160;of&#160;each&#160;operator&#160;is&#160;listed<br/>in&#160;column&#160;N&#160;<a href="Rubys.html#116">of&#160;Table 4-2</a>.&#160;Note&#160;that&#160;the&#160;operators&#160;+&#160;and&#160;–&#160;have&#160;both&#160;unary&#160;and&#160;binary<br/>forms.<br/>The&#160;<i>precedence</i>&#160;of&#160;an&#160;operator&#160;specifies&#160;how&#160;“tightly”&#160;an&#160;operator&#160;is&#160;bound&#160;to&#160;its&#160;op-<br/>erands,&#160;and&#160;affects&#160;the&#160;order&#160;of&#160;evaluation&#160;of&#160;an&#160;expression.&#160;Consider&#160;this&#160;expression,<br/>for example:<br/>
1 + 2 * 3 &#160; &#160; # =&gt; 7<br/>
The&#160;multiplication&#160;operator&#160;has&#160;higher&#160;precedence&#160;than&#160;the&#160;addition&#160;operator,&#160;so&#160;the<br/>multiplication&#160;is&#160;performed&#160;first&#160;and&#160;the&#160;expression&#160;evaluates&#160;to&#160;<a href="Rubys.html#116">7.&#160;Table&#160;4-2&#160;</a>is&#160;arranged<br/>in&#160;order&#160;from&#160;high-precedence&#160;operators&#160;to&#160;low-precedence&#160;operators.&#160;Note&#160;that&#160;there<br/>are&#160;&#160;both&#160;&#160;high-&#160;&#160;and&#160;&#160;low-precedence&#160;&#160;operators&#160;&#160;for&#160;&#160;Boolean&#160;&#160;AND,&#160;&#160;OR,&#160;&#160;and&#160;&#160;NOT<br/>operations.<br/>Operator&#160;precedence&#160;only&#160;specifies&#160;the&#160;default&#160;order&#160;of&#160;evaluation&#160;for&#160;an&#160;expression.<br/>You&#160;can&#160;always&#160;use&#160;parentheses&#160;to&#160;group&#160;subexpressions&#160;and&#160;specify&#160;your&#160;own&#160;order<br/>of evaluation. For example:<br/>
(1 + 2) * 3 &#160; # =&gt; 9<br/>
The&#160;<i>associativity</i>&#160;of&#160;an&#160;operator&#160;specifies&#160;the&#160;order&#160;of&#160;evaluation&#160;when&#160;the&#160;same&#160;operator<br/>(or&#160;operators&#160;with&#160;the&#160;same&#160;precedence)&#160;appear&#160;sequentially&#160;in&#160;an&#160;expression.&#160;Column<br/>A&#160;of&#160;<a href="Rubys.html#116">Table&#160;4-2&#160;</a>specifies&#160;the&#160;associativity&#160;of&#160;each&#160;operator.&#160;The&#160;value&#160;“L”&#160;means&#160;that<br/>expressions&#160;are&#160;evaluated&#160;from&#160;left&#160;to&#160;right.&#160;The&#160;value&#160;“R”&#160;means&#160;that&#160;expressions&#160;are<br/>evaluated&#160;from&#160;right&#160;to&#160;left.&#160;And&#160;the&#160;value&#160;“N”&#160;means&#160;that&#160;the&#160;operator&#160;is&#160;<i>nonassocia-<br/>tive</i>&#160;and&#160;cannot&#160;be&#160;used&#160;multiple&#160;times&#160;in&#160;an&#160;expression&#160;without&#160;parentheses&#160;to&#160;specify<br/>the evaluation order.<br/>Most&#160;arithmetic&#160;operators&#160;are&#160;left-associative,&#160;which&#160;means&#160;that&#160;10-5-2&#160;is&#160;evaluated&#160;as<br/>(10-5)-2&#160;instead&#160;of&#160;10-(5-2).&#160;Exponentiation,&#160;on&#160;the&#160;other&#160;hand,&#160;is&#160;right-associative,<br/>so&#160;2**3**4&#160;is&#160;evaluated&#160;as&#160;2**(3**4).&#160;Assignment&#160;is&#160;another&#160;right-associative&#160;operator.<br/>In&#160;the&#160;expression&#160;a=b=0,&#160;the&#160;value&#160;0&#160;is&#160;first&#160;assigned&#160;to&#160;the&#160;variable&#160;b.&#160;Then&#160;the&#160;value&#160;of<br/>that expression (also&#160;0) is assigned to the variable&#160;a.<br/>Ruby&#160;implements&#160;a&#160;number&#160;of&#160;its&#160;operators&#160;as&#160;methods,&#160;allowing&#160;classes&#160;to&#160;define&#160;new<br/>meanings&#160;for&#160;those&#160;operators.&#160;Column&#160;M&#160;of&#160;<a href="Rubys.html#116">Table&#160;4-2&#160;</a>specifies&#160;which&#160;operators&#160;are<br/>methods.&#160;Operators&#160;marked&#160;with&#160;a&#160;“Y”&#160;are&#160;implemented&#160;with&#160;methods&#160;and&#160;may&#160;be<br/>
<b>4.6 &#160;Operators&#160;|&#160;101</b><br/>
<hr/>
<a name=116></a>redefined,&#160;and&#160;operators&#160;marked&#160;with&#160;an&#160;“N”&#160;may&#160;not.&#160;In&#160;general,&#160;classes&#160;may&#160;define<br/>their&#160;own&#160;arithmetic,&#160;ordering,&#160;and&#160;equality&#160;operators,&#160;but&#160;they&#160;may&#160;not&#160;redefine&#160;the<br/>various&#160;Boolean&#160;operators.&#160;We&#160;categorize&#160;operators&#160;in&#160;this&#160;chapter&#160;according&#160;to&#160;their<br/>most&#160;common&#160;purpose&#160;for&#160;the&#160;standard&#160;Ruby&#160;classes.&#160;Other&#160;classes&#160;may&#160;define&#160;different<br/>meanings&#160;for&#160;the&#160;operators.&#160;The&#160;+&#160;operator,&#160;for&#160;example,&#160;performs&#160;numeric&#160;addition<br/>and&#160;is&#160;categorized&#160;as&#160;an&#160;arithmetic&#160;operator.&#160;But&#160;it&#160;is&#160;also&#160;used&#160;to&#160;concatenate&#160;strings<br/>and&#160;arrays.&#160;A&#160;method-based&#160;operator&#160;is&#160;invoked&#160;as&#160;a&#160;method&#160;of&#160;its&#160;lefthand&#160;operand<br/>(or its only operand, in the case of unary operators). The righthand operand is passed<br/>as&#160;an&#160;argument&#160;to&#160;the&#160;method.&#160;You&#160;can&#160;look&#160;up&#160;a&#160;class’s&#160;definition&#160;of&#160;any&#160;method-<br/>based&#160;operator&#160;as&#160;you&#160;would&#160;look&#160;up&#160;any&#160;other&#160;method&#160;of&#160;a&#160;class.&#160;For&#160;example,&#160;use<br/><i>ri</i>&#160;to look up the definition of the&#160;*&#160;operator for strings:<br/>
ri 'String.*'<br/>
To define unary&#160;+&#160;and unary&#160;–&#160;operators, use method names&#160;+@&#160;and&#160;-@&#160;to avoid ambi-<br/>guity&#160;with&#160;the&#160;binary&#160;operators&#160;that&#160;use&#160;the&#160;same&#160;symbols.&#160;The&#160;!=&#160;and&#160;!~&#160;operators&#160;are<br/>defined&#160;as&#160;the&#160;negation&#160;of&#160;the&#160;==&#160;and&#160;=~&#160;operators.&#160;In&#160;Ruby&#160;1.9,&#160;you&#160;can&#160;redefine&#160;!=<br/>and&#160;&#160;!~.&#160;&#160;In&#160;&#160;earlier&#160;&#160;versions&#160;&#160;of&#160;&#160;the&#160;&#160;language,&#160;&#160;you&#160;&#160;cannot.&#160;&#160;Ruby&#160;&#160;1.9&#160;&#160;also&#160;&#160;allows&#160;&#160;the<br/>unary&#160;!&#160;operator to be redefined.<br/>
<i>Table 4-2. Ruby operators, by precedence (high to low), with arity (N), associativity (A), and<br/>definability (M)</i><br/>
<b>Operator(s)</b><br/>
<b>N</b><br/>
<b>A</b><br/>
<b>M</b><br/>
<b>Operation</b><br/>
! ~ +<br/>
1<br/>
R<br/>
Y<br/>
Boolean NOT, bitwise complement, unary plusa<br/>
**<br/>
2<br/>
R<br/>
Y<br/>
Exponentiation<br/>
-<br/>
1<br/>
R<br/>
Y<br/>
Unary minus (define with&#160;-@)<br/>
* / %<br/>
2<br/>
L<br/>
Y<br/>
Multiplication, division, modulo (remainder)<br/>
+ -<br/>
2<br/>
L<br/>
Y<br/>
Addition (or concatenation), subtraction<br/>
&lt;&lt; &gt;&gt;<br/>
2<br/>
L<br/>
Y<br/>
Bitwise shift-left (or append), bitwise shift-right<br/>
&amp;<br/>
2<br/>
L<br/>
Y<br/>
Bitwise AND<br/>
| ^<br/>
2<br/>
L<br/>
Y<br/>
Bitwise OR, bitwise XOR<br/>
&lt; &lt;= &gt;= &gt;<br/>
2<br/>
L<br/>
Y<br/>
Ordering<br/>
== === != =~ !~ &lt;=&gt;<br/>
2<br/>
N<br/>
Y<br/>
Equality, pattern matching, comparisonb<br/>
&amp;&amp;<br/>
2<br/>
L<br/>
N<br/>
Boolean AND<br/>
||<br/>
2<br/>
L<br/>
N<br/>
Boolean OR<br/>
.. ...<br/>
2<br/>
N<br/>
N<br/>
Range creation and Boolean flip-flops<br/>
?:<br/>
3<br/>
R<br/>
N<br/>
Conditional<br/>
rescue<br/>
2<br/>
L<br/>
N<br/>
Exception-handling modifier<br/>
=<br/>
2<br/>
R<br/>
N<br/>
Assignment<br/>
**= *= /= %= += -=<br/>&lt;&lt;= &gt;&gt;=<br/>&amp;&amp;= &amp;= ||= |= ^=<br/>
<b>102&#160;|&#160;Chapter 4:</b> <b>Expressions and Operators</b><br/>
<hr/>
<a name=117></a><b>Operator(s)</b><br/>
<b>N</b><br/>
<b>A</b><br/>
<b>M</b><br/>
<b>Operation</b><br/>
defined?<br/>
1<br/>
N<br/>
N<br/>
Test variable definition and type<br/>
not<br/>
1<br/>
R<br/>
N<br/>
Boolean NOT (low precedence)<br/>
and or<br/>
2<br/>
L<br/>
N<br/>
Boolean AND, Boolean OR (low precedence)<br/>
if unless while until<br/>
2<br/>
N<br/>
N<br/>
Conditional and loop modifiers<br/>
a&#160;!&#160;may not be redefined prior to Ruby 1.9. Define unary plus with&#160;+@.<br/>b&#160;!=&#160;and&#160;!~&#160;may not be redefined prior to Ruby 1.9.<br/>
<b>4.6.1 &#160;Unary + and –<br/></b>The&#160;unary&#160;minus&#160;operator&#160;changes&#160;the&#160;sign&#160;of&#160;its&#160;numeric&#160;argument.&#160;The&#160;unary&#160;plus<br/>is&#160;allowed,&#160;but&#160;it&#160;has&#160;no&#160;effect&#160;on&#160;numeric&#160;operands—it&#160;simply&#160;returns&#160;the&#160;value&#160;of&#160;its<br/>operand.&#160;It&#160;is&#160;provided&#160;for&#160;symmetry&#160;with&#160;unary&#160;minus,&#160;and&#160;can,&#160;of&#160;course,&#160;be&#160;rede-<br/>fined.&#160;Note&#160;that&#160;unary&#160;minus&#160;has&#160;slightly&#160;lower&#160;precedence&#160;than&#160;unary&#160;plus;&#160;this&#160;is<br/>described in the next section on the&#160;**&#160;operator.<br/>The&#160;names&#160;of&#160;these&#160;unary&#160;operators&#160;as&#160;methods&#160;are&#160;-@&#160;and&#160;+@. Use these names when<br/>redefining the operators, invoking the operators as methods, or looking up documen-<br/>tation for the operators. These special names are necessary to disambiguate the unary<br/>plus and minus operators from binary plus and minus.<br/>
<b>4.6.2 &#160;Exponentiation: **<br/></b>**&#160;performs&#160;exponentiation,&#160;raising&#160;its&#160;first&#160;argument&#160;to&#160;the&#160;power&#160;of&#160;the&#160;second.&#160;Note<br/>that&#160;you&#160;can&#160;compute&#160;roots&#160;of&#160;a&#160;number&#160;by&#160;using&#160;a&#160;fractional&#160;number&#160;as&#160;the&#160;second<br/>operand.&#160;For&#160;example,&#160;the&#160;cube&#160;root&#160;of&#160;x&#160;is&#160;x**(1.0/3.0). Similarly,&#160;x**-y&#160;is the same<br/>as&#160;&#160;1/(x**y).&#160;&#160;The&#160;&#160;**&#160;&#160;operator&#160;&#160;is&#160;&#160;right-associative,&#160;&#160;so&#160;&#160;x**y**z&#160;&#160;is&#160;&#160;the&#160;&#160;same&#160;&#160;thing&#160;&#160;as<br/>x**(y**z).&#160;Finally,&#160;note&#160;that&#160;**&#160;has&#160;higher&#160;precedence&#160;than&#160;the&#160;unary&#160;minus&#160;operator,<br/>so&#160;-1**0.5&#160;is the same thing as&#160;-(1**0.5). If you really want to take the square root of<br/>-1,&#160;you&#160;must&#160;use&#160;parentheses:&#160;(-1)**0.5.&#160;(The&#160;imaginary&#160;result&#160;is&#160;not-a-number,&#160;and<br/>the expression evaluates to&#160;NaN.)<br/>
<b>4.6.3 &#160;Arithmetic: +, –, *, /, and %<br/></b>The&#160;operators&#160;+,&#160;–,&#160;*,&#160;and&#160;/&#160;perform&#160;addition,&#160;subtraction,&#160;multiplication,&#160;and&#160;division<br/>on&#160;all&#160;Numeric&#160;classes.&#160;Integer&#160;division&#160;returns&#160;an&#160;integer&#160;result&#160;and&#160;discards&#160;any&#160;re-<br/>mainder.&#160;The&#160;remainder&#160;can&#160;be&#160;computed&#160;with&#160;the&#160;modulo&#160;operator&#160;%.&#160;Integer&#160;division<br/>by&#160;zero&#160;raises&#160;ZeroDivisionError.&#160;Floating-point&#160;division&#160;by&#160;zero&#160;returns&#160;plus&#160;or&#160;minus<br/>Infinity.&#160;&#160;Floating-point&#160;&#160;division&#160;&#160;of&#160;&#160;zero&#160;&#160;by&#160;&#160;zero&#160;&#160;returns&#160;&#160;NaN.&#160;&#160;See&#160;&#160;<a href="Rubys.html#58">§3.1.3&#160;&#160;</a>for&#160;&#160;further<br/>details on Ruby’s integer and floating-point arithmetic.<br/>The&#160;String&#160;class uses the&#160;+&#160;operator for string concatenation, the&#160;*&#160;operator for string<br/>repetition, and the&#160;%&#160;operator for&#160;sprintf&#160;argument substitution into a string.<br/>
<b>4.6 &#160;Operators&#160;|&#160;103</b><br/>
<hr/>
<a name=118></a>The&#160;Array&#160;class&#160;uses&#160;+&#160;for&#160;array&#160;concatenation&#160;and&#160;–&#160;for&#160;array&#160;subtraction.&#160;Array&#160;uses<br/>the&#160;*&#160;operator&#160;in&#160;different&#160;ways,&#160;depending&#160;on&#160;the&#160;class&#160;of&#160;the&#160;second&#160;operand.&#160;When<br/>an&#160;array&#160;is&#160;“multiplied”&#160;by&#160;a&#160;number,&#160;the&#160;result&#160;is&#160;a&#160;new&#160;array&#160;that&#160;repeats&#160;the&#160;contents<br/>of&#160;the&#160;operand&#160;array&#160;the&#160;specified&#160;number&#160;of&#160;times.&#160;But&#160;when&#160;an&#160;array&#160;is&#160;multiplied&#160;by<br/>a&#160;string,&#160;the&#160;result&#160;is&#160;the&#160;same&#160;as&#160;calling&#160;the&#160;join&#160;method&#160;of&#160;the&#160;array&#160;and&#160;passing&#160;that<br/>string as the argument.<br/>
<b>4.6.4 &#160;Shift and Append: &lt;&lt; and &gt;&gt;<br/></b>The&#160;Fixnum&#160;and&#160;Bignum&#160;classes&#160;define&#160;the&#160;&lt;&lt;&#160;and&#160;&gt;&gt;&#160;operators&#160;to&#160;shift&#160;the&#160;bits&#160;of&#160;the<br/>lefthand&#160;argument&#160;to&#160;the&#160;left&#160;and&#160;to&#160;the&#160;right.&#160;The&#160;righthand&#160;argument&#160;is&#160;the&#160;number<br/>of positions to shift the bits, and negative values result in a shift in the opposite direc-<br/>tion:&#160;a&#160;left-shift&#160;of&#160;–2&#160;is&#160;the&#160;same&#160;as&#160;a&#160;right-shift&#160;of&#160;2.&#160;High-order&#160;bits&#160;are&#160;never&#160;“shifted<br/>off”&#160;&#160;when&#160;&#160;a&#160;&#160;Fixnum&#160;&#160;is&#160;&#160;shifted&#160;&#160;left.&#160;&#160;If&#160;&#160;the&#160;&#160;result&#160;&#160;of&#160;&#160;a&#160;&#160;shift&#160;&#160;does&#160;&#160;not&#160;&#160;fit&#160;&#160;in&#160;&#160;a&#160;&#160;Fixnum,&#160;&#160;a<br/>Bignum&#160;value&#160;is&#160;returned.&#160;Right&#160;shifts,&#160;however,&#160;always&#160;discard&#160;the&#160;low-order&#160;bits&#160;of&#160;the<br/>argument.<br/>Shifting&#160;a&#160;number&#160;left&#160;by&#160;1&#160;bit&#160;is&#160;the&#160;same&#160;as&#160;multiplication&#160;by&#160;2.&#160;Shifting&#160;a&#160;number<br/>right by&#160;1&#160;bit&#160;is&#160;the&#160;same&#160;as&#160;integer&#160;division&#160;by&#160;2.&#160;Here&#160;are&#160;some&#160;examples&#160;that&#160;express<br/>numbers in binary notation and then convert their results back to binary form:<br/>
(0b1011 &lt;&lt; 1).to_s(2) &#160; # =&gt; &#34;10110&#34; &#160; 11 &lt;&lt; 1 =&gt; 22<br/>(0b10110 &gt;&gt; 2).to_s(2) &#160;# =&gt; &#34;101&#34; &#160; &#160; 22 &gt;&gt; 2 =&gt; 5<br/>
The&#160;&lt;&lt;&#160;operator&#160;is&#160;also&#160;used&#160;as&#160;an&#160;append&#160;operator,&#160;and&#160;it’s&#160;probably&#160;more&#160;common<br/>in this form. The&#160;String,&#160;Array, and&#160;IO&#160;classes define it in this way, as do a number of<br/>other “appendable” classes from the standard library, such as&#160;Queue&#160;and&#160;Logger:<br/>
message = &#34;hello&#34; &#160; &#160; &#160; &#160;# A string<br/>messages = [] &#160; &#160; &#160; &#160; &#160; &#160;# An empty array<br/>message &lt;&lt; &#34; world&#34; &#160; &#160; &#160;# Append to the string<br/>messages &lt;&lt; message &#160; &#160; &#160;# Append message to the array<br/>STDOUT &lt;&lt; message &#160; &#160; &#160; &#160;# Print the message to standard output stream<br/>
<b>4.6.5 &#160;Complement, Union, Intersection: ~, &amp;, |, and ^<br/></b>Fixnum&#160;and&#160;Bignum&#160;define&#160;these&#160;operators&#160;to&#160;perform&#160;bitwise&#160;NOT,&#160;AND,&#160;OR,&#160;and&#160;XOR<br/>operations.&#160;&#160;~&#160;&#160;is&#160;&#160;a&#160;&#160;high-precedence&#160;&#160;unary&#160;&#160;operator,&#160;&#160;and&#160;&#160;the&#160;&#160;others&#160;&#160;are&#160;&#160;medium-<br/>precedence binary operators.<br/>
~&#160;changes&#160;each&#160;0&#160;bit&#160;of&#160;its&#160;integer&#160;operand&#160;to&#160;a&#160;1,&#160;and&#160;each&#160;1&#160;bit&#160;to&#160;a&#160;0,&#160;producing&#160;the<br/>binary&#160;1s-complement of a number. For any integer&#160;x,&#160;~x&#160;is the same as&#160;-x-1.<br/>
&amp;&#160;is&#160;the&#160;bitwise&#160;AND&#160;operator&#160;for&#160;two&#160;numbers.&#160;The&#160;bits&#160;of&#160;the&#160;result&#160;are&#160;set&#160;to&#160;1&#160;only<br/>if the corresponding bit in each operand is set to&#160;1. For example:<br/>
(0b1010 &amp; 0b1100).to_s(2) &#160;# =&gt; &#34;1000&#34;<br/>
|&#160;is&#160;the&#160;bitwise&#160;OR&#160;operator&#160;for&#160;two&#160;integers.&#160;A&#160;bit&#160;in&#160;the&#160;result&#160;is&#160;1&#160;if&#160;either&#160;corre-<br/>sponding bit in the operands is&#160;1. For example:<br/>
<b>104&#160;|&#160;Chapter 4:</b> <b>Expressions and Operators</b><br/>
<hr/>
<a name=119></a>(0b1010 | 0b1100).to_s(2) &#160;# =&gt; &#34;1110&#34;<br/>
^&#160;is the bitwise XOR (exclusive-OR) for integers. A bit in the result is&#160;1&#160;if one (but not<br/>both) of the corresponding bits in the operands is&#160;1. For example:<br/>
(0b1010 ^ 0b1100).to_s(2) &#160;# =&gt; &#34;110&#34;<br/>
Other&#160;classes&#160;use&#160;these&#160;operators&#160;as&#160;well,&#160;usually&#160;in&#160;ways&#160;that&#160;are&#160;compatible&#160;with&#160;their<br/>logical&#160;AND,&#160;OR,&#160;and&#160;NOT&#160;meanings.&#160;Arrays&#160;use&#160;&amp;&#160;and&#160;|&#160;for&#160;set&#160;intersection&#160;and&#160;union<br/>operations. When&#160;&amp;&#160;is&#160;applied&#160;to&#160;two&#160;arrays,&#160;it&#160;returns&#160;a&#160;new&#160;array&#160;that&#160;contains&#160;only<br/>those&#160;elements&#160;that&#160;appear&#160;in&#160;the&#160;lefthand&#160;array&#160;AND&#160;the&#160;righthand&#160;array.&#160;When&#160;|&#160;is<br/>applied&#160;to&#160;two&#160;arrays,&#160;it&#160;returns&#160;a&#160;new&#160;array&#160;that&#160;contains&#160;any&#160;elements&#160;that&#160;appear&#160;in<br/>either&#160;&#160;the&#160;&#160;lefthand&#160;&#160;array&#160;&#160;OR&#160;&#160;the&#160;&#160;righthand&#160;&#160;array.&#160;&#160;See&#160;&#160;<a href="Rubys.html#353">§9.5.2.7&#160;&#160;</a>for&#160;&#160;details&#160;&#160;and<br/>examples.<br/>
TrueClass,&#160;FalseClass, and&#160;NilClass&#160;define&#160;&amp;,&#160;|, and&#160;^&#160;(but not&#160;~),&#160;so&#160;that&#160;they&#160;can&#160;be<br/>used&#160;as&#160;Boolean&#160;operators.&#160;Note,&#160;however,&#160;that&#160;this&#160;is&#160;rarely&#160;the&#160;correct&#160;thing&#160;to&#160;do.<br/>The&#160;Boolean&#160;operators&#160;&amp;&amp;&#160;and&#160;||&#160;(described&#160;later&#160;in&#160;<a href="Rubys.html#121">§4.6.8)&#160;</a>are&#160;intended&#160;for&#160;Boolean<br/>operands,&#160;and&#160;are&#160;more&#160;efficient&#160;because&#160;they&#160;do&#160;not&#160;evaluate&#160;their&#160;righthand&#160;operand<br/>unless its value will affect the result of the operation.<br/>
<b>4.6.6 &#160;Comparison: &lt;, &lt;=, &gt;, &gt;=, and &lt;=&gt;<br/></b>Some&#160;classes&#160;define&#160;a&#160;natural&#160;order&#160;for&#160;their&#160;values.&#160;Numbers&#160;are&#160;ordered&#160;by&#160;magnitude;<br/>strings&#160;&#160;are&#160;&#160;ordered&#160;&#160;alphabetically;&#160;&#160;dates&#160;&#160;are&#160;&#160;ordered&#160;&#160;chronologically.&#160;&#160;The&#160;&#160;less-than<br/>(&lt;),&#160;less-than-or-equal-to&#160;(&lt;=),&#160;greater-than-or-equal-to&#160;(&gt;=),&#160;and&#160;greater-than&#160;(&gt;)&#160;op-<br/>erators&#160;make&#160;assertions&#160;about&#160;the&#160;relative&#160;order&#160;of&#160;two&#160;values.&#160;They&#160;evaluate&#160;to&#160;true&#160;if<br/>the&#160;assertion&#160;is&#160;true,&#160;and&#160;they&#160;evaluate&#160;to&#160;false&#160;otherwise.&#160;(And&#160;they&#160;typically&#160;raise&#160;an<br/>exception if their arguments are of incomparable types.)<br/>Classes&#160;may&#160;define&#160;the&#160;comparison&#160;operators&#160;individually.&#160;It&#160;is&#160;easier&#160;and&#160;more&#160;com-<br/>mon,&#160;however,&#160;for&#160;a&#160;class&#160;to&#160;define&#160;the&#160;single&#160;&lt;=&gt;&#160;operator.&#160;This&#160;is&#160;a&#160;general-purpose<br/>comparison&#160;operator,&#160;and&#160;its&#160;return&#160;value&#160;indicates&#160;the&#160;relative&#160;order&#160;of&#160;the&#160;two&#160;oper-<br/>ands.&#160;If&#160;the&#160;lefthand&#160;operand&#160;is&#160;less&#160;than&#160;the&#160;righthand&#160;operand,&#160;then&#160;&lt;=&gt;&#160;returns&#160;–1.<br/>If&#160;the&#160;lefthand&#160;operand&#160;is&#160;greater,&#160;it&#160;returns&#160;+1.&#160;If&#160;the&#160;two&#160;operands&#160;are&#160;equal,&#160;the&#160;op-<br/>erator&#160;returns&#160;0.&#160;And&#160;if&#160;the&#160;two&#160;operands&#160;are&#160;not&#160;comparable,&#160;it&#160;returns&#160;nil.*&#160;&#160;Once the<br/>&lt;=&gt;&#160;&#160;operator&#160;&#160;is&#160;&#160;defined,&#160;&#160;a&#160;&#160;class&#160;&#160;may&#160;&#160;simply&#160;&#160;include&#160;&#160;the&#160;&#160;module&#160;&#160;Comparable,&#160;&#160;which<br/>defines the other comparison operators (including the&#160;==&#160;operator) in terms of&#160;&lt;=&gt;.<br/>The&#160;Module&#160;class&#160;deserves&#160;special&#160;mention:&#160;it&#160;implements&#160;the&#160;comparison&#160;operators&#160;to<br/>indicate&#160;subclass&#160;relationships&#160;(Module&#160;is&#160;the&#160;superclass&#160;of&#160;Class).&#160;For&#160;classes&#160;A&#160;and&#160;B,<br/>A &lt; B&#160;is&#160;true&#160;if&#160;A&#160;is&#160;a&#160;subclass&#160;or&#160;descendant&#160;of&#160;B.&#160;In&#160;this&#160;case,&#160;“less&#160;than”&#160;means&#160;“is<br/>
*&#160;Some&#160;implementations&#160;of&#160;this&#160;operator&#160;may&#160;return&#160;any&#160;value&#160;less&#160;than&#160;0&#160;or&#160;any&#160;value&#160;greater&#160;than&#160;0, instead<br/>
of&#160;–1&#160;and&#160;+1.&#160;If&#160;you&#160;implement&#160;&lt;=&gt;,&#160;your&#160;implementation&#160;should&#160;return&#160;–1,&#160;0,&#160;or&#160;+1.&#160;But&#160;if&#160;you&#160;use&#160;&lt;=&gt;, you<br/>should&#160;test&#160;for&#160;values&#160;less&#160;than&#160;or&#160;greater&#160;than&#160;zero,&#160;rather&#160;than&#160;assuming&#160;that&#160;the&#160;result&#160;will&#160;always&#160;be&#160;–1,<br/>0, or&#160;+1.<br/>
<b>4.6 &#160;Operators&#160;|&#160;105</b><br/>
<hr/>
<a name=120></a>more&#160;specialized&#160;than”&#160;or&#160;“is&#160;a&#160;narrower&#160;type&#160;than.”&#160;As&#160;a&#160;mnemonic,&#160;note&#160;that&#160;(as&#160;we’ll<br/><a href="Rubys.html#227">learn in Chapter 7) the&#160;</a>&lt;&#160;character is also used when declaring a subclass:<br/>
# Declare class A as a subclass of B<br/>class A &lt; B<br/>end<br/>
Module&#160;defines&#160;&gt;&#160;to&#160;work&#160;like&#160;&lt;&#160;with&#160;its&#160;operands&#160;reversed.&#160;And&#160;it&#160;defines&#160;&lt;=&#160;and&#160;&gt;=&#160;so<br/>that they also return&#160;true&#160;if&#160;the&#160;two&#160;operands&#160;are&#160;the&#160;same&#160;class.&#160;The&#160;most&#160;interesting<br/>things&#160;about&#160;these&#160;Module&#160;comparison&#160;operators&#160;is&#160;that&#160;Module&#160;only&#160;defines&#160;a&#160;partial<br/>ordering&#160;on&#160;its&#160;values.&#160;Consider&#160;the&#160;classes&#160;String&#160;and&#160;Numeric.&#160;Both&#160;are&#160;subclasses&#160;of<br/>Object,&#160;and&#160;neither&#160;one&#160;is&#160;a&#160;subclass&#160;of&#160;the&#160;other.&#160;In&#160;this&#160;case,&#160;when&#160;the&#160;two&#160;operands<br/>are unrelated, the comparison operators return&#160;nil&#160;instead of&#160;true&#160;or&#160;false:<br/>
String &lt; Object &#160; &#160; &#160; &#160;# true: String is more specialized than Object<br/>Object &gt; Numeric &#160; &#160; &#160; # true: Object is more general than Numeric<br/>Numeric &lt; Integer &#160; &#160; &#160;# false: Numeric is not more specialized than Integer<br/>String &lt; Numeric &#160; &#160; &#160; # nil: String and Numeric are not related<br/>
If&#160;a&#160;class&#160;defines&#160;a&#160;total&#160;ordering&#160;on&#160;its&#160;values,&#160;and&#160;a &lt; b&#160;is&#160;not&#160;true,&#160;then&#160;you&#160;can&#160;be<br/>sure&#160;that&#160;a &gt;= b&#160;<i>is</i>&#160;true.&#160;But&#160;when&#160;a&#160;class,&#160;like&#160;Module,&#160;defines&#160;only&#160;a&#160;partial&#160;ordering,<br/>you must not make this assumption.<br/>
<b>4.6.7 &#160;Equality: ==, !=, =~, !~, and ===<br/></b>==&#160;is&#160;the&#160;equality&#160;operator.&#160;It&#160;determines&#160;whether&#160;two&#160;values&#160;are&#160;equal,&#160;according&#160;to<br/>the&#160;lefthand&#160;operand’s&#160;definition&#160;of&#160;“equal.”&#160;The&#160;!=&#160;operator&#160;is&#160;simply&#160;the&#160;inverse&#160;of<br/>==:&#160;it&#160;calls&#160;==&#160;and&#160;then&#160;returns&#160;the&#160;opposite.&#160;You&#160;can&#160;redefine&#160;!=&#160;in&#160;Ruby&#160;1.9&#160;but&#160;not&#160;in<br/><a href="Rubys.html#90">Ruby 1.8. See §3.8.5 for a more detailed discussion of object equality in Ruby.</a><br/>
=~&#160;is&#160;the&#160;pattern-matching&#160;operator.&#160;Object&#160;defines&#160;this&#160;operator&#160;so&#160;that&#160;it&#160;always&#160;re-<br/>turns&#160;false.&#160;String&#160;redefines&#160;it&#160;so&#160;that&#160;it&#160;expects&#160;a&#160;Regexp&#160;as&#160;its&#160;righthand&#160;argument.<br/>And&#160;Regexp&#160;redefines&#160;the&#160;operator&#160;so&#160;that&#160;it&#160;expects&#160;a&#160;String&#160;as&#160;its&#160;righthand&#160;argument.<br/>Both&#160;of&#160;these&#160;operators&#160;return&#160;nil&#160;if&#160;the&#160;string&#160;does&#160;not&#160;match&#160;the&#160;pattern.&#160;If&#160;the&#160;string<br/>does&#160;&#160;match&#160;&#160;the&#160;&#160;pattern,&#160;&#160;the&#160;&#160;operators&#160;&#160;return&#160;&#160;the&#160;&#160;integer&#160;&#160;index&#160;&#160;at&#160;&#160;which&#160;&#160;the&#160;&#160;match<br/>begins.&#160;(Note&#160;that&#160;in&#160;Boolean&#160;expressions,&#160;nil&#160;works&#160;like&#160;false&#160;and&#160;any&#160;integer&#160;works<br/>like&#160;true.)<br/>The&#160;!~&#160;operator&#160;is&#160;the&#160;inverse&#160;of&#160;=~:&#160;it&#160;calls&#160;=~&#160;and&#160;returns&#160;true&#160;if&#160;=~&#160;returned&#160;nil&#160;or<br/>false&#160;if&#160;=~&#160;returned an integer. You can redefine&#160;!~&#160;in Ruby 1.9 but not in Ruby 1.8.<br/>
The&#160;===&#160;operator is the case-equality operator. It is used implicitly by&#160;case&#160;statements<br/>(see&#160;&#160;<a href="Rubys.html#131">Chapter&#160;&#160;5).&#160;&#160;</a>Its&#160;&#160;explicit&#160;&#160;use&#160;&#160;is&#160;&#160;much&#160;&#160;less&#160;&#160;common&#160;&#160;than&#160;&#160;==.&#160;&#160;Range,&#160;&#160;Class,&#160;&#160;and<br/>Regexp&#160;&#160;define&#160;&#160;this&#160;&#160;operator&#160;&#160;as&#160;&#160;a&#160;&#160;kind&#160;&#160;of&#160;&#160;membership&#160;&#160;or&#160;&#160;pattern-matching&#160;&#160;operator.<br/>Other&#160;classes&#160;inherit&#160;Object’s&#160;definition,&#160;which&#160;simply&#160;invokes&#160;the&#160;==&#160;operator&#160;instead.<br/><a href="Rubys.html#90">See §3.8.5. Note that there is no&#160;</a>!==&#160;operator; if you want to negate&#160;===, you must do<br/>it yourself.<br/>
<b>106&#160;|&#160;Chapter 4:</b> <b>Expressions and Operators</b><br/>
<hr/>
<a name=121></a><b>4.6.8 &#160;Boolean Operators: &amp;&amp;, ||, !, and, or, not<br/></b>Ruby’s&#160;Boolean&#160;operators&#160;are&#160;built&#160;into&#160;the&#160;language&#160;and&#160;are&#160;not&#160;based&#160;on&#160;methods:<br/>classes,&#160;for&#160;example,&#160;cannot&#160;define&#160;their&#160;own&#160;&amp;&amp;&#160;method.&#160;The&#160;reason&#160;for&#160;this&#160;is&#160;that<br/>Boolean&#160;operators&#160;can&#160;be&#160;applied&#160;to&#160;any&#160;value&#160;and&#160;must&#160;behave&#160;consistently&#160;for&#160;any<br/>kind&#160;of&#160;operand.&#160;Ruby&#160;defines&#160;special&#160;true&#160;and&#160;false&#160;values&#160;but&#160;does&#160;not&#160;have&#160;a&#160;Boolean<br/>type.&#160;For&#160;the&#160;purposes&#160;of&#160;all&#160;Boolean&#160;operators,&#160;the&#160;values&#160;false&#160;and&#160;nil&#160;are&#160;considered<br/>false.&#160;And&#160;every&#160;other&#160;value,&#160;including&#160;true,&#160;0,&#160;NaN,&#160;&#34;&#34;,&#160;[],&#160;and&#160;{},&#160;is&#160;considered&#160;true.<br/>Note&#160;that&#160;!&#160;is&#160;an&#160;exception;&#160;you&#160;can&#160;redefine&#160;this&#160;operator&#160;in&#160;Ruby&#160;1.9&#160;(but&#160;not&#160;in&#160;Ruby<br/>1.8).&#160;Note&#160;also&#160;that&#160;you&#160;can&#160;define&#160;methods&#160;named&#160;and,&#160;or,&#160;and&#160;not,&#160;but&#160;these&#160;methods<br/>are&#160;ordinary&#160;methods&#160;and&#160;do&#160;not&#160;alter&#160;the&#160;behavior&#160;of&#160;the&#160;operators&#160;with&#160;the&#160;same&#160;name.<br/>Another&#160;reason&#160;that&#160;Ruby’s&#160;Boolean&#160;operators&#160;are&#160;a&#160;core&#160;part&#160;of&#160;the&#160;language&#160;rather<br/>than&#160;redefinable&#160;methods&#160;is&#160;that&#160;the&#160;binary&#160;operators&#160;are&#160;“short-circuiting.”&#160;If&#160;the&#160;value<br/>of&#160;the&#160;operation&#160;is&#160;completely&#160;determined&#160;by&#160;the&#160;lefthand&#160;operand,&#160;then&#160;the&#160;righthand<br/>operand&#160;is&#160;ignored&#160;and&#160;is&#160;never&#160;even&#160;evaluated.&#160;If&#160;the&#160;righthand&#160;operand&#160;is&#160;an&#160;expres-<br/>sion&#160;&#160;with&#160;&#160;side&#160;&#160;effects&#160;&#160;(such&#160;&#160;as&#160;&#160;assignment,&#160;&#160;or&#160;&#160;an&#160;&#160;invocation&#160;&#160;of&#160;&#160;a&#160;&#160;method&#160;&#160;with&#160;&#160;side<br/>effects),&#160;then&#160;that&#160;side&#160;effect&#160;may&#160;or&#160;may&#160;not&#160;occur,&#160;based&#160;on&#160;the&#160;value&#160;of&#160;the&#160;lefthand<br/>operand.<br/>
&amp;&amp;&#160;is&#160;a&#160;Boolean&#160;AND&#160;operator.&#160;It&#160;returns&#160;a&#160;true&#160;value&#160;if&#160;both&#160;its&#160;left&#160;operand&#160;AND&#160;its<br/>right&#160;operand&#160;are&#160;true&#160;values.&#160;Otherwise,&#160;it&#160;returns&#160;a&#160;false&#160;value.&#160;Note&#160;that&#160;this&#160;de-<br/>scription&#160;says&#160;“a&#160;true&#160;value”&#160;and&#160;“a&#160;false&#160;value”&#160;instead&#160;of&#160;“the&#160;true&#160;value”&#160;and&#160;“the<br/>false&#160;value.”&#160;&amp;&amp;&#160;is&#160;often&#160;used&#160;in&#160;conjunction&#160;with&#160;comparison&#160;operators,&#160;such&#160;as&#160;==<br/>and&#160;&lt;, in expressions like this:<br/>
x == 0 &amp;&amp; y &gt; 1<br/>
The&#160;&#160;comparison&#160;&#160;and&#160;&#160;equality&#160;&#160;operators&#160;&#160;actually&#160;&#160;evaluate&#160;&#160;to&#160;&#160;the&#160;&#160;values&#160;&#160;true&#160;&#160;and<br/>false, and in this case, the&#160;&amp;&amp;&#160;operator&#160;is&#160;operating&#160;on&#160;actual&#160;Boolean&#160;values.&#160;But&#160;this<br/>is not always the case. The operator can also be used like this:<br/>
x &amp;&amp; y<br/>
In this case,&#160;x&#160;and&#160;y&#160;can be anything. The value of the expression is either the value of<br/>x&#160;or&#160;it&#160;is&#160;the&#160;value&#160;of&#160;y. If both&#160;x&#160;and&#160;y&#160;are&#160;true&#160;values,&#160;then&#160;the&#160;value&#160;of&#160;the&#160;expression<br/>is&#160;the&#160;value&#160;of&#160;y.&#160;If&#160;x&#160;is&#160;a&#160;false&#160;value,&#160;then&#160;the&#160;value&#160;of&#160;the&#160;expression&#160;is&#160;x. Otherwise,<br/>y&#160;must be a false value, and the value of the expression is&#160;y.<br/>
Here’s&#160;how&#160;the&#160;&amp;&amp;&#160;operator&#160;actually&#160;works.&#160;First,&#160;it&#160;evaluates&#160;its&#160;lefthand&#160;operand.&#160;If<br/>this&#160;operand&#160;is&#160;nil&#160;or&#160;false,&#160;then&#160;it&#160;returns&#160;that&#160;value&#160;and&#160;skips&#160;the&#160;righthand&#160;operand<br/>altogether.&#160;Otherwise,&#160;the&#160;lefthand&#160;operand&#160;is&#160;a&#160;true&#160;value&#160;and&#160;the&#160;overall&#160;value&#160;of&#160;the<br/>&amp;&amp;&#160;operator&#160;depends&#160;on&#160;the&#160;value&#160;of&#160;the&#160;righthand&#160;operand.&#160;In&#160;this&#160;case,&#160;the&#160;operator<br/>evaluates its righthand operand and returns that value.<br/>The&#160;fact&#160;that&#160;&amp;&amp;&#160;may&#160;skip&#160;its&#160;righthand&#160;operand&#160;can&#160;be&#160;used&#160;to&#160;advantage&#160;in&#160;your&#160;code.<br/>Consider this expression:<br/>
x &amp;&amp; print(x.to_s)<br/>
<b>4.6 &#160;Operators&#160;|&#160;107</b><br/>
<hr/>
<a name=122></a>This code prints the value of&#160;x&#160;as a string, but only if&#160;x&#160;is not&#160;nil&#160;or&#160;false.*<br/>The&#160;||&#160;operator&#160;returns&#160;the&#160;Boolean&#160;OR&#160;of&#160;its&#160;operands.&#160;It&#160;returns&#160;a&#160;true&#160;value&#160;if&#160;either<br/>of&#160;its&#160;operands&#160;is&#160;a&#160;true&#160;value.&#160;If&#160;both&#160;operands&#160;are&#160;false&#160;values,&#160;then&#160;it&#160;returns&#160;a&#160;false<br/>value. Like&#160;&amp;&amp;, the&#160;||&#160;operator&#160;ignores&#160;its&#160;righthand&#160;operand&#160;if&#160;its&#160;value&#160;has&#160;no&#160;impact<br/>on&#160;the&#160;value&#160;of&#160;the&#160;operation.&#160;The&#160;||&#160;operator&#160;works&#160;like&#160;this:&#160;first,&#160;it&#160;evaluates&#160;its<br/>lefthand&#160;operand.&#160;If&#160;this&#160;is&#160;any&#160;value&#160;other&#160;than&#160;nil&#160;or&#160;false,&#160;it&#160;simply&#160;returns&#160;that<br/>value. Otherwise, it evaluates its righthand operand and returns that value.<br/>
||&#160;can be used as a conjunction to join multiple comparison or equality expressions:<br/>
x &lt; 0 || y &lt; 0 || z &lt; 0 &#160; # Are any of the coordinates negative?<br/>
In&#160;this&#160;case,&#160;the&#160;operands&#160;to&#160;||&#160;will&#160;be&#160;actual&#160;true&#160;or&#160;false&#160;values,&#160;and&#160;the&#160;result&#160;will<br/>also&#160;be&#160;true&#160;or&#160;false.&#160;But&#160;||&#160;is&#160;not&#160;restricted&#160;to&#160;working&#160;with&#160;true&#160;and&#160;false.&#160;One<br/>idiomatic use of&#160;||&#160;is to return the first non-nil&#160;value in a series of alternatives:<br/>
# If the argument x is nil, then get its value from a hash of user preferences<br/># or from a constant default value.<br/>x = x || preferences[:x] || Defaults::X<br/>
Note that&#160;&amp;&amp;&#160;has higher precedence than&#160;||. Consider this expression:<br/>
1 || 2 &amp;&amp; nil &#160; &#160; # =&gt; 1<br/>
The&#160;&amp;&amp;&#160;is&#160;performed&#160;first,&#160;and&#160;the&#160;value&#160;of&#160;this&#160;expression&#160;is&#160;1.&#160;If&#160;the&#160;||&#160;was&#160;performed<br/>first, however, the value would be&#160;nil:<br/>
(1 || 2) &amp;&amp; nil &#160; # =&gt; nil<br/>
The&#160;!&#160;operator&#160;performs&#160;a&#160;unary&#160;Boolean&#160;NOT.&#160;If&#160;the&#160;operand&#160;is&#160;nil&#160;or&#160;false,&#160;then<br/>the&#160;!&#160;operator returns&#160;true. Otherwise,&#160;!&#160;returns&#160;false.<br/>The&#160;!&#160;operator&#160;is&#160;at&#160;the&#160;highest&#160;precedence.&#160;This&#160;means&#160;that&#160;if&#160;you&#160;want&#160;to&#160;compute<br/>the&#160;logical&#160;inverse&#160;of&#160;an&#160;expression&#160;that&#160;itself&#160;uses&#160;operators,&#160;you&#160;must&#160;use&#160;parentheses:<br/>
!(a &amp;&amp; b)<br/>
Incidentally,&#160;one&#160;of&#160;the&#160;principles&#160;of&#160;Boolean&#160;logic&#160;allows&#160;the&#160;expression&#160;above&#160;to&#160;be<br/>rewritten as:<br/>
!a || !b<br/>
The&#160;and,&#160;or,&#160;and&#160;not&#160;operators&#160;are&#160;low-precedence&#160;versions&#160;of&#160;&amp;&amp;,&#160;||,&#160;and&#160;!.&#160;One&#160;reason<br/>to&#160;use&#160;these&#160;variants&#160;is&#160;simply&#160;that&#160;their&#160;names&#160;are&#160;English&#160;and&#160;this&#160;can&#160;make&#160;your&#160;code<br/>easier to read. Try reading this line of code, for example:<br/>
if x &gt; 0 and y &gt; 0 and not defined? d then d = Math.sqrt(x*x + y*y) end<br/>
Another&#160;reason&#160;for&#160;these&#160;alternate&#160;versions&#160;of&#160;the&#160;Boolean&#160;operators&#160;is&#160;the&#160;fact&#160;that&#160;they<br/>have&#160;lower&#160;precedence&#160;than&#160;the&#160;assignment&#160;operator.&#160;This&#160;means&#160;that&#160;you&#160;can&#160;write&#160;a<br/>
*&#160;Just&#160;because&#160;an&#160;expression&#160;can&#160;be&#160;written&#160;this&#160;way&#160;doesn’t&#160;mean&#160;that&#160;it&#160;should&#160;be.&#160;In&#160;<a href="Rubys.html#131">Chapter&#160;5,&#160;</a>we’ll&#160;see<br/>
that this expression is better written as:<br/>
print(x.to_s) if x&#160;<br/>
<b>108&#160;|&#160;Chapter 4:</b> <b>Expressions and Operators</b><br/>
<hr/>
<a name=123></a>Boolean&#160;&#160;expression&#160;&#160;such&#160;&#160;as&#160;&#160;the&#160;&#160;following&#160;&#160;that&#160;&#160;assigns&#160;&#160;values&#160;&#160;to&#160;&#160;variables&#160;&#160;until&#160;&#160;it<br/>encounters a false value:<br/>
if a = f(x) and b = f(y) and c = f(z) then d = g(a,b,c) end<br/>
This expression simply would not work if written with&#160;&amp;&amp;&#160;instead of&#160;and.<br/>You&#160;should&#160;note&#160;that&#160;and&#160;and&#160;or&#160;have&#160;the&#160;same&#160;precedence&#160;(and&#160;not&#160;is&#160;just&#160;slightly<br/>higher).&#160;Because&#160;and&#160;and&#160;or&#160;have&#160;the&#160;same&#160;precedence,&#160;and&#160;&amp;&amp;&#160;and&#160;||&#160;have&#160;different<br/>precedences, the following two expressions compute different values:<br/>
x || y &amp;&amp; nil &#160; &#160; &#160; &#160;# &amp;&amp; is performed first &#160; =&gt; x<br/>x or y and nil &#160; &#160; &#160; # evaluated left-to-right =&gt; nil&#160;<br/>
<b>4.6.9 &#160;Ranges and Flip-Flops: .. and ...<br/></b>We’ve&#160;seen&#160;..&#160;and&#160;...&#160;before&#160;in&#160;<a href="Rubys.html#82">§3.5&#160;</a>where&#160;they&#160;were&#160;described&#160;as&#160;part&#160;of&#160;the&#160;Range<br/>literal&#160;syntax.&#160;When&#160;the&#160;start&#160;and&#160;end&#160;points&#160;of&#160;a&#160;range&#160;are&#160;themselves&#160;integer&#160;literals,<br/>as in&#160;1..10,&#160;the&#160;Ruby&#160;interpreter&#160;creates&#160;a&#160;literal&#160;Range&#160;object&#160;while&#160;parsing.&#160;But&#160;if&#160;the<br/>start&#160;and&#160;end&#160;point&#160;expressions&#160;are&#160;anything&#160;more&#160;complicated&#160;than&#160;integer&#160;literals,&#160;as<br/>in&#160;x..2*x,&#160;then&#160;it&#160;is&#160;not&#160;really&#160;accurate&#160;to&#160;call&#160;this&#160;a&#160;Range&#160;literal.&#160;Instead,&#160;it&#160;is&#160;a&#160;range<br/>creation&#160;expression.&#160;It&#160;follows,&#160;therefore,&#160;that&#160;..&#160;and&#160;...&#160;are&#160;operators&#160;rather&#160;than&#160;just<br/>range literal syntax.<br/>The&#160;..&#160;and&#160;...&#160;operators&#160;are&#160;not&#160;method-based&#160;and&#160;cannot&#160;be&#160;redefined.&#160;They&#160;have<br/>relatively&#160;low&#160;precedence,&#160;which&#160;means&#160;that&#160;they&#160;can&#160;usually&#160;be&#160;used&#160;without&#160;putting<br/>parentheses around the left or right operands:<br/>
x+1..x*x<br/>
The value of these operators is a&#160;Range&#160;object.&#160;x..y&#160;is the same as:<br/>
Range.new(x,y)<br/>
And&#160;x...y&#160;is the same as:<br/>
Range.new(x,y,true)<br/>
<b>4.6.9.1 &#160;Boolean flip-flops<br/></b>When&#160;the&#160;..&#160;and&#160;...&#160;operators&#160;are&#160;used&#160;in&#160;a&#160;conditional,&#160;such&#160;as&#160;an&#160;if&#160;statement,&#160;or<br/>in&#160;a&#160;loop,&#160;such&#160;as&#160;a&#160;while<a href="Rubys.html#131">&#160;loop (see&#160;Chapter 5&#160;</a>for&#160;more&#160;about&#160;conditionals&#160;and&#160;loops),<br/>they&#160;&#160;do&#160;&#160;not&#160;&#160;create&#160;&#160;Range&#160;&#160;objects.&#160;&#160;Instead,&#160;&#160;they&#160;&#160;create&#160;&#160;a&#160;&#160;special&#160;&#160;kind&#160;&#160;of&#160;&#160;Boolean<br/>expression&#160;called&#160;a&#160;<i>flip-flop</i>.&#160;A&#160;flip-flop&#160;expression&#160;evaluates&#160;to&#160;true&#160;or&#160;false,&#160;just&#160;as<br/>comparison&#160;and&#160;equality&#160;expressions&#160;do.&#160;The&#160;extraordinarily&#160;unusual&#160;thing&#160;about&#160;a<br/>flip-flop&#160;expression,&#160;however,&#160;is&#160;that&#160;its&#160;value&#160;depends&#160;on&#160;the&#160;value&#160;of&#160;previous&#160;evalu-<br/>ations.&#160;&#160;This&#160;&#160;means&#160;&#160;that&#160;&#160;a&#160;&#160;flip-flop&#160;&#160;expression&#160;&#160;has&#160;&#160;state&#160;&#160;associated&#160;&#160;with&#160;&#160;it;&#160;&#160;it&#160;&#160;must<br/>remember&#160;information&#160;about&#160;previous&#160;evaluations.&#160;Because&#160;it&#160;has&#160;state,&#160;you&#160;would<br/>expect&#160;a&#160;flip-flop&#160;to&#160;be&#160;an&#160;object&#160;of&#160;some&#160;sort.&#160;But&#160;it&#160;isn’t—it’s&#160;a&#160;Ruby&#160;expression,&#160;and<br/>the&#160;Ruby&#160;interpreter&#160;stores&#160;the&#160;state&#160;(just&#160;a&#160;single&#160;Boolean&#160;value)&#160;it&#160;requires&#160;in&#160;its&#160;internal<br/>parsed representation of the expression.<br/>
<b>4.6 &#160;Operators&#160;|&#160;109</b><br/>
<hr/>
<a name=124></a>With&#160;that&#160;background&#160;in&#160;mind,&#160;consider&#160;the&#160;flip-flop&#160;in&#160;the&#160;following&#160;code.&#160;Note&#160;that<br/>the&#160;&#160;first&#160;&#160;..&#160;&#160;in&#160;&#160;the&#160;&#160;code&#160;&#160;creates&#160;&#160;a&#160;&#160;Range&#160;&#160;object.&#160;&#160;The&#160;&#160;second&#160;&#160;one&#160;&#160;creates&#160;&#160;the&#160;&#160;flip-flop<br/>expression:<br/>
(1..10).each {|x| print x if x==3..x==5 }<br/>
The&#160;flip-flop&#160;consists&#160;of&#160;two&#160;Boolean&#160;expressions&#160;joined&#160;with&#160;the&#160;..&#160;operator,&#160;in&#160;the<br/>context&#160;of&#160;a&#160;conditional&#160;or&#160;loop.&#160;A&#160;flip-flop&#160;expression&#160;is&#160;false&#160;unless&#160;and&#160;until&#160;the<br/>lefthand&#160;expression&#160;evaluates&#160;to&#160;true.&#160;Once&#160;that&#160;expression&#160;has&#160;become&#160;true,&#160;the&#160;ex-<br/>pression&#160;“flips”&#160;into&#160;a&#160;persistent&#160;true&#160;state.&#160;It&#160;remains&#160;in&#160;that&#160;state,&#160;and&#160;subsequent<br/>evaluations&#160;return&#160;true&#160;until&#160;the&#160;righthand&#160;expression&#160;evaluates&#160;to&#160;true.&#160;When&#160;that<br/>happens, the flip-flop “flops” back to a persistent&#160;false&#160;state. Subsequent evaluations<br/>of the expression return&#160;false&#160;until the lefthand expression becomes&#160;true&#160;again.<br/>In&#160;the&#160;code&#160;example,&#160;the&#160;flip-flop&#160;is&#160;evaluated&#160;repeatedly,&#160;for&#160;values&#160;of&#160;x&#160;from&#160;1&#160;to<br/>10.&#160;&#160;It&#160;&#160;starts&#160;&#160;off&#160;&#160;in&#160;&#160;the&#160;&#160;false&#160;&#160;state,&#160;&#160;and&#160;&#160;evaluates&#160;&#160;to&#160;&#160;false&#160;&#160;when&#160;&#160;x&#160;&#160;is&#160;&#160;1&#160;&#160;and&#160;&#160;2.&#160;&#160;When<br/>x==3,&#160;the&#160;flip-flop&#160;flips&#160;to&#160;true&#160;and&#160;returns&#160;true.&#160;It&#160;continues&#160;to&#160;return&#160;true&#160;when&#160;x&#160;is<br/>4&#160;and&#160;5.&#160;When&#160;x==5,&#160;however,&#160;the&#160;flip-flop&#160;flops&#160;back&#160;to&#160;false,&#160;and&#160;returns&#160;false&#160;for<br/>the remaining values of&#160;x. The result is that this code prints&#160;345.<br/>Flip-flops&#160;can&#160;be&#160;written&#160;with&#160;either&#160;..&#160;or&#160;....&#160;The&#160;difference&#160;is&#160;that&#160;when&#160;a&#160;..&#160;flip-flop<br/>flips&#160;to&#160;true,&#160;it&#160;returns&#160;true&#160;but&#160;also&#160;tests&#160;its&#160;righthand&#160;expression&#160;to&#160;see&#160;if&#160;it&#160;should<br/>flop&#160;its&#160;internal&#160;state&#160;back&#160;to&#160;false.&#160;The&#160;...&#160;form&#160;waits&#160;for&#160;its&#160;next&#160;evaluation&#160;before<br/>testing the righthand expression. Consider these two lines:<br/>
# Prints &#34;3&#34;. Flips and flops back when x==3<br/>(1..10).each {|x| print x if x==3..x&gt;=3 } &#160;<br/># Prints &#34;34&#34;. Flips when x == 3 and flops when x==4<br/>(1..10).each {|x| print x if x==3...x&gt;=3 } # Prints &#34;34&#34;<br/>
Flip-flops&#160;are&#160;a&#160;fairly&#160;obscure&#160;feature&#160;of&#160;Ruby&#160;and&#160;are&#160;probably&#160;best&#160;avoided&#160;in&#160;your<br/>code.&#160;They&#160;are&#160;not&#160;unique&#160;to&#160;Ruby,&#160;however.&#160;Ruby&#160;inherits&#160;this&#160;feature&#160;from&#160;Perl,&#160;which<br/>in&#160;turn&#160;inherits&#160;them&#160;from&#160;the&#160;Unix&#160;text-processing&#160;tools&#160;<i>sed</i>&#160;and&#160;<i>awk</i>.*&#160;&#160;Flip-flops&#160;were<br/>originally&#160;intended&#160;for&#160;matching&#160;the&#160;lines&#160;of&#160;a&#160;text&#160;file&#160;between&#160;a&#160;start&#160;pattern&#160;and&#160;an<br/>end&#160;pattern.&#160;This&#160;continues&#160;to&#160;be&#160;a&#160;useful&#160;way&#160;to&#160;use&#160;them.&#160;The&#160;following&#160;simple&#160;Ruby<br/>program&#160;demonstrates&#160;a&#160;flip-flop.&#160;It&#160;reads&#160;a&#160;text&#160;file&#160;line-by-line&#160;and&#160;prints&#160;any&#160;line&#160;that<br/>contains the text “TODO”. It then continues printing lines until it reads a blank line:<br/>
ARGF.each do |line| &#160; # For each line of standard in or of named files<br/>&#160; print line if line=~/TODO/..line=~/^$/ # Print lines when flip-flop is true<br/>end<br/>
It&#160;is&#160;difficult&#160;to&#160;formally&#160;describe&#160;the&#160;precise&#160;behavior&#160;of&#160;a&#160;flip-flop.&#160;It&#160;is&#160;easier&#160;to&#160;un-<br/>derstand&#160;flip-flops&#160;by&#160;studying&#160;code&#160;that&#160;behaves&#160;in&#160;an&#160;equivalent&#160;way.&#160;The&#160;following<br/>function&#160;behaves&#160;like&#160;the&#160;flip-flop&#160;x==3..x==5.&#160;It&#160;hardcodes&#160;the&#160;lefthand&#160;and&#160;righthand<br/>conditions&#160;into&#160;the&#160;function&#160;itself,&#160;and&#160;it&#160;uses&#160;a&#160;global&#160;variable&#160;to&#160;store&#160;the&#160;state&#160;of&#160;the<br/>flip-flop:<br/>
*&#160;..&#160;creates an&#160;<i>awk</i>-style flip-flop, and&#160;...&#160;creates a&#160;<i>sed</i>-style flip-flop.<br/>
<b>110&#160;|&#160;Chapter 4:</b> <b>Expressions and Operators</b><br/>
<hr/>
<a name=125></a>$state = false &#160; &#160; &#160; &#160; &#160; &#160;# Global storage for flip-flop state<br/>def flipflop(x) &#160; &#160; &#160; &#160; &#160; # Test value of x against flip-flop<br/>&#160; if !$state &#160; &#160; &#160; &#160; &#160; &#160; &#160;# If saved state is false<br/>&#160; &#160; result = (x == 3) &#160; &#160; # Result is value of lefthand operand<br/>&#160; &#160; if result &#160; &#160; &#160; &#160; &#160; &#160; # If that result is true<br/>&#160; &#160; &#160; $state = !(x == 5) &#160;# Then saved state is not of the righthand operand<br/>&#160; &#160; end<br/>&#160; &#160; result &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Return result<br/>&#160; else &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Otherwise, if saved state is true<br/>&#160; &#160; $state = !(x == 5) &#160; &#160;# Then save the inverse of the righthand operand<br/>&#160; &#160; true &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# And return true without testing lefthand<br/>&#160; end<br/>end<br/>
With&#160;this&#160;flip-flop&#160;function&#160;defined,&#160;we&#160;can&#160;write&#160;the&#160;following&#160;code,&#160;which&#160;prints<br/>345&#160;just like our earlier example:<br/>
(1..10).each {|x| print x if flipflop(x) }<br/>
The following function simulates the behavior of the three-dot flip-flop&#160;x==3...x&gt;=3:<br/>
$state2 = false<br/>def flipflop2(x)<br/>&#160; if !$state2<br/>&#160; &#160; $state2 = (x == 3)<br/>&#160; else<br/>&#160; &#160; $state2 = !(x &gt;= 3)<br/>&#160; &#160; true<br/>&#160; end<br/>end<br/>
# Now try it out<br/>(1..10).each {|x| print x if x==3...x&gt;=3 } &#160;# Prints &#34;34&#34;&#160;<br/>(1..10).each {|x| print x if flipflop2(x) } # Prints &#34;34&#34;&#160;<br/>
&#160;<br/>
<b>4.6.10 &#160;Conditional: ?:<br/></b>The&#160;?:&#160;operator&#160;is&#160;known&#160;as&#160;the&#160;conditional&#160;operator.&#160;It&#160;is&#160;the&#160;only&#160;ternary&#160;operator<br/>(three&#160;operands)&#160;in&#160;Ruby.&#160;The&#160;first&#160;operand&#160;appears&#160;before&#160;the&#160;question&#160;mark.&#160;The<br/>second&#160;&#160;operand&#160;&#160;appears&#160;&#160;between&#160;&#160;the&#160;&#160;question&#160;&#160;mark&#160;&#160;and&#160;&#160;the&#160;&#160;colon.&#160;&#160;And&#160;&#160;the&#160;&#160;third<br/>operand appears after the colon.<br/>The&#160;?:&#160;operator&#160;always&#160;evaluates&#160;its&#160;first&#160;operand.&#160;If&#160;the&#160;first&#160;operand&#160;is&#160;anything&#160;other<br/>than&#160;&#160;false&#160;&#160;or&#160;&#160;nil,&#160;&#160;the&#160;&#160;value&#160;&#160;of&#160;&#160;the&#160;&#160;expression&#160;&#160;is&#160;&#160;the&#160;&#160;value&#160;&#160;of&#160;&#160;the&#160;&#160;second&#160;&#160;operand.<br/>Otherwise,&#160;if&#160;the&#160;first&#160;operand&#160;is&#160;false&#160;or&#160;nil,&#160;then&#160;the&#160;value&#160;of&#160;the&#160;expression&#160;is&#160;the<br/>value&#160;of&#160;the&#160;third&#160;operand.&#160;In&#160;either&#160;case,&#160;one&#160;of&#160;the&#160;operands&#160;is&#160;never&#160;evaluated&#160;(which<br/>matters&#160;&#160;if&#160;&#160;it&#160;&#160;includes&#160;&#160;side&#160;&#160;effects&#160;&#160;like&#160;&#160;assignment).&#160;&#160;Here&#160;&#160;is&#160;&#160;an&#160;&#160;example&#160;&#160;use&#160;&#160;of&#160;&#160;this<br/>operator:<br/>
&#34;You have #{n} #{n==1 ? 'message' : 'messages'}&#34;<br/>
As&#160;you&#160;can&#160;see,&#160;the&#160;?:&#160;operator&#160;acts&#160;like&#160;a&#160;compact&#160;if/then/else&#160;statement.&#160;(Ruby’s<br/>if&#160;conditional&#160;is&#160;described&#160;<a href="Rubys.html#131">in&#160;Chapter&#160;5.)&#160;</a>The&#160;first&#160;operand&#160;is&#160;the&#160;condition&#160;that&#160;is&#160;being<br/>
<b>4.6 &#160;Operators&#160;|&#160;111</b><br/>
<hr/>
<a name=126></a>tested,&#160;like&#160;the&#160;expression&#160;after&#160;the&#160;if.&#160;The&#160;second&#160;operand&#160;is&#160;like&#160;the&#160;code&#160;that&#160;follows<br/>the&#160;then.&#160;And&#160;the&#160;third&#160;operand&#160;is&#160;like&#160;the&#160;code&#160;that&#160;follows&#160;the&#160;else.&#160;The&#160;difference<br/>between&#160;the&#160;?:&#160;operator&#160;and&#160;the&#160;if&#160;statement,&#160;of&#160;course,&#160;is&#160;that&#160;the&#160;if&#160;statement&#160;allows<br/>arbitrary amounts of code in its&#160;then&#160;and&#160;else&#160;clauses, whereas the&#160;?:&#160;operator allows<br/>only single expressions.<br/>The&#160;?:&#160;operator&#160;has&#160;fairly&#160;low&#160;precedence,&#160;which&#160;means&#160;that&#160;it&#160;is&#160;usually&#160;not&#160;necessary<br/>to&#160;put&#160;parentheses&#160;around&#160;the&#160;operands.&#160;If&#160;the&#160;first&#160;operand&#160;uses&#160;the&#160;defined?&#160;operator,<br/>or if the second and third operands perform assignments, then parentheses are neces-<br/>sary.&#160;Remember&#160;that&#160;Ruby&#160;allows&#160;method&#160;names&#160;to&#160;end&#160;with&#160;a&#160;question&#160;mark.&#160;If&#160;the<br/>first&#160;&#160;operand&#160;&#160;of&#160;&#160;the&#160;&#160;?:&#160;&#160;operator&#160;&#160;ends&#160;&#160;with&#160;&#160;an&#160;&#160;identifier,&#160;&#160;you&#160;&#160;must&#160;&#160;put&#160;&#160;parentheses<br/>around&#160;the&#160;first&#160;operand&#160;or&#160;include&#160;a&#160;disambiguating&#160;space&#160;between&#160;that&#160;operand&#160;and<br/>the&#160;question&#160;mark.&#160;If&#160;you&#160;don’t&#160;do&#160;this,&#160;the&#160;Ruby&#160;interpreter&#160;thinks&#160;that&#160;the&#160;question<br/>mark of the operator is part of the previous identifier. For example:<br/>
x==3?y:z &#160; &#160; &#160;# This is legal<br/>3==x?y:z &#160; &#160; &#160;# Syntax error: x? is interpreted as a method name<br/>(3==x)?y:z &#160; &#160;# Okay: parentheses fix the problem<br/>3==x ?y:z &#160; &#160; # Spaces also resolve the problem<br/>
The&#160;question&#160;mark&#160;must&#160;appear&#160;on&#160;the&#160;same&#160;line&#160;as&#160;the&#160;first&#160;argument.&#160;In&#160;Ruby&#160;1.8,<br/>the&#160;colon&#160;must&#160;appear&#160;on&#160;the&#160;same&#160;line&#160;as&#160;the&#160;second&#160;argument.&#160;In&#160;Ruby&#160;1.9,&#160;however,<br/>a&#160;newline&#160;is&#160;allowed&#160;before&#160;the&#160;colon.&#160;You&#160;must&#160;follow&#160;the&#160;colon&#160;by&#160;a&#160;space&#160;in&#160;this&#160;case,<br/>however, so it doesn’t appear to introduce a symbol literal.<br/><a href="Rubys.html#116">Table&#160;4-2&#160;</a>(earlier&#160;in&#160;this&#160;chapter)&#160;says&#160;that&#160;the&#160;?:&#160;operator&#160;is&#160;right-associative.&#160;If&#160;the<br/>operator is used twice in the same expression, the rightmost one is grouped:<br/>
a ? b : c ? d : e &#160; &#160;# This expression...<br/>a ? b : (c ? d : e) &#160;# is evaluated like this..<br/>(a ? b : c) ? d : e &#160;# NOT like this<br/>
This&#160;kind&#160;of&#160;ambiguity&#160;is&#160;actually&#160;fairly&#160;rare&#160;with&#160;the&#160;?:&#160;operator.&#160;The&#160;following&#160;ex-<br/>pression&#160;&#160;uses&#160;&#160;three&#160;&#160;conditional&#160;&#160;operators&#160;&#160;to&#160;&#160;compute&#160;&#160;the&#160;&#160;maximum&#160;&#160;value&#160;&#160;of&#160;&#160;three<br/>variables.&#160;&#160;No&#160;&#160;parentheses&#160;&#160;are&#160;&#160;required&#160;&#160;(although&#160;&#160;spaces&#160;&#160;are&#160;&#160;required&#160;&#160;before&#160;&#160;the<br/>question marks), as there is only one possible way to parse the statement:<br/>
max = x&gt;y ? x&gt;z ? x : z : y&gt;z ? y : z<br/>max = x&gt;y ? (x&gt;z ? x : z) : (y&gt;z ? y : z) &#160;# With explicit parentheses<br/>
<b>4.6.11 &#160;Assignment Operators<br/></b>You’ve&#160;already&#160;read&#160;about&#160;assignment&#160;expressions&#160;in&#160;<a href="Rubys.html#106">§4.5.&#160;</a>It&#160;is&#160;worth&#160;noting&#160;here&#160;a<br/>few&#160;points&#160;about&#160;the&#160;assignment&#160;operators&#160;used&#160;in&#160;those&#160;expressions.&#160;First,&#160;the&#160;value<br/>of&#160;an&#160;assignment&#160;expression&#160;is&#160;the&#160;value&#160;(or&#160;an&#160;array&#160;of&#160;the&#160;values)&#160;that&#160;appears&#160;on&#160;the<br/>righthand&#160;side&#160;of&#160;the&#160;assignment&#160;operator.&#160;Second,&#160;assignment&#160;operators&#160;are&#160;right-<br/>associative.&#160;Points&#160;one&#160;and&#160;two&#160;together&#160;are&#160;what&#160;make&#160;expressions&#160;like&#160;this&#160;one&#160;work:<br/>
x = y = z = 0 &#160; &#160; &#160;# Assign zero to variables x, y, and z<br/>x = (y = (z = 0)) &#160;# This equivalent expression shows order of evaluation<br/>
<b>112&#160;|&#160;Chapter 4:</b> <b>Expressions and Operators</b><br/>
<hr/>
<a name=127></a>Third,&#160;note&#160;that&#160;assignment&#160;has&#160;very&#160;low&#160;precedence.&#160;Precedence rules mean that just<br/>about&#160;&#160;anything&#160;&#160;that&#160;&#160;follows&#160;&#160;an&#160;&#160;assignment&#160;&#160;operator&#160;&#160;will&#160;&#160;be&#160;&#160;evaluated&#160;&#160;before&#160;&#160;the<br/>assignment is performed. The main exceptions are the&#160;and,&#160;or, and&#160;not&#160;operators.<br/>Finally,&#160;note&#160;that&#160;although&#160;assignment&#160;operators&#160;cannot&#160;be&#160;defined&#160;as&#160;methods,&#160;the<br/>compound&#160;assignment&#160;operators&#160;like&#160;+=&#160;use&#160;redefinable&#160;operators&#160;like&#160;+.&#160;Redefining<br/>the&#160;+&#160;operator&#160;does&#160;not&#160;affect&#160;the&#160;assignment&#160;performed&#160;by&#160;the&#160;+=&#160;operator,&#160;but&#160;it&#160;does<br/>affect the addition performed by that operator.<br/>
<b>4.6.12 &#160;The defined? Operator<br/></b>defined?&#160;is&#160;a&#160;unary&#160;operator&#160;that&#160;tests&#160;whether&#160;its&#160;operand&#160;is&#160;defined&#160;or&#160;not.&#160;Normally,<br/>using&#160;an&#160;undefined&#160;variable&#160;or&#160;method&#160;raises&#160;an&#160;exception.&#160;When&#160;the&#160;expression&#160;on<br/>the&#160;right&#160;of&#160;the&#160;defined?&#160;operator&#160;uses&#160;an&#160;undefined&#160;variable&#160;or&#160;method&#160;(including<br/>operators&#160;defined&#160;as&#160;methods),&#160;defined?&#160;simply&#160;returns&#160;nil.&#160;Similarly,&#160;defined?&#160;returns<br/>nil&#160;if&#160;the&#160;operand&#160;is&#160;an&#160;expression&#160;that&#160;uses&#160;yield&#160;or&#160;super&#160;in&#160;an&#160;inappropriate&#160;context<br/>(i.e.,&#160;&#160;when&#160;&#160;there&#160;&#160;is&#160;&#160;no&#160;&#160;block&#160;&#160;to&#160;&#160;yield&#160;&#160;to,&#160;&#160;or&#160;&#160;no&#160;&#160;superclass&#160;&#160;method&#160;&#160;to&#160;&#160;invoke).&#160;&#160;It&#160;&#160;is<br/>important&#160;to&#160;understand&#160;that&#160;the&#160;expression&#160;that&#160;is&#160;the&#160;operand&#160;to&#160;&#160;defined?&#160;is&#160;not<br/>actually&#160;evaluated;&#160;it&#160;is&#160;simply&#160;checked&#160;to&#160;see&#160;whether&#160;it&#160;<i>could&#160;be</i>&#160;evaluated&#160;without<br/>error. Here is a typical use of the&#160;defined?&#160;operator:<br/>
# Compute f(x), but only if f and x are both defined<br/>y = f(x) if defined? f(x)<br/>
If&#160;the&#160;operand&#160;is&#160;defined,&#160;the&#160;defined?&#160;operator&#160;returns&#160;a&#160;string.&#160;The&#160;content&#160;of&#160;this<br/>returned&#160;string&#160;is&#160;usually&#160;unimportant;&#160;what&#160;matters&#160;is&#160;that&#160;it&#160;is&#160;a&#160;true&#160;value—neither<br/>nil&#160;nor&#160;false.&#160;It&#160;is&#160;possible,&#160;however,&#160;to&#160;inspect&#160;the&#160;value&#160;returned&#160;by&#160;this&#160;operator&#160;to<br/>learn&#160;something&#160;about&#160;the&#160;type&#160;of&#160;the&#160;expression&#160;on&#160;the&#160;righthand&#160;<a href="Rubys.html#127">side.&#160;Table 4-3&#160;lists<br/></a>the possible return values of this operator.<br/>
<i>Table 4-3. Return values of the defined? operator</i><br/>
<b>Operand expression type</b><br/>
<b>Return value</b><br/>
Reference to defined local variable<br/>
&#34;local-variable&#34;<br/>
Reference to defined block local variable (Ruby 1.8 only)<br/>
&#34;local-variable(in-<br/>block)&#34;<br/>
Reference to defined global variable<br/>
&#34;global-variable&#34;<br/>
Special regular expression global variables,&#160;$&amp;,&#160;$+,&#160;$`,&#160;$', and&#160;$1&#160;to&#160;$9, when defined<br/>
Name of variable, as a string<br/>
following a successful match (Ruby 1.8 only)<br/>Reference to defined constant<br/>
&#34;constant&#34;<br/>
Reference to defined instance variable<br/>
&#34;instance-variable&#34;<br/>
Reference to defined class variable<br/>
&#34;class variable&#34;&#160;(note<br/>no hyphen)<br/>
nil<br/>
&#34;nil&#34;&#160;(note this is a string)<br/>
true,&#160;false<br/>
&#34;true&#34;,&#160;&#34;false&#34;<br/>
<b>4.6 &#160;Operators&#160;|&#160;113</b><br/>
<hr/>
<a name=128></a><b>Operand expression type</b><br/>
<b>Return value</b><br/>
self<br/>
&#34;self&#34;<br/>
yield&#160;when there is a block to yield to (see also&#160;Kernel&#160;method&#160;block_given?)<br/>
&#34;yield&#34;<br/>
super&#160;when in context where it is allowed<br/>
&#34;super&#34;<br/>
Assignment (assignment is not actually performed)<br/>
&#34;assignment&#34;<br/>
Method invocation, including operators defined as methods (method is not actually invoked<br/>
&#34;method&#34;<br/>
and need not have correct number of arguments; see also&#160;Object.respond_to?)<br/>Any other valid expression, including literals and built-in operators<br/>
&#34;expression&#34;<br/>
Any expression that uses an undefined variable or method name, or that uses&#160;yield&#160;or<br/>
nil<br/>
super&#160;where they are not allowed<br/>
The&#160;&#160;defined?&#160;&#160;operator&#160;&#160;has&#160;&#160;very&#160;&#160;low&#160;&#160;precedence.&#160;&#160;If&#160;&#160;you&#160;&#160;want&#160;&#160;to&#160;&#160;test&#160;&#160;whether&#160;&#160;two<br/>variables are defined, use&#160;and&#160;instead of&#160;&amp;&amp;:<br/>
defined? a and defined? b &#160; &#160;# This works<br/>defined? a &amp;&amp; defined? b &#160; &#160; # Evaluated as: defined?((a &amp;&amp; defined? b))<br/>
<b>4.6.13 &#160;Statement Modifiers<br/></b>rescue,&#160;if,&#160;unless,&#160;while, and&#160;until&#160;are&#160;conditional,&#160;looping,&#160;and&#160;exception-handling<br/>statements&#160;that&#160;affect&#160;the&#160;flow-of-control&#160;of&#160;a&#160;Ruby&#160;program.&#160;They&#160;can&#160;also&#160;be&#160;used&#160;as<br/>statement modifiers, in code like this:<br/>
print x if x<br/>
In&#160;this&#160;modifier&#160;form,&#160;they&#160;can&#160;be&#160;considered&#160;operators&#160;in&#160;which&#160;the&#160;value&#160;of&#160;the&#160;right-<br/>hand&#160;expression&#160;affects&#160;the&#160;execution&#160;of&#160;the&#160;lefthand&#160;expression.&#160;(Or,&#160;in&#160;the&#160;case&#160;of&#160;the<br/>rescue&#160;modifier,&#160;the&#160;exception&#160;status&#160;of&#160;the&#160;lefthand&#160;expression&#160;affects&#160;the&#160;execution<br/>of the righthand operand.)<br/>It&#160;is&#160;not&#160;particularly&#160;useful&#160;to&#160;describe&#160;these&#160;keywords&#160;as&#160;operators.&#160;They&#160;are&#160;docu-<br/>mented,&#160;&#160;in&#160;&#160;both&#160;&#160;their&#160;&#160;statement&#160;&#160;and&#160;&#160;expression&#160;&#160;modifier&#160;&#160;form,&#160;&#160;in&#160;&#160;<a href="Rubys.html#131">Chapter&#160;&#160;5.&#160;&#160;</a>The<br/>keywords&#160;&#160;are&#160;&#160;listed&#160;&#160;in&#160;&#160;<a href="Rubys.html#116">Table&#160;&#160;4-2&#160;&#160;</a>simply&#160;&#160;to&#160;&#160;show&#160;&#160;their&#160;&#160;precedence&#160;&#160;relative&#160;&#160;to&#160;&#160;other<br/>operators.&#160;Note&#160;that&#160;they&#160;all&#160;have&#160;very&#160;low&#160;precedence,&#160;but&#160;that&#160;the&#160;rescue&#160;statement<br/>modifier has higher precedence than assignment.<br/>
<b>4.6.14 &#160;Nonoperators<br/></b>Most&#160;of&#160;Ruby’s&#160;operators&#160;are&#160;written&#160;using&#160;punctuation&#160;characters.&#160;Ruby’s&#160;grammar<br/>also&#160;uses&#160;a&#160;number&#160;of&#160;punctuation&#160;characters&#160;that&#160;are&#160;not&#160;operators.&#160;Although&#160;we’ve<br/>seen&#160;(or&#160;will&#160;see)&#160;much&#160;of&#160;this&#160;nonoperator&#160;punctuation&#160;elsewhere&#160;in&#160;this&#160;book,&#160;let’s<br/>review it here:<br/>
<b>114&#160;|&#160;Chapter 4:</b> <b>Expressions and Operators</b><br/>
<hr/>
<a name=129></a>()<br/>
Parentheses are an optional part of method definition and invocation syntax. It is<br/>better to think of method invocation as a special kind of expression than to think<br/>of&#160;()&#160;as&#160;a&#160;method-invocation&#160;operator.&#160;Parentheses&#160;are&#160;also&#160;used&#160;for&#160;grouping&#160;to<br/>affect the order of evaluation of subexpressions.<br/>
[]<br/>
Square&#160;brackets&#160;are&#160;used&#160;in&#160;array&#160;literals&#160;and&#160;for&#160;querying&#160;and&#160;setting&#160;array&#160;and<br/>hash&#160;values.&#160;In&#160;that&#160;context,&#160;they&#160;are&#160;syntactic&#160;sugar&#160;for&#160;method&#160;invocation&#160;and<br/>behave&#160;&#160;somewhat&#160;&#160;like&#160;&#160;redefinable&#160;&#160;operators&#160;&#160;with&#160;&#160;arbitrary&#160;&#160;arity.&#160;&#160;See&#160;&#160;<a href="Rubys.html#103">§4.4&#160;&#160;</a>and<br/><a href="Rubys.html#108">§4.5.3.</a><br/>
{}<br/>
Curly&#160;braces&#160;are&#160;an&#160;alternative&#160;to&#160;do/end&#160;in&#160;blocks,&#160;and&#160;are&#160;also&#160;used&#160;in&#160;hash&#160;literals.<br/>In neither case do they act as operators.<br/>
.<i>&#160;and&#160;</i>::<br/>
.&#160;and&#160;::&#160;are&#160;used&#160;in&#160;qualified&#160;names,&#160;separating&#160;the&#160;name&#160;of&#160;a&#160;method&#160;from&#160;the<br/>object&#160;on&#160;which&#160;it&#160;is&#160;invoked,&#160;or&#160;the&#160;name&#160;of&#160;a&#160;constant&#160;from&#160;the&#160;module&#160;in&#160;which<br/>it&#160;is&#160;defined.&#160;These&#160;are&#160;not&#160;operators&#160;because&#160;the&#160;righthand&#160;side&#160;is&#160;not&#160;a&#160;value&#160;but<br/>an identifier.<br/>
;<i>,&#160;</i>,<i>, and&#160;</i>=&gt;<br/>
These&#160;punctuation&#160;characters&#160;are&#160;separators&#160;rather&#160;than&#160;operators.&#160;The&#160;semicolon<br/>(;)&#160;is&#160;used&#160;to&#160;separate&#160;statements&#160;on&#160;the&#160;same&#160;line;&#160;the&#160;comma&#160;(,)&#160;is&#160;used&#160;to&#160;separate<br/>method&#160;arguments&#160;and&#160;the&#160;elements&#160;of&#160;array&#160;and&#160;hash&#160;literals;&#160;and&#160;the&#160;arrow&#160;(=&gt;)<br/>is used to separate hash keys from hash values in hash literals.<br/>
:<br/>
A colon is used to prefix symbol literals and is also used in Ruby 1.9 hash syntax.<br/>
*<i>,&#160;</i>&amp;<i>, and&#160;</i>&lt;<br/>
These&#160;punctuation&#160;characters&#160;are&#160;operators&#160;in&#160;some&#160;contexts,&#160;but&#160;they&#160;are&#160;also<br/>used in ways that are not operators. Putting&#160;*&#160;before an array in an assignment or<br/>method&#160;invocation&#160;expression&#160;expands&#160;or&#160;unpacks&#160;the&#160;array&#160;into&#160;its&#160;individual<br/>elements.&#160;Although&#160;it&#160;is&#160;sometimes&#160;known&#160;as&#160;the&#160;splat&#160;operator,&#160;it&#160;is&#160;not&#160;really&#160;an<br/>operator;&#160;*a&#160;cannot stand alone as an expression.<br/>&amp;&#160;can&#160;be&#160;used&#160;in&#160;a&#160;method&#160;declaration&#160;before&#160;the&#160;name&#160;of&#160;the&#160;last&#160;method&#160;argument,<br/>and&#160;this&#160;causes&#160;any&#160;block&#160;passed&#160;to&#160;the&#160;method&#160;to&#160;be&#160;assigned&#160;to&#160;that&#160;argument.<br/><a href="Rubys.html#189">(See&#160;Chapter&#160;6.)&#160;</a>It&#160;can&#160;also&#160;be&#160;used&#160;in&#160;method&#160;invocation&#160;to&#160;pass&#160;a&#160;proc&#160;to&#160;a&#160;method<br/>as if it were a block.<br/>&lt;&#160;is used in class definitions to specify the superclass of class.<br/>
<b>4.6 &#160;Operators&#160;|&#160;115</b><br/>
<hr/>
<a name=130></a><hr/>
<a name=131></a><img src="Ruby-131_1.jpg"/><br/>
<b>CHAPTER&#160;5</b><br/>
<b>Statements and Control Structures</b><br/>
<b>117</b><br/>
<hr/>
<a name=132></a>Consider&#160;&#160;the&#160;&#160;following&#160;&#160;Ruby&#160;&#160;program.&#160;&#160;It&#160;&#160;adds&#160;&#160;two&#160;&#160;numbers&#160;&#160;passed&#160;&#160;to&#160;&#160;it&#160;&#160;on&#160;&#160;the<br/>command line and prints the sum:<br/>
x = ARGV[0].to_f &#160;# Convert first argument to a number<br/>y = ARGV[1].to_f &#160;# Convert second argument to a number<br/>sum = x + y &#160; &#160; &#160; # Add the arguments<br/>puts sum &#160; &#160; &#160; &#160; &#160;# Print the sum<br/>
This&#160;is&#160;a&#160;simple&#160;program&#160;that&#160;consists&#160;primarily&#160;of&#160;variable&#160;assignment&#160;and&#160;method<br/>invocations.&#160;What&#160;makes&#160;it&#160;particularly&#160;simple&#160;is&#160;its&#160;purely&#160;sequential&#160;execution.&#160;The<br/>four&#160;lines&#160;of&#160;code&#160;are&#160;executed&#160;one&#160;after&#160;the&#160;other&#160;without&#160;branching&#160;or&#160;repetition.&#160;It<br/>is&#160;a&#160;rare&#160;program&#160;that&#160;can&#160;be&#160;this&#160;simple.&#160;This&#160;chapter&#160;introduces&#160;Ruby’s&#160;control&#160;struc-<br/>tures,&#160;which&#160;alter&#160;the&#160;sequential&#160;execution,&#160;or&#160;<i>flow-of-control</i>,&#160;of&#160;a&#160;program.&#160;We&#160;cover:<br/>
•&#160;Conditionals<br/>•&#160;Loops<br/>•&#160;Iterators and blocks<br/>•&#160;Flow-altering statements like&#160;return&#160;and&#160;break<br/>•&#160;Exceptions<br/>•&#160;The special-case BEGIN and END statements<br/>•&#160;The esoteric control structures known as&#160;<i>fibers</i>&#160;and&#160;<i>continuations</i><br/>
<b>5.1 &#160;Conditionals<br/></b>The&#160;&#160;most&#160;&#160;common&#160;&#160;control&#160;&#160;structure,&#160;&#160;in&#160;&#160;any&#160;&#160;programming&#160;&#160;language,&#160;&#160;is&#160;&#160;the<br/>conditional.&#160;This&#160;is&#160;a&#160;way&#160;of&#160;telling&#160;the&#160;computer&#160;to&#160;conditionally&#160;execute&#160;some&#160;code:<br/>to&#160;execute&#160;it&#160;only&#160;if&#160;some&#160;condition&#160;is&#160;satisfied.&#160;The&#160;condition&#160;is&#160;an&#160;expression—if&#160;it<br/>evaluates to any value other than&#160;false&#160;or&#160;nil, then the condition is satisfied.<br/>Ruby&#160;&#160;has&#160;&#160;a&#160;&#160;rich&#160;&#160;vocabulary&#160;&#160;for&#160;&#160;expressing&#160;&#160;conditionals.&#160;&#160;The&#160;&#160;syntax&#160;&#160;choices&#160;&#160;are<br/>described&#160;in&#160;the&#160;subsections&#160;that&#160;follow.&#160;When&#160;writing&#160;Ruby&#160;code,&#160;you&#160;can&#160;choose&#160;the<br/>one that seems most elegant for the task at hand.<br/>
<b>5.1.1 &#160;if<br/></b>The&#160;most&#160;straightforward&#160;of&#160;the&#160;conditionals&#160;is&#160;if.&#160;In&#160;its&#160;simplest&#160;form,&#160;it&#160;looks&#160;like&#160;this:<br/>
if&#160;<i>expression<br/></i>&#160;&#160;<i>code<br/></i>end<br/>
The&#160;<i>code</i>&#160;between&#160;if&#160;and&#160;end&#160;is&#160;executed&#160;if&#160;(and&#160;only&#160;if)&#160;the&#160;<i>expression</i>&#160;evaluates&#160;to<br/>something&#160;other&#160;than&#160;false&#160;or&#160;nil.&#160;The&#160;<i>code</i>&#160;must&#160;be&#160;separated&#160;from&#160;the&#160;<i>expression</i><br/>
<b>118&#160;|&#160;Chapter 5:</b> <b>Statements and Control Structures</b><br/>
<hr/>
<a name=133></a>with&#160;a&#160;newline&#160;or&#160;semicolon&#160;or&#160;the&#160;keyword&#160;then.*&#160;&#160;Here&#160;are&#160;two&#160;ways&#160;to&#160;write&#160;the&#160;same<br/>simple conditional:<br/>
# If x is less than 10, increment it<br/>if x &lt; 10 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # newline separator<br/>&#160; x += 1<br/>end<br/>if x &lt; 10 then x += 1 end &#160; &#160; # then separator<br/>
You&#160;can&#160;also&#160;use&#160;then&#160;as&#160;the&#160;separator&#160;token,&#160;and&#160;follow&#160;it&#160;with&#160;a&#160;newline.&#160;Doing&#160;so<br/>makes your code robust; it will work even if the newline is subsequently removed:<br/>
if x &lt; 10 then<br/>&#160; x += 1<br/>end<br/>
Programmers&#160;who&#160;are&#160;used&#160;to&#160;C,&#160;or&#160;languages&#160;whose&#160;syntax&#160;is&#160;derived&#160;from&#160;C,&#160;should<br/>note two important things about Ruby’s&#160;if&#160;statement:<br/>
•&#160;Parentheses&#160;&#160;are&#160;&#160;not&#160;&#160;required&#160;&#160;(and&#160;&#160;typically&#160;&#160;not&#160;&#160;used)&#160;&#160;around&#160;&#160;the&#160;&#160;conditional<br/>
expression.&#160;The&#160;newline,&#160;semicolon,&#160;or&#160;then&#160;keyword&#160;serves&#160;to&#160;delimit&#160;the&#160;expres-<br/>sion instead.<br/>
•&#160;The&#160;end&#160;keyword&#160;is&#160;required,&#160;even&#160;when&#160;the&#160;code&#160;to&#160;be&#160;conditionally&#160;executed<br/>
consists&#160;of&#160;a&#160;single&#160;statement.&#160;The&#160;modifier&#160;form&#160;of&#160;if,&#160;described&#160;below,&#160;provides<br/>a way to write simple conditionals without the&#160;end&#160;keyword.<br/>
<b>5.1.1.1 &#160;else<br/></b>An&#160;&#160;if&#160;&#160;statement&#160;&#160;may&#160;&#160;include&#160;&#160;an&#160;&#160;else&#160;&#160;clause&#160;&#160;to&#160;&#160;specify&#160;&#160;code&#160;&#160;to&#160;&#160;be&#160;&#160;executed&#160;&#160;if&#160;&#160;the<br/>condition is not true:<br/>
if&#160;<i>expression<br/></i>&#160;&#160;<i>code<br/></i>else<br/>&#160;&#160;<i>code<br/></i>end<br/>
The&#160;<i>code</i>&#160;between&#160;the&#160;if&#160;and&#160;else&#160;is&#160;executed&#160;if&#160;<i>expression</i>&#160;evaluates&#160;to&#160;anything&#160;other<br/>than&#160;&#160;false&#160;&#160;or&#160;&#160;nil.&#160;&#160;Otherwise&#160;&#160;(if&#160;&#160;<i>expression</i>&#160;&#160;is&#160;&#160;false&#160;&#160;or&#160;&#160;nil),&#160;&#160;the&#160;&#160;<i>code</i>&#160;&#160;between&#160;&#160;the<br/>else&#160;and&#160;end&#160;is&#160;executed.&#160;As&#160;in&#160;the&#160;simple&#160;form&#160;of&#160;if,&#160;the&#160;<i>expression</i>&#160;must&#160;be&#160;separated<br/>from&#160;&#160;the&#160;&#160;<i>code</i>&#160;&#160;that&#160;&#160;follows&#160;&#160;it&#160;&#160;by&#160;&#160;a&#160;&#160;newline,&#160;&#160;a&#160;&#160;semicolon,&#160;&#160;or&#160;&#160;the&#160;&#160;keyword&#160;&#160;then.&#160;&#160;The<br/>else&#160;&#160;and&#160;&#160;end&#160;&#160;keywords&#160;&#160;fully&#160;&#160;delimit&#160;&#160;the&#160;&#160;second&#160;&#160;chunk&#160;&#160;of&#160;&#160;<i>code</i>,&#160;&#160;and&#160;&#160;no&#160;&#160;newlines&#160;&#160;or<br/>additional delimiters are required.<br/>Here is an example of a conditional that includes an&#160;else&#160;clause:<br/>
if data &#160; &#160; &#160; &#160; # If the array exists<br/>&#160; data &lt;&lt; x &#160; &#160; # &#160; then append a value to it.<br/>else &#160; &#160; &#160; &#160; &#160; &#160;# Otherwise...<br/>
*&#160;Ruby 1.8 also allows a colon, but this syntax is no longer legal in 1.9.<br/>
<b>5.1 &#160;Conditionals&#160;|&#160;119</b><br/>
<hr/>
<a name=134></a>&#160; data = [x] &#160; &#160;# &#160; create a new array that holds the value.<br/>end &#160; &#160; &#160; &#160; &#160; &#160; # This is the end of the conditional.<br/>
<b>5.1.1.2 &#160;elsif<br/></b>If you want&#160;to&#160;test&#160;more&#160;than&#160;one&#160;condition&#160;within&#160;a&#160;conditional,&#160;you&#160;can&#160;add&#160;one&#160;or<br/>more&#160;elsif&#160;clauses&#160;between&#160;an&#160;if&#160;and&#160;an&#160;else.&#160;elsif&#160;is&#160;a&#160;shortened&#160;form&#160;of&#160;“else&#160;if.”<br/>Note that there is only one&#160;<i>e</i>&#160;in&#160;elsif. A conditional using&#160;elsif&#160;looks like this:<br/>
if&#160;<i>expression1<br/></i>&#160;&#160;<i>code1<br/></i>elsif&#160;<i>expression2<br/></i>&#160;&#160;<i>code2<br/></i>&#160; &#160; &#160; .<br/>&#160; &#160; &#160; .<br/>&#160; &#160; &#160; .<br/>elsif&#160;<i>expressionN<br/></i>&#160;&#160;<i>codeN<br/></i>else<br/>&#160;&#160;<i>code<br/></i>end<br/>
If&#160;<i>expression1</i>&#160;evaluates&#160;to&#160;anything&#160;other&#160;than&#160;false&#160;or&#160;nil,&#160;then&#160;<i>code1</i>&#160;is&#160;executed.<br/>Otherwise,&#160;&#160;<i>expression2</i>&#160;&#160;is&#160;&#160;evaluated.&#160;&#160;If&#160;&#160;it&#160;&#160;is&#160;&#160;anything&#160;&#160;other&#160;&#160;than&#160;&#160;false&#160;&#160;or&#160;&#160;nil,&#160;&#160;then<br/><i>code2</i>&#160;is&#160;executed.&#160;This&#160;process&#160;continues&#160;until&#160;an&#160;expression&#160;evaluates&#160;to&#160;something<br/>other&#160;than&#160;false&#160;or&#160;nil,&#160;or&#160;until&#160;all&#160;elsif&#160;clauses&#160;have&#160;been&#160;tested.&#160;If&#160;the&#160;expression<br/>associated&#160;with&#160;the&#160;last&#160;elsif&#160;clause&#160;is&#160;false&#160;or&#160;nil,&#160;and&#160;the&#160;elsif&#160;clause&#160;is&#160;followed&#160;by<br/>an&#160;else&#160;clause,&#160;then&#160;the&#160;code&#160;between&#160;else&#160;and&#160;end&#160;is&#160;executed.&#160;If&#160;no&#160;else&#160;clause&#160;is<br/>present, then no code is executed at all.<br/>
elsif&#160;is like&#160;if:&#160;the&#160;expression&#160;must&#160;be&#160;separated&#160;from&#160;the&#160;code&#160;by&#160;a&#160;newline,&#160;a&#160;semi-<br/>colon, or a&#160;then&#160;keyword. Here is an example of a multiway conditional using&#160;elsif:<br/>
&#160;<br/>
if x == 1<br/>&#160; name = &#34;one&#34;<br/>elsif x == 2<br/>&#160; name = &#34;two&#34;<br/>elsif x == 3 then name = &#34;three&#34;<br/>elsif x == 4; name = &#34;four&#34;<br/>else<br/>&#160; name = &#34;many&#34;<br/>end<br/>
<b>5.1.1.3 &#160;Return value<br/></b>In&#160;most&#160;languages,&#160;the&#160;if&#160;conditional&#160;is&#160;a&#160;statement.&#160;In&#160;Ruby,&#160;however,&#160;everything&#160;is<br/>an&#160;expression,&#160;even&#160;the&#160;control&#160;structures&#160;that&#160;are&#160;commonly&#160;called&#160;statements.&#160;The<br/>return&#160;value&#160;of&#160;an&#160;if&#160;“statement”&#160;(i.e.,&#160;the&#160;value&#160;that&#160;results&#160;from&#160;evaluating&#160;an&#160;if<br/>expression)&#160;is&#160;the&#160;value&#160;of&#160;the&#160;last&#160;expression&#160;in&#160;the&#160;code&#160;that&#160;was&#160;executed,&#160;or&#160;nil&#160;if<br/>no block of code was executed.<br/>
<b>120&#160;|&#160;Chapter 5:</b> <b>Statements and Control Structures</b><br/>
<hr/>
<a name=135></a>The&#160;&#160;fact&#160;&#160;that&#160;&#160;if&#160;&#160;statements&#160;&#160;return&#160;&#160;a&#160;&#160;value&#160;&#160;means&#160;&#160;that,&#160;&#160;for&#160;&#160;example,&#160;&#160;the&#160;&#160;multiway<br/>conditional shown previously can be elegantly rewritten as follows:<br/>
name = if &#160; &#160;x == 1 then &#34;one&#34;<br/>&#160; &#160; &#160; &#160;elsif x == 2 then &#34;two&#34;<br/>&#160; &#160; &#160; &#160;elsif x == 3 then &#34;three&#34;<br/>&#160; &#160; &#160; &#160;elsif x == 4 then &#34;four&#34;<br/>&#160; &#160; &#160; &#160;else &#160; &#160; &#160; &#160; &#160; &#160; &#160;&#34;many&#34;<br/>&#160; &#160; &#160; &#160;end<br/>
<b>5.1.2 &#160;if As a Modifier<br/></b>When&#160;if&#160;is&#160;used&#160;in&#160;its&#160;normal&#160;statement&#160;form,&#160;Ruby’s&#160;grammar&#160;requires&#160;that&#160;it&#160;be<br/>terminated&#160;with&#160;the&#160;end&#160;keyword.&#160;For&#160;simple,&#160;single-line&#160;conditionals,&#160;this&#160;is&#160;somewhat<br/>awkward.&#160;This&#160;is&#160;just&#160;a&#160;parsing&#160;problem,&#160;and&#160;the&#160;solution&#160;is&#160;to&#160;use&#160;the&#160;if&#160;keyword&#160;itself<br/>as&#160;&#160;the&#160;&#160;delimiter&#160;&#160;that&#160;&#160;separates&#160;&#160;the&#160;&#160;code&#160;&#160;to&#160;&#160;be&#160;&#160;executed&#160;&#160;from&#160;&#160;the&#160;&#160;conditional<br/>expression. Instead of writing:<br/>
if&#160;<i>expression</i>&#160;then&#160;<i>code</i>&#160;end<br/>
we can simply write:<br/>
<i>code</i>&#160;if&#160;<i>expression</i><br/>
When&#160;used&#160;in&#160;this&#160;form,&#160;if&#160;is&#160;known&#160;as&#160;a&#160;statement&#160;(or&#160;expression)&#160;<i>modifier</i>. If you’re<br/>a&#160;Perl&#160;programmer,&#160;you&#160;may&#160;be&#160;accustomed&#160;to&#160;this&#160;syntax.&#160;If&#160;not,&#160;please&#160;note&#160;that&#160;the<br/>code to execute comes first, and the expression follows. For example:<br/>
puts message if message &#160; &#160;# Output message, if it is defined<br/>
This&#160;syntax&#160;places&#160;more&#160;emphasis&#160;on&#160;the&#160;code&#160;to&#160;be&#160;executed,&#160;and&#160;less&#160;emphasis&#160;on<br/>the&#160;condition&#160;under&#160;which&#160;it&#160;will&#160;be&#160;executed.&#160;Using&#160;this&#160;syntax&#160;can&#160;make&#160;your&#160;code<br/>more&#160;readable&#160;when&#160;the&#160;condition&#160;is&#160;a&#160;trivial&#160;one&#160;or&#160;when&#160;the&#160;condition&#160;is&#160;almost&#160;always<br/>true.<br/>Even&#160;though&#160;the&#160;condition&#160;is&#160;written&#160;last,&#160;it&#160;is&#160;evaluated&#160;first.&#160;If&#160;it&#160;evaluates&#160;to&#160;anything<br/>other than&#160;false&#160;or&#160;nil,&#160;then&#160;the&#160;code&#160;is&#160;evaluated,&#160;and&#160;its&#160;value&#160;is&#160;used&#160;as&#160;the&#160;return<br/>value&#160;of&#160;the&#160;modified&#160;expression.&#160;Otherwise,&#160;the&#160;code&#160;is&#160;not&#160;executed,&#160;and&#160;the&#160;return<br/>value&#160;of&#160;the&#160;modified&#160;expression&#160;is&#160;nil.&#160;Obviously,&#160;this&#160;syntax&#160;does&#160;not&#160;allow&#160;any&#160;kind<br/>of&#160;else&#160;clause.<br/>To use&#160;if&#160;as&#160;a&#160;modifier,&#160;it&#160;must&#160;follow&#160;the&#160;modified&#160;statement&#160;or&#160;expression&#160;immedi-<br/>ately,&#160;with&#160;no&#160;intervening&#160;line&#160;break.&#160;Inserting&#160;a&#160;newline&#160;into&#160;the&#160;previous&#160;example<br/>turns&#160;it&#160;into&#160;an&#160;unmodified&#160;method&#160;invocation&#160;followed&#160;by&#160;an&#160;incomplete&#160;if&#160;statement:<br/>
puts message &#160; &#160; &#160; &#160;# Unconditional<br/>if message &#160; &#160; &#160; &#160; &#160;# Incomplete!<br/>
The&#160;if&#160;modifier has very low precedence and binds more loosely than the assignment<br/>operator.&#160;Be&#160;sure&#160;you&#160;know&#160;just&#160;what&#160;expression&#160;you&#160;are&#160;modifying&#160;when&#160;you&#160;use&#160;it.<br/>For example, the following two lines of code are different:<br/>
<b>5.1 &#160;Conditionals&#160;|&#160;121</b><br/>
<hr/>
<a name=136></a>y = x.invert if x.respond_to? :invert<br/>y = (x.invert if x.respond_to? :invert)<br/>
In&#160;the&#160;first&#160;line,&#160;the&#160;modifier&#160;applies&#160;to&#160;the&#160;assignment&#160;expression.&#160;If&#160;x&#160;does&#160;not&#160;have&#160;a<br/>method&#160;named&#160;invert,&#160;then&#160;nothing&#160;happens&#160;at&#160;all,&#160;and&#160;the&#160;value&#160;of&#160;y&#160;is&#160;not&#160;modified.<br/>In&#160;the&#160;second&#160;line,&#160;the&#160;if&#160;modifier&#160;applies&#160;only&#160;to&#160;the&#160;method&#160;call.&#160;If&#160;x&#160;does&#160;not&#160;have<br/>an&#160;invert&#160;method,&#160;then&#160;the&#160;modified&#160;expression&#160;evaluates&#160;to&#160;nil,&#160;and&#160;this&#160;is&#160;the&#160;value<br/>that is assigned to&#160;y.<br/>An&#160;if&#160;modifier&#160;binds&#160;to&#160;the&#160;single&#160;nearest&#160;expression.&#160;If&#160;you&#160;want&#160;to&#160;modify&#160;more&#160;than<br/>one&#160;expression,&#160;you&#160;can&#160;use&#160;parentheses&#160;or&#160;a&#160;begin&#160;statement&#160;for&#160;grouping.&#160;But&#160;this<br/>approach&#160;is&#160;problematic&#160;because&#160;readers&#160;don’t&#160;know&#160;that&#160;the&#160;code&#160;is&#160;part&#160;of&#160;a&#160;condi-<br/>tional&#160;until&#160;they&#160;reach&#160;the&#160;bottom.&#160;Also,&#160;using&#160;an&#160;if&#160;modifier&#160;in&#160;this&#160;way&#160;gives&#160;up&#160;the<br/>conciseness&#160;that&#160;is&#160;the&#160;primary&#160;benefit&#160;of&#160;this&#160;syntax.&#160;When&#160;more&#160;than&#160;one&#160;line&#160;of&#160;code<br/>is&#160;involved,&#160;you&#160;should&#160;typically&#160;use&#160;a&#160;traditional&#160;if&#160;statement&#160;rather&#160;than&#160;an&#160;if&#160;modi-<br/>fier. Compare the following three side-by-side alternatives:<br/>
if expression &#160; &#160; begin &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;(<br/>&#160; line1 &#160; &#160; &#160; &#160; &#160; &#160; line1 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;line1<br/>&#160; line2 &#160; &#160; &#160; &#160; &#160; &#160; line2 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;line2<br/>end &#160; &#160; &#160; &#160; &#160; &#160; &#160; end if expression &#160; &#160;) end if expression<br/>
Note&#160;that&#160;an&#160;expression&#160;modified&#160;with&#160;an&#160;if&#160;clause&#160;is&#160;itself&#160;an&#160;expression&#160;that&#160;can&#160;be<br/>modified. It is therefore possible to attach multiple&#160;if&#160;modifiers to an expression:<br/>
# Output message if message exists and the output method is defined<br/>puts message if message if defined? puts<br/>
Repeating&#160;an&#160;if&#160;modifier&#160;like&#160;this&#160;is&#160;hard&#160;to&#160;read,&#160;however,&#160;and&#160;it&#160;makes&#160;more&#160;sense&#160;to<br/>combine the two conditions into a single expression:<br/>
puts message if message and defined? puts<br/>
<b>5.1.3 &#160;unless<br/></b>unless,&#160;as&#160;a&#160;statement&#160;or&#160;a&#160;modifier,&#160;is&#160;the&#160;opposite&#160;of&#160;if:&#160;it&#160;executes&#160;code&#160;only&#160;if&#160;an<br/>associated&#160;expression&#160;evaluates&#160;to&#160;false&#160;or&#160;nil.&#160;Its&#160;syntax&#160;is&#160;just&#160;like&#160;if,&#160;except&#160;that<br/>elsif&#160;clauses are not allowed:<br/>
# single-way unless statement<br/>unless&#160;<i>condition<br/></i>&#160;&#160;<i>code<br/></i>end<br/>
# two-way unless statement<br/>unless&#160;<i>condition<br/></i>&#160;&#160;<i>code<br/></i>else<br/>&#160;&#160;<i>code<br/></i>end<br/>
# unless modifier<br/><i>code</i>&#160;unless&#160;<i>condition</i><br/>
<b>122&#160;|&#160;Chapter 5:</b> <b>Statements and Control Structures</b><br/>
<hr/>
<a name=137></a>The&#160;unless&#160;statement,&#160;like&#160;the&#160;if&#160;statement,&#160;requires&#160;that&#160;the&#160;condition&#160;and&#160;the&#160;code<br/>are&#160;separated&#160;by&#160;a&#160;newline,&#160;a&#160;semicolon,&#160;or&#160;the&#160;&#160;then&#160;keyword.&#160;Also&#160;like&#160;&#160;if,&#160;unless<br/>statements&#160;are&#160;expressions&#160;and&#160;return&#160;the&#160;value&#160;of&#160;the&#160;code&#160;they&#160;execute,&#160;or&#160;nil&#160;if&#160;they<br/>execute nothing:<br/>
# Call the to_s method on object o, unless o is nil<br/>s = unless o.nil? &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# newline separator<br/>&#160; o.to_s<br/>end<br/>s = unless o.nil? then o.to_s end &#160; &#160; &#160; &#160;# then separator<br/>
For single-line conditionals like this, the modifier form of&#160;unless&#160;is usually clearer:<br/>
s = o.to_s unless o.nil?<br/>
Ruby&#160;has&#160;no&#160;equivalent&#160;of&#160;the&#160;elsif&#160;clause&#160;for&#160;an&#160;unless&#160;conditional.&#160;You&#160;can&#160;still&#160;write<br/>a multiway&#160;unless&#160;statement, however, if you’re willing to be a little more verbose:<br/>
unless x == 0<br/>&#160; puts &#34;x is not 0&#34;<br/>else<br/>&#160; unless y == 0<br/>&#160; &#160; puts &#34;y is not 0&#34;<br/>&#160; else<br/>&#160; &#160; unless z == 0<br/>&#160; &#160; &#160; puts &#34;z is not 0&#34;<br/>&#160; &#160; else<br/>&#160; &#160; &#160; puts &#34;all are 0&#34;<br/>&#160; &#160; end<br/>&#160; end<br/>end<br/>
<b>5.1.4 &#160;case<br/></b>The&#160;case&#160;statement&#160;is&#160;a&#160;multiway&#160;conditional.&#160;There&#160;are&#160;two&#160;forms&#160;of&#160;this&#160;statement.<br/>The&#160;simple&#160;(and&#160;infrequently&#160;used)&#160;form&#160;is&#160;nothing&#160;more&#160;than&#160;an&#160;alternative&#160;syntax&#160;for<br/>if/elsif/else. These two side-by-side expressions are equivalent:<br/>
name = case &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; name = if &#160; &#160;x == 1 then &#34;one&#34;<br/>&#160; &#160; &#160; &#160;when x == 1 then &#34;one&#34; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;elsif x == 2 then &#34;two&#34;<br/>&#160; &#160; &#160; &#160;when x == 2 then &#34;two&#34; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;elsif x == 3 then &#34;three&#34;<br/>&#160; &#160; &#160; &#160;when x == 3 then &#34;three&#34; &#160; &#160; &#160; &#160; &#160; &#160; &#160;elsif x == 4 then &#34;four&#34;<br/>&#160; &#160; &#160; &#160;when x == 4 then &#34;four&#34; &#160; &#160; &#160; &#160; &#160; &#160; &#160; else &#34;many&#34;<br/>&#160; &#160; &#160; &#160;else &#34;many&#34; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; end<br/>&#160; &#160; &#160; &#160;end<br/>
As&#160;you&#160;can&#160;see&#160;from&#160;this&#160;code,&#160;the&#160;case&#160;statement&#160;returns&#160;a&#160;value,&#160;just&#160;as&#160;the&#160;if&#160;statement<br/>does.&#160;As&#160;with&#160;the&#160;if&#160;statement,&#160;the&#160;then&#160;keyword&#160;following&#160;the&#160;when&#160;clauses&#160;can&#160;be<br/>replaced with a newline or semicolon:*<br/>
*&#160;Ruby&#160;1.8&#160;also&#160;allows&#160;a&#160;colon&#160;in&#160;place&#160;of&#160;then,&#160;as&#160;it&#160;does&#160;for&#160;the&#160;if&#160;statement.&#160;But&#160;this&#160;syntax&#160;is&#160;no&#160;longer<br/>
allowed in Ruby 1.9.<br/>
<b>5.1 &#160;Conditionals&#160;|&#160;123</b><br/>
<hr/>
<a name=138></a>case&#160;<br/>when x == 1<br/>&#160; &#34;one&#34;<br/>when x == 2&#160;<br/>&#160; &#34;two&#34;<br/>when x == 3<br/>&#160; &#34;three&#34;<br/>end<br/>
The&#160;case&#160;statement&#160;tests&#160;each&#160;of&#160;its&#160;when&#160;expressions&#160;in&#160;the&#160;order&#160;they&#160;are&#160;written&#160;until<br/>it&#160;finds&#160;one&#160;that&#160;evaluates&#160;to&#160;true.&#160;If&#160;it&#160;finds&#160;one,&#160;it&#160;evaluates&#160;the&#160;statements&#160;that&#160;come<br/>between&#160;that&#160;when&#160;and&#160;the&#160;following&#160;when,&#160;else,&#160;or&#160;end.&#160;The&#160;last&#160;expression&#160;evaluated<br/>becomes&#160;the&#160;return&#160;value&#160;of&#160;the&#160;case&#160;statement.&#160;Once&#160;a&#160;when&#160;clause&#160;that&#160;evaluates&#160;to<br/>true&#160;has been found, no other&#160;when&#160;clauses are considered.<br/>
The&#160;else&#160;clause&#160;of&#160;a&#160;case&#160;statement&#160;is&#160;optional,&#160;but&#160;if&#160;it&#160;appears,&#160;it&#160;must&#160;come&#160;at&#160;the<br/>end&#160;of&#160;the&#160;statement,&#160;after&#160;all&#160;when&#160;clauses.&#160;If&#160;no&#160;when&#160;clause&#160;is&#160;true,&#160;and&#160;there&#160;is&#160;an<br/>else&#160;&#160;clause,&#160;&#160;then&#160;&#160;the&#160;&#160;code&#160;&#160;between&#160;&#160;else&#160;&#160;and&#160;&#160;end&#160;&#160;is&#160;&#160;executed.&#160;&#160;The&#160;&#160;value&#160;&#160;of&#160;&#160;the&#160;&#160;last<br/>expression&#160;evaluated&#160;in&#160;this&#160;code&#160;becomes&#160;the&#160;value&#160;of&#160;the&#160;case&#160;statement.&#160;If&#160;no&#160;when<br/>clause&#160;is&#160;true&#160;and&#160;there&#160;is&#160;no&#160;else&#160;clause,&#160;then&#160;no&#160;code&#160;is&#160;executed&#160;and&#160;the&#160;value&#160;of&#160;the<br/>case&#160;statement is&#160;nil.<br/>
A&#160;when&#160;clause&#160;within&#160;a&#160;case&#160;statement&#160;may&#160;have&#160;more&#160;than&#160;one&#160;(comma-separated)<br/>expression&#160;associated&#160;with&#160;it.&#160;If&#160;any&#160;one&#160;of&#160;these&#160;expressions&#160;evaluates&#160;to&#160;true,&#160;then<br/>the&#160;code&#160;associated&#160;with&#160;that&#160;when&#160;is&#160;executed.&#160;In&#160;this&#160;simple&#160;form&#160;of&#160;the&#160;case&#160;statement,<br/>the commas aren’t particularly useful and act just like the&#160;||&#160;operator:<br/>
case<br/>when x == 1, y == 0 then &#160;&#34;x is one or y is zero&#34; &#160;# Obscure syntax<br/>when x == 2 || y == 1 then &#34;x is two or y is one&#34; &#160;# Easier to understand<br/>end<br/>
All&#160;the&#160;case&#160;examples&#160;we’ve&#160;seen&#160;so&#160;far&#160;demonstrate&#160;the&#160;simpler,&#160;less&#160;common&#160;form&#160;of<br/>the&#160;statement.&#160;case&#160;is&#160;really&#160;more&#160;powerful&#160;than&#160;this.&#160;Notice&#160;that&#160;in&#160;most&#160;of&#160;the&#160;exam-<br/>ples,&#160;the&#160;left&#160;side&#160;of&#160;each&#160;when&#160;clause&#160;expression&#160;is&#160;the&#160;same.&#160;In&#160;the&#160;common&#160;form&#160;of<br/>case,&#160;we&#160;factor&#160;this&#160;repeated&#160;lefthand&#160;expression&#160;of&#160;the&#160;when&#160;clause&#160;and&#160;associate&#160;it&#160;with<br/>the&#160;case&#160;itself:<br/>
name = case x<br/>&#160; &#160; &#160; &#160;when 1 &#160; &#160; &#160; &#160; &#160; &#160; # Just the value to compare to x<br/>&#160; &#160; &#160; &#160; &#160;&#34;one&#34;<br/>&#160; &#160; &#160; &#160;when 2 then &#34;two&#34; &#160;# Then keyword instead of newline<br/>&#160; &#160; &#160; &#160;when 3; &#34;three&#34; &#160; &#160;# Semicolon instead of newline<br/>&#160; &#160; &#160; &#160;else &#34;many&#34; &#160; &#160; &#160; &#160;# Optional else clause at end<br/>&#160; &#160; &#160; &#160;end<br/>
In&#160;this&#160;form&#160;of&#160;the&#160;case&#160;statement,&#160;the&#160;expression&#160;associated&#160;with&#160;the&#160;case&#160;is&#160;evaluated<br/>once,&#160;and&#160;then&#160;it’s&#160;compared&#160;to&#160;the&#160;values&#160;obtained&#160;by&#160;evaluating&#160;the&#160;when&#160;expression.<br/>The&#160;comparisons&#160;are&#160;performed&#160;in&#160;the&#160;order&#160;in&#160;which&#160;the&#160;when&#160;clauses&#160;are&#160;written,&#160;and<br/>the code associated with the first matching&#160;when&#160;is executed. If no match is found, the<br/>code&#160;associated&#160;with&#160;the&#160;else&#160;clause&#160;(if&#160;there&#160;is&#160;one)&#160;is&#160;executed.&#160;The&#160;return&#160;value&#160;of<br/>
<b>124&#160;|&#160;Chapter 5:</b> <b>Statements and Control Structures</b><br/>
<hr/>
<a name=139></a>this&#160;form&#160;of&#160;the&#160;case&#160;statement&#160;is&#160;the&#160;same&#160;as&#160;the&#160;return&#160;value&#160;of&#160;the&#160;simpler&#160;form:&#160;the<br/>value of the last expression evaluated, or&#160;nil&#160;if no&#160;when&#160;or&#160;else&#160;matches.<br/>The&#160;important&#160;thing&#160;to&#160;understand&#160;about&#160;the&#160;case&#160;statement&#160;is&#160;how&#160;the&#160;values&#160;of&#160;the<br/>when&#160;clauses&#160;are&#160;compared&#160;to&#160;the&#160;expression&#160;that&#160;follows&#160;the&#160;case&#160;keyword.&#160;This&#160;com-<br/>parison&#160;is&#160;done&#160;using&#160;the&#160;===&#160;operator.&#160;This&#160;operator&#160;is&#160;invoked&#160;on&#160;the&#160;value&#160;of&#160;the<br/>when&#160;&#160;expression&#160;&#160;and&#160;&#160;is&#160;&#160;passed&#160;&#160;the&#160;&#160;value&#160;&#160;of&#160;&#160;the&#160;&#160;case&#160;&#160;expression.&#160;&#160;Therefore,&#160;&#160;the&#160;&#160;case<br/>statement above is equivalent to the following (except that&#160;x&#160;is only evaluated once in<br/>the code above):<br/>
name = case<br/>&#160; &#160; &#160; &#160;when 1 === x then &#34;one&#34;<br/>&#160; &#160; &#160; &#160;when 2 === x then &#34;two&#34;<br/>&#160; &#160; &#160; &#160;when 3 === x then &#34;three&#34;<br/>&#160; &#160; &#160; &#160;else &#34;many&#34;<br/>&#160; &#160; &#160; &#160;end<br/>
===&#160;is&#160;the&#160;<i>case&#160;equality&#160;operator</i>.&#160;For&#160;many&#160;classes,&#160;such&#160;as&#160;the&#160;Fixnum&#160;class&#160;used&#160;earlier,<br/>the&#160;===&#160;operator&#160;behaves&#160;just&#160;the&#160;same&#160;as&#160;==.&#160;But&#160;certain&#160;classes&#160;define&#160;this&#160;operator&#160;in<br/>interesting&#160;&#160;ways.&#160;&#160;The&#160;&#160;Class&#160;&#160;class&#160;&#160;defines&#160;&#160;===&#160;&#160;so&#160;&#160;that&#160;&#160;it&#160;&#160;tests&#160;&#160;whether&#160;&#160;the&#160;&#160;righthand<br/>operand&#160;is&#160;an&#160;instance&#160;of&#160;the&#160;class&#160;named&#160;by&#160;the&#160;lefthand&#160;operand.&#160;Range&#160;defines&#160;this<br/>operator&#160;&#160;to&#160;&#160;test&#160;&#160;whether&#160;&#160;the&#160;&#160;value&#160;&#160;on&#160;&#160;the&#160;&#160;right&#160;&#160;falls&#160;&#160;within&#160;&#160;the&#160;&#160;range&#160;&#160;on&#160;&#160;the&#160;&#160;left.<br/>Regexp&#160;defines&#160;it&#160;so&#160;that&#160;it&#160;tests&#160;whether&#160;the&#160;text&#160;on&#160;the&#160;right&#160;matches&#160;the&#160;pattern&#160;on<br/>the&#160;left.&#160;In&#160;Ruby&#160;1.9,Symbol&#160;defines&#160;===&#160;so&#160;that&#160;it&#160;tests&#160;for&#160;symbol&#160;or&#160;string&#160;equality.<br/>With&#160;these&#160;definitions&#160;of&#160;case&#160;equality,&#160;we&#160;are&#160;able&#160;to&#160;write&#160;interesting&#160;case&#160;statements<br/>like the following:<br/>
# Take different actions depending on the class of x<br/>puts case x<br/>&#160; &#160; &#160;when String then &#34;string&#34;<br/>&#160; &#160; &#160;when Numeric then &#34;number&#34;<br/>&#160; &#160; &#160;when TrueClass, FalseClass then &#34;boolean&#34;<br/>&#160; &#160; &#160;else &#34;other&#34;<br/>&#160; &#160; &#160;end<br/>
# Compute 2006 U.S. income tax using case and Range objects<br/>tax = case income<br/>&#160; &#160; &#160; when 0..7550<br/>&#160; &#160; &#160; &#160; income * 0.1<br/>&#160; &#160; &#160; when 7550..30650<br/>&#160; &#160; &#160; &#160; 755 + (income-7550)*0.15<br/>&#160; &#160; &#160; when 30650..74200<br/>&#160; &#160; &#160; &#160; 4220 + (income-30655)*0.25<br/>&#160; &#160; &#160; when 74200..154800<br/>&#160; &#160; &#160; &#160; 15107.5 + (income-74201)*0.28<br/>&#160; &#160; &#160; when 154800..336550<br/>&#160; &#160; &#160; &#160; 37675.5 + (income-154800)*0.33<br/>&#160; &#160; &#160; else<br/>&#160; &#160; &#160; &#160; 97653 + (income-336550)*0.35<br/>&#160; &#160; &#160; end<br/>
# Get user's input and process it, ignoring comments and exiting<br/>
<b>5.1 &#160;Conditionals&#160;|&#160;125</b><br/>
<hr/>
<a name=140></a># when the user enters the word &#34;quit&#34;<br/>while line=gets.chomp do &#160;# Loop, asking the user for input each time<br/>&#160; case line<br/>&#160; when /^\s*#/ &#160; &#160; &#160; &#160; &#160; &#160;# If input looks like a comment...<br/>&#160; &#160; &#160; next &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# &#160; skip to the next line.<br/>&#160; when /^quit$/i &#160; &#160; &#160; &#160; &#160;# If input is &#34;quit&#34; (case insensitive)...<br/>&#160; &#160; break &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # &#160; exit the loop.<br/>&#160; else &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Otherwise...<br/>&#160; &#160; puts line.reverse &#160; &#160; # &#160; reverse the user's input and print it.<br/>&#160; end<br/>end<br/>
A&#160;when&#160;clause&#160;can&#160;have&#160;more&#160;than&#160;one&#160;expression&#160;associated&#160;with&#160;it.&#160;Multiple&#160;expres-<br/>sions&#160;are&#160;separated&#160;by&#160;commas,&#160;and&#160;the&#160;===&#160;operator&#160;is&#160;invoked&#160;on&#160;each&#160;one.&#160;That&#160;is,<br/>it is possible to trigger the same block of code with more than one value:<br/>
def hasValue?(x) &#160; &#160; &#160; &#160; # Define a method named hasValue?<br/>&#160; case x &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Multiway conditional based on value of x<br/>&#160; when nil, [], &#34;&#34;, 0 &#160; &#160;# if nil===x || []===x || &#34;&#34;===x || 0===x then<br/>&#160; &#160; false &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# &#160; method return value is false<br/>&#160; else &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Otherwise<br/>&#160; &#160; true &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # &#160; method return value is true<br/>&#160; end<br/>end<br/>
<b>case versus switch</b><br/>
Java&#160;programmers&#160;and&#160;others&#160;accustomed&#160;to&#160;C-derived&#160;language&#160;syntax&#160;are&#160;familiar<br/>with&#160;a&#160;multiway&#160;conditional&#160;switch&#160;statement,&#160;which&#160;is&#160;similar&#160;to&#160;Ruby’s&#160;case&#160;state-<br/>ment. There are, however, a number of important differences:<br/>
•&#160;In Java and related languages, the name of the statement is&#160;switch&#160;and its clauses<br/>
are&#160;labeled&#160;with&#160;case&#160;and&#160;default.&#160;Ruby&#160;uses&#160;case&#160;as&#160;the&#160;name&#160;of&#160;the&#160;statement,<br/>and&#160;when&#160;and&#160;else&#160;for the clauses.<br/>
•&#160;The&#160;switch&#160;statement&#160;of&#160;other&#160;languages&#160;simply&#160;transfers&#160;control&#160;to&#160;the&#160;start&#160;of&#160;the<br/>
appropriate&#160;case.&#160;From&#160;there,&#160;control&#160;continues&#160;and&#160;can&#160;“fall&#160;through”&#160;to&#160;other<br/>cases,&#160;until&#160;it&#160;reaches&#160;the&#160;end&#160;of&#160;the&#160;switch&#160;statement&#160;or&#160;encounters&#160;a&#160;break&#160;or<br/>return&#160;statement.&#160;This&#160;fall-through&#160;behavior&#160;allows&#160;multiple&#160;case&#160;clauses to refer<br/>to the same block of code. In Ruby, this same purpose is served by allowing mul-<br/>tiple&#160;comma-separated&#160;expressions&#160;to&#160;be&#160;associated&#160;with&#160;each&#160;when&#160;clause.&#160;Ruby’s<br/>case&#160;statement never allows fall-through.<br/>
•&#160;In&#160;Java&#160;and&#160;most&#160;compiled&#160;languages&#160;with&#160;C-like&#160;syntax,&#160;the&#160;expressions&#160;associ-<br/>
ated&#160;with&#160;each&#160;case&#160;label&#160;must&#160;be&#160;compile-time&#160;constants&#160;rather&#160;than&#160;arbitrary<br/>runtime&#160;&#160;expressions.&#160;&#160;This&#160;&#160;often&#160;&#160;allows&#160;&#160;the&#160;&#160;compiler&#160;&#160;to&#160;&#160;implement&#160;&#160;the&#160;&#160;switch<br/>statement&#160;using&#160;a&#160;very&#160;fast&#160;lookup&#160;table.&#160;There&#160;is&#160;no&#160;such&#160;restriction&#160;on&#160;Ruby’s<br/>case&#160;statement,&#160;and&#160;its&#160;performance&#160;is&#160;equivalent&#160;to&#160;using&#160;an&#160;if&#160;statement&#160;with<br/>repeated&#160;elsif&#160;clauses.<br/>
<b>126&#160;|&#160;Chapter 5:</b> <b>Statements and Control Structures</b><br/>
<hr/>
<a name=141></a><b>5.1.5 &#160;The ?: Operator<br/></b>The&#160;&#160;conditional&#160;&#160;operator&#160;&#160;?:,&#160;&#160;described&#160;&#160;earlier&#160;&#160;in&#160;&#160;<a href="Rubys.html#125">§4.6.10,&#160;&#160;</a>behaves&#160;&#160;much&#160;&#160;like&#160;&#160;an&#160;&#160;if<br/>statement,&#160;with&#160;?&#160;replacing&#160;then&#160;and&#160;:&#160;replacing&#160;else.&#160;It&#160;provides&#160;a&#160;succinct&#160;way&#160;to<br/>express conditionals:<br/>
def how_many_messages(n) # Handle singular/plural&#160;<br/>&#160; &#34;You have &#34; + n.to_s + (n==1 ? &#34; message.&#34; : &#34; messages.&#34;)<br/>end<br/>
<b>5.2 &#160;Loops<br/></b>This&#160;section&#160;documents&#160;Ruby’s&#160;simple&#160;looping&#160;statements:&#160;while,&#160;until,&#160;and&#160;for.&#160;Ruby<br/>also&#160;includes&#160;the&#160;ability&#160;to&#160;define&#160;custom&#160;looping&#160;constructs&#160;known&#160;as&#160;<i>iterators</i>. Iter-<br/>ators&#160;&#160;(see&#160;&#160;<a href="Rubys.html#144">§5.3)&#160;&#160;</a>are&#160;&#160;probably&#160;&#160;more&#160;&#160;commonly&#160;&#160;used&#160;&#160;than&#160;&#160;Ruby’s&#160;&#160;built-in&#160;&#160;looping<br/>statements; they are documented later in this chapter.<br/>
<b>5.2.1 &#160;while and until<br/></b>Ruby’s&#160;basic&#160;looping&#160;statements&#160;are&#160;while&#160;and&#160;until.&#160;They&#160;execute&#160;a&#160;chunk&#160;of&#160;code<br/><i>while</i>&#160;a certain condition is true, or&#160;<i>until</i>&#160;the condition becomes true. For example:<br/>
x = 10 &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Initialize a loop counter variable<br/>while x &gt;= 0 do &#160; &#160; &#160;# Loop while x is greater than or equal to 0<br/>&#160; puts x &#160; &#160; &#160; &#160; &#160; &#160; # &#160; Print out the value of x<br/>&#160; x = x - 1 &#160; &#160; &#160; &#160; &#160;# &#160; Subtract 1 from x<br/>end &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# The loop ends here<br/>
# Count back up to 10 using an until loop<br/>x = 0 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Start at 0 (instead of -1)<br/>until x &gt; 10 do &#160; &#160; &#160;# Loop until x is greater than 10<br/>&#160; puts x<br/>&#160; x = x + 1<br/>end &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Loop ends here<br/>
The&#160;loop&#160;condition&#160;is&#160;the&#160;Boolean&#160;expression&#160;that&#160;appears&#160;between&#160;the&#160;while&#160;or&#160;until&#160;<br/>and&#160;do&#160;keywords.&#160;The&#160;loop&#160;body&#160;is&#160;the&#160;Ruby&#160;code&#160;that&#160;appears&#160;between&#160;the&#160;do&#160;and&#160;the<br/>end&#160;keyword. The&#160;while&#160;loop&#160;evaluates&#160;its&#160;condition.&#160;If&#160;the&#160;value&#160;is&#160;anything&#160;other&#160;than<br/>false&#160;or&#160;nil,&#160;it&#160;executes&#160;its&#160;body,&#160;and&#160;then&#160;loops&#160;to&#160;evaluate&#160;its&#160;condition&#160;again.&#160;In&#160;this<br/>way,&#160;the&#160;body&#160;is&#160;executed&#160;repeatedly,&#160;zero&#160;or&#160;more&#160;times,&#160;while&#160;the&#160;condition remains<br/>true (or, more strictly, non-false&#160;and non-nil).<br/>The&#160;until&#160;loop&#160;is&#160;the&#160;reverse.&#160;The&#160;condition&#160;is&#160;tested&#160;and&#160;the&#160;body&#160;is&#160;executed&#160;if&#160;the<br/>condition&#160;evaluates&#160;to&#160;false&#160;or&#160;nil.&#160;This&#160;means&#160;that&#160;the&#160;body&#160;is&#160;executed&#160;zero&#160;or&#160;more<br/>times&#160;while&#160;the&#160;condition&#160;is&#160;false&#160;or&#160;nil.&#160;Note&#160;that&#160;any&#160;until&#160;loop&#160;can&#160;be&#160;converted&#160;to<br/>a&#160;while&#160;simply&#160;by&#160;negating&#160;the&#160;condition.&#160;Most&#160;programmers&#160;are&#160;familiar&#160;with&#160;while<br/>loops,&#160;but&#160;many&#160;have&#160;not&#160;used&#160;until&#160;loops&#160;before.&#160;For&#160;this&#160;reason,&#160;you&#160;may&#160;want&#160;to<br/>use&#160;while&#160;loops except when&#160;until&#160;truly improves the clarity of your code.<br/>
<b>5.2 &#160;Loops&#160;|&#160;127</b><br/>
<hr/>
<a name=142></a>The&#160;do&#160;keyword&#160;in&#160;a&#160;while&#160;or&#160;until&#160;loop&#160;is&#160;like&#160;the&#160;then&#160;keyword&#160;in&#160;an&#160;if&#160;statement: it<br/>may&#160;be&#160;omitted&#160;altogether&#160;as&#160;long&#160;as&#160;a&#160;newline&#160;(or&#160;semicolon)&#160;appears&#160;between&#160;the<br/>loop condition and the loop body.*<br/>
<b>5.2.2 &#160;while and until As Modifiers<br/></b>If the body&#160;of&#160;a&#160;loop&#160;is&#160;a&#160;single&#160;Ruby&#160;expression,&#160;you&#160;can&#160;express&#160;that&#160;loop&#160;in&#160;a&#160;partic-<br/>ularly&#160;compact&#160;form&#160;by&#160;using&#160;while&#160;or&#160;until&#160;as&#160;a&#160;modifier&#160;after&#160;the&#160;expression.&#160;For<br/>example:<br/>
x = 0 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Initialize loop variable<br/>puts x = x + 1 while x &lt; 10 &#160; &#160;# Output and increment in a single expression<br/>
This modifier syntax uses the&#160;while&#160;keyword itself to separate the loop body from the<br/>loop&#160;condition,&#160;and&#160;avoids&#160;the&#160;need&#160;for&#160;the&#160;do&#160;(or&#160;newline)&#160;and&#160;end&#160;keywords.&#160;Contrast<br/>this code with the more traditional&#160;while&#160;loop written on a single line:<br/>
x = 0<br/>while x &lt; 10 do puts x = x + 1 end<br/>
until&#160;can be used as a modifier just as&#160;while&#160;can be:<br/>
a = [1,2,3] &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Initialize an array<br/>puts a.pop until a.empty? &#160; # Pop elements from array until empty<br/>
Note that when&#160;while&#160;and&#160;until&#160;are&#160;used&#160;as&#160;modifiers,&#160;they&#160;must&#160;appear&#160;on&#160;the&#160;same<br/>line&#160;as&#160;the&#160;loop&#160;body&#160;that&#160;they&#160;modify.&#160;If&#160;there&#160;is&#160;a&#160;newline&#160;between&#160;the&#160;loop&#160;body&#160;and<br/>the&#160;&#160;while&#160;&#160;or&#160;&#160;until&#160;&#160;keyword,&#160;&#160;the&#160;&#160;Ruby&#160;&#160;interpreter&#160;&#160;will&#160;&#160;treat&#160;&#160;the&#160;&#160;loop&#160;&#160;body&#160;&#160;as&#160;&#160;an<br/>unmodified expression and the&#160;while&#160;or&#160;until&#160;as the beginning of a regular loop.<br/>When&#160;while&#160;and&#160;until&#160;are&#160;used&#160;as&#160;modifiers&#160;for&#160;a&#160;single&#160;Ruby&#160;expression,&#160;the&#160;loop<br/>condition&#160;is&#160;tested&#160;first,&#160;even&#160;though&#160;it&#160;is&#160;written&#160;after&#160;the&#160;loop&#160;body.&#160;The&#160;loop&#160;body&#160;is<br/>
&#160;<br/>
executed&#160;zero&#160;or&#160;more&#160;times,&#160;just&#160;as&#160;if&#160;it&#160;were&#160;formatted&#160;as&#160;a&#160;regular&#160;while&#160;or&#160;until&#160;loop.<br/>There&#160;is&#160;a&#160;special-case&#160;exception&#160;to&#160;this&#160;rule.&#160;When&#160;the&#160;expression&#160;being&#160;evaluated&#160;is<br/>a&#160;compound&#160;expression&#160;delimited&#160;by&#160;begin&#160;and&#160;end&#160;keywords,&#160;then&#160;the&#160;body&#160;is&#160;executed<br/>first before the condition is tested:<br/>
x = 10 &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Initialize loop variable<br/>begin &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Start a compound expression: executed at least once<br/>&#160; puts x &#160; &#160; &#160; &#160; &#160; &#160;# &#160; output x<br/>&#160; x = x - 1 &#160; &#160; &#160; &#160; # &#160; decrement x<br/>end until x == 0 &#160; &#160;# End compound expression and modify it with a loop<br/>
This&#160;results&#160;in&#160;a&#160;construct&#160;much&#160;like&#160;the&#160;do/while&#160;loop&#160;of&#160;C,&#160;C++,&#160;and&#160;Java.&#160;Despite<br/>its&#160;similarity&#160;to&#160;the&#160;do/while&#160;loop&#160;of&#160;other&#160;languages,&#160;this&#160;special-case&#160;behavior&#160;of&#160;loop<br/>modifiers&#160;&#160;with&#160;&#160;the&#160;&#160;begin&#160;&#160;statement&#160;&#160;is&#160;&#160;counterintuitive&#160;&#160;and&#160;&#160;its&#160;&#160;use&#160;&#160;is&#160;&#160;discouraged.<br/>Future&#160;releases&#160;of&#160;Ruby&#160;may&#160;forbid&#160;the&#160;use&#160;of&#160;while&#160;and&#160;until&#160;modifiers&#160;with&#160;begin/end.<br/>
*&#160;In Ruby 1.8, a colon may be used in place of the&#160;do&#160;keyword. This is no longer allowed in Ruby 1.9.<br/>
<b>128&#160;|&#160;Chapter 5:</b> <b>Statements and Control Structures</b><br/>
<hr/>
<a name=143></a>Note&#160;that&#160;if&#160;you&#160;group&#160;multiple&#160;statements&#160;with&#160;parentheses&#160;and&#160;apply&#160;an&#160;until&#160;modifier<br/>to that grouped expression, you do not get this special case behavior:<br/>
x = 0 &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Initialize loop variable<br/>( &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Start a compound expression: may be executed 0 times<br/>&#160; puts x &#160; &#160; &#160; &#160; &#160; &#160;# &#160; output x<br/>&#160; x = x - 1 &#160; &#160; &#160; &#160; # &#160; decrement x<br/>) until x == 0 &#160; &#160; &#160;# End compound expression and modify it with a loop<br/>
<b>5.2.3 &#160;The for/in Loop<br/></b>The&#160;for&#160;loop,&#160;or&#160;for/in&#160;loop,&#160;iterates&#160;through&#160;the&#160;elements&#160;of&#160;an&#160;enumerable&#160;object<br/>(such&#160;as&#160;an&#160;array).&#160;On&#160;each&#160;iteration,&#160;it&#160;assigns&#160;an&#160;element&#160;to&#160;a&#160;specified&#160;loop&#160;variable<br/>and then executes the body of the loop. A&#160;for&#160;loop looks like this:<br/>
for&#160;<i>var</i>&#160;in&#160;<i>collection</i>&#160;do<br/>&#160;&#160;<i>body<br/></i>end<br/>
<i>var</i>&#160;is&#160;a&#160;variable&#160;or&#160;a&#160;comma-separated&#160;list&#160;of&#160;variables.&#160;<i>collection</i>&#160;is&#160;any&#160;object&#160;that<br/>has&#160;an&#160;each&#160;iterator&#160;method.&#160;Arrays&#160;and&#160;hashes&#160;define&#160;the&#160;each&#160;method,&#160;and&#160;many&#160;other<br/>Ruby&#160;objects&#160;do,&#160;too.&#160;The&#160;for/in&#160;loop&#160;calls&#160;the&#160;each&#160;method&#160;of&#160;the&#160;specified&#160;object.&#160;As<br/>that&#160;iterator&#160;yields&#160;values,&#160;the&#160;for&#160;loop&#160;assigns&#160;each&#160;value&#160;(or&#160;each&#160;set&#160;of&#160;values)&#160;to&#160;the<br/>specified&#160;variable&#160;(or&#160;variables)&#160;and&#160;then&#160;executes&#160;the&#160;code&#160;in&#160;<i>body</i>.&#160;As&#160;with&#160;the&#160;while<br/>and&#160;until&#160;loops,&#160;the&#160;do&#160;keyword&#160;is&#160;optional&#160;and&#160;may&#160;be&#160;replaced&#160;with&#160;a&#160;newline&#160;or<br/>semicolon.<br/>Here are some sample&#160;for&#160;loops:<br/>
# Print the elements in an array<br/>array = [1,2,3,4,5]<br/>for element in array&#160;<br/>&#160; puts element<br/>end<br/>
# Print the keys and values in a hash<br/>hash = {:a=&gt;1, :b=&gt;2, :c=&gt;3}<br/>for key,value in hash<br/>&#160; puts &#34;#{key} =&gt; #{value}&#34;<br/>end<br/>
The&#160;loop&#160;variable&#160;or&#160;variables&#160;of&#160;a&#160;for&#160;loop&#160;are&#160;not&#160;local&#160;to&#160;the&#160;loop;&#160;they&#160;remain&#160;defined<br/>even&#160;after&#160;the&#160;loop&#160;exits.&#160;Similarly,&#160;new&#160;variables&#160;defined&#160;within&#160;the&#160;body&#160;of&#160;the&#160;loop<br/>continue to exist after the loop exits.<br/>The fact that the&#160;for&#160;loop&#160;depends&#160;on&#160;the&#160;each&#160;iterator&#160;method&#160;implies&#160;that&#160;for&#160;loops<br/>are&#160;much&#160;like&#160;iterators.&#160;For&#160;example,&#160;the&#160;for&#160;loop&#160;shown&#160;above&#160;for&#160;enumerating&#160;the<br/>keys&#160;and&#160;values&#160;of&#160;a&#160;hash&#160;could&#160;also&#160;be&#160;written&#160;with&#160;an&#160;explicit&#160;use&#160;of&#160;the&#160;each&#160;iterator:<br/>
hash = {:a=&gt;1, :b=&gt;2, :c=&gt;3}<br/>hash.each do |key,value|<br/>&#160; puts &#34;#{key} =&gt; #{value}&#34;<br/>end<br/>
<b>5.2 &#160;Loops&#160;|&#160;129</b><br/>
<hr/>
<a name=144></a>The&#160;only&#160;difference&#160;between&#160;the&#160;for&#160;version&#160;of&#160;the&#160;loop&#160;and&#160;the&#160;each&#160;version&#160;is&#160;that&#160;the<br/>block&#160;of&#160;code&#160;that&#160;follows&#160;an&#160;iterator&#160;does&#160;define&#160;a&#160;new&#160;variable&#160;scope.&#160;Details&#160;are&#160;in<br/>the discussion of iterators later in this chapter.<br/>
<b>5.3 &#160;Iterators and Enumerable Objects<br/></b>Although&#160;while,&#160;until,&#160;and&#160;for&#160;loops&#160;are&#160;a&#160;core&#160;part&#160;of&#160;the&#160;Ruby&#160;language,&#160;it&#160;is&#160;probably<br/>more&#160;common&#160;to&#160;write&#160;loops&#160;using&#160;special&#160;methods&#160;known&#160;as&#160;<i>iterators</i>.&#160;Iterators&#160;are<br/>one&#160;of&#160;the&#160;most&#160;noteworthy&#160;features&#160;of&#160;Ruby,&#160;and&#160;examples&#160;such&#160;as&#160;the&#160;following&#160;are<br/>common in introductory Ruby tutorials:<br/>
3.times { puts &#34;thank you!&#34; } &#160;# Express gratitude three times<br/>data.each {|x| puts x } &#160; &#160; &#160; &#160;# Print each element x of data<br/>[1,2,3].map {|x| x*x } &#160; &#160; &#160; &#160; # Compute squares of array elements<br/>factorial = 1 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Compute the factorial of n<br/>2.upto(n) {|x| factorial *= x }<br/>
The&#160;times,&#160;each,&#160;map,&#160;and&#160;upto&#160;methods&#160;are&#160;all&#160;iterators,&#160;and&#160;they&#160;interact&#160;with&#160;the<br/><i>block</i>&#160;of&#160;code&#160;that&#160;follows&#160;them.&#160;The&#160;complex&#160;control&#160;structure&#160;behind&#160;this&#160;is&#160;yield.<br/>The&#160;yield&#160;statement&#160;temporarily&#160;returns&#160;control&#160;from&#160;the&#160;iterator&#160;method&#160;to&#160;the&#160;meth-<br/>od&#160;that&#160;invoked&#160;the&#160;iterator.&#160;Specifically,&#160;control&#160;flow&#160;goes&#160;from&#160;the&#160;iterator&#160;to&#160;the&#160;block<br/>of&#160;code&#160;associated&#160;with&#160;the&#160;invocation&#160;of&#160;the&#160;iterator.&#160;When&#160;the&#160;end&#160;of&#160;the&#160;block&#160;is<br/>reached,&#160;the&#160;iterator&#160;method&#160;regains&#160;control&#160;and&#160;execution&#160;resumes&#160;at&#160;the&#160;first&#160;state-<br/>ment&#160;following&#160;the&#160;yield.&#160;In&#160;order&#160;to&#160;implement&#160;some&#160;kind&#160;of&#160;looping&#160;construct,&#160;an<br/>iterator&#160;method&#160;will&#160;typically&#160;invoke&#160;the&#160;yield&#160;statement&#160;multiple&#160;times.&#160;<a href="Rubys.html#145">Figure&#160;5-1<br/></a>illustrates&#160;this&#160;complex&#160;flow&#160;of&#160;control.&#160;Blocks&#160;and&#160;yield&#160;are&#160;described&#160;in&#160;detail&#160;in<br/><a href="Rubys.html#154">§5.4&#160;</a>below;&#160;for&#160;now,&#160;we&#160;focus&#160;on&#160;the&#160;iteration&#160;itself&#160;rather&#160;than&#160;the&#160;control&#160;structure<br/>that enables it.<br/>As&#160;you&#160;can&#160;see&#160;from&#160;the&#160;previous&#160;examples,&#160;blocks&#160;may&#160;be&#160;parameterized.&#160;Vertical&#160;bars<br/>at&#160;the&#160;start&#160;of&#160;a&#160;block&#160;are&#160;like&#160;parentheses&#160;in&#160;a&#160;method&#160;definition—they&#160;hold&#160;a&#160;list&#160;of<br/>parameter&#160;names.&#160;The&#160;yield&#160;statement&#160;is&#160;like&#160;a&#160;method&#160;invocation;&#160;it&#160;is&#160;followed&#160;by<br/>zero or more expressions whose values are assigned to the block parameters.<br/>
<b>Iterators that Don’t Iterate</b><br/>
We&#160;use&#160;the&#160;term&#160;<i>iterator</i>&#160;in&#160;this&#160;book&#160;to&#160;mean&#160;any&#160;method&#160;that&#160;uses&#160;the&#160;yield&#160;statement.<br/>They&#160;do&#160;not&#160;actually&#160;have&#160;to&#160;serve&#160;an&#160;iteration&#160;or&#160;looping&#160;function.*&#160;&#160;The&#160;tap&#160;method<br/>defined&#160;(in&#160;Ruby&#160;1.9&#160;and&#160;1.8.7)&#160;by&#160;the&#160;Object&#160;class&#160;is&#160;an&#160;example.&#160;It&#160;invokes&#160;the&#160;asso-<br/>ciated&#160;&#160;block&#160;&#160;once,&#160;&#160;passing&#160;&#160;the&#160;&#160;receiver&#160;&#160;as&#160;&#160;the&#160;&#160;only&#160;&#160;argument.&#160;&#160;Then&#160;&#160;it&#160;&#160;returns&#160;&#160;the<br/>receiver.&#160;It&#160;is&#160;handy&#160;for&#160;“tapping&#160;into”&#160;a&#160;method&#160;chain,&#160;as&#160;in&#160;the&#160;following&#160;code&#160;which<br/>uses&#160;tap&#160;to output debugging messages:<br/>
*&#160;Within&#160;the&#160;Japanese&#160;Ruby&#160;community,&#160;the&#160;term&#160;“iterator”&#160;has&#160;fallen&#160;out&#160;of&#160;use&#160;because&#160;it&#160;implies&#160;an<br/>
iteration&#160;that&#160;is&#160;not&#160;actually&#160;required.&#160;A&#160;phrase&#160;like&#160;“method&#160;that&#160;expects&#160;an&#160;associated&#160;block”&#160;is&#160;verbose<br/>but more precise.<br/>
<b>130&#160;|&#160;Chapter 5:</b> <b>Statements and Control Structures</b><br/>
<hr/>
<a name=145></a><img src="Ruby-145_1.png"/><br/>
<i>Figure 5-1. An iterator yielding to its invoking method</i><br/>
chars = &#34;hello world&#34;.tap {|x| puts &#34;original object: #{x.inspect}&#34;}<br/>&#160; .each_char &#160; &#160; &#160; &#160; .tap {|x| puts &#34;each_char returns: #{x.inspect}&#34;}<br/>&#160; .to_a &#160; &#160; &#160; &#160; &#160; &#160; &#160;.tap {|x| puts &#34;to_a returns: #{x.inspect}&#34;}<br/>&#160; .map {|c| c.succ } .tap {|x| puts &#34;map returns: #{x.inspect}&#34; }<br/>&#160; .sort &#160; &#160; &#160; &#160; &#160; &#160; &#160;.tap {|x| puts &#34;sort returns: #{x.inspect}&#34;}<br/>
Another&#160;&#160;common&#160;&#160;function&#160;&#160;for&#160;&#160;iterators&#160;&#160;is&#160;&#160;automatic&#160;&#160;resource&#160;&#160;deallocation.&#160;&#160;The<br/>File.open&#160;method&#160;can&#160;be&#160;used&#160;as&#160;an&#160;iterator,&#160;for&#160;example.&#160;It&#160;opens&#160;the&#160;named&#160;file,<br/>creating&#160;a&#160;File&#160;object&#160;to&#160;represent&#160;it.&#160;If&#160;no&#160;block&#160;is&#160;associated&#160;with&#160;the&#160;invocation,&#160;it<br/>simply&#160;returns&#160;the&#160;File&#160;object&#160;and&#160;leaves&#160;the&#160;responsibility&#160;for&#160;closing&#160;the&#160;file&#160;with&#160;the<br/>calling&#160;code.&#160;If&#160;there&#160;is&#160;a&#160;block&#160;associated&#160;with&#160;the&#160;File.open&#160;call,&#160;however,&#160;it&#160;passes<br/>the&#160;new&#160;File&#160;object&#160;to&#160;that&#160;block&#160;and&#160;then&#160;automatically&#160;closes&#160;the&#160;file&#160;when&#160;the&#160;block<br/>returns.&#160;This&#160;ensures&#160;that&#160;files&#160;will&#160;always&#160;be&#160;closed&#160;and&#160;frees&#160;programmers&#160;from&#160;this<br/>housekeeping&#160;&#160;detail.&#160;&#160;In&#160;&#160;this&#160;&#160;case,&#160;&#160;when&#160;&#160;a&#160;&#160;block&#160;&#160;is&#160;&#160;associated&#160;&#160;with&#160;&#160;the&#160;&#160;call&#160;&#160;to<br/>File.open,&#160;the&#160;return&#160;value&#160;of&#160;method&#160;is&#160;not&#160;a&#160;File&#160;object&#160;but&#160;whatever&#160;value&#160;the&#160;block<br/>returned.<br/>
<b>5.3.1 &#160;Numeric Iterators<br/></b>The core&#160;Ruby&#160;API&#160;provides&#160;a&#160;number&#160;of&#160;standard&#160;iterators.&#160;The&#160;Kernel&#160;method&#160;loop<br/>behaves&#160;like&#160;an&#160;infinite&#160;loop,&#160;running&#160;its&#160;associated&#160;block&#160;repeatedly&#160;until&#160;the&#160;block<br/>executes a&#160;return,&#160;break, or other statement that exits from the loop.<br/>The Integer class defines three commonly used iterators. The&#160;upto&#160;method invokes its<br/>associated&#160;block&#160;once&#160;for&#160;each&#160;integer&#160;between&#160;the&#160;integer&#160;on&#160;which&#160;it&#160;is&#160;invoked&#160;and<br/>the integer which is passed as an argument. For example:<br/>
<b>5.3 &#160;Iterators and Enumerable Objects&#160;|&#160;131</b><br/>
<hr/>
<a name=146></a>4.upto(6) {|x| print x} &#160; # =&gt; prints &#34;456&#34;<br/>
As&#160;you&#160;can&#160;see,&#160;upto&#160;yields&#160;each&#160;integer&#160;to&#160;the&#160;associated&#160;block,&#160;and&#160;it&#160;includes&#160;both<br/>the&#160;starting&#160;point&#160;and&#160;the&#160;end&#160;point&#160;in&#160;the&#160;iteration.&#160;In&#160;general,&#160;n.upto(m)&#160;runs&#160;its&#160;block<br/>m-n+1&#160;times.<br/>
The&#160;downto&#160;method&#160;is&#160;just&#160;like&#160;upto&#160;but&#160;iterates&#160;from&#160;a&#160;larger&#160;number&#160;down&#160;to&#160;a&#160;smaller<br/>number.<br/>When&#160;the&#160;Integer.times&#160;method&#160;is&#160;invoked&#160;on&#160;the&#160;integer&#160;n,&#160;it&#160;invokes&#160;its&#160;block&#160;n&#160;times,<br/>passing values&#160;0&#160;through&#160;n-1&#160;on successive iterations. For example:<br/>
3.times {|x| print x } &#160; &#160;# =&gt; prints &#34;012&#34;<br/>
In general,&#160;n.times&#160;is equivalent to&#160;0.upto(n-1).<br/>If&#160;you&#160;want&#160;to&#160;do&#160;a&#160;numeric&#160;iteration&#160;using&#160;floating-point&#160;numbers,&#160;you&#160;can&#160;use&#160;the<br/>more&#160;complex&#160;step&#160;method&#160;defined&#160;by&#160;the&#160;Numeric&#160;class.&#160;The&#160;following&#160;iterator,&#160;for<br/>example, starts at&#160;0&#160;and iterates in steps of&#160;0.1&#160;until it reaches&#160;Math::PI:<br/>
0.step(Math::PI, 0.1) {|x| puts Math.sin(x) }<br/>
<b>5.3.2 &#160;Enumerable Objects<br/></b>Array,&#160;Hash,&#160;Range,&#160;and&#160;a&#160;number&#160;of&#160;other&#160;classes&#160;define&#160;an&#160;each&#160;iterator&#160;that&#160;passes<br/>each&#160;element&#160;of&#160;the&#160;collection&#160;to&#160;the&#160;associated&#160;block.&#160;This&#160;is&#160;perhaps&#160;the&#160;most&#160;com-<br/>monly&#160;used&#160;iterator&#160;in&#160;Ruby;&#160;as&#160;we&#160;saw&#160;earlier,&#160;the&#160;for&#160;loop&#160;only&#160;works&#160;for&#160;iterating<br/>over objects that have&#160;each&#160;methods. Examples of&#160;each&#160;iterators:<br/>
[1,2,3].each {|x| print x } &#160; # =&gt; prints &#34;123&#34;<br/>(1..3).each &#160;{|x| print x } &#160; # =&gt; prints &#34;123&#34; Same as 1.upto(3)<br/>
The&#160;each&#160;iterator&#160;is&#160;not&#160;only&#160;for&#160;traditional&#160;“data&#160;structure”&#160;classes.&#160;Ruby’s&#160;IO&#160;class<br/>defines&#160;an&#160;each&#160;iterator&#160;that&#160;yields&#160;lines&#160;of&#160;text&#160;read&#160;from&#160;the&#160;Input/Output&#160;object.&#160;Thus,<br/>you can process the lines of a file in Ruby with code like this:<br/>
File.open(filename) do |f| &#160; &#160; &#160; # Open named file, pass as f<br/>&#160; f.each {|line| print line } &#160; &#160;# Print each line in f<br/>end &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# End block and close file<br/>
Most&#160;classes&#160;that&#160;define&#160;an&#160;each&#160;method&#160;also&#160;include&#160;the&#160;Enumerable&#160;module,&#160;which<br/>defines&#160;&#160;a&#160;&#160;number&#160;&#160;of&#160;&#160;more&#160;&#160;specialized&#160;&#160;iterators&#160;&#160;that&#160;&#160;are&#160;&#160;implemented&#160;&#160;on&#160;&#160;top&#160;&#160;of&#160;&#160;the<br/>each&#160;method.&#160;One&#160;such&#160;useful&#160;iterator&#160;is&#160;each_with_index,&#160;which&#160;allows&#160;us&#160;to&#160;add&#160;line<br/>numbering to the previous example:<br/>
File.open(filename) do |f|<br/>&#160; f.each_with_index do |line,number|<br/>&#160; &#160; print &#34;#{number}: #{line}&#34;<br/>&#160; end<br/>end<br/>
Some&#160;&#160;of&#160;&#160;the&#160;&#160;most&#160;&#160;commonly&#160;&#160;used&#160;&#160;Enumerable&#160;&#160;iterators&#160;&#160;are&#160;&#160;the&#160;&#160;rhyming&#160;&#160;methods<br/>collect,&#160;select,&#160;reject,&#160;and&#160;inject.&#160;The&#160;collect&#160;method&#160;(also&#160;known&#160;as&#160;map)&#160;executes<br/>
<b>132&#160;|&#160;Chapter 5:</b> <b>Statements and Control Structures</b><br/>
<hr/>
<a name=147></a>its&#160;associated&#160;block&#160;for&#160;each&#160;element&#160;of&#160;the&#160;enumerable&#160;object,&#160;and&#160;collects&#160;the&#160;return<br/>values of the blocks into an array:<br/>
squares = [1,2,3].collect {|x| x*x} &#160; # =&gt; [1,4,9]<br/>
The&#160;select&#160;method&#160;invokes&#160;the&#160;associated&#160;block&#160;for&#160;each&#160;element&#160;in&#160;the&#160;enumerable<br/>object,&#160;and&#160;returns&#160;an&#160;array&#160;of&#160;elements&#160;for&#160;which&#160;the&#160;block&#160;returns&#160;a&#160;value&#160;other&#160;than<br/>false&#160;or&#160;nil. For example:<br/>
evens = (1..10).select {|x| x%2 == 0} # =&gt; [2,4,6,8,10]<br/>
The&#160;reject&#160;method&#160;is&#160;simply&#160;the&#160;opposite&#160;of&#160;select;&#160;it&#160;returns&#160;an&#160;array&#160;of&#160;elements&#160;for<br/>which the block returns&#160;nil&#160;or&#160;false. For example:<br/>
odds = (1..10).reject {|x| x%2 == 0} &#160;# =&gt; [1,3,5,7,9]<br/>
The&#160;inject&#160;method&#160;is&#160;a&#160;little&#160;more&#160;complicated&#160;than&#160;the&#160;others.&#160;It&#160;invokes&#160;the&#160;associated<br/>block&#160;with&#160;two&#160;arguments.&#160;The&#160;first&#160;argument&#160;is&#160;an&#160;accumulated&#160;value&#160;of&#160;some&#160;sort<br/>from&#160;previous&#160;iterations.&#160;The&#160;second&#160;argument&#160;is&#160;the&#160;next&#160;element&#160;of&#160;the&#160;enumerable<br/>object.&#160;The&#160;return&#160;value&#160;of&#160;the&#160;block&#160;becomes&#160;the&#160;first&#160;block&#160;argument&#160;for&#160;the&#160;next<br/>iteration,&#160;or&#160;becomes&#160;the&#160;return&#160;value&#160;of&#160;the&#160;iterator&#160;after&#160;the&#160;last&#160;iteration.&#160;The&#160;initial<br/>value&#160;of&#160;the&#160;accumulator&#160;variable&#160;is&#160;either&#160;the&#160;argument&#160;to&#160;inject,&#160;if&#160;there&#160;is&#160;one,&#160;or<br/>the&#160;first&#160;element&#160;of&#160;the&#160;enumerable&#160;object.&#160;(In&#160;this&#160;case,&#160;the&#160;block&#160;is&#160;invoked&#160;just&#160;once<br/>for the first two elements.) Examples make&#160;inject&#160;more clear:<br/>
data = [2, 5, 3, 4]<br/>sum = data.inject {|sum, x| sum + x } &#160; &#160; &#160;# =&gt; 14 &#160; &#160;(2+5+3+4)<br/>floatprod = data.inject(1.0) {|p,x| p*x } &#160;# =&gt; 120.0 (1.0*2*5*3*4)<br/>max = data.inject {|m,x| m&gt;x ? m : x } &#160; &#160; # =&gt; 5 &#160; &#160; (largest element)<br/>
<a href="Rubys.html#342">See §9.5.1 for further details on the&#160;</a>Enumerable&#160;module and its iterators.<br/>
<b>5.3.3 &#160;Writing Custom Iterators<br/></b>The defining&#160;feature&#160;of&#160;an&#160;iterator&#160;method&#160;is&#160;that&#160;it&#160;invokes&#160;a&#160;block&#160;of&#160;code&#160;associated<br/>with&#160;&#160;the&#160;&#160;method&#160;&#160;invocation.&#160;&#160;You&#160;&#160;do&#160;&#160;this&#160;&#160;with&#160;&#160;the&#160;&#160;yield&#160;&#160;statement.&#160;&#160;The&#160;&#160;following<br/>method is a trivial iterator that just invokes its block twice:<br/>
def twice<br/>&#160; yield<br/>&#160; yield<br/>end<br/>
To&#160;&#160;pass&#160;&#160;argument&#160;&#160;values&#160;&#160;to&#160;&#160;the&#160;&#160;block,&#160;&#160;follow&#160;&#160;the&#160;&#160;yield&#160;&#160;statement&#160;&#160;with&#160;&#160;a&#160;&#160;comma-<br/>separated&#160;list&#160;of&#160;expressions.&#160;As&#160;with&#160;method&#160;invocation,&#160;the&#160;argument&#160;values&#160;may<br/>optionally&#160;be&#160;enclosed&#160;in&#160;parentheses.&#160;The&#160;following&#160;simple&#160;iterator&#160;shows&#160;a&#160;use&#160;of<br/>yield:<br/>
# This method expects a block. It generates n values of the form<br/># m*i + c, for i from 0..n-1, and yields them, one at a time,&#160;<br/># to the associated block.<br/>def sequence(n, m, c)<br/>
<b>5.3 &#160;Iterators and Enumerable Objects&#160;|&#160;133</b><br/>
<hr/>
<a name=148></a>&#160; i = 0<br/>&#160; while(i &lt; n) &#160; &#160; &#160;# Loop n times<br/>&#160; &#160; yield m*i + c &#160; # Invoke the block, and pass a value to it<br/>&#160; &#160; i += 1 &#160; &#160; &#160; &#160; &#160;# Increment i each time<br/>&#160; end<br/>end<br/>
# Here is an invocation of that method, with a block.<br/># It prints the values 1, 6, and 11<br/>sequence(3, 5, 1) {|y| puts y }<br/>
<b>Nomenclature: yield and Iterators</b><br/>
Depending&#160;on&#160;your&#160;programming&#160;background,&#160;you&#160;may&#160;find&#160;the&#160;terms&#160;“yield”&#160;and<br/>“iterator”&#160;confusing.&#160;The&#160;sequence&#160;method&#160;shown&#160;earlier&#160;is&#160;a&#160;fairly&#160;clear&#160;example&#160;of<br/>why&#160;yield&#160;has&#160;the&#160;name&#160;it&#160;does.&#160;After&#160;computing&#160;each&#160;number&#160;in&#160;the&#160;sequence,&#160;the<br/>method&#160;yields&#160;control&#160;(and&#160;yields&#160;the&#160;computed&#160;number)&#160;to&#160;the&#160;block,&#160;so&#160;that&#160;the&#160;block<br/>can&#160;work&#160;with&#160;it.&#160;It&#160;is&#160;not&#160;always&#160;this&#160;clear,&#160;however;&#160;in&#160;some&#160;code&#160;it&#160;may&#160;seem&#160;as&#160;if&#160;it<br/>is the block that is yielding a result back to the method that invoked it.<br/>
A&#160;method&#160;such&#160;as&#160;sequence&#160;that&#160;expects&#160;a&#160;block&#160;and&#160;invokes&#160;it&#160;multiple&#160;times&#160;is&#160;called<br/>an&#160;<i>iterator</i>&#160;because&#160;it&#160;looks&#160;and&#160;behaves&#160;like&#160;a&#160;loop.&#160;This&#160;may&#160;be&#160;confusing&#160;if&#160;you&#160;are<br/>used&#160;to&#160;languages&#160;like&#160;Java&#160;in&#160;which&#160;iterators&#160;are&#160;objects.&#160;In&#160;Java,&#160;the&#160;client&#160;code&#160;that<br/>uses the iterator is in control and “pulls” values from the iterator when it needs them.<br/>In&#160;Ruby,&#160;the&#160;iterator&#160;method&#160;is&#160;in&#160;control&#160;and&#160;“pushes”&#160;values&#160;to&#160;the&#160;block&#160;that&#160;wants<br/>them.<br/>
This&#160;nomenclature&#160;issue&#160;is&#160;related&#160;to&#160;the&#160;distinction&#160;between&#160;“internal&#160;iterators”&#160;and<br/>“external iterators,” which is discussed later in this section.<br/>
Here&#160;is&#160;another&#160;example&#160;of&#160;a&#160;Ruby&#160;iterator;&#160;it&#160;passes&#160;two&#160;arguments&#160;to&#160;its&#160;block.&#160;It&#160;is<br/>worth&#160;noticing&#160;that&#160;the&#160;implementation&#160;of&#160;this&#160;iterator&#160;uses&#160;another&#160;iterator&#160;internally:<br/>
# Generate n points evenly spaced around the circumference of a&#160;<br/># circle of radius r centered at (0,0). Yield the x and y coordinates<br/># of each point to the associated block.<br/>def circle(r,n)<br/>&#160; n.times do |i| &#160; &#160;# Notice that this method is implemented with a block<br/>&#160; &#160; angle = Math::PI * 2 * i / n<br/>&#160; &#160; yield r*Math.cos(angle), r*Math.sin(angle)<br/>&#160; end<br/>end<br/>
# This invocation of the iterator prints:<br/># (1.00, 0.00) (0.00, 1.00) (-1.00, 0.00) (-0.00, -1.00)<br/>circle(1,4) {|x,y| printf &#34;(%.2f, %.2f) &#34;, x, y }<br/>
Using&#160;the&#160;&#160;yield&#160;keyword&#160;really&#160;is&#160;a&#160;lot&#160;like&#160;invoking&#160;a&#160;method.&#160;(See&#160;<a href="Rubys.html#189">Chapter&#160;6&#160;</a>for<br/>complete&#160;details&#160;on&#160;method&#160;invocation.)&#160;Parentheses&#160;around&#160;the&#160;arguments&#160;are&#160;op-<br/>tional. You can use&#160;*&#160;to&#160;expand&#160;an&#160;array&#160;into&#160;individual&#160;arguments.&#160;yield&#160;even allows<br/>you&#160;&#160;to&#160;&#160;pass&#160;&#160;a&#160;&#160;hash&#160;&#160;literal&#160;&#160;without&#160;&#160;the&#160;&#160;curly&#160;&#160;braces&#160;&#160;around&#160;&#160;it.&#160;&#160;Unlike&#160;&#160;a&#160;&#160;method<br/>
<b>134&#160;|&#160;Chapter 5:</b> <b>Statements and Control Structures</b><br/>
<hr/>
<a name=149></a>invocation,&#160;however,&#160;a&#160;yield&#160;expression&#160;may&#160;not&#160;be&#160;followed&#160;by&#160;a&#160;block.&#160;You&#160;cannot<br/>pass a block to a block.<br/>If&#160;a&#160;method&#160;is&#160;invoked&#160;without&#160;a&#160;block,&#160;it&#160;is&#160;an&#160;error&#160;for&#160;that&#160;method&#160;to&#160;yield, because<br/>there&#160;is&#160;nothing&#160;to&#160;yield&#160;to.&#160;Sometimes&#160;you&#160;want&#160;to&#160;write&#160;a&#160;method&#160;that&#160;yields&#160;to&#160;a&#160;block<br/>if&#160;one&#160;is&#160;provided&#160;but&#160;takes&#160;some&#160;default&#160;action&#160;(other&#160;than&#160;raising&#160;an&#160;error)&#160;if&#160;invoked<br/>with&#160;no&#160;block.&#160;To&#160;do&#160;this,&#160;use&#160;&#160;block_given?&#160;to&#160;determine&#160;whether&#160;there&#160;is&#160;a&#160;block<br/>associated&#160;with&#160;the&#160;invocation.&#160;block_given?,&#160;and&#160;its&#160;synonym&#160;iterator?,&#160;are&#160;Kernel<br/>methods, so they act like global functions. Here is an example:<br/>
# Return an array with n elements of the form m*i+c<br/># If a block is given, also yield each element to the block<br/>def sequence(n, m, c)<br/>&#160; i, s = 0, [] &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Initialize variables<br/>&#160; while(i &lt; n) &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Loop n times<br/>&#160; &#160; y = m*i + c &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Compute value<br/>&#160; &#160; yield y if block_given? &#160; &#160; # Yield, if block<br/>&#160; &#160; s &lt;&lt; y &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Store the value<br/>&#160; &#160; i += 1<br/>&#160; end<br/>&#160; s &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Return the array of values<br/>end<br/>
<b>5.3.4 &#160;Enumerators<br/></b>An&#160;&#160;<i>enumerator</i>&#160;&#160;is&#160;&#160;an&#160;&#160;Enumerable&#160;&#160;object&#160;&#160;whose&#160;&#160;purpose&#160;&#160;is&#160;&#160;to&#160;&#160;enumerate&#160;&#160;some&#160;&#160;other<br/>object.&#160;To&#160;use&#160;enumerators&#160;in&#160;Ruby&#160;1.8,&#160;you must&#160;require 'enumerator'. In Ruby 1.9<br/>(and&#160;also&#160;1.8.7),&#160;enumerators&#160;are&#160;built-in&#160;and&#160;no&#160;require&#160;is&#160;necessary.&#160;(As&#160;we’ll&#160;see<br/>later,&#160;the&#160;built-in&#160;enumerators&#160;have&#160;substantially&#160;more&#160;functionality&#160;than&#160;that&#160;provided<br/>by the&#160;enumerator&#160;library.)<br/>Enumerators are of class&#160;Enumerable::Enumerator. Although this class can be instanti-<br/>ated&#160;directly&#160;with&#160;new,&#160;this&#160;is&#160;not&#160;how&#160;enumerators&#160;are&#160;typically&#160;created.&#160;Instead,&#160;use<br/>to_enum&#160;or&#160;its&#160;synonym&#160;enum_for,&#160;which&#160;are&#160;methods&#160;of&#160;Object.&#160;With&#160;no&#160;arguments,<br/>to_enum&#160;returns&#160;an&#160;enumerator&#160;whose&#160;each&#160;method&#160;simply&#160;calls&#160;the&#160;each&#160;method&#160;of&#160;the<br/>target&#160;object.&#160;Suppose&#160;you&#160;have&#160;an&#160;array&#160;and&#160;a&#160;method&#160;that&#160;expects&#160;an&#160;enumerable<br/>object.&#160;You&#160;don’t&#160;want&#160;to&#160;pass&#160;the&#160;array&#160;object&#160;itself,&#160;because&#160;it&#160;is&#160;mutable,&#160;and&#160;you<br/>don’t&#160;trust&#160;the&#160;method&#160;not&#160;to&#160;modify&#160;it.&#160;Instead&#160;of&#160;making&#160;a&#160;defensive&#160;deep&#160;copy&#160;of&#160;the<br/>array,&#160;just&#160;call&#160;to_enum&#160;on&#160;it,&#160;and&#160;pass&#160;the&#160;resulting&#160;enumerator&#160;instead&#160;of&#160;the&#160;array<br/>itself.&#160;In&#160;effect,&#160;you’re&#160;creating&#160;an&#160;enumerable&#160;but&#160;immutable&#160;proxy&#160;object&#160;for&#160;your<br/>array:<br/>
# Call this method with an Enumerator instead of a mutable array.<br/># This is a useful defensive strategy to avoid bugs.<br/>process(data.to_enum) &#160;# Instead of just process(data)<br/>
You&#160;can&#160;also&#160;pass&#160;arguments&#160;to&#160;to_enum, although the&#160;enum_for&#160;synonym seems more<br/>natural&#160;in&#160;this&#160;case.&#160;The&#160;first&#160;argument&#160;should&#160;be&#160;a&#160;symbol&#160;that&#160;identifies&#160;an&#160;iterator<br/>method.&#160;The&#160;each&#160;method&#160;of&#160;the&#160;resulting&#160;Enumerator&#160;will&#160;invoke&#160;the&#160;named&#160;method<br/>
<b>5.3 &#160;Iterators and Enumerable Objects&#160;|&#160;135</b><br/>
<hr/>
<a name=150></a>of&#160;&#160;the&#160;&#160;original&#160;&#160;object.&#160;&#160;Any&#160;&#160;remaining&#160;&#160;arguments&#160;&#160;to&#160;&#160;enum_for&#160;&#160;will&#160;&#160;be&#160;&#160;passed&#160;&#160;to&#160;&#160;that<br/>named&#160;method.&#160;In&#160;Ruby&#160;1.9,&#160;the&#160;String&#160;class&#160;is&#160;not&#160;Enumerable,&#160;but&#160;it&#160;defines&#160;three<br/>iterator&#160;methods:&#160;each_char,&#160;each_byte,&#160;and&#160;each_line.&#160;Suppose&#160;we&#160;want&#160;to&#160;use&#160;an<br/>Enumerable&#160;method, such as&#160;map,&#160;and&#160;we&#160;want&#160;it&#160;to&#160;be&#160;based&#160;on&#160;the&#160;each_char&#160;iterator.<br/>We do this by creating an enumerator:<br/>
s = &#34;hello&#34;<br/>s.enum_for(:each_char).map {|c| c.succ } &#160;# =&gt; [&#34;i&#34;, &#34;f&#34;, &#34;m&#34;, &#34;m&#34;, &#34;p&#34;]<br/>
In&#160;Ruby&#160;1.9&#160;(and&#160;1.8.7),&#160;it&#160;is&#160;usually&#160;not&#160;even&#160;necessary&#160;to&#160;use&#160;to_enum&#160;or&#160;enum_for<br/>explicitly&#160;as&#160;we&#160;did&#160;in&#160;the&#160;previous&#160;examples.&#160;This&#160;is&#160;because&#160;the&#160;built-in&#160;iterator&#160;meth-<br/>ods&#160;of&#160;Ruby&#160;1.9&#160;(which&#160;include&#160;the&#160;numeric&#160;iterators&#160;times,&#160;upto,&#160;downto, and&#160;step, as<br/>well&#160;as&#160;each&#160;and&#160;related&#160;methods&#160;of&#160;Enumerable)&#160;automatically&#160;return&#160;an&#160;enumerator<br/>when&#160;invoked&#160;with&#160;no&#160;block.&#160;So,&#160;to&#160;pass&#160;an&#160;array&#160;enumerator&#160;to&#160;a&#160;method&#160;rather&#160;than<br/>the array itself, you can simply call the&#160;each&#160;method:<br/>
process(data.each_char) &#160;# Instead of just process(data)<br/>
This&#160;syntax&#160;is&#160;even&#160;more&#160;natural&#160;if&#160;we&#160;use&#160;the&#160;chars&#160;alias&#160;in&#160;place&#160;of&#160;each_char.&#160;To&#160;map<br/>the characters of a string to an array of characters, for example, just use&#160;.chars.map:<br/>
&#34;hello&#34;.chars.map {|c| c.succ } &#160;# =&gt; [&#34;i&#34;, &#34;f&#34;, &#34;m&#34;, &#34;m&#34;, &#34;p&#34;]<br/>
Here&#160;are&#160;some&#160;other&#160;examples&#160;that&#160;rely&#160;on&#160;enumerator&#160;objects&#160;returned&#160;by&#160;iterator<br/>methods.&#160;Note&#160;that&#160;it&#160;is&#160;not&#160;just&#160;iterator&#160;methods&#160;defined&#160;by&#160;Enumerable&#160;that&#160;can&#160;return<br/>enumerator objects; numeric iterators like&#160;times&#160;and&#160;upto&#160;do the same:<br/>
enumerator = 3.times &#160; &#160; &#160; &#160; &#160; &#160; # An enumerator object<br/>enumerator.each {|x| print x } &#160; # Prints &#34;012&#34;<br/>
# downto returns an enumerator with a select method<br/>10.downto(1).select {|x| x%2==0} &#160;# =&gt; [10,8,6,4,2]<br/>
# each_byte iterator returns an enumerator with a to_a method<br/>&#34;hello&#34;.each_byte.to_a &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; [104, 101, 108, 108, 111]<br/>
You&#160;&#160;can&#160;&#160;duplicate&#160;&#160;this&#160;&#160;behavior&#160;&#160;in&#160;&#160;your&#160;&#160;own&#160;&#160;iterator&#160;&#160;methods&#160;&#160;by&#160;&#160;returning<br/>self.to_enum&#160;when&#160;no&#160;block&#160;is&#160;supplied.&#160;Here,&#160;for&#160;example,&#160;is&#160;a&#160;version&#160;of&#160;the&#160;twice<br/>iterator shown earlier that can return an enumerator if no block is provided:<br/>
def twice<br/>&#160; if block_given?<br/>&#160; &#160; yield<br/>&#160; &#160; yield<br/>&#160; else<br/>&#160; &#160; self.to_enum(:twice) &#160; &#160;<br/>&#160; end<br/>end<br/>
In&#160;Ruby&#160;1.9,&#160;enumerator&#160;objects&#160;define&#160;a&#160;with_index&#160;method&#160;that&#160;is&#160;not&#160;available&#160;in&#160;the<br/>Ruby 1.8 enumerator module.&#160;with_index&#160;simply returns a new enumerator that adds<br/>an&#160;index&#160;parameter&#160;to&#160;the&#160;iteration.&#160;For&#160;example,&#160;the&#160;following&#160;returns&#160;an&#160;enumerator<br/>that yields the characters of a string and their index within the string:<br/>
<b>136&#160;|&#160;Chapter 5:</b> <b>Statements and Control Structures</b><br/>
<hr/>
<a name=151></a>enumerator = s.each_char.with_index<br/>
Finally,&#160;&#160;keep&#160;&#160;in&#160;&#160;mind&#160;&#160;that&#160;&#160;enumerators,&#160;&#160;in&#160;&#160;both&#160;&#160;Ruby&#160;&#160;1.8&#160;&#160;and&#160;&#160;1.9,&#160;&#160;are&#160;&#160;Enumerable<br/>objects that can be used with the&#160;for&#160;loop. For example:<br/>
for line, number in text.each_line.with_index<br/>&#160; print &#34;#{number+1}: #{line}&#34;<br/>end<br/>
<b>5.3.5 &#160;External Iterators<br/></b>Our discussion&#160;of&#160;enumerators&#160;has&#160;focused&#160;on&#160;their&#160;use&#160;as&#160;Enumerable&#160;proxy&#160;objects.<br/>In&#160;Ruby&#160;1.9,&#160;(and&#160;1.8.7,&#160;though&#160;the&#160;implementation&#160;is&#160;not&#160;as&#160;efficient)&#160;however,&#160;enu-<br/>merators&#160;have&#160;another&#160;very&#160;important&#160;use:&#160;they&#160;are&#160;<i>external iterators</i>.&#160;You&#160;can&#160;use&#160;an<br/>enumerator&#160;&#160;to&#160;&#160;loop&#160;&#160;through&#160;&#160;the&#160;&#160;elements&#160;&#160;of&#160;&#160;a&#160;&#160;collection&#160;&#160;by&#160;&#160;repeatedly&#160;&#160;calling&#160;&#160;the<br/>next&#160;method.&#160;When&#160;there&#160;are&#160;no&#160;more&#160;elements,&#160;this&#160;method&#160;raises&#160;a&#160;StopIteration<br/>exception:<br/>
iterator = 9.downto(1) &#160; &#160; &#160; &#160; &#160; &#160; # An enumerator as external iterator<br/>begin &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# So we can use rescue below<br/>&#160; print iterator.next while true &#160; # Call the next method repeatedly<br/>rescue StopIteration &#160; &#160; &#160; &#160; &#160; &#160; &#160; # When there are no more values<br/>&#160; puts &#34;...blastoff!&#34; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# An expected, nonexceptional condition<br/>end<br/>
<b>Internal versus External Iterators</b><br/>
The&#160;“gang&#160;of&#160;four”&#160;define&#160;and&#160;contrast&#160;internal&#160;and&#160;external&#160;iterators&#160;quite&#160;clearly&#160;in<br/>their design patterns book:*<br/>
A&#160;fundamental&#160;issue&#160;is&#160;deciding&#160;which&#160;party&#160;controls&#160;the&#160;iteration,&#160;the&#160;iterator&#160;or<br/>the&#160;client&#160;that&#160;uses&#160;the&#160;iterator.&#160;When&#160;the&#160;client&#160;controls&#160;the&#160;iteration,&#160;the&#160;iterator<br/>is called an&#160;<b>external iterator</b>,&#160;and&#160;when&#160;the&#160;iterator&#160;controls&#160;it,&#160;the&#160;iterator&#160;is&#160;an<br/><b>internal iterator</b>.&#160;Clients&#160;that&#160;use&#160;an&#160;external&#160;iterator&#160;must&#160;advance&#160;the&#160;traversal<br/>and&#160;request&#160;the&#160;next&#160;element&#160;explicitly&#160;from&#160;the&#160;iterator.&#160;In&#160;contrast,&#160;the&#160;client<br/>hands&#160;an&#160;internal&#160;iterator&#160;an&#160;operation&#160;to&#160;perform,&#160;and&#160;the&#160;iterator&#160;applies&#160;that<br/>operation to every element....<br/>
External&#160;iterators&#160;are&#160;more&#160;flexible&#160;than&#160;internal&#160;iterators.&#160;It’s&#160;easy&#160;to&#160;compare<br/>two&#160;collections&#160;for&#160;equality&#160;with&#160;an&#160;external&#160;iterator,&#160;for&#160;example,&#160;but&#160;it’s&#160;practi-<br/>cally&#160;impossible&#160;with&#160;internal&#160;iterators….&#160;But&#160;on&#160;the&#160;other&#160;hand,&#160;internal&#160;iterators<br/>are easier to use, because they define the iteration logic for you.<br/>
In&#160;Ruby,&#160;iterator&#160;methods&#160;like&#160;each&#160;are&#160;internal&#160;iterators;&#160;they&#160;control&#160;the&#160;iteration&#160;and<br/>“push”&#160;values&#160;to&#160;the&#160;block&#160;of&#160;code&#160;associated&#160;with&#160;the&#160;method&#160;invocation.&#160;Enumerators<br/>have&#160;an&#160;each&#160;method&#160;for&#160;internal&#160;iteration,&#160;but&#160;in&#160;Ruby&#160;1.9&#160;and&#160;later,&#160;they&#160;also&#160;work<br/>as&#160;external&#160;iterators—client&#160;code&#160;can&#160;sequentially&#160;“pull”&#160;values&#160;from&#160;an&#160;enumerator<br/>with&#160;next.<br/>
*&#160;<i>Design&#160;&#160;Patterns:&#160;&#160;Elements&#160;&#160;of&#160;&#160;Reusable&#160;&#160;Object-Oriented&#160;&#160;Software</i>,&#160;&#160;by&#160;&#160;Gamma,&#160;&#160;Helm,&#160;&#160;Johnson,&#160;&#160;and<br/>
Vlissides (Addison-Wesley).<br/>
<b>5.3 &#160;Iterators and Enumerable Objects&#160;|&#160;137</b><br/>
<hr/>
<a name=152></a>External&#160;iterators&#160;are&#160;quite&#160;simple&#160;to&#160;use:&#160;just&#160;call&#160;next&#160;each&#160;time&#160;you&#160;want&#160;another<br/>element.&#160;When&#160;there&#160;are&#160;no&#160;more&#160;elements&#160;left,&#160;next&#160;will raise a&#160;StopIteration&#160;excep-<br/>tion.&#160;&#160;This&#160;&#160;may&#160;&#160;seem&#160;&#160;unusual—an&#160;&#160;exception&#160;&#160;is&#160;&#160;raised&#160;&#160;for&#160;&#160;an&#160;&#160;expected&#160;&#160;termination<br/>condition&#160;rather&#160;than&#160;an&#160;unexpected&#160;and&#160;exceptional&#160;event.&#160;(StopIteration&#160;is&#160;a&#160;de-<br/>scendant&#160;of&#160;StandardError&#160;and&#160;IndexError;&#160;note&#160;that&#160;it&#160;is&#160;one&#160;of&#160;the&#160;only&#160;exception<br/>classes&#160;that&#160;does&#160;not&#160;have&#160;the&#160;word&#160;“error”&#160;in&#160;its&#160;name.)&#160;Ruby&#160;follows&#160;Python&#160;in&#160;this<br/>external&#160;iteration&#160;technique.&#160;By&#160;treating&#160;loop&#160;termination&#160;as&#160;an&#160;exception,&#160;it&#160;makes<br/>your&#160;&#160;looping&#160;&#160;logic&#160;&#160;extremely&#160;&#160;simple;&#160;&#160;there&#160;&#160;is&#160;&#160;no&#160;&#160;need&#160;&#160;to&#160;&#160;check&#160;&#160;the&#160;&#160;return&#160;&#160;value&#160;&#160;of<br/>next&#160;&#160;for&#160;&#160;a&#160;&#160;special&#160;&#160;end-of-iteration&#160;&#160;value,&#160;&#160;and&#160;&#160;there&#160;&#160;is&#160;&#160;no&#160;&#160;need&#160;&#160;to&#160;&#160;call&#160;&#160;some&#160;&#160;kind&#160;&#160;of<br/>next?&#160;predicate before calling&#160;next.<br/>
To&#160;simplify&#160;looping&#160;with&#160;external&#160;iterators,&#160;the&#160;Kernel.loop&#160;method&#160;includes&#160;(in&#160;Ruby<br/>1.9)&#160;an&#160;implicit&#160;rescue&#160;clause&#160;and&#160;exits&#160;cleanly&#160;when&#160;StopIteration&#160;is&#160;raised.&#160;Thus,&#160;the<br/>countdown code shown earlier could more easily be written like this:<br/>
iterator = 9.downto(1)<br/>loop do &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Loop until StopIteration is raised<br/>&#160; print iterator.next &#160; # Print next item<br/>end<br/>puts &#34;...blastoff!&#34;<br/>
Many&#160;external&#160;iterators&#160;can&#160;be&#160;restarted&#160;by&#160;calling&#160;the&#160;rewind&#160;method.&#160;Note,&#160;however,<br/>that&#160;rewind&#160;is not effective for all enumerators. If an enumerator is based on an object<br/>like&#160;a&#160;File&#160;which&#160;reads&#160;lines&#160;sequentially,&#160;calling&#160;rewind&#160;will&#160;not&#160;restart&#160;the&#160;iteration<br/>from&#160;&#160;the&#160;&#160;beginning.&#160;&#160;In&#160;&#160;general,&#160;&#160;if&#160;&#160;new&#160;&#160;invocations&#160;&#160;of&#160;&#160;each&#160;&#160;on&#160;&#160;the&#160;&#160;underlying<br/>Enumerable&#160;object&#160;do&#160;not&#160;restart&#160;the&#160;iteration&#160;from&#160;the&#160;beginning,&#160;then&#160;calling&#160;rewind<br/>will not restart it either.<br/>Once&#160;an&#160;external&#160;iteration&#160;has&#160;started&#160;(i.e.,&#160;after&#160;next&#160;has&#160;been&#160;called&#160;for&#160;the&#160;first&#160;time),<br/>an&#160;enumerator&#160;cannot&#160;be&#160;cloned&#160;or&#160;duplicated.&#160;It&#160;is&#160;typically&#160;possible&#160;to&#160;clone&#160;an&#160;enu-<br/>merator&#160;before&#160;next&#160;is&#160;called,&#160;or&#160;after&#160;StopIteration&#160;has&#160;been&#160;raised&#160;or&#160;rewind&#160;is&#160;called.<br/>Normally,&#160;enumerators&#160;with&#160;next&#160;methods&#160;are&#160;created&#160;from&#160;Enumerable&#160;objects&#160;that<br/>have&#160;an&#160;each&#160;method.&#160;If,&#160;for&#160;some&#160;reason,&#160;you&#160;define&#160;a&#160;class&#160;that&#160;provides&#160;a&#160;next&#160;method<br/>for&#160;external&#160;iteration&#160;instead&#160;of&#160;an&#160;each&#160;method&#160;for&#160;internal&#160;iteration,&#160;you&#160;can&#160;easily<br/>implement&#160;each&#160;in&#160;terms&#160;of&#160;next.&#160;In&#160;fact,&#160;turning&#160;an&#160;externally&#160;iterable&#160;class&#160;that&#160;im-<br/>plements&#160;next&#160;into&#160;an&#160;Enumerable&#160;class&#160;is&#160;as&#160;simple&#160;as&#160;mixing&#160;in&#160;(with&#160;include—see<br/><a href="Rubys.html#261">§7.5) a module like this:</a><br/>
module Iterable<br/>&#160; include Enumerable &#160; &#160; &#160; &#160; &#160;# Define iterators on top of each<br/>&#160; def each &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# And define each on top of next<br/>&#160; &#160; loop { yield self.next }<br/>&#160; end<br/>end<br/>
Another&#160;way&#160;to&#160;use&#160;an&#160;external&#160;iterator&#160;is&#160;to&#160;pass&#160;it&#160;to&#160;an&#160;internal&#160;iterator&#160;method&#160;like<br/>this one:<br/>
def iterate(iterator)<br/>&#160; loop { yield iterator.next }<br/>
<b>138&#160;|&#160;Chapter 5:</b> <b>Statements and Control Structures</b><br/>
<hr/>
<a name=153></a>end<br/>
iterate(9.downto(1)) {|x| print x }<br/>
The&#160;earlier&#160;quote&#160;from&#160;<i>Design&#160;Patterns</i>&#160;alluded&#160;to&#160;one&#160;of&#160;the&#160;key&#160;features&#160;of&#160;external<br/>iterators:&#160;they&#160;solve&#160;the&#160;parallel&#160;iteration&#160;problem.&#160;Suppose&#160;you&#160;have&#160;two&#160;Enumerable<br/>collections&#160;and&#160;need&#160;to&#160;iterate&#160;their&#160;elements&#160;in&#160;pairs:&#160;the&#160;first&#160;elements&#160;of&#160;each&#160;collec-<br/>tion,&#160;then&#160;the&#160;second&#160;elements,&#160;and&#160;so&#160;on.&#160;Without&#160;an&#160;external&#160;iterator,&#160;you&#160;must<br/>convert&#160;&#160;one&#160;&#160;of&#160;&#160;the&#160;&#160;collections&#160;&#160;to&#160;&#160;an&#160;&#160;array&#160;&#160;(with&#160;&#160;the&#160;&#160;to_a&#160;&#160;method&#160;&#160;defined&#160;&#160;by<br/>Enumerable)&#160;so&#160;that&#160;you&#160;can&#160;access&#160;its&#160;elements&#160;while&#160;iterating&#160;the&#160;other&#160;collection&#160;with<br/>each.<br/>
<a href="Rubys.html#153">Example 5-1</a>&#160;shows&#160;the&#160;implementation&#160;of&#160;three&#160;iterator&#160;methods.&#160;All&#160;three&#160;accept&#160;an<br/>arbitrary&#160;number&#160;of&#160;Enumerable&#160;objects&#160;and&#160;iterate&#160;them&#160;in&#160;different&#160;ways.&#160;One&#160;is&#160;a<br/>simple&#160;&#160;sequential&#160;&#160;iteration&#160;&#160;using&#160;&#160;only&#160;&#160;internal&#160;&#160;iterators;&#160;&#160;the&#160;&#160;other&#160;&#160;two&#160;&#160;are&#160;&#160;parallel<br/>iterations and can only be done using the external iteration features of Ruby 1.9.<br/>
<i>Example 5-1. Parallel iteration with external iterators</i><br/>
# Call the each method of each collection in turn.<br/># This is not a parallel iteration and does not require enumerators.<br/>def sequence(*enumerables, &amp;block)<br/>&#160; enumerables.each do |enumerable|<br/>&#160; &#160; enumerable.each(&amp;block)<br/>&#160; end<br/>end<br/>
# Iterate the specified collections, interleaving their elements.<br/># This can't be done efficiently without external iterators.<br/># Note the use of the uncommon else clause in begin/rescue.<br/>def interleave(*enumerables)<br/>&#160; # Convert enumerable collections to an array of enumerators.<br/>
&#160;<br/>
&#160; enumerators = enumerables.map {|e| e.to_enum }<br/>&#160; # Loop until we don't have any more enumerators.<br/>&#160; until enumerators.empty?<br/>&#160; &#160; begin<br/>&#160; &#160; &#160; e = enumerators.shift &#160; # Take the first enumerator<br/>&#160; &#160; &#160; yield e.next &#160; &#160; &#160; &#160; &#160; &#160;# Get its next and pass to the block<br/>&#160; &#160; rescue StopIteration &#160; &#160; &#160;# If no more elements, do nothing<br/>&#160; &#160; else &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# If no exception occurred<br/>&#160; &#160; &#160; enumerators &lt;&lt; e &#160; &#160; &#160; &#160;# Put the enumerator back<br/>&#160; &#160; end<br/>&#160; end<br/>end<br/>
# Iterate the specified collections, yielding tuples of values,<br/># one value from each of the collections. See also Enumerable.zip.<br/>def bundle(*enumerables)<br/>&#160; enumerators = enumerables.map {|e| e.to_enum }<br/>&#160; loop { yield enumerators.map {|e| e.next} }<br/>end<br/>
# Examples of how these iterator methods work<br/>a,b,c = [1,2,3], 4..6, 'a'..'e'<br/>
<b>5.3 &#160;Iterators and Enumerable Objects&#160;|&#160;139</b><br/>
<hr/>
<a name=154></a>sequence(a,b,c) {|x| print x} &#160; # prints &#34;123456abcde&#34;<br/>interleave(a,b,c) {|x| print x} # prints &#34;14a25b36cde&#34;<br/>bundle(a,b,c) {|x| print x} &#160; &#160; # '[1, 4, &#34;a&#34;][2, 5, &#34;b&#34;][3, 6, &#34;c&#34;]'<br/>
The&#160;bundle&#160;method&#160;of&#160;<a href="Rubys.html#153">Example 5-1&#160;</a>is&#160;similar&#160;to&#160;the&#160;Enumerable.zip&#160;method.&#160;In&#160;Ruby<br/>1.8,&#160;zip&#160;must&#160;first&#160;convert&#160;its&#160;Enumerable&#160;arguments&#160;to&#160;arrays&#160;and&#160;then&#160;use&#160;those&#160;arrays<br/>while&#160;iterating&#160;through&#160;the&#160;Enumerable&#160;object&#160;it&#160;is&#160;called&#160;on.&#160;In&#160;Ruby&#160;1.9,&#160;however,<br/>the&#160;zip&#160;method&#160;can&#160;use&#160;external&#160;iterators.&#160;This&#160;makes&#160;it&#160;(typically)&#160;more&#160;efficient&#160;in<br/>space and time, and also allows it to work with unbounded collections that could not<br/>be converted into an array of finite size.<br/>
<b>5.3.6 &#160;Iteration and Concurrent Modification<br/></b>In&#160;general,&#160;Ruby’s&#160;core&#160;collection&#160;of&#160;classes&#160;iterate&#160;over&#160;live&#160;objects&#160;rather&#160;than&#160;private<br/>copies&#160;or&#160;“snapshots”&#160;of&#160;those&#160;objects,&#160;and&#160;they&#160;make&#160;no&#160;attempt&#160;to&#160;detect&#160;or&#160;prevent<br/>concurrent&#160;&#160;modification&#160;&#160;to&#160;&#160;the&#160;&#160;collection&#160;&#160;while&#160;&#160;it&#160;&#160;is&#160;&#160;being&#160;&#160;iterated.&#160;&#160;If&#160;&#160;you&#160;&#160;call&#160;&#160;the<br/>each&#160;method&#160;of&#160;an&#160;array,&#160;for&#160;example,&#160;and&#160;the&#160;block&#160;associated&#160;with&#160;that&#160;invocation<br/>calls&#160;the&#160;shift&#160;method&#160;of&#160;the&#160;same&#160;array,&#160;the&#160;results&#160;of&#160;the&#160;iteration&#160;may&#160;be&#160;surprising:<br/>
a = [1,2,3,4,5]<br/>a.each {|x| puts &#34;#{x},#{a.shift}&#34; } &#160;# prints &#34;1,1\n3,2\n5,3&#34;<br/>
You&#160;may&#160;see&#160;similarly&#160;surprising&#160;behavior&#160;if&#160;one&#160;thread&#160;modifies&#160;a&#160;collection&#160;while<br/>another thread is iterating it. One way to avoid this is to make a defensive copy of the<br/>collection&#160;&#160;before&#160;&#160;iterating&#160;&#160;it.&#160;&#160;The&#160;&#160;following&#160;&#160;code,&#160;&#160;for&#160;&#160;example,&#160;&#160;adds&#160;&#160;a&#160;&#160;method<br/>each_in_snapshot&#160;to the&#160;Enumerable&#160;module:<br/>
module Enumerable<br/>&#160; def each_in_snapshot &amp;block<br/>&#160; &#160; snapshot = self.dup &#160; &#160;# Make a private copy of the Enumerable object<br/>&#160; &#160; snapshot.each &amp;block &#160; # And iterate on the copy<br/>&#160; end<br/>end<br/>
<b>5.4 &#160;Blocks<br/></b>The&#160;use&#160;of&#160;blocks&#160;is&#160;fundamental&#160;to&#160;the&#160;use&#160;of&#160;iterators.&#160;In&#160;the&#160;previous&#160;section,&#160;we<br/>focused&#160;on&#160;iterators&#160;as&#160;a&#160;kind&#160;of&#160;looping&#160;construct.&#160;Blocks&#160;were&#160;implicit&#160;to&#160;our&#160;discus-<br/>sion&#160;but&#160;were&#160;not&#160;the&#160;subject&#160;of&#160;it.&#160;Now&#160;we&#160;turn&#160;our&#160;attention&#160;to&#160;the&#160;block&#160;themselves.<br/>The subsections that follow explain:<br/>
•&#160;The syntax for associating a block with a method invocation<br/>•&#160;The “return value” of a block<br/>•&#160;The scope of variables in blocks<br/>•&#160;The difference between block parameters and method parameters<br/>
<b>140&#160;|&#160;Chapter 5:</b> <b>Statements and Control Structures</b><br/>
<hr/>
<a name=155></a><b>5.4.1 &#160;Block Syntax<br/></b>Blocks&#160;may&#160;not&#160;stand&#160;alone;&#160;they&#160;are&#160;only&#160;legal&#160;following&#160;a&#160;method&#160;invocation.&#160;You<br/>can,&#160;however,&#160;place&#160;a&#160;block&#160;after&#160;any&#160;method&#160;invocation;&#160;if&#160;the&#160;method&#160;is&#160;not&#160;an&#160;iterator<br/>and&#160;never&#160;invokes&#160;the&#160;block&#160;with&#160;yield,&#160;the&#160;block&#160;will&#160;be&#160;silently&#160;ignored.&#160;Blocks&#160;are<br/>delimited&#160;with&#160;curly&#160;braces&#160;or&#160;with&#160;do&#160;and&#160;end&#160;keywords.&#160;The&#160;opening&#160;curly&#160;brace&#160;or&#160;<br/>the&#160;do&#160;keyword&#160;must&#160;be&#160;on&#160;the&#160;same&#160;line&#160;as&#160;the&#160;method&#160;invocation,&#160;or&#160;else&#160;Ruby&#160;in-<br/>terprets&#160;the&#160;line&#160;terminator&#160;as&#160;a&#160;statement&#160;terminator&#160;and&#160;invokes&#160;the&#160;method&#160;without<br/>the block:<br/>
# Print the numbers 1 to 10<br/>1.upto(10) {|x| puts x } &#160; # Invocation and block on one line with braces<br/>1.upto(10) do |x| &#160; &#160; &#160; &#160; &#160;# Block delimited with do/end<br/>&#160; puts x<br/>end<br/>1.upto(10) &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # No block specified<br/>&#160;{|x| puts x } &#160; &#160; &#160; &#160; &#160; &#160; # Syntax error: block not after an invocation<br/>
One&#160;common&#160;convention&#160;is&#160;to&#160;use&#160;curly&#160;braces&#160;when&#160;a&#160;block&#160;fits&#160;on&#160;a&#160;single&#160;line,&#160;and<br/>to use&#160;do&#160;and&#160;end&#160;when&#160;the&#160;block&#160;extends&#160;over&#160;multiple&#160;lines.This&#160;is&#160;not&#160;completely&#160;a<br/>matter&#160;of&#160;convention,&#160;however;&#160;the&#160;Ruby&#160;parser&#160;binds&#160;{&#160;tightly&#160;to&#160;the&#160;token&#160;that&#160;pre-<br/>cedes&#160;it.&#160;If&#160;you&#160;omit&#160;the&#160;parentheses&#160;around&#160;method&#160;arguments&#160;and&#160;use&#160;curly&#160;brace<br/>delimiters&#160;for&#160;a&#160;block,&#160;then&#160;the&#160;block&#160;will&#160;be&#160;associated&#160;with&#160;the&#160;last&#160;method&#160;argument<br/>rather&#160;than&#160;the&#160;method&#160;itself,&#160;which&#160;is&#160;probably&#160;not&#160;what&#160;you&#160;want.&#160;To&#160;avoid&#160;this&#160;case,<br/>put parentheses around the arguments or delimit the block with&#160;do&#160;and&#160;end:<br/>
1.upto(3) {|x| puts x } &#160; &#160;# Parens and curly braces work<br/>1.upto 3 do |x| puts x end # No parens, block delimited with do/end<br/>1.upto 3 {|x| puts x } &#160; &#160; # Syntax Error: trying to pass a block to 3!<br/>
Blocks&#160;can&#160;be&#160;parameterized,&#160;just&#160;as&#160;methods&#160;can.&#160;Block&#160;parameters&#160;are&#160;separated&#160;with<br/>commas&#160;and&#160;delimited&#160;with&#160;a&#160;pair&#160;of&#160;vertical&#160;bar&#160;(|)&#160;characters,&#160;but&#160;they&#160;are&#160;otherwise<br/><a href="Rubys.html#159">much like method parameters (see §5.4.5 for details):</a><br/>
# The Hash.each iterator passes two arguments to its block<br/>hash.each do |key, value| &#160; # For each (key,value) pair in the hash<br/>&#160; puts &#34;#{key}: #{value}&#34; &#160; # Print the key and the value<br/>end &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # End of the block<br/>
It&#160;is&#160;a&#160;common&#160;convention&#160;to&#160;write&#160;the&#160;block&#160;parameters&#160;on&#160;the&#160;same&#160;line&#160;as&#160;the&#160;method<br/>invocation&#160;and&#160;the&#160;opening&#160;brace&#160;or&#160;do&#160;keyword,&#160;but&#160;this&#160;is&#160;not&#160;required&#160;by&#160;the&#160;syntax.<br/>
<b>5.4.2 &#160;The Value of a Block<br/></b>In&#160;the&#160;iterator&#160;examples&#160;shown&#160;so&#160;far&#160;in&#160;this&#160;chapter,&#160;the&#160;iterator&#160;method&#160;has&#160;yielded<br/>values&#160;to&#160;its&#160;associated&#160;block&#160;but&#160;has&#160;ignored&#160;the&#160;value&#160;returned&#160;by&#160;the&#160;block.&#160;This&#160;is<br/>not&#160;always&#160;the&#160;case,&#160;however.&#160;Consider&#160;the&#160;Array.sort&#160;method.&#160;If&#160;you&#160;associate&#160;a&#160;block<br/>with&#160;an&#160;invocation&#160;of&#160;this&#160;method,&#160;it&#160;will&#160;yield&#160;pairs&#160;of&#160;elements&#160;to&#160;the&#160;block,&#160;and&#160;it&#160;is<br/>the&#160;block’s&#160;job&#160;to&#160;sort&#160;them.&#160;The&#160;block’s&#160;return&#160;value&#160;(–1,&#160;0,&#160;or&#160;1)&#160;indicates&#160;the&#160;ordering<br/>
<b>5.4 &#160;Blocks&#160;|&#160;141</b><br/>
<hr/>
<a name=156></a>of&#160;the&#160;two&#160;arguments.&#160;The&#160;“return&#160;value”&#160;of&#160;the&#160;block&#160;is&#160;available&#160;to&#160;the&#160;iterator&#160;method<br/>as the value of the&#160;yield&#160;statement.<br/>The&#160;“return&#160;value”&#160;of&#160;a&#160;block&#160;is&#160;simply&#160;the&#160;value&#160;of&#160;the&#160;last&#160;expression&#160;evaluated&#160;in&#160;the<br/>block. So, to sort an array of words from longest to shortest, we could write:<br/>
# The block takes two words and &#34;returns&#34; their relative order<br/>words.sort! {|x,y| y.length &lt;=&gt; x.length}<br/>
We’ve&#160;been&#160;placing&#160;the&#160;phrase&#160;“return&#160;value”&#160;in&#160;quotes&#160;for&#160;a&#160;very&#160;important&#160;reason:<br/>you&#160;should&#160;not&#160;normally&#160;use&#160;the&#160;return&#160;keyword&#160;to&#160;return&#160;from&#160;a&#160;block.&#160;A&#160;return&#160;inside<br/>a&#160;block&#160;causes&#160;the&#160;containing&#160;method&#160;(not&#160;the&#160;iterator&#160;method&#160;that&#160;yields&#160;to&#160;the&#160;block,<br/>but&#160;the&#160;method&#160;that&#160;the&#160;block&#160;is&#160;part&#160;of)&#160;to&#160;return.&#160;There&#160;are,&#160;of&#160;course,&#160;times&#160;when<br/>this&#160;is&#160;exactly&#160;what&#160;you&#160;want&#160;to&#160;do.&#160;But&#160;don’t&#160;use&#160;return&#160;if&#160;you&#160;just&#160;want&#160;to&#160;return&#160;from<br/>a&#160;block&#160;to&#160;the&#160;method&#160;that&#160;called&#160;yield.&#160;If&#160;you&#160;need&#160;to&#160;force&#160;a&#160;block&#160;to&#160;return&#160;to&#160;the<br/>invoking&#160;method&#160;before&#160;it&#160;reaches&#160;the&#160;last&#160;expression,&#160;or&#160;if&#160;you&#160;want&#160;to&#160;return&#160;more<br/>than&#160;one&#160;value,&#160;you&#160;can&#160;use&#160;next&#160;instead&#160;of&#160;return.&#160;(return,&#160;next,&#160;and&#160;the&#160;related&#160;state-<br/>ment&#160;break&#160;are&#160;explained&#160;in&#160;detail&#160;<a href="Rubys.html#160">in&#160;§5.5.)&#160;</a>Here&#160;is&#160;an&#160;example&#160;that&#160;uses&#160;next&#160;to&#160;return<br/>from the block:<br/>
array.collect do |x|<br/>&#160; next 0 if x == nil &#160;# Return prematurely if x is nil<br/>&#160; next x, x*x &#160; &#160; &#160; &#160; # Return two values<br/>end<br/>
Note&#160;that&#160;it&#160;is&#160;not&#160;particularly&#160;common&#160;to&#160;use&#160;next&#160;in&#160;this&#160;way,&#160;and&#160;the&#160;code&#160;above&#160;is<br/>easily rewritten without it:<br/>
array.collect do |x|<br/>&#160; if x == nil<br/>&#160; &#160; 0<br/>&#160; else<br/>&#160; &#160; [x, x*x]<br/>&#160; end<br/>end<br/>
<b>5.4.3 &#160;Blocks and Variable Scope<br/></b>Blocks&#160;define&#160;a&#160;new&#160;variable&#160;scope:&#160;variables&#160;created&#160;within&#160;a&#160;block&#160;exist&#160;only&#160;within<br/>that&#160;&#160;block&#160;&#160;and&#160;&#160;are&#160;&#160;undefined&#160;&#160;outside&#160;&#160;of&#160;&#160;the&#160;&#160;block.&#160;&#160;Be&#160;&#160;cautious,&#160;&#160;however;&#160;&#160;the&#160;&#160;local<br/>variables&#160;in&#160;a&#160;method&#160;are&#160;available&#160;to&#160;any&#160;blocks&#160;within&#160;that&#160;method.&#160;So&#160;if&#160;a&#160;block<br/>assigns&#160;a&#160;value&#160;to&#160;a&#160;variable&#160;that&#160;is&#160;already&#160;defined&#160;outside&#160;of&#160;the&#160;block,&#160;this&#160;does&#160;not<br/>create&#160;a&#160;new&#160;block-local&#160;variable&#160;but&#160;instead&#160;assigns&#160;a&#160;new&#160;value&#160;to&#160;the&#160;already-existing<br/>variable. Sometimes, this is exactly the behavior we want:<br/>
total = 0 &#160;&#160;<br/>data.each {|x| total += x } &#160;# Sum the elements of the data array<br/>puts total &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Print out that sum<br/>
Sometimes, however, we do not want to alter variables in the enclosing scope, but we<br/>do&#160;so&#160;inadvertently.&#160;This&#160;problem&#160;is&#160;a&#160;particular&#160;concern&#160;for&#160;block&#160;parameters&#160;in&#160;Ruby<br/>
<b>142&#160;|&#160;Chapter 5:</b> <b>Statements and Control Structures</b><br/>
<hr/>
<a name=157></a>1.8.&#160;In&#160;Ruby&#160;1.8,&#160;if&#160;a&#160;block&#160;parameter&#160;shares&#160;the&#160;name&#160;of&#160;an&#160;existing&#160;variable,&#160;then<br/>invocations&#160;of&#160;the&#160;block&#160;simply&#160;assign&#160;a&#160;value&#160;to&#160;that&#160;existing&#160;variable&#160;rather&#160;than&#160;cre-<br/>ating&#160;&#160;a&#160;&#160;new&#160;&#160;block-local&#160;&#160;variable.&#160;&#160;The&#160;&#160;following&#160;&#160;code,&#160;&#160;for&#160;&#160;example,&#160;&#160;is&#160;&#160;problematic<br/>because it uses the same identifier&#160;i&#160;as the block parameter for two nested blocks:<br/>
1.upto(10) do |i| &#160; &#160; &#160; &#160; # 10 rows<br/>&#160; 1.upto(10) do |i| &#160; &#160; &#160; # Each has 10 columns<br/>&#160; &#160; print &#34;#{i} &#34; &#160; &#160; &#160; &#160; # Print column number<br/>&#160; end<br/>&#160; print &#34; ==&gt; Row #{i}\n&#34; # Try to print row number, but get column number<br/>end<br/>
Ruby&#160;1.9&#160;is&#160;different:&#160;block&#160;parameters&#160;are&#160;always&#160;local&#160;to&#160;their&#160;block,&#160;and&#160;invocations<br/>of&#160;the&#160;block&#160;never&#160;assign&#160;values&#160;to&#160;existing&#160;variables.&#160;If&#160;Ruby&#160;1.9&#160;is&#160;invoked&#160;with&#160;the<br/>-w&#160;flag,&#160;it&#160;will&#160;warn&#160;you&#160;if&#160;a&#160;block&#160;parameter&#160;has&#160;the&#160;same&#160;name&#160;as&#160;an&#160;existing&#160;variable.<br/>This helps you avoid writing code that runs differently in 1.8 and 1.9.<br/>Ruby&#160;1.9&#160;is&#160;different&#160;in&#160;another&#160;important&#160;way,&#160;too.&#160;Block&#160;syntax&#160;has&#160;been&#160;extended<br/>to&#160;allow&#160;you&#160;to&#160;declare&#160;block-local&#160;variables&#160;that&#160;are&#160;guaranteed&#160;to&#160;be&#160;local,&#160;even&#160;if&#160;a<br/>variable&#160;by&#160;the&#160;same&#160;name&#160;already&#160;exists&#160;in&#160;the&#160;enclosing&#160;scope.&#160;To&#160;do&#160;this,&#160;follow&#160;the<br/>list&#160;of&#160;block&#160;parameters&#160;with&#160;a&#160;semicolon&#160;and&#160;a&#160;comma-separated&#160;list&#160;of&#160;block&#160;local<br/>variables. Here is an example:<br/>
x = y = 0 &#160; &#160; &#160; &#160; &#160; &#160;# local variables<br/>1.upto(4) do |x;y| &#160; # x and y are local to block<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# x and y &#34;shadow&#34; the outer variables<br/>&#160; y = x + 1 &#160; &#160; &#160; &#160; &#160;# Use y as a scratch variable<br/>&#160; puts y*y &#160; &#160; &#160; &#160; &#160; # Prints 4, 9, 16, 25<br/>end<br/>[x,y] &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; [0,0]: block does not alter these<br/>
In&#160;this&#160;code,&#160;x&#160;is&#160;a&#160;block&#160;parameter:&#160;it&#160;gets&#160;a&#160;value&#160;when&#160;the&#160;block&#160;is&#160;invoked&#160;with&#160;yield.<br/>y&#160;is&#160;a&#160;block-local&#160;variable.&#160;It&#160;does&#160;not&#160;receive&#160;any&#160;value&#160;from&#160;a&#160;yield&#160;invocation, but it<br/>has&#160;the&#160;value&#160;nil&#160;until&#160;the&#160;block&#160;actually&#160;assigns&#160;some&#160;other&#160;value&#160;to&#160;it.&#160;The&#160;point&#160;of<br/>declaring&#160;&#160;these&#160;&#160;block-local&#160;&#160;variables&#160;&#160;is&#160;&#160;to&#160;&#160;guarantee&#160;&#160;that&#160;&#160;you&#160;&#160;will&#160;&#160;not&#160;&#160;inadvertently<br/>clobber&#160;the&#160;value&#160;of&#160;some&#160;existing&#160;variable.&#160;(This&#160;might&#160;happen&#160;if&#160;a&#160;block&#160;is&#160;cut-and-<br/>pasted from one method to another, for example.) If you invoke Ruby 1.9 with the&#160;-w<br/>option, it will warn you if a block-local variable shadows an existing variable.<br/>Blocks&#160;can&#160;have&#160;more&#160;than&#160;one&#160;parameter&#160;and&#160;more&#160;than&#160;one&#160;local&#160;variable,&#160;of&#160;course.<br/>Here is a block with two parameters and three local variables:<br/>
hash.each {|key,value; i,j,k| ... }<br/>
<b>5.4.4 &#160;Passing Arguments to a Block<br/></b>We’ve&#160;said&#160;previously&#160;that&#160;the&#160;parameters&#160;to&#160;a&#160;block&#160;are&#160;much&#160;like&#160;the&#160;parameters&#160;to<br/>a&#160;method.&#160;They&#160;are&#160;not&#160;strictly&#160;the&#160;same,&#160;however.&#160;The&#160;argument&#160;values&#160;that&#160;follow&#160;a<br/>yield&#160;keyword&#160;are&#160;assigned&#160;to&#160;block&#160;parameters&#160;following&#160;rules&#160;that&#160;are&#160;closer&#160;to&#160;the<br/>rules&#160;for&#160;variable&#160;assignment&#160;than&#160;to&#160;the&#160;rules&#160;for&#160;method&#160;invocation.&#160;Thus,&#160;when&#160;an<br/>
<b>5.4 &#160;Blocks&#160;|&#160;143</b><br/>
<hr/>
<a name=158></a>iterator executes&#160;yield k,v&#160;to&#160;invoke&#160;a&#160;block&#160;declared&#160;with&#160;parameters&#160;|key, value|,<br/>it is equivalent to this assignment statement:<br/>
key,value = k,v<br/>
The&#160;Hash.each_pair&#160;iterator yields a key/value pair like this:*<br/>
{:one=&gt;1}.each_pair {|key,value| ... } # key=:one, value=1<br/>
In&#160;Ruby&#160;1.8,&#160;it&#160;is&#160;even&#160;more&#160;clear&#160;that&#160;block&#160;invocation&#160;uses&#160;variable&#160;assignment.&#160;Recall<br/>that&#160;in&#160;Ruby&#160;1.8&#160;parameters&#160;are&#160;only&#160;local&#160;to&#160;the&#160;block&#160;if&#160;they&#160;are&#160;not&#160;already&#160;in&#160;use&#160;as<br/>local&#160;variables&#160;of&#160;the&#160;containing&#160;method.&#160;If&#160;they&#160;are&#160;already&#160;local&#160;variables,&#160;then&#160;they<br/>are&#160;simply&#160;assigned&#160;to.&#160;In&#160;fact,&#160;Ruby&#160;1.8&#160;allows&#160;any&#160;kind&#160;of&#160;variable&#160;to&#160;be&#160;used&#160;as&#160;a<br/>block parameter, including global variables and instance variables:<br/>
{:one=&gt;1}.each_pair {|$key, @value| ... } # No longer works in Ruby 1.9<br/>
This&#160;iterator&#160;sets&#160;the&#160;global&#160;variable&#160;$key&#160;to&#160;:one&#160;and&#160;sets&#160;the&#160;instance&#160;variable&#160;@value<br/>to 1. As already noted, Ruby 1.9 makes block parameters local to the block. This also<br/>means that block parameters can no longer be global or instance variables.<br/>The&#160;Hash.each&#160;iterator&#160;yields&#160;key/value&#160;pairs&#160;as&#160;two&#160;elements&#160;of&#160;a&#160;single&#160;array.&#160;It&#160;is&#160;very<br/>common, however, to see code like this:<br/>
hash.each {|k,v| ... } &#160;# key and value assigned to params k and v<br/>
This&#160;&#160;also&#160;&#160;works&#160;&#160;by&#160;&#160;parallel&#160;&#160;assignment.&#160;&#160;The&#160;&#160;yielded&#160;&#160;value,&#160;&#160;a&#160;&#160;two-element&#160;&#160;array,&#160;&#160;is<br/>assigned to the variables&#160;k&#160;and&#160;v:<br/>
k,v = [key, value]<br/>
By&#160;the&#160;rules&#160;of&#160;parallel&#160;assignment&#160;<a href="Rubys.html#111">(see&#160;§4.5.5),&#160;</a>a&#160;single&#160;array&#160;on&#160;the&#160;right&#160;is&#160;expanded<br/>to and its elements assigned to the multiple variables on the left.<br/>Block&#160;invocation&#160;does&#160;not&#160;work&#160;exactly&#160;like&#160;parallel&#160;assignment.&#160;Imagine&#160;an&#160;iterator<br/>that&#160;passes&#160;two&#160;values&#160;to&#160;its&#160;block.&#160;By&#160;the&#160;rules&#160;of&#160;parallel&#160;assignment,&#160;we&#160;might&#160;expect<br/>to&#160;be&#160;able&#160;to&#160;declare&#160;a&#160;block&#160;with&#160;a&#160;single&#160;parameter&#160;and&#160;have&#160;the&#160;two&#160;values&#160;automat-<br/>ically filled into an array for us. But it does not work that way:<br/>
def two; yield 1,2; end &#160;# An iterator that yields two values<br/>two {|x| p x } &#160; &#160; # Ruby 1.8: warns and prints [1,2],<br/>two {|x| p x } &#160; &#160; # Ruby 1.9: prints 1, no warning<br/>two {|*x| p x } &#160; &#160;# Either version: prints [1,2]; no warning<br/>two {|x,| p x } &#160; &#160;# Either version: prints 1; no warning<br/>
In&#160;Ruby&#160;1.8,&#160;multiple&#160;arguments&#160;are&#160;packed&#160;into&#160;an&#160;array&#160;when&#160;there&#160;is&#160;a&#160;single&#160;block<br/>parameter,&#160;but&#160;this&#160;is&#160;deprecated&#160;and&#160;generates&#160;a&#160;warning&#160;message.&#160;In&#160;Ruby&#160;1.9,&#160;the<br/>first&#160;value&#160;yielded&#160;is&#160;assigned&#160;to&#160;the&#160;block&#160;parameter&#160;and&#160;the&#160;second&#160;value&#160;is&#160;silently<br/>discarded.&#160;If&#160;we&#160;want&#160;multiple&#160;yielded&#160;values&#160;to&#160;be&#160;packed&#160;into&#160;an&#160;array&#160;and&#160;assigned<br/>
*&#160;The&#160;Ruby&#160;1.8&#160;each_pair&#160;yields&#160;two&#160;separate&#160;values&#160;to&#160;the&#160;block.&#160;In&#160;Ruby&#160;1.9,&#160;the&#160;each_pair&#160;iterator&#160;is&#160;a<br/>
synonym&#160;for&#160;each&#160;and&#160;passes&#160;a&#160;single&#160;array&#160;argument,&#160;as&#160;will&#160;be&#160;explained&#160;shortly.&#160;The&#160;code&#160;shown&#160;here,<br/>however, works correctly in both versions.<br/>
<b>144&#160;|&#160;Chapter 5:</b> <b>Statements and Control Structures</b><br/>
<hr/>
<a name=159></a>to&#160;a&#160;single&#160;block&#160;parameter,&#160;we&#160;must&#160;explicitly&#160;indicate&#160;this&#160;by&#160;prefixing&#160;the&#160;parameter<br/>with&#160;an&#160;*,&#160;exactly&#160;as&#160;we’d&#160;do&#160;in&#160;a&#160;method&#160;declaration.&#160;<a href="Rubys.html#189">(See&#160;Chapter 6</a>&#160;for&#160;a&#160;thorough<br/>discussion&#160;&#160;of&#160;&#160;method&#160;&#160;parameters&#160;&#160;and&#160;&#160;method&#160;&#160;declaration.)&#160;&#160;Also&#160;&#160;note&#160;&#160;that&#160;&#160;we&#160;&#160;can<br/>explicitly&#160;discard&#160;the&#160;second&#160;yielded&#160;value&#160;by&#160;declaring&#160;a&#160;block&#160;parameter&#160;list&#160;that&#160;ends<br/>with&#160;a&#160;comma,&#160;as&#160;if&#160;to&#160;say:&#160;“There&#160;is&#160;another&#160;parameter,&#160;but&#160;it&#160;is&#160;unused&#160;and&#160;I&#160;can’t&#160;be<br/>bothered to pick a name for it.”<br/>Although&#160;block&#160;invocation&#160;does&#160;not&#160;behave&#160;like&#160;parallel&#160;assignment&#160;in&#160;this&#160;case,&#160;it&#160;does<br/>not behave like method invocation, either. If we declare a method with one argument<br/>and&#160;then&#160;pass&#160;two&#160;arguments&#160;to&#160;it,&#160;Ruby&#160;doesn’t&#160;just&#160;print&#160;a&#160;warning,&#160;it&#160;raises&#160;an&#160;error.<br/>The&#160;yield&#160;statement&#160;allows&#160;bare&#160;hashes&#160;as&#160;the&#160;last&#160;argument&#160;value,&#160;just&#160;as&#160;method<br/>invocations (see&#160;<a href="Rubys.html#202">§6.4.4</a>)&#160;do.&#160;That&#160;is,&#160;if&#160;the&#160;last&#160;argument&#160;to&#160;yield&#160;is a hash literal, you<br/>may&#160;omit&#160;the&#160;curly&#160;braces.&#160;Because&#160;it&#160;is&#160;not&#160;common&#160;for&#160;iterators&#160;to&#160;yield&#160;hashes,&#160;we<br/>have to contrive an example to demonstrate this:<br/>
def hashiter; yield :a=&gt;1, :b=&gt;2; end &#160;# Note no curly braces<br/>hashiter {|hash| puts hash[:a] } &#160; &#160; &#160; # Prints 1<br/>
<b>5.4.5 &#160;Block Parameters in Ruby 1.9<br/></b>In&#160;Ruby&#160;1.8,&#160;only&#160;the&#160;last&#160;block&#160;parameter&#160;may&#160;have&#160;an&#160;*&#160;prefix.&#160;Ruby&#160;1.9&#160;lifts&#160;this<br/>restriction&#160;and&#160;allows&#160;any&#160;one&#160;block&#160;parameter,&#160;regardless&#160;of&#160;its&#160;position&#160;in&#160;the&#160;list,&#160;to<br/>have an&#160;*&#160;prefix:<br/>
def five; yield 1,2,3,4,5; end &#160; &#160; # Yield 5 values<br/>five do |head, *body, tail| &#160; &#160; &#160; &#160;# Extra values go into body array<br/>&#160; print head, body, tail &#160; &#160; &#160; &#160; &#160; # Prints &#34;1[2,3,4]5&#34;<br/>end<br/>
In&#160;Ruby&#160;1.9&#160;block&#160;parameters&#160;can&#160;have&#160;default&#160;values&#160;just&#160;like&#160;method&#160;parameters&#160;can.<br/>Suppose,&#160;for&#160;example,&#160;that&#160;you&#160;want&#160;to&#160;iterate&#160;the&#160;values&#160;of&#160;an&#160;object&#160;o&#160;but you don’t<br/>know if&#160;o&#160;is an array or a hash. You could use a block like this:<br/>
o.each {|key=nil,value| puts value}<br/>
If&#160;the&#160;each&#160;iterator&#160;yields&#160;a&#160;single&#160;value,&#160;it&#160;is&#160;assigned&#160;to&#160;the&#160;second&#160;block&#160;parameter.&#160;If<br/>each&#160;yields a pair of values, they are assigned to both parameters.<br/>
In&#160;Ruby&#160;1.9,&#160;the&#160;final&#160;block&#160;parameter&#160;may&#160;be&#160;prefixed&#160;with&#160;&amp;&#160;to&#160;indicate&#160;that&#160;it&#160;is&#160;to<br/>receive&#160;any&#160;block&#160;associated&#160;with&#160;the&#160;invocation&#160;of&#160;the&#160;block.&#160;Recall,&#160;however,&#160;that&#160;a<br/>yield&#160;invocation&#160;may&#160;not&#160;have&#160;a&#160;block&#160;associated&#160;with&#160;it.&#160;We’ll&#160;learn&#160;<a href="Rubys.html#189">in&#160;Chapter&#160;6&#160;</a>that<br/>a&#160;block&#160;can&#160;be&#160;converted&#160;into&#160;a&#160;Proc,&#160;and&#160;blocks&#160;<i>can</i>&#160;be&#160;associated&#160;with&#160;Proc&#160;invocations.<br/><a href="Rubys.html#189">The following code example should make sense once you have read Chapter 6:</a><br/>
# This Proc expects a block&#160;<br/>printer = lambda {|&amp;b| puts b.call } # Print value returned by b<br/>printer.call { &#34;hi&#34; } &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Pass a block to the block!<br/>
<b>5.4 &#160;Blocks&#160;|&#160;145</b><br/>
<hr/>
<a name=160></a><b>5.5 &#160;Altering Control Flow<br/></b>In&#160;addition&#160;to&#160;conditionals,&#160;loops,&#160;and&#160;iterators,&#160;Ruby&#160;supports&#160;a&#160;number&#160;of&#160;statements<br/>that alter the flow-of-control in a Ruby program. These statements are:<br/>
return<br/>
Causes a method to exit and return a value to its caller.<br/>
break<br/>
Causes a loop (or iterator) to exit.<br/>
next<br/>
Causes&#160;a&#160;loop&#160;(or&#160;iterator)&#160;to&#160;skip&#160;the&#160;rest&#160;of&#160;the&#160;current&#160;iteration&#160;and&#160;move&#160;on&#160;to<br/>the next iteration.<br/>
redo<br/>
Restarts a loop or iterator from the beginning.<br/>
retry<br/>
Restarts&#160;an&#160;iterator,&#160;reevaluating&#160;the&#160;entire&#160;expression.&#160;The&#160;retry&#160;keyword&#160;can&#160;also<br/>be used in exception handling, as we’ll see later in the chapter.<br/>
throw/catch<br/>
A&#160;very&#160;general&#160;control&#160;structure&#160;that&#160;is&#160;named&#160;like&#160;and&#160;works&#160;like&#160;an&#160;exception<br/>propagation&#160;and&#160;handling&#160;mechanism.&#160;throw&#160;and&#160;catch&#160;are&#160;not&#160;Ruby’s&#160;primary<br/>exception&#160;&#160;mechanism&#160;&#160;(that&#160;&#160;would&#160;&#160;be&#160;&#160;raise&#160;&#160;and&#160;&#160;rescue,&#160;&#160;described&#160;&#160;later&#160;&#160;in&#160;&#160;this<br/>chapter). Instead, they are used as a kind of multilevel or labeled&#160;break.<br/>
The subsections that follow describe each of these statements in detail.<br/>
<b>5.5.1 &#160;return<br/></b>The&#160;return&#160;statement&#160;causes&#160;the&#160;enclosing&#160;method&#160;to&#160;return&#160;to&#160;its&#160;caller.&#160;If&#160;you&#160;know<br/>C,&#160;Java,&#160;or&#160;a&#160;related&#160;language,&#160;you&#160;probably&#160;already&#160;have&#160;an&#160;intuitive&#160;understanding&#160;of<br/>the&#160;&#160;return&#160;&#160;statement.&#160;&#160;Don’t&#160;&#160;skip&#160;&#160;this&#160;&#160;section,&#160;&#160;however,&#160;&#160;because&#160;&#160;the&#160;&#160;behavior&#160;&#160;of<br/>return&#160;within a block may not be intuitive to you.<br/>
return&#160;may&#160;optionally&#160;be&#160;followed&#160;by&#160;an&#160;expression,&#160;or&#160;a&#160;comma-separated&#160;list&#160;of&#160;ex-<br/>pressions.&#160;If&#160;there&#160;is&#160;no&#160;expression,&#160;then&#160;the&#160;return&#160;value&#160;of&#160;the&#160;method&#160;is&#160;nil. If there<br/>is&#160;one&#160;expression,&#160;then&#160;the&#160;value&#160;of&#160;that&#160;expression&#160;becomes&#160;the&#160;return&#160;value&#160;of&#160;the<br/>method.&#160;If&#160;there&#160;is&#160;more&#160;than&#160;one&#160;expression&#160;after&#160;the&#160;return&#160;keyword,&#160;then&#160;the&#160;return<br/>value of the method is an array containing the values of those expressions.<br/>Note&#160;that&#160;most&#160;methods&#160;do&#160;not&#160;require&#160;the&#160;return&#160;statement.&#160;When&#160;flow-of-control<br/>reaches&#160;the&#160;end&#160;of&#160;a&#160;method,&#160;the&#160;method&#160;automatically&#160;returns&#160;to&#160;its&#160;caller.&#160;The&#160;return<br/>value&#160;in&#160;this&#160;case&#160;is&#160;the&#160;value&#160;of&#160;the&#160;last&#160;expression&#160;in&#160;the&#160;method.&#160;Most&#160;Ruby&#160;pro-<br/>grammers omit&#160;return&#160;when it is not necessary. Instead of writing&#160;return x&#160;as the last<br/>line of a method, they would simply write&#160;x.<br/>
<b>146&#160;|&#160;Chapter 5:</b> <b>Statements and Control Structures</b><br/>
<hr/>
<a name=161></a><img src="Ruby-161_1.png"/><br/>
<i>Figure 5-2. The return statement in a block</i><br/>
return&#160;is&#160;useful&#160;if&#160;you&#160;want&#160;to&#160;return&#160;from&#160;a&#160;method&#160;prematurely,&#160;or&#160;if&#160;you&#160;want&#160;to<br/>return more than one value. For example:<br/>
# Return two copies of x, if x is not nil<br/>def double(x)<br/>&#160; return nil if x == nil &#160; # Return prematurely<br/>&#160; return x, x.dup &#160; &#160; &#160; &#160; &#160;# Return multiple values<br/>end<br/>
When&#160;first&#160;learning&#160;about&#160;Ruby&#160;blocks,&#160;it&#160;is&#160;natural&#160;to&#160;think&#160;of&#160;them&#160;as&#160;some&#160;kind&#160;of<br/>nested&#160;function&#160;or&#160;mini-method.&#160;And&#160;if&#160;you&#160;think&#160;of&#160;them&#160;this&#160;way,&#160;you&#160;might&#160;expect<br/>return&#160;simply&#160;to&#160;cause&#160;the&#160;block&#160;to&#160;return&#160;to&#160;the&#160;iterator&#160;that&#160;yielded&#160;to&#160;it.&#160;But&#160;blocks<br/>are&#160;not&#160;methods,&#160;and&#160;the&#160;return&#160;keyword&#160;does&#160;not&#160;work&#160;this&#160;way.&#160;In&#160;fact,&#160;return&#160;is<br/>remarkably&#160;consistent;&#160;it&#160;always&#160;causes&#160;the&#160;enclosing&#160;method&#160;to&#160;return,&#160;regardless of<br/>how deeply nested within blocks it is.*<br/>Note&#160;that&#160;the&#160;enclosing&#160;method&#160;is&#160;not&#160;the&#160;same&#160;thing&#160;as&#160;the&#160;invoking&#160;method.&#160;When<br/>the&#160;return&#160;statement&#160;is&#160;used&#160;in&#160;a&#160;block,&#160;it&#160;does&#160;not&#160;just&#160;cause&#160;the&#160;block&#160;to&#160;return.&#160;And<br/>it&#160;does&#160;not&#160;just&#160;cause&#160;the&#160;iterator&#160;that&#160;invokes&#160;the&#160;block&#160;to&#160;return.&#160;return&#160;always&#160;causes<br/>the&#160;enclosing&#160;method&#160;to&#160;return.&#160;The&#160;enclosing&#160;method,&#160;also&#160;called&#160;the&#160;<i>lexically enclos-<br/>ing</i>&#160;method,&#160;is&#160;the&#160;method&#160;that&#160;the&#160;block&#160;appears&#160;inside&#160;of&#160;when&#160;you&#160;look&#160;at&#160;the&#160;source<br/><a href="Rubys.html#161">code. Figure 5-2 illustrates the behavior of the&#160;</a>return&#160;statement in a block.<br/>The following code defines a method that uses&#160;return&#160;to return from inside a block:<br/>
# Return the index of the first occurrence of target within array or nil<br/># Note that this code just duplicates the Array.index method<br/>def find(array, target)<br/>&#160; array.each_with_index do |element,index|<br/>
*&#160;We’ll&#160;see&#160;an&#160;exception&#160;when&#160;we&#160;consider&#160;lambdas&#160;<a href="Rubys.html#211">in&#160;§6.5.5.1.&#160;</a>A&#160;lambda&#160;is&#160;a&#160;kind&#160;of&#160;a&#160;function&#160;created&#160;from<br/>
a block, and the behavior of&#160;return&#160;within a lambda is different from its behavior in an ordinary block.<br/>
<b>5.5 &#160;Altering Control Flow&#160;|&#160;147</b><br/>
<hr/>
<a name=162></a>&#160; &#160; return index if (element == target) &#160;# return from find<br/>&#160; end<br/>&#160; nil &#160;# If we didn't find the element, return nil<br/>end<br/>
The&#160;return&#160;statement&#160;in&#160;this&#160;code&#160;does&#160;not&#160;just&#160;cause&#160;the&#160;block&#160;to&#160;return&#160;to&#160;the&#160;iterator<br/>that&#160;invoked&#160;it.&#160;And&#160;it&#160;does&#160;not&#160;just&#160;cause&#160;the&#160;each_with_index&#160;iterator&#160;to&#160;return.&#160;It<br/>causes the&#160;find&#160;method to return a value to its caller.<br/>
<b>5.5.2 &#160;break<br/></b>When&#160;used&#160;within&#160;a&#160;loop,&#160;the&#160;break&#160;statement&#160;transfers&#160;control&#160;out&#160;of&#160;the&#160;loop&#160;to&#160;the<br/>first&#160;expression&#160;following&#160;the&#160;loop.&#160;Readers&#160;who&#160;know&#160;C,&#160;Java,&#160;or&#160;a&#160;similar&#160;language<br/>will already be familiar with the use of&#160;break&#160;in a loop:<br/>
while(line = gets.chop) &#160; &#160; # A loop starts here<br/>&#160; break if line == &#34;quit&#34; &#160; # If this break statement is executed...<br/>&#160; puts eval(line)<br/>end<br/>puts &#34;Good bye&#34; &#160; &#160; &#160; &#160; &#160; &#160; # ...then control is transferred here<br/>
When&#160;used&#160;in&#160;a&#160;block,&#160;break&#160;transfers&#160;control&#160;out&#160;of&#160;the&#160;block,&#160;out&#160;of&#160;the&#160;iterator&#160;that<br/>invoked&#160;the&#160;block,&#160;and&#160;to&#160;the&#160;first&#160;expression&#160;following&#160;the&#160;invocation&#160;of&#160;the&#160;iterator.<br/>For example:<br/>
f.each do |line| &#160; &#160; &#160; &#160; &#160; &#160; # Iterate over the lines in file f<br/>&#160; break if line == &#34;quit\n&#34; &#160;# If this break statement is executed...<br/>&#160; puts eval(line)<br/>end<br/>puts &#34;Good bye&#34; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# ...then control is transferred here<br/>
As&#160;you&#160;can&#160;see,&#160;using&#160;break&#160;inside&#160;a&#160;block&#160;is&#160;lexically&#160;the&#160;same&#160;as&#160;using&#160;it&#160;inside&#160;a&#160;loop.<br/>If&#160;you&#160;consider&#160;the&#160;call&#160;stack,&#160;however,&#160;break&#160;in&#160;a&#160;block&#160;is&#160;more&#160;complicated&#160;because<br/>it&#160;forces&#160;the&#160;iterator&#160;method&#160;that&#160;the&#160;block&#160;is&#160;associated&#160;with&#160;to&#160;return.&#160;<a href="Rubys.html#163">Figure&#160;5-3<br/></a>illustrates this.<br/>Note&#160;that&#160;unlike&#160;return,&#160;break&#160;never&#160;causes&#160;the&#160;lexically&#160;enclosing&#160;method&#160;to&#160;return.<br/>break&#160;can&#160;only&#160;appear&#160;within&#160;a&#160;lexically&#160;enclosing&#160;loop&#160;or&#160;within&#160;a&#160;block.&#160;Using&#160;it&#160;in<br/>any other context causes a&#160;LocalJumpError.<br/>
<b>5.5.2.1 &#160;break with a value<br/></b>Recall&#160;that&#160;all&#160;syntactic&#160;constructs&#160;in&#160;Ruby&#160;are&#160;expressions,&#160;and&#160;all&#160;can&#160;have&#160;a&#160;value.<br/>The&#160;break&#160;statement&#160;can&#160;specify&#160;a&#160;value&#160;for&#160;the&#160;loop&#160;or&#160;iterator&#160;it&#160;is&#160;breaking&#160;out&#160;of.<br/>The&#160;break&#160;keyword&#160;may&#160;be&#160;followed&#160;by&#160;an&#160;expression&#160;or&#160;a&#160;comma-separated&#160;list&#160;of<br/>expressions.&#160;If&#160;break&#160;is&#160;used&#160;with&#160;no&#160;expression,&#160;then&#160;the&#160;value&#160;of&#160;the&#160;loop&#160;expression,<br/>or&#160;the&#160;return&#160;value&#160;of&#160;the&#160;iterator&#160;method,&#160;is&#160;nil.&#160;If&#160;break&#160;is&#160;used&#160;with&#160;a&#160;single&#160;expression,<br/>then&#160;the&#160;value&#160;of&#160;that&#160;expression&#160;becomes&#160;the&#160;value&#160;of&#160;the&#160;loop&#160;expression&#160;or&#160;the&#160;return<br/>value&#160;of&#160;the&#160;iterator.&#160;And&#160;if&#160;break&#160;is&#160;used&#160;with&#160;multiple&#160;expressions,&#160;then&#160;the&#160;values&#160;of<br/>
<b>148&#160;|&#160;Chapter 5:</b> <b>Statements and Control Structures</b><br/>
<hr/>
<a name=163></a><img src="Ruby-163_1.png"/><br/>
<i>Figure 5-3. The break statement in a block</i><br/>
those&#160;expressions&#160;are&#160;placed&#160;into&#160;an&#160;array,&#160;and&#160;that&#160;array&#160;becomes&#160;the&#160;value&#160;of&#160;the&#160;loop<br/>expression or the return value of the iterator.<br/>By&#160;contrast,&#160;a&#160;while&#160;loop&#160;that&#160;terminates&#160;normally&#160;with&#160;no&#160;break&#160;always&#160;has&#160;a&#160;value&#160;of<br/>nil.&#160;The&#160;return&#160;value&#160;of&#160;an&#160;iterator&#160;that&#160;terminates&#160;normally&#160;is&#160;defined&#160;by&#160;the&#160;iterator<br/>method.&#160;Many&#160;iterators,&#160;such&#160;as&#160;times&#160;and&#160;each,&#160;simply&#160;return&#160;the&#160;object&#160;on&#160;which&#160;they<br/>were invoked.<br/>
<b>5.5.3 &#160;next<br/></b>The&#160;next&#160;statement&#160;causes&#160;a&#160;loop&#160;or&#160;iterator&#160;to&#160;end&#160;the&#160;current&#160;iteration&#160;and&#160;begin&#160;the<br/>next.&#160;C&#160;and&#160;Java&#160;programmers&#160;know&#160;this&#160;control&#160;structure&#160;by&#160;the&#160;name&#160;continue.&#160;Here<br/>is&#160;next&#160;in a loop:<br/>
while(line = gets.chop) &#160; &#160; # A loop starts here<br/>&#160; next if line[0,1] == &#34;#&#34; &#160;# If this line is a comment, go on to the next<br/>&#160; puts eval(line)<br/>&#160; # Control goes here when the next statement is executed<br/>end<br/>
When&#160;next&#160;is&#160;used&#160;within&#160;a&#160;block,&#160;it&#160;causes&#160;the&#160;block&#160;to&#160;exit&#160;immediately,&#160;returning<br/>control&#160;to&#160;the&#160;iterator&#160;method,&#160;which&#160;may&#160;then&#160;begin&#160;a&#160;new&#160;iteration&#160;by&#160;invoking&#160;the<br/>block again:<br/>
f.each do |line| &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Iterate over the lines in file f<br/>&#160; next if line[0,1] == &#34;#&#34; &#160; &#160;# If this line is a comment, go to the next<br/>&#160; puts eval(line)<br/>&#160; # Control goes here when the next statement is executed<br/>end<br/>
Using&#160;next&#160;in&#160;a&#160;block&#160;is&#160;lexically&#160;the&#160;same&#160;as&#160;using&#160;it&#160;in&#160;a&#160;while,&#160;until, or&#160;for/in&#160;loop.<br/>When&#160;you&#160;consider&#160;the&#160;calling&#160;sequence,&#160;however,&#160;the&#160;block&#160;case&#160;is&#160;more&#160;complicated,<br/><a href="Rubys.html#164">as Figure 5-4 illustrates.</a><br/>
<b>5.5 &#160;Altering Control Flow&#160;|&#160;149</b><br/>
<hr/>
<a name=164></a><img src="Ruby-164_1.png"/><br/>
<i>Figure 5-4. The next statement in a block</i><br/>
<b>next, break, and return</b><br/>
It&#160;is&#160;instructive&#160;to&#160;contrast&#160;<a href="Rubys.html#164">Figure&#160;5-4&#160;</a>with&#160;Figures&#160;<a href="Rubys.html#161">5-2&#160;</a>and&#160;<a href="Rubys.html#163">5-3.&#160;</a>The&#160;next&#160;statement<br/>causes&#160;a&#160;block&#160;to&#160;return&#160;to&#160;the&#160;iterator&#160;method&#160;that&#160;invoked&#160;it.&#160;The&#160;break&#160;statement<br/>causes&#160;the&#160;block&#160;to&#160;return&#160;to&#160;its&#160;iterator&#160;and&#160;the&#160;iterator&#160;to&#160;return&#160;to&#160;the&#160;enclosing<br/>method.&#160;And&#160;the&#160;return&#160;statement&#160;causes&#160;the&#160;block&#160;to&#160;return&#160;to&#160;the&#160;iterator,&#160;the&#160;iterator<br/>to return to the enclosing method, and the enclosing method to return to its caller.<br/>
next&#160;may&#160;only&#160;be&#160;used&#160;within&#160;a&#160;loop&#160;or&#160;a&#160;block;&#160;it&#160;raises&#160;a&#160;LocalJumpError&#160;when&#160;used<br/>in any other context.<br/>
<b>5.5.3.1 &#160;next and block value<br/></b>Like&#160;the&#160;return&#160;and&#160;break&#160;keywords,&#160;next&#160;may&#160;be&#160;used&#160;alone,&#160;or&#160;it&#160;may&#160;be&#160;followed&#160;by<br/>an&#160;expression&#160;or&#160;a&#160;comma-separated&#160;list&#160;of&#160;expressions.&#160;When&#160;next&#160;is&#160;used&#160;in&#160;a&#160;loop,<br/>any&#160;values&#160;following&#160;next&#160;are&#160;ignored.&#160;In&#160;a&#160;block,&#160;however,&#160;the&#160;expression&#160;or&#160;expres-<br/>sions&#160;&#160;become&#160;&#160;the&#160;&#160;“return&#160;&#160;value”&#160;&#160;of&#160;&#160;the&#160;&#160;yield&#160;&#160;statement&#160;&#160;that&#160;&#160;invoked&#160;&#160;the&#160;&#160;block.&#160;&#160;If<br/>next&#160;&#160;is&#160;&#160;not&#160;&#160;followed&#160;&#160;by&#160;&#160;an&#160;&#160;expression,&#160;&#160;then&#160;&#160;the&#160;&#160;value&#160;&#160;of&#160;&#160;the&#160;&#160;yield&#160;&#160;is&#160;&#160;nil.&#160;&#160;If&#160;&#160;next&#160;&#160;is<br/>followed&#160;by&#160;one&#160;expression,&#160;then&#160;the&#160;value&#160;of&#160;that&#160;expression&#160;becomes&#160;the&#160;value&#160;of&#160;the<br/>yield. And if&#160;next&#160;is followed by a list of expressions, then the value of the&#160;yield&#160;is an<br/>array of the value of those expressions.<br/>In&#160;our&#160;earlier&#160;discussion&#160;of&#160;the&#160;return&#160;statement,&#160;we&#160;were&#160;careful&#160;to&#160;explain&#160;that&#160;blocks<br/>are&#160;not&#160;functions,&#160;and&#160;that&#160;the&#160;return&#160;statement&#160;does&#160;not&#160;make&#160;a&#160;block&#160;return&#160;to&#160;the<br/>iterator&#160;that&#160;invoked&#160;it.&#160;As&#160;you&#160;can&#160;see,&#160;this&#160;is&#160;exactly&#160;what&#160;the&#160;next&#160;statement&#160;does.<br/>Here is code where you might use it in this way:<br/>
squareroots = data.collect do |x|<br/>&#160; next 0 if x &lt; 0 &#160;# Return 0 for negative values<br/>
<b>150&#160;|&#160;Chapter 5:</b> <b>Statements and Control Structures</b><br/>
<hr/>
<a name=165></a>&#160; Math.sqrt(x)<br/>end<br/>
Normally,&#160;the&#160;value&#160;of&#160;a&#160;yield&#160;expression&#160;is&#160;the&#160;value&#160;of&#160;the&#160;last&#160;expression&#160;in&#160;the&#160;block.<br/>As with the&#160;return&#160;statement,&#160;it&#160;is&#160;not&#160;often&#160;necessary&#160;to&#160;explicitly&#160;use&#160;next&#160;to specify<br/>a value. This code could also have been written like this, for example:<br/>
squareroots = data.collect do |x|<br/>&#160; if (x &lt; 0) then 0 else Math.sqrt(x) end<br/>end<br/>
<b>5.5.4 &#160;redo<br/></b>The&#160;redo&#160;statement&#160;restarts&#160;the&#160;current&#160;iteration&#160;of&#160;a&#160;loop&#160;or&#160;iterator.&#160;This&#160;is&#160;not&#160;the<br/>same&#160;thing&#160;as&#160;next.&#160;next&#160;transfers&#160;control&#160;to&#160;the&#160;end&#160;of&#160;a&#160;loop&#160;or&#160;block&#160;so&#160;that&#160;the&#160;next<br/>iteration&#160;can&#160;begin,&#160;whereas&#160;redo&#160;transfers&#160;control&#160;back&#160;to&#160;the&#160;top&#160;of&#160;the&#160;loop&#160;or&#160;block<br/>so&#160;that&#160;the&#160;iteration&#160;can&#160;start&#160;over.&#160;If&#160;you&#160;come&#160;to&#160;Ruby&#160;from&#160;C-like&#160;languages,&#160;then<br/>redo&#160;is probably a new control structure for you.<br/>
redo&#160;transfers&#160;control&#160;to&#160;the&#160;first&#160;expression&#160;in&#160;the&#160;body&#160;of&#160;the&#160;loop&#160;or&#160;in&#160;a&#160;block.&#160;It<br/>does&#160;not&#160;retest&#160;the&#160;loop&#160;condition,&#160;and&#160;it&#160;does&#160;not&#160;fetch&#160;the&#160;next&#160;element&#160;from&#160;an<br/>iterator.&#160;The&#160;following&#160;while&#160;loop&#160;would&#160;normally&#160;terminate&#160;after&#160;three&#160;iterations,&#160;but<br/>a&#160;redo&#160;statement makes it iterate four times:<br/>
i = 0<br/>while(i &lt; 3) &#160; # Prints &#34;0123&#34; instead of &#34;012&#34;<br/>&#160; # Control returns here when redo is executed<br/>&#160; print i<br/>&#160; i += 1<br/>&#160; redo if i == 3<br/>end<br/>
&#160;<br/>
redo&#160;is&#160;not&#160;a&#160;commonly&#160;used&#160;statement,&#160;and&#160;many&#160;examples,&#160;like&#160;this&#160;one,&#160;are&#160;con-<br/>trived.&#160;One&#160;use,&#160;however,&#160;is&#160;to&#160;recover&#160;from&#160;input&#160;errors&#160;when&#160;prompting&#160;a&#160;user&#160;for<br/>input. The following code uses&#160;redo&#160;within a block for this purpose:<br/>
puts &#34;Please enter the first word you think of&#34;<br/>words = %w(apple banana cherry) &#160; # shorthand for [&#34;apple&#34;, &#34;banana&#34;, &#34;cherry&#34;]<br/>response = words.collect do |word|<br/>&#160; # Control returns here when redo is executed<br/>&#160; print word + &#34;&gt; &#34; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Prompt the user<br/>&#160; response = gets.chop &#160; &#160; &#160; &#160; &#160; &#160;# Get a response<br/>&#160; if response.size == 0 &#160; &#160; &#160; &#160; &#160; # If user entered nothing<br/>&#160; &#160; word.upcase! &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Emphasize the prompt with uppercase<br/>&#160; &#160; redo &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# And skip to the top of the block<br/>&#160; end<br/>&#160; response &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Return the response<br/>end<br/>
<b>5.5 &#160;Altering Control Flow&#160;|&#160;151</b><br/>
<hr/>
<a name=166></a><b>5.5.5 &#160;retry<br/></b>The&#160;retry&#160;statement&#160;is&#160;normally&#160;used&#160;in&#160;a&#160;rescue&#160;clause&#160;to&#160;reexecute&#160;a&#160;block&#160;of&#160;code<br/>that&#160;raised&#160;an&#160;exception.&#160;This&#160;is&#160;described&#160;<a href="Rubys.html#175">in&#160;§5.6.3.5.&#160;</a>In&#160;Ruby&#160;1.8,&#160;however,&#160;retry&#160;has<br/>another&#160;use:&#160;it&#160;restarts&#160;an&#160;iterator-based&#160;iteration&#160;(or&#160;any&#160;method&#160;invocation)&#160;from&#160;the<br/>beginning. This use of the&#160;retry&#160;statement&#160;is&#160;extremely&#160;rare,&#160;and&#160;it&#160;has&#160;been&#160;removed<br/>from&#160;&#160;the&#160;&#160;language&#160;&#160;in&#160;&#160;Ruby&#160;&#160;1.9.&#160;&#160;It&#160;&#160;should,&#160;&#160;therefore,&#160;&#160;be&#160;&#160;considered&#160;&#160;a&#160;&#160;deprecated<br/>language feature and should not be used in new code.<br/>In a block, the&#160;retry&#160;statement does not just redo the current invocation of the block;<br/>it&#160;causes&#160;the&#160;block&#160;and&#160;the&#160;iterator&#160;method&#160;to&#160;exit&#160;and&#160;then&#160;reevaluates&#160;the&#160;iterator<br/>expression to restart the iteration. Consider the following code:<br/>
n = 10<br/>n.times do |x| &#160; # Iterate n times from 0 to n–1<br/>&#160; print x &#160; &#160; &#160; &#160;# Print iteration number<br/>&#160; if x == 9 &#160; &#160; &#160;# If we've reached 9<br/>&#160; &#160; n -= 1 &#160; &#160; &#160; # Decrement n (we won't reach 9 the next time!)<br/>&#160; &#160; retry &#160; &#160; &#160; &#160;# Restart the iteration<br/>&#160; end<br/>end<br/>
The&#160;code&#160;uses&#160;retry&#160;to&#160;restart&#160;the&#160;iterator,&#160;but&#160;it&#160;is&#160;careful&#160;to&#160;avoid&#160;an&#160;infinite&#160;loop.&#160;On<br/>the&#160;first&#160;invocation,&#160;it&#160;prints&#160;the&#160;numbers&#160;0123456789&#160;and&#160;then&#160;restarts.&#160;On&#160;the&#160;second<br/>invocation, it prints the numbers&#160;012345678&#160;and does not restart.<br/>The&#160;magic&#160;of&#160;the&#160;retry&#160;statement&#160;is&#160;that&#160;it&#160;does&#160;not&#160;retry&#160;the&#160;iterator&#160;in&#160;exactly&#160;the&#160;same<br/>way&#160;each&#160;time.&#160;It&#160;completely&#160;reevaluates&#160;the&#160;iterator&#160;expression,&#160;which&#160;means&#160;that&#160;the<br/>arguments&#160;to&#160;the&#160;iterator&#160;(and&#160;even&#160;the&#160;object&#160;on&#160;which&#160;it&#160;is&#160;invoked)&#160;may&#160;be&#160;different<br/>each&#160;time&#160;the&#160;iterator&#160;is&#160;retried.&#160;If&#160;you&#160;are&#160;not&#160;used&#160;to&#160;highly&#160;dynamic&#160;languages&#160;like<br/>Ruby, this reevaluation may seem counterintuitive to you.<br/>The&#160;retry&#160;statement&#160;is&#160;not&#160;restricted&#160;to&#160;use&#160;in&#160;blocks;&#160;it&#160;always&#160;just&#160;reevaluates&#160;the<br/>nearest&#160;containing&#160;method&#160;invocation.&#160;This&#160;means&#160;that&#160;it&#160;can&#160;be&#160;used&#160;(prior&#160;to&#160;Ruby<br/>1.9) to write iterators like the following that works like a&#160;while&#160;loop:<br/>
# This method behaves like a while loop: if x is non-nil and non-false,<br/># invoke the block and then retry to restart the loop and test the<br/># condition again. This method is slightly different than a true while loop:&#160;<br/># you can use C-style curly braces to delimit the loop body. And<br/># variables used only within the body of the loop remain local to the block.<br/>def repeat_while(x)<br/>&#160; if x &#160; &#160; # If the condition was not nil or false<br/>&#160; &#160; yield &#160;# Run the body of the loop<br/>&#160; &#160; retry &#160;# Retry and re-evaluate loop condition<br/>&#160; end<br/>end<br/>
<b>152&#160;|&#160;Chapter 5:</b> <b>Statements and Control Structures</b><br/>
<hr/>
<a name=167></a><b>5.5.6 &#160;throw and catch<br/></b>throw&#160;and&#160;catch&#160;are&#160;Kernel&#160;methods&#160;that&#160;define&#160;a&#160;control&#160;structure&#160;that&#160;can&#160;be&#160;thought<br/>of&#160;as&#160;a&#160;multilevel&#160;break.&#160;throw&#160;doesn’t&#160;just&#160;break&#160;out&#160;of&#160;the&#160;current&#160;loop&#160;or&#160;block&#160;but<br/>can&#160;actually&#160;transfer&#160;out&#160;any&#160;number&#160;of&#160;levels,&#160;causing&#160;the&#160;block&#160;defined&#160;with&#160;a&#160;catch<br/>to&#160;exit.&#160;The&#160;catch&#160;need&#160;not&#160;even&#160;be&#160;in&#160;the&#160;same&#160;method&#160;as&#160;the&#160;throw.&#160;It&#160;can&#160;be&#160;in&#160;the<br/>calling method, or somewhere even further up the call stack.<br/>Languages&#160;like&#160;Java&#160;and&#160;JavaScript&#160;allow&#160;loops&#160;to&#160;be&#160;named&#160;or&#160;labeled&#160;with&#160;an&#160;arbitrary<br/>prefix.&#160;When&#160;this&#160;is&#160;done,&#160;a&#160;control&#160;structure&#160;known&#160;as&#160;a&#160;“labeled&#160;break”&#160;causes&#160;the<br/>named loop to exit. Ruby’s&#160;catch&#160;method defines a labeled block of code, and Ruby’s<br/>throw&#160;method&#160;causes&#160;that&#160;block&#160;to&#160;exit.&#160;But&#160;throw&#160;and&#160;catch&#160;are&#160;much&#160;more&#160;general<br/>than&#160;a&#160;labeled&#160;break.&#160;For&#160;one,&#160;it&#160;can&#160;be&#160;used&#160;with&#160;any&#160;kind&#160;of&#160;statement&#160;and&#160;is&#160;not<br/>restricted to loops. More profoundly, a&#160;throw&#160;can propagate up the call stack to cause<br/>a block in an invoking method to exit.<br/>If&#160;you&#160;are&#160;familiar&#160;with&#160;languages&#160;like&#160;Java&#160;and&#160;JavaScript,&#160;then&#160;you&#160;probably&#160;recognize<br/>throw&#160;and&#160;catch&#160;as&#160;the&#160;keywords&#160;those&#160;languages&#160;use&#160;for&#160;raising&#160;and&#160;handling&#160;excep-<br/>tions.&#160;Ruby&#160;does&#160;exceptions&#160;differently,&#160;using&#160;raise&#160;and&#160;rescue,&#160;which&#160;we’ll&#160;learn&#160;about<br/>later&#160;in&#160;this&#160;chapter.&#160;But&#160;the&#160;parallel&#160;to&#160;exceptions&#160;is&#160;intentional.&#160;Calling&#160;throw&#160;is very<br/>much&#160;like&#160;raising&#160;an&#160;exception.&#160;And&#160;the&#160;way&#160;a&#160;throw&#160;propagates&#160;out&#160;through&#160;the&#160;lexical<br/>scope&#160;and&#160;then&#160;up&#160;the&#160;call&#160;stack&#160;is&#160;very&#160;much&#160;the&#160;same&#160;as&#160;the&#160;way&#160;an&#160;exception&#160;prop-<br/>agates&#160;out&#160;and&#160;up.&#160;(We’ll&#160;see&#160;much&#160;more&#160;about&#160;exception&#160;propagation&#160;later&#160;in&#160;the<br/>chapter.)&#160;Despite&#160;the&#160;similarity&#160;to&#160;exceptions,&#160;it&#160;is&#160;best&#160;to&#160;consider&#160;throw&#160;and&#160;catch&#160;as<br/>a&#160;general-purpose&#160;(if&#160;perhaps&#160;infrequently&#160;used)&#160;control&#160;structure&#160;rather&#160;than&#160;an&#160;ex-<br/>ception&#160;&#160;mechanism.&#160;&#160;If&#160;&#160;you&#160;&#160;want&#160;&#160;to&#160;&#160;signal&#160;&#160;an&#160;&#160;error&#160;&#160;or&#160;&#160;exceptional&#160;&#160;condition,&#160;&#160;use<br/>raise&#160;instead of&#160;throw.<br/>
The&#160;following&#160;code&#160;demonstrates&#160;how&#160;throw&#160;and&#160;catch&#160;can&#160;be&#160;used&#160;to&#160;“break&#160;out”&#160;of<br/>nested loops:<br/>
for matrix in data do &#160; &#160; &#160; &#160; &#160; &#160; # Process a deeply nested data structure.<br/>&#160; catch :missing_data do &#160; &#160; &#160; &#160; &#160;# Label this statement so we can break out.<br/>&#160; &#160; for row in matrix do<br/>&#160; &#160; &#160; for value in row do<br/>&#160; &#160; &#160; &#160; throw :missing_data unless value # Break out of two loops at once.<br/>&#160; &#160; &#160; &#160; # Otherwise, do some actual data processing here.<br/>&#160; &#160; &#160; end<br/>&#160; &#160; end<br/>&#160; end<br/>&#160; # We end up here after the nested loops finish processing each matrix.<br/>&#160; # We also get here if :missing_data is thrown.<br/>end<br/>
Note&#160;that&#160;the&#160;catch&#160;method&#160;takes&#160;a&#160;symbol&#160;argument&#160;and&#160;a&#160;block.&#160;It&#160;executes&#160;the&#160;block<br/>and&#160;returns&#160;when&#160;the&#160;block&#160;exits&#160;or&#160;when&#160;the&#160;specified&#160;symbol&#160;is&#160;thrown.&#160;throw&#160;also<br/>expects&#160;a&#160;symbol&#160;as&#160;its&#160;argument&#160;and&#160;causes&#160;the&#160;corresponding&#160;catch&#160;invocation&#160;to<br/>return.&#160;If&#160;no&#160;catch&#160;call&#160;matches&#160;the&#160;symbol&#160;passed&#160;to&#160;throw,&#160;then&#160;a&#160;NameError&#160;exception<br/>
<b>5.5 &#160;Altering Control Flow&#160;|&#160;153</b><br/>
<hr/>
<a name=168></a>is&#160;raised.&#160;Both&#160;catch&#160;and&#160;throw&#160;can&#160;be&#160;invoked&#160;with&#160;string&#160;arguments&#160;instead&#160;of&#160;symbols.<br/>These are converted internally to symbols.<br/>One&#160;of&#160;the&#160;features&#160;of&#160;&#160;throw&#160;and&#160;catch&#160;is&#160;that&#160;they&#160;work&#160;even&#160;when&#160;the&#160;&#160;throw&#160;and<br/>catch&#160;are in different methods. We could refactor this code to put the innermost loop<br/>into a separate method, and the control flow would still work correctly.<br/>If&#160;throw&#160;is&#160;never&#160;called,&#160;a&#160;catch&#160;invocation&#160;returns&#160;the&#160;value&#160;of&#160;the&#160;last&#160;expression&#160;in&#160;its<br/>block.&#160;If&#160;throw&#160;is&#160;called,&#160;then&#160;the&#160;return&#160;value&#160;of&#160;the&#160;corresponding&#160;catch&#160;is,&#160;by&#160;default,<br/>nil.&#160;You&#160;can,&#160;however,&#160;specify&#160;an&#160;arbitrary&#160;return&#160;value&#160;for&#160;catch&#160;by passing a second<br/>argument&#160;to&#160;throw.&#160;The&#160;return&#160;value&#160;of&#160;catch&#160;can&#160;help&#160;you&#160;distinguish&#160;normal&#160;com-<br/>pletion&#160;of&#160;the&#160;block&#160;from&#160;abnormal&#160;completion&#160;with&#160;throw,&#160;and&#160;this&#160;allows&#160;you&#160;to&#160;write<br/>code that does any special processing necessary to respond to the&#160;throw.<br/>
throw&#160;and&#160;catch&#160;are&#160;not&#160;commonly&#160;used&#160;in&#160;practice.&#160;If&#160;you&#160;find&#160;yourself&#160;using&#160;catch<br/>and&#160;&#160;throw&#160;&#160;within&#160;&#160;the&#160;&#160;same&#160;&#160;method,&#160;&#160;consider&#160;&#160;refactoring&#160;&#160;the&#160;&#160;catch&#160;&#160;into&#160;&#160;a&#160;&#160;separate<br/>method definition and replacing the throw with a&#160;return.<br/>
<b>5.6 &#160;Exceptions and Exception Handling<br/></b>An&#160;<i>exception</i>&#160;is&#160;an&#160;object&#160;that&#160;represents&#160;some&#160;kind&#160;of&#160;exceptional&#160;condition;&#160;it&#160;indicates<br/>that&#160;something&#160;has&#160;gone&#160;wrong.&#160;This&#160;could&#160;be&#160;a&#160;programming&#160;error—attempting&#160;to<br/>divide&#160;by&#160;zero,&#160;attempting&#160;to&#160;invoke&#160;a&#160;method&#160;on&#160;an&#160;object&#160;that&#160;does&#160;not&#160;define&#160;the<br/>method,&#160;or&#160;passing&#160;an&#160;invalid&#160;argument&#160;to&#160;a&#160;method.&#160;Or&#160;it&#160;could&#160;be&#160;the&#160;result&#160;from<br/>some&#160;&#160;kind&#160;&#160;of&#160;&#160;external&#160;&#160;condition—making&#160;&#160;a&#160;&#160;network&#160;&#160;request&#160;&#160;when&#160;&#160;the&#160;&#160;network&#160;&#160;is<br/>down, or trying to create an object when the system is out of memory.<br/>When&#160;one&#160;of&#160;these&#160;errors&#160;or&#160;conditions&#160;occurs,&#160;an&#160;exception&#160;is&#160;<i>raised</i>&#160;(or&#160;<i>thrown</i>). By<br/>default,&#160;Ruby&#160;programs&#160;terminate&#160;when&#160;an&#160;exception&#160;occurs.&#160;But&#160;it&#160;is&#160;possible&#160;to&#160;de-<br/>clare&#160;exception&#160;handlers.&#160;An&#160;exception&#160;handler&#160;is&#160;a&#160;block&#160;of&#160;code&#160;that&#160;is&#160;executed&#160;if&#160;an<br/>exception&#160;&#160;occurs&#160;&#160;during&#160;&#160;the&#160;&#160;execution&#160;&#160;of&#160;&#160;some&#160;&#160;other&#160;&#160;block&#160;&#160;of&#160;&#160;code.&#160;&#160;In&#160;&#160;this&#160;&#160;sense,<br/>exceptions&#160;are&#160;a&#160;kind&#160;of&#160;control&#160;statement.&#160;Raising&#160;an&#160;exception&#160;transfers&#160;the&#160;flow-of-<br/>control&#160;to&#160;exception&#160;handling&#160;code.&#160;This&#160;is&#160;like&#160;using&#160;the&#160;break&#160;statement&#160;to&#160;exit&#160;from<br/>a&#160;loop.&#160;As&#160;we’ll&#160;see,&#160;though,&#160;exceptions&#160;are&#160;quite&#160;different&#160;from&#160;the&#160;break&#160;statement;<br/>they&#160;may&#160;transfer&#160;control&#160;out&#160;of&#160;many&#160;enclosing&#160;blocks&#160;and&#160;even&#160;up&#160;the&#160;call&#160;stack&#160;in<br/>order to reach the exception handler.<br/>Ruby&#160;uses&#160;the&#160;Kernel&#160;method&#160;raise&#160;to&#160;raise&#160;exceptions,&#160;and&#160;uses&#160;a&#160;rescue&#160;clause&#160;to<br/>handle&#160;exceptions.&#160;Exceptions&#160;raised&#160;by&#160;raise&#160;are&#160;instances&#160;of&#160;the&#160;Exception&#160;class&#160;or<br/>one&#160;of&#160;its&#160;many&#160;subclasses.&#160;The&#160;throw&#160;and&#160;catch&#160;methods&#160;described&#160;earlier&#160;in&#160;this&#160;chap-<br/>ter&#160;are&#160;not&#160;intended&#160;to&#160;signal&#160;and&#160;handle&#160;exceptions,&#160;but&#160;a&#160;symbol&#160;thrown&#160;by&#160;throw<br/>propagates&#160;in&#160;the&#160;same&#160;way&#160;that&#160;an&#160;exception&#160;raised&#160;by&#160;raise&#160;does.&#160;Exception&#160;objects,<br/>exception&#160;propagation,&#160;the&#160;raise&#160;method,&#160;and&#160;the&#160;rescue&#160;clause&#160;are&#160;described&#160;in&#160;detail<br/>in the subsections that follow.<br/>
<b>154&#160;|&#160;Chapter 5:</b> <b>Statements and Control Structures</b><br/>
<hr/>
<a name=169></a><b>5.6.1 &#160;Exception Classes and Exception Objects<br/></b>Exception objects&#160;are&#160;instances&#160;of&#160;the&#160;Exception&#160;class&#160;or&#160;one&#160;of&#160;its&#160;subclasses.&#160;Numer-<br/>ous&#160;subclasses&#160;exist.&#160;These&#160;subclasses&#160;do&#160;not&#160;typically&#160;define&#160;new&#160;methods&#160;or&#160;new<br/>behavior,&#160;but&#160;they&#160;allow&#160;exceptions&#160;to&#160;be&#160;categorized&#160;by&#160;type.&#160;The&#160;class&#160;hierarchy&#160;is<br/><a href="Rubys.html#169">illustrated in Figure 5-5.</a><br/>
Object<br/>&#160;+--Exception<br/>&#160; &#160; &#160;+--NoMemoryError<br/>&#160; &#160; &#160;+--ScriptError<br/>&#160; &#160; &#160;| &#160; +--LoadError<br/>&#160; &#160; &#160;| &#160; +--NotImplementedError<br/>&#160; &#160; &#160;| &#160; +--SyntaxError<br/>&#160; &#160; &#160;+--SecurityError &#160; &#160; &#160; &#160; # Was a StandardError in 1.8<br/>&#160; &#160; &#160;+--SignalException<br/>&#160; &#160; &#160;| &#160; +--Interrupt<br/>&#160; &#160; &#160;+--SystemExit<br/>&#160; &#160; &#160;+--SystemStackError &#160; &#160; &#160;# Was a StandardError in 1.8<br/>&#160; &#160; &#160;+--StandardError<br/>&#160; &#160; &#160; &#160; &#160;+--ArgumentError<br/>&#160; &#160; &#160; &#160; &#160;+--FiberError &#160; &#160; &#160; &#160;# New in 1.9<br/>&#160; &#160; &#160; &#160; &#160;+--IOError<br/>&#160; &#160; &#160; &#160; &#160;| &#160; +--EOFError<br/>&#160; &#160; &#160; &#160; &#160;+--IndexError<br/>&#160; &#160; &#160; &#160; &#160;| &#160; +--KeyError &#160; &#160; &#160;# New in 1.9<br/>&#160; &#160; &#160; &#160; &#160;| &#160; +--StopIteration # New in 1.9<br/>&#160; &#160; &#160; &#160; &#160;+--LocalJumpError<br/>&#160; &#160; &#160; &#160; &#160;+--NameError<br/>&#160; &#160; &#160; &#160; &#160;| &#160; +--NoMethodError<br/>&#160; &#160; &#160; &#160; &#160;+--RangeError<br/>&#160; &#160; &#160; &#160; &#160;| &#160; +--FloatDomainError<br/>&#160; &#160; &#160; &#160; &#160;+--RegexpError<br/>&#160; &#160; &#160; &#160; &#160;+--RuntimeError<br/>&#160; &#160; &#160; &#160; &#160;+--SystemCallError<br/>&#160; &#160; &#160; &#160; &#160;+--ThreadError<br/>&#160; &#160; &#160; &#160; &#160;+--TypeError<br/>&#160; &#160; &#160; &#160; &#160;+--ZeroDivisionError<br/>
<i>Figure 5-5. The Ruby Exception Class Hierarchy</i><br/>
You&#160;don’t&#160;need&#160;to&#160;be&#160;familiar&#160;with&#160;each&#160;of&#160;these&#160;exception&#160;subclasses.&#160;Their&#160;names&#160;tell<br/>you&#160;what&#160;they&#160;are&#160;used&#160;for.&#160;It&#160;is&#160;important&#160;to&#160;note&#160;that&#160;most&#160;of&#160;these&#160;subclasses&#160;extend<br/>a class known as&#160;StandardError.&#160;These&#160;are&#160;the&#160;“normal”&#160;exceptions&#160;that&#160;typical&#160;Ruby<br/>programs&#160;try&#160;to&#160;handle.&#160;The&#160;other&#160;exceptions&#160;represent&#160;lower-level,&#160;more&#160;serious,&#160;or<br/>less&#160;recoverable&#160;conditions,&#160;and&#160;normal&#160;Ruby&#160;programs&#160;do&#160;not&#160;typically&#160;attempt&#160;to<br/>handle them.<br/>If&#160;you&#160;use&#160;<i>ri</i>&#160;to&#160;find&#160;documentation&#160;for&#160;these&#160;exception&#160;classes,&#160;you’ll&#160;find&#160;that&#160;most&#160;of<br/>them&#160;are&#160;undocumented.&#160;This&#160;is&#160;in&#160;part&#160;because&#160;most&#160;of&#160;them&#160;add&#160;no&#160;new&#160;methods&#160;to<br/>
<b>5.6 &#160;Exceptions and Exception Handling&#160;|&#160;155</b><br/>
<hr/>
<a name=170></a>those defined by the base&#160;Exception&#160;class.&#160;The&#160;important&#160;thing&#160;to&#160;know&#160;about&#160;a&#160;given<br/>exception&#160;class&#160;is&#160;when&#160;it&#160;can&#160;be&#160;raised.&#160;This&#160;is&#160;typically&#160;documented&#160;by&#160;the&#160;methods<br/>that raise the exception rather than by the exception class itself.<br/>
<b>5.6.1.1 &#160;The methods of exception objects<br/></b>The&#160;Exception&#160;class&#160;defines two methods that return details about the exception. The<br/>message&#160;method returns a string that may provide human-readable details about what<br/>went&#160;wrong.&#160;If&#160;a&#160;Ruby&#160;program&#160;exits&#160;with&#160;an&#160;unhandled&#160;exception,&#160;this&#160;message&#160;will<br/>typically&#160;be&#160;displayed&#160;to&#160;the&#160;end&#160;user,&#160;but&#160;the&#160;primary&#160;purpose&#160;of&#160;this&#160;message&#160;is&#160;to&#160;aid<br/>a programmer in diagnosing the problem.<br/>The&#160;other&#160;important&#160;method&#160;of&#160;exception&#160;objects&#160;is&#160;backtrace.&#160;This&#160;method&#160;returns<br/>an&#160;array&#160;of&#160;strings&#160;that&#160;represents&#160;the&#160;call&#160;stack&#160;at&#160;the&#160;point&#160;that&#160;the&#160;exception&#160;was<br/>raised. Each element of the array is a string of the form:<br/>
<i>filename</i>&#160;:&#160;<i>linenumber</i>&#160;in&#160;<i>methodname</i><br/>
The&#160;first&#160;element&#160;of&#160;the&#160;array&#160;specifies&#160;the&#160;position&#160;at&#160;which&#160;the&#160;exception&#160;was&#160;raised;<br/>the&#160;second&#160;element&#160;specifies&#160;the&#160;position&#160;at&#160;which&#160;the&#160;method&#160;that&#160;raised&#160;the&#160;exception<br/>was&#160;called;&#160;the&#160;third&#160;element&#160;specifies&#160;the&#160;position&#160;at&#160;which&#160;that&#160;method&#160;was&#160;called;<br/>and&#160;so&#160;on.&#160;(The&#160;Kernel&#160;method&#160;caller&#160;returns&#160;a&#160;stack&#160;trace&#160;in&#160;this&#160;same&#160;format;&#160;you<br/>can&#160;try&#160;it&#160;out&#160;in&#160;<i>irb</i>.)&#160;Exception&#160;objects&#160;are&#160;typically&#160;created&#160;by&#160;the&#160;raise&#160;method.&#160;When<br/>this&#160;is&#160;done,&#160;the&#160;raise&#160;method&#160;sets&#160;the&#160;stack&#160;trace&#160;of&#160;the&#160;exception&#160;appropriately.&#160;If&#160;you<br/>create&#160;your&#160;own&#160;exception&#160;object,&#160;you&#160;can&#160;set&#160;the&#160;stack&#160;trace&#160;to&#160;whatever&#160;you&#160;want<br/>with the&#160;set_backtrace&#160;method.<br/>
<b>5.6.1.2 &#160;Creating exception objects<br/></b>Exception&#160;objects&#160;are&#160;typically&#160;created&#160;by&#160;the&#160;raise&#160;method,&#160;as&#160;we’ll&#160;see&#160;below.&#160;How-<br/>ever,&#160;you&#160;can&#160;create&#160;your&#160;own&#160;objects&#160;with&#160;the&#160;normal&#160;new&#160;method,&#160;or&#160;with&#160;another<br/>class&#160;method&#160;named&#160;exception.&#160;Both&#160;accept&#160;a&#160;single&#160;optional&#160;string&#160;argument.&#160;If&#160;speci-<br/>fied, the string becomes the value of the&#160;message&#160;method.<br/>
<b>5.6.1.3 &#160;Defining new exception classes<br/></b>If&#160;you&#160;are&#160;defining&#160;a&#160;module&#160;of&#160;Ruby&#160;code,&#160;it&#160;is&#160;often&#160;appropriate&#160;to&#160;define&#160;your&#160;own<br/>subclass&#160;of&#160;StandardError&#160;for&#160;exceptions&#160;that&#160;are&#160;specific&#160;to&#160;your&#160;module.&#160;This&#160;may&#160;be<br/>a trivial, one-line subclass:<br/>
class MyError &lt; StandardError; end<br/>
<b>5.6.2 &#160;Raising Exceptions with raise<br/></b>The&#160;Kernel&#160;method&#160;raise&#160;raises&#160;an&#160;exception.&#160;fail&#160;is&#160;a&#160;synonym&#160;that&#160;is&#160;sometimes&#160;used<br/>when&#160;the&#160;expectation&#160;is&#160;that&#160;the&#160;exception&#160;will&#160;cause&#160;the&#160;program&#160;to&#160;exit.&#160;There&#160;are<br/>several ways to invoke&#160;raise:<br/>
<b>156&#160;|&#160;Chapter 5:</b> <b>Statements and Control Structures</b><br/>
<hr/>
<a name=171></a>•&#160;If&#160;raise&#160;is&#160;called&#160;with&#160;no&#160;arguments,&#160;it&#160;creates&#160;a&#160;new&#160;RuntimeError&#160;object&#160;(with&#160;no<br/>
message)&#160;and&#160;raises&#160;it.&#160;Or,&#160;if&#160;raise&#160;is&#160;used&#160;with&#160;no&#160;arguments&#160;inside&#160;a&#160;rescue&#160;clause,<br/>it simply re-raises the exception that was being handled.<br/>
•&#160;If&#160;&#160;raise&#160;&#160;is&#160;&#160;called&#160;&#160;with&#160;&#160;a&#160;&#160;single&#160;&#160;Exception&#160;&#160;object&#160;&#160;as&#160;&#160;its&#160;&#160;argument,&#160;&#160;it&#160;&#160;raises&#160;&#160;that<br/>
exception. Despite its simplicity, this is not actually a common way to use&#160;raise.<br/>
•&#160;If&#160;&#160;raise&#160;&#160;is&#160;&#160;called&#160;&#160;with&#160;&#160;a&#160;&#160;single&#160;&#160;string&#160;&#160;argument,&#160;&#160;it&#160;&#160;creates&#160;&#160;a&#160;&#160;new&#160;&#160;RuntimeError<br/>
exception&#160;object,&#160;with&#160;the&#160;specified&#160;string&#160;as&#160;its&#160;message,&#160;and&#160;raises&#160;that&#160;exception.<br/>This is a very common way to use&#160;raise.<br/>
•&#160;If&#160;&#160;the&#160;&#160;first&#160;&#160;argument&#160;&#160;to&#160;&#160;raise&#160;&#160;is&#160;&#160;an&#160;&#160;object&#160;&#160;that&#160;&#160;has&#160;&#160;an&#160;&#160;exception&#160;&#160;method,&#160;&#160;then<br/>
raise&#160;&#160;invokes&#160;&#160;that&#160;&#160;method&#160;&#160;and&#160;&#160;raises&#160;&#160;the&#160;&#160;Exception&#160;&#160;object&#160;&#160;that&#160;&#160;it&#160;&#160;returns.&#160;&#160;The<br/>Exception&#160;class&#160;defines&#160;an&#160;exception&#160;method,&#160;so&#160;you&#160;can&#160;specify&#160;the&#160;class&#160;object<br/>for any kind of exception as the first argument to&#160;raise.<br/>raise&#160;accepts&#160;a&#160;string&#160;as&#160;its&#160;optional&#160;second&#160;argument.&#160;If&#160;a&#160;string&#160;is&#160;specified,&#160;it&#160;is<br/>passed&#160;to&#160;the&#160;exception&#160;method&#160;of&#160;the&#160;first&#160;argument.&#160;This&#160;string&#160;is&#160;intended&#160;for<br/>use as the exception message.<br/>raise&#160;also&#160;accepts&#160;an&#160;optional&#160;third&#160;argument.&#160;An&#160;array&#160;of&#160;strings&#160;may&#160;be&#160;specified<br/>here,&#160;and&#160;they&#160;will&#160;be&#160;used&#160;as&#160;the&#160;backtrace&#160;for&#160;the&#160;exception&#160;object.&#160;If&#160;this&#160;third<br/>argument&#160;is&#160;not&#160;specified,&#160;raise&#160;sets&#160;the&#160;backtrace&#160;of&#160;the&#160;exception&#160;itself&#160;(using&#160;the<br/>Kernel&#160;method&#160;caller).<br/>
The&#160;following&#160;code&#160;defines&#160;a&#160;simple&#160;method&#160;that&#160;raises&#160;an&#160;exception&#160;if&#160;invoked&#160;with&#160;a<br/>parameter whose value is invalid:<br/>
def factorial(n) &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Define a factorial method with argument n<br/>&#160; raise &#34;bad argument&#34; if n &lt; 1 &#160;# Raise an exception for bad n<br/>&#160; return 1 if n == 1 &#160; &#160; &#160; &#160; &#160; &#160; # factorial(1) is 1<br/>&#160; n * factorial(n-1) &#160; &#160; &#160; &#160; &#160; &#160; # Compute other factorials recursively<br/>end<br/>
This&#160;method&#160;invokes&#160;raise&#160;with&#160;a&#160;single&#160;string&#160;argument.&#160;These&#160;are&#160;some&#160;equivalent<br/>ways to raise the same exception:<br/>
raise RuntimeError, &#34;bad argument&#34; if n &lt; 1<br/>raise RuntimeError.new(&#34;bad argument&#34;) if n &lt; 1<br/>raise RuntimeError.exception(&#34;bad argument&#34;) if n &lt; 1<br/>
In&#160;this&#160;example,&#160;an&#160;exception&#160;of&#160;class&#160;ArgumentError&#160;is&#160;probably&#160;more&#160;appropriate&#160;than<br/>RuntimeError:<br/>
raise ArgumentError if n &lt; 1<br/>
And a more detailed error message would be helpful:<br/>
raise ArgumentError, &#34;Expected argument &gt;= 1. Got #{n}&#34; if n &lt; 1<br/>
The&#160;intent&#160;of&#160;the&#160;exception&#160;we’re&#160;raising&#160;here&#160;is&#160;to&#160;point&#160;out&#160;a&#160;problem&#160;with&#160;the&#160;invo-<br/>cation&#160;of&#160;the&#160;factorial&#160;method,&#160;not&#160;with&#160;the&#160;code&#160;inside&#160;the&#160;method.&#160;The&#160;exception<br/>raised&#160;&#160;by&#160;&#160;the&#160;&#160;code&#160;&#160;here&#160;&#160;will&#160;&#160;have&#160;&#160;a&#160;&#160;backtrace&#160;&#160;whose&#160;&#160;first&#160;&#160;element&#160;&#160;identifies&#160;&#160;where<br/>raise&#160;was&#160;called.&#160;The&#160;second&#160;element&#160;of&#160;the&#160;array&#160;will&#160;actually&#160;identify&#160;the&#160;code&#160;that<br/>
<b>5.6 &#160;Exceptions and Exception Handling&#160;|&#160;157</b><br/>
<hr/>
<a name=172></a>called&#160;factorial&#160;with&#160;the&#160;bad&#160;argument.&#160;If&#160;we&#160;want&#160;to&#160;point&#160;directly&#160;to&#160;the&#160;problem<br/>code,&#160;we&#160;can&#160;provide&#160;a&#160;custom&#160;stack&#160;trace&#160;as&#160;the&#160;third&#160;argument&#160;to&#160;raise&#160;with&#160;the<br/>Kernel&#160;method&#160;caller:<br/>
if n &lt; 1<br/>&#160; raise ArgumentError, &#34;Expected argument &gt;= 1. Got #{n}&#34;, caller<br/>end<br/>
Note&#160;that&#160;the&#160;factorial&#160;method&#160;checks&#160;whether&#160;its&#160;argument&#160;is&#160;in&#160;the&#160;correct&#160;range,<br/>but&#160;it&#160;does&#160;not&#160;check&#160;whether&#160;it&#160;is&#160;of&#160;the&#160;right&#160;type.&#160;We&#160;might&#160;add&#160;more&#160;careful&#160;error-<br/>checking by adding the following as the first line of the method:<br/>
raise TypeError, &#34;Integer argument expected&#34; if not n.is_a? Integer<br/>
On&#160;&#160;the&#160;&#160;other&#160;&#160;hand,&#160;&#160;notice&#160;&#160;what&#160;&#160;happens&#160;&#160;if&#160;&#160;we&#160;&#160;pass&#160;&#160;a&#160;&#160;string&#160;&#160;argument&#160;&#160;to&#160;&#160;the<br/>factorial&#160;method&#160;as&#160;it&#160;is&#160;written&#160;above.&#160;Ruby&#160;compares&#160;the&#160;argument&#160;n&#160;to the integer<br/>1&#160;with the&#160;&lt;&#160;operator.&#160;If&#160;the&#160;argument&#160;is&#160;a&#160;string,&#160;the&#160;comparison&#160;makes&#160;no&#160;sense,&#160;and<br/>it&#160;fails&#160;by&#160;raising&#160;a&#160;TypeError.&#160;If&#160;the&#160;argument&#160;is&#160;an&#160;instance&#160;of&#160;some&#160;class&#160;that&#160;does&#160;not<br/>define the&#160;&lt;&#160;operator, then we get a&#160;NoMethodError&#160;instead.<br/>The&#160;point&#160;here&#160;is&#160;that&#160;exceptions&#160;can&#160;occur&#160;even&#160;if&#160;we&#160;do&#160;not&#160;call&#160;raise&#160;in&#160;our&#160;own<br/>code.&#160;It&#160;is&#160;important,&#160;therefore,&#160;to&#160;know&#160;how&#160;to&#160;handle&#160;exceptions,&#160;even&#160;if&#160;we&#160;never<br/>raise them ourselves. Handling exceptions is covered in the next section.<br/>
<b>5.6.3 &#160;Handling Exceptions with rescue<br/></b>raise&#160;is&#160;a&#160;Kernel&#160;method.&#160;A&#160;rescue&#160;clause,&#160;by&#160;contrast,&#160;is&#160;a&#160;fundamental&#160;part&#160;of&#160;the<br/>Ruby language.&#160;rescue&#160;is&#160;not&#160;a&#160;statement&#160;in&#160;its&#160;own&#160;right,&#160;but&#160;rather&#160;a&#160;clause&#160;that&#160;can<br/>be attached to other Ruby statements. Most commonly, a&#160;rescue&#160;clause is attached to<br/>a&#160;begin&#160;statement.&#160;The&#160;begin&#160;statement&#160;exists&#160;simply&#160;to&#160;delimit&#160;the&#160;block&#160;of&#160;code&#160;within<br/>which&#160;exceptions&#160;are&#160;to&#160;be&#160;handled.&#160;A&#160;begin&#160;statement&#160;with&#160;a&#160;rescue&#160;clause looks like<br/>this:<br/>
begin<br/>&#160; # Any number of Ruby statements go here.<br/>&#160; # Usually, they are executed without exceptions and<br/>&#160; # execution continues after the end statement.<br/>rescue<br/>&#160; # This is the rescue clause; exception-handling code goes here.<br/>&#160; # If an exception is raised by the code above, or propagates up<br/>&#160; # from one of the methods called above, then execution jumps here.<br/>end<br/>
<b>5.6.3.1 &#160;Naming the exception object<br/></b>In&#160;a&#160;rescue&#160;clause,&#160;the&#160;global&#160;variable&#160;$!&#160;refers&#160;to&#160;the&#160;Exception&#160;object&#160;that&#160;is&#160;being<br/>handled.&#160;&#160;The&#160;&#160;exclamation&#160;&#160;mark&#160;&#160;is&#160;&#160;a&#160;&#160;mnemonic:&#160;&#160;an&#160;&#160;exception&#160;&#160;is&#160;&#160;kind&#160;&#160;of&#160;&#160;like&#160;&#160;an<br/>exclamation. If your program includes the line:<br/>
require 'English'<br/>
<b>158&#160;|&#160;Chapter 5:</b> <b>Statements and Control Structures</b><br/>
<hr/>
<a name=173></a>then you can use the global variable&#160;$ERROR_INFO&#160;instead.<br/>A&#160;better&#160;alternative&#160;to&#160;$!&#160;or&#160;$ERROR_INFO&#160;is&#160;to&#160;specify&#160;a&#160;variable&#160;name&#160;for&#160;the&#160;exception<br/>object in the&#160;rescue&#160;clause itself:<br/>
rescue =&gt; ex<br/>
The&#160;&#160;statements&#160;&#160;of&#160;&#160;this&#160;&#160;rescue&#160;&#160;clause&#160;&#160;can&#160;&#160;now&#160;&#160;use&#160;&#160;the&#160;&#160;variable&#160;&#160;ex&#160;&#160;to&#160;&#160;refer&#160;&#160;to&#160;&#160;the<br/>Exception&#160;object that describes the exception. For example:<br/>
begin &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Handle exceptions in this block<br/>&#160; x = factorial(-1) &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Note illegal argument<br/>rescue =&gt; ex &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Store exception in variable ex<br/>&#160; puts &#34;#{ex.class}: #{ex.message}&#34; &#160;# Handle exception by printing message<br/>end &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# End the begin/rescue block<br/>
Note that a&#160;rescue&#160;clause&#160;does&#160;not&#160;define&#160;a&#160;new&#160;variable&#160;scope,&#160;and&#160;a&#160;variable&#160;named<br/>in&#160;the&#160;rescue&#160;clause&#160;is&#160;visible&#160;even&#160;after&#160;the&#160;end&#160;of&#160;the&#160;rescue&#160;clause.&#160;If&#160;you&#160;use&#160;a&#160;variable<br/>in&#160;a&#160;rescue&#160;clause,&#160;then&#160;an&#160;exception&#160;object&#160;may&#160;be&#160;visible&#160;after&#160;the&#160;rescue&#160;is&#160;complete,<br/>even when&#160;$!&#160;is no longer set.<br/>
<b>5.6.3.2 &#160;Handling exceptions by type<br/></b>The&#160;rescue&#160;clauses&#160;shown&#160;here&#160;handle&#160;any&#160;exception&#160;that&#160;is&#160;a&#160;StandardError&#160;(or&#160;sub-<br/>class)&#160;and&#160;ignore&#160;any&#160;Exception&#160;object&#160;that&#160;is&#160;not&#160;a&#160;StandardError.&#160;If&#160;you&#160;want&#160;to&#160;handle<br/>nonstandard&#160;exceptions&#160;outside&#160;the&#160;StandardError&#160;hierarchy,&#160;or&#160;if&#160;you&#160;want&#160;to&#160;handle<br/>only&#160;specific&#160;types&#160;of&#160;exceptions,&#160;you&#160;must&#160;include&#160;one&#160;or&#160;more&#160;exception&#160;classes&#160;in<br/>the&#160;rescue&#160;clause. Here’s how you would write a&#160;rescue&#160;clause that would handle any<br/>kind of exception:<br/>
rescue Exception<br/>
Here’s&#160;how&#160;you&#160;would&#160;write&#160;a&#160;rescue&#160;clause&#160;to&#160;handle&#160;an&#160;ArgumentError&#160;and&#160;assign&#160;the<br/>exception object to the variable&#160;e:<br/>
rescue ArgumentError =&gt; e<br/>
Recall&#160;&#160;that&#160;&#160;the&#160;&#160;factorial&#160;&#160;method&#160;&#160;we&#160;&#160;defined&#160;&#160;earlier&#160;&#160;can&#160;&#160;raise&#160;&#160;ArgumentError&#160;&#160;or<br/>TypeError. Here’s&#160;how&#160;we&#160;would&#160;write&#160;a&#160;rescue&#160;clause&#160;to&#160;handle&#160;exceptions&#160;of&#160;either<br/>of these types and assign the exception object to the variable&#160;error:<br/>
rescue ArgumentError, TypeError =&gt; error<br/>
Here,&#160;finally,&#160;we&#160;see&#160;the&#160;syntax&#160;of&#160;the&#160;rescue&#160;clause&#160;at&#160;its&#160;most&#160;general.&#160;The&#160;rescue<br/>keyword&#160;is&#160;followed&#160;by&#160;zero&#160;or&#160;more&#160;comma-separated&#160;expressions,&#160;each&#160;of&#160;which&#160;must<br/>evaluate&#160;&#160;to&#160;&#160;a&#160;&#160;class&#160;&#160;object&#160;&#160;that&#160;&#160;represents&#160;&#160;the&#160;&#160;Exception&#160;&#160;class&#160;&#160;or&#160;&#160;a&#160;&#160;subclass.&#160;&#160;These<br/>expressions are optionally followed by&#160;=&gt;&#160;and a variable name.<br/>Now&#160;suppose&#160;we&#160;want&#160;to&#160;handle&#160;both&#160;ArgumentError&#160;and&#160;TypeError,&#160;but&#160;we&#160;want&#160;to<br/>handle&#160;these&#160;two&#160;exceptions&#160;in&#160;different&#160;ways.&#160;We&#160;might&#160;use&#160;a&#160;case&#160;statement&#160;to&#160;run<br/>different&#160;code&#160;based&#160;on&#160;the&#160;class&#160;of&#160;the&#160;exception&#160;object.&#160;It&#160;is&#160;more&#160;elegant,&#160;however,<br/>to&#160;simply&#160;use&#160;multiple&#160;rescue&#160;clauses.&#160;A&#160;begin&#160;statement&#160;can&#160;have&#160;zero&#160;or&#160;more&#160;of&#160;them:<br/>
<b>5.6 &#160;Exceptions and Exception Handling&#160;|&#160;159</b><br/>
<hr/>
<a name=174></a>begin<br/>&#160; x = factorial(1)<br/>rescue ArgumentError =&gt; ex<br/>&#160; puts &#34;Try again with a value &gt;= 1&#34;<br/>rescue TypeError =&gt; ex<br/>&#160; puts &#34;Try again with an integer&#34;<br/>end<br/>
Note&#160;that&#160;the&#160;Ruby&#160;interpreter&#160;attempts&#160;to&#160;match&#160;exceptions&#160;to&#160;rescue&#160;clauses&#160;in&#160;the<br/>order&#160;they&#160;are&#160;written.&#160;Therefore,&#160;you&#160;should&#160;list&#160;your&#160;most&#160;specific&#160;exception&#160;sub-<br/>classes&#160;first&#160;and&#160;follow&#160;these&#160;with&#160;more&#160;general&#160;types.&#160;If&#160;you&#160;want&#160;to&#160;handle&#160;EOFError<br/>differently&#160;than&#160;IOError,&#160;for&#160;example,&#160;be&#160;sure&#160;to&#160;put&#160;the&#160;rescue&#160;clause&#160;for&#160;EOFError&#160;first<br/>or the&#160;IOError&#160;code&#160;will&#160;handle&#160;it.&#160;If&#160;you&#160;want&#160;a&#160;“catch-all”&#160;rescue&#160;clause that handles<br/>any&#160;&#160;exception&#160;&#160;not&#160;&#160;handled&#160;&#160;by&#160;&#160;previous&#160;&#160;clauses,&#160;&#160;use&#160;&#160;rescue Exception&#160;&#160;as&#160;&#160;the&#160;&#160;last<br/>rescue&#160;clause.<br/>
<b>5.6.3.3 &#160;Propagation of exceptions<br/></b>Now&#160;that&#160;we’ve&#160;introduced&#160;rescue&#160;clauses,&#160;we&#160;can&#160;explain&#160;in&#160;more&#160;detail&#160;the&#160;propa-<br/>gation&#160;of&#160;exceptions.&#160;When&#160;an&#160;exception&#160;is&#160;raised,&#160;control&#160;is&#160;immediately&#160;transferred<br/>outward&#160;and&#160;upward&#160;until&#160;a&#160;suitable&#160;rescue&#160;clause&#160;is&#160;found&#160;to&#160;handle&#160;the&#160;exception.<br/>When the&#160;raise&#160;method&#160;executes,&#160;the&#160;Ruby&#160;interpreter&#160;looks&#160;to&#160;see&#160;whether&#160;the&#160;con-<br/>taining&#160;block&#160;has&#160;a&#160;rescue&#160;clause&#160;associated&#160;with&#160;it.&#160;If&#160;not&#160;(or&#160;if&#160;the&#160;rescue&#160;clause&#160;is&#160;not<br/>declared&#160;to&#160;handle&#160;that&#160;kind&#160;of&#160;exception),&#160;then&#160;the&#160;interpreter&#160;looks&#160;at&#160;the&#160;containing<br/>block&#160;of&#160;the&#160;containing&#160;block.&#160;If&#160;there&#160;is&#160;no&#160;suitable&#160;rescue&#160;clause&#160;anywhere&#160;in&#160;the<br/>method that called&#160;raise, then the method itself exits.<br/>When&#160;a&#160;method&#160;exits&#160;because&#160;of&#160;an&#160;exception,&#160;it&#160;is&#160;not&#160;the&#160;same&#160;thing&#160;as&#160;a&#160;normal<br/>return.&#160;The&#160;method&#160;does&#160;not&#160;have&#160;a&#160;return&#160;value,&#160;and&#160;the&#160;exception&#160;object&#160;continues<br/>propagating&#160;from&#160;the&#160;site&#160;of&#160;the&#160;method&#160;invocation.&#160;The&#160;exception&#160;propagates&#160;outward<br/>through the enclosing blocks, looking for a&#160;rescue&#160;clause declared to handle it. And if<br/>no&#160;such&#160;clause&#160;is&#160;found,&#160;then&#160;this&#160;method&#160;returns&#160;to&#160;<i>its</i>&#160;caller.&#160;This&#160;continues&#160;up&#160;the<br/>call&#160;stack.&#160;If&#160;no&#160;exception&#160;handler&#160;is&#160;ever&#160;located,&#160;then&#160;the&#160;Ruby&#160;interpreter&#160;prints&#160;the<br/>exception&#160;&#160;message&#160;&#160;and&#160;&#160;backtrace&#160;&#160;and&#160;&#160;exits.&#160;&#160;For&#160;&#160;a&#160;&#160;concrete&#160;&#160;example,&#160;&#160;consider&#160;&#160;the<br/>following code:<br/>
def explode &#160; &#160; &#160; &#160;# This method raises a RuntimeError 10% of the time<br/>&#160; raise &#34;bam!&#34; if rand(10) == 0<br/>end<br/>
def risky &#160;&#160;<br/>&#160; begin &#160; &#160; &#160; &#160; &#160; &#160;# This block<br/>&#160; &#160; 10.times do &#160; &#160;# contains another block<br/>&#160; &#160; &#160; explode &#160; &#160; &#160;# that might raise an exception.<br/>&#160; &#160; end &#160; &#160; &#160; &#160; &#160; &#160;# No rescue clause here, so propagate out.<br/>&#160; rescue TypeError # This rescue clause cannot handle a RuntimeError..<br/>&#160; &#160; puts $! &#160; &#160; &#160; &#160;# so skip it and propagate out.<br/>&#160; end &#160; &#160; &#160; &#160; &#160; &#160; &#160;<br/>&#160; &#34;hello&#34; &#160; &#160; &#160; &#160; &#160;# This is the normal return value, if no exception occurs.<br/>end &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# No rescue clause here, so propagate up to caller.<br/>
<b>160&#160;|&#160;Chapter 5:</b> <b>Statements and Control Structures</b><br/>
<hr/>
<a name=175></a>def defuse<br/>&#160; begin &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # The following code may fail with an exception.<br/>&#160; &#160; puts risky &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Try to invoke and print the return value.<br/>&#160; rescue RuntimeError =&gt; e &#160;# If we get an exception<br/>&#160; &#160; puts e.message &#160; &#160; &#160; &#160; &#160;# print the error message instead.<br/>&#160; end &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;&#160;<br/>end<br/>
defuse<br/>
An&#160;exception&#160;is&#160;raised&#160;in&#160;the&#160;method&#160;explode.&#160;That&#160;method&#160;has&#160;no&#160;rescue&#160;clause,&#160;so<br/>the&#160;exception&#160;propagates&#160;out&#160;to&#160;its&#160;caller,&#160;a&#160;method&#160;named&#160;risky.&#160;risky&#160;has&#160;a&#160;rescue<br/>clause,&#160;&#160;but&#160;&#160;it&#160;&#160;is&#160;&#160;only&#160;&#160;declared&#160;&#160;to&#160;&#160;handle&#160;&#160;TypeError&#160;&#160;exceptions,&#160;&#160;not&#160;&#160;RuntimeError<br/>exceptions.&#160;The&#160;exception&#160;propagates&#160;out&#160;through&#160;the&#160;lexical&#160;blocks&#160;of&#160;risky&#160;and&#160;then<br/>propagates&#160;up&#160;to&#160;the&#160;caller,&#160;a&#160;method&#160;named&#160;defuse.&#160;defuse&#160;has&#160;a&#160;rescue&#160;clause&#160;for<br/>RuntimeError&#160;&#160;exceptions,&#160;&#160;so&#160;&#160;control&#160;&#160;is&#160;&#160;transferred&#160;&#160;to&#160;&#160;this&#160;&#160;rescue&#160;&#160;clause&#160;&#160;and&#160;&#160;the<br/>exception stops propagating.<br/>Note&#160;that&#160;this&#160;code&#160;includes&#160;the&#160;use&#160;of&#160;an&#160;iterator&#160;(the&#160;Integer.times&#160;method)&#160;with&#160;an<br/>associated&#160;block.&#160;For&#160;simplicity,&#160;we&#160;said&#160;that&#160;the&#160;exception&#160;simply&#160;propagated&#160;outward<br/>through&#160;this&#160;lexical&#160;block.&#160;The&#160;truth&#160;is&#160;that&#160;blocks&#160;behave&#160;more&#160;like&#160;method&#160;invocations<br/>for&#160;the&#160;purposes&#160;of&#160;exception&#160;propagation.&#160;The&#160;exception&#160;propagates&#160;from&#160;the&#160;block<br/>up&#160;&#160;to&#160;&#160;the&#160;&#160;iterator&#160;&#160;that&#160;&#160;invoked&#160;&#160;the&#160;&#160;block.&#160;&#160;Predefined&#160;&#160;looping&#160;&#160;iterators&#160;&#160;like<br/>Integer.times&#160;do&#160;no&#160;exception&#160;handling&#160;of&#160;their&#160;own,&#160;so&#160;the&#160;exception&#160;propagates&#160;up<br/>the call stack from the&#160;times&#160;iterator to the&#160;risky&#160;method that invoked it.<br/>
<b>5.6.3.4 &#160;Exceptions during exception handling<br/></b>If an exception occurs during&#160;the execution of a&#160;rescue&#160;clause, the exception that was<br/>originally&#160;being&#160;handled&#160;is&#160;discarded,&#160;and&#160;the&#160;new&#160;exception&#160;propagates&#160;from&#160;the&#160;point<br/>at&#160;which&#160;it&#160;was&#160;raised.&#160;Note&#160;that&#160;this&#160;new&#160;exception&#160;cannot&#160;be&#160;handled&#160;by&#160;rescue&#160;clauses<br/>that follow the one in which it occurred.<br/>
<b>5.6.3.5 &#160;retry in a rescue clause<br/></b>When&#160;the&#160;retry&#160;statement&#160;is&#160;used&#160;within&#160;a&#160;rescue&#160;clause,&#160;it&#160;reruns&#160;the&#160;block&#160;of&#160;code&#160;to<br/>which the&#160;rescue&#160;is&#160;attached.&#160;When&#160;an&#160;exception&#160;is&#160;caused&#160;by&#160;a&#160;transient&#160;failure,&#160;such<br/>as an overloaded server, it might make sense to handle the exception by simply trying<br/>again.&#160;&#160;Many&#160;&#160;other&#160;&#160;exceptions,&#160;&#160;however,&#160;&#160;reflect&#160;&#160;programming&#160;&#160;errors&#160;&#160;(TypeError,<br/>ZeroDivisionError)&#160;or&#160;nontransient&#160;failures&#160;(EOFError&#160;or&#160;NoMemoryError).&#160;retry&#160;is&#160;not<br/>a suitable handling technique for these exceptions.<br/>Here&#160;is&#160;a&#160;simple&#160;example&#160;that&#160;uses&#160;retry&#160;in&#160;an&#160;attempt&#160;to&#160;wait&#160;for&#160;a&#160;network&#160;failure&#160;to<br/>be&#160;resolved.&#160;It&#160;tries&#160;to&#160;read&#160;the&#160;contents&#160;of&#160;a&#160;URL,&#160;and&#160;retries&#160;upon&#160;failure.&#160;It&#160;never&#160;tries<br/>more&#160;than&#160;four&#160;times&#160;in&#160;all,&#160;and&#160;it&#160;uses&#160;“exponential&#160;backoff”&#160;to&#160;increase&#160;the&#160;wait&#160;time<br/>between attempts:<br/>
<b>5.6 &#160;Exceptions and Exception Handling&#160;|&#160;161</b><br/>
<hr/>
<a name=176></a>require 'open-uri'<br/>
tries = 0 &#160; &#160; &#160; # How many times have we tried to read the URL<br/>begin &#160; &#160; &#160; &#160; &#160; # This is where a retry begins<br/>&#160; tries += 1 &#160; &#160;# Try to print out the contents of a URL<br/>&#160; open('http://www.example.com/') {|f| puts f.readlines }<br/>rescue OpenURI::HTTPError =&gt; e &#160;# If we get an HTTP error<br/>&#160; puts e.message &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Print the error message<br/>&#160; if (tries &lt; 4) &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# If we haven't tried 4 times yet...<br/>&#160; &#160; sleep(2**tries) &#160; &#160; &#160; &#160; &#160; &#160; # Wait for 2, 4, or 8 seconds<br/>&#160; &#160; retry &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # And then try again!<br/>&#160; end<br/>end<br/>
<b>5.6.4 &#160;The else Clause<br/></b>A&#160;begin&#160;statement&#160;may&#160;include&#160;an&#160;else&#160;clause&#160;after&#160;its&#160;rescue&#160;clauses.&#160;You&#160;might&#160;guess<br/>that&#160;the&#160;else&#160;clause&#160;is&#160;a&#160;catch-all&#160;rescue:&#160;that&#160;it&#160;handles&#160;any&#160;exception&#160;that&#160;does&#160;not<br/>match&#160;a&#160;previous&#160;rescue&#160;clause.&#160;This&#160;is&#160;not&#160;what&#160;else&#160;is&#160;for.&#160;The&#160;else&#160;clause&#160;is&#160;an<br/>alternative&#160;to&#160;the&#160;rescue&#160;clauses;&#160;it&#160;is&#160;used&#160;if&#160;none&#160;of&#160;the&#160;rescue&#160;clauses&#160;are&#160;needed.&#160;That<br/>is,&#160;the&#160;code&#160;in&#160;an&#160;else&#160;clause&#160;is&#160;executed&#160;if&#160;the&#160;code&#160;in&#160;the&#160;body&#160;of&#160;the&#160;begin&#160;statement<br/>runs to completion without exceptions.<br/>Putting&#160;code&#160;in&#160;an&#160;else&#160;clause&#160;is&#160;a&#160;lot&#160;like&#160;simply&#160;tacking&#160;it&#160;on&#160;to&#160;the&#160;end&#160;of&#160;the&#160;begin<br/>clause. The only difference is that when you use an&#160;else&#160;clause, any exceptions raised<br/>by that clause are not handled by the&#160;rescue&#160;statements.<br/>The&#160;use&#160;of&#160;an&#160;else&#160;clause&#160;is&#160;not&#160;particularly&#160;common&#160;in&#160;Ruby,&#160;but&#160;they&#160;can&#160;be&#160;stylis-<br/>tically&#160;useful&#160;to&#160;emphasize&#160;the&#160;difference&#160;between&#160;normal&#160;completion&#160;of&#160;a&#160;block&#160;of&#160;code<br/>and exceptional completion of a block of code.<br/>Note&#160;that&#160;it&#160;does&#160;not&#160;make&#160;sense&#160;to&#160;use&#160;an&#160;else&#160;clause&#160;without&#160;one&#160;or&#160;more&#160;rescue<br/>clauses.&#160;The&#160;Ruby&#160;interpreter&#160;allows&#160;it&#160;but&#160;issues&#160;a&#160;warning.&#160;No&#160;rescue&#160;clause&#160;may<br/>appear after an&#160;else&#160;clause.<br/>Finally,&#160;note&#160;that&#160;the&#160;code&#160;in&#160;an&#160;else&#160;clause&#160;is&#160;only&#160;executed&#160;if&#160;the&#160;code&#160;in&#160;the&#160;begin<br/>clause&#160;&#160;runs&#160;&#160;to&#160;&#160;completion&#160;&#160;and&#160;&#160;“falls&#160;&#160;off”&#160;&#160;the&#160;&#160;end.&#160;&#160;If&#160;&#160;an&#160;&#160;exception&#160;&#160;occurs,&#160;&#160;then&#160;&#160;the<br/>else&#160;clause&#160;will&#160;obviously&#160;not&#160;be&#160;executed.&#160;But&#160;break,&#160;return,&#160;next,&#160;and&#160;similar&#160;state-<br/>ments in the&#160;begin&#160;clause may also prevent the execution of the&#160;else&#160;clause.<br/>
<b>5.6.5 &#160;The ensure Clause<br/></b>A&#160;begin&#160;statement&#160;may&#160;have&#160;one&#160;final&#160;clause.&#160;The&#160;optional&#160;ensure&#160;clause,&#160;if&#160;it&#160;appears,<br/>must&#160;come&#160;after&#160;all&#160;rescue&#160;and&#160;else&#160;clauses.&#160;It&#160;may&#160;also&#160;be&#160;used&#160;by&#160;itself&#160;without&#160;any<br/>rescue&#160;or&#160;else&#160;clauses.<br/>
The&#160;ensure&#160;clause&#160;contains&#160;code&#160;that&#160;always&#160;runs,&#160;no&#160;matter&#160;what&#160;happens&#160;with&#160;the<br/>code following&#160;begin:<br/>
<b>162&#160;|&#160;Chapter 5:</b> <b>Statements and Control Structures</b><br/>
<hr/>
<a name=177></a>•&#160;If&#160;that&#160;code&#160;runs&#160;to&#160;completion,&#160;then&#160;control&#160;jumps&#160;to&#160;the&#160;else&#160;clause—if there is<br/>
one—and then to the&#160;ensure&#160;clause.<br/>
•&#160;If&#160;the&#160;code&#160;executes&#160;a&#160;return&#160;statement,&#160;then&#160;the&#160;execution&#160;skips&#160;the&#160;else&#160;clause<br/>
and jumps directly to the&#160;ensure&#160;clause before returning.<br/>
•&#160;If&#160;the&#160;code&#160;following&#160;begin&#160;raises&#160;an&#160;exception,&#160;then&#160;control&#160;jumps&#160;to&#160;the&#160;appro-<br/>
priate&#160;rescue&#160;clause, and then to the&#160;ensure&#160;clause.<br/>
•&#160;If&#160;there&#160;is&#160;no&#160;rescue&#160;clause,&#160;or&#160;if&#160;no&#160;rescue&#160;clause&#160;can&#160;handle&#160;the&#160;exception,&#160;then<br/>
control&#160;jumps&#160;directly&#160;to&#160;the&#160;ensure&#160;clause.&#160;The&#160;code&#160;in&#160;the&#160;ensure&#160;clause&#160;is&#160;exe-<br/>cuted&#160;before&#160;the&#160;exception&#160;propagates&#160;out&#160;to&#160;containing&#160;blocks&#160;or&#160;up&#160;the&#160;call&#160;stack.<br/>
The&#160;purpose&#160;of&#160;the&#160;ensure&#160;clause&#160;is&#160;to&#160;ensure&#160;that&#160;housekeeping&#160;details&#160;such&#160;as&#160;closing<br/>files,&#160;disconnecting&#160;database&#160;connections,&#160;and&#160;committing&#160;or&#160;aborting&#160;transactions&#160;get<br/>taken&#160;care&#160;of.&#160;It&#160;is&#160;a&#160;powerful&#160;control&#160;structure,&#160;and&#160;you&#160;should&#160;use&#160;it&#160;whenever&#160;you<br/>allocate&#160;a&#160;resource&#160;(such&#160;as&#160;a&#160;file&#160;handle&#160;or&#160;database&#160;connection)&#160;to&#160;ensure&#160;that&#160;proper<br/>deallocation or cleanup occurs.<br/>Note&#160;that&#160;ensure&#160;clauses&#160;complicate&#160;the&#160;propagation&#160;of&#160;exceptions.&#160;In&#160;our&#160;earlier&#160;ex-<br/>planation,&#160;we&#160;omitted&#160;any&#160;discussion&#160;of&#160;ensure&#160;clauses.&#160;When&#160;an&#160;exception&#160;propagates,<br/>it does not simply jump magically from the point where it is raised to the point where<br/>it&#160;is&#160;handled.&#160;There&#160;really&#160;is&#160;a&#160;propagation&#160;process.&#160;The&#160;Ruby&#160;interpreter&#160;searches&#160;out<br/>through&#160;containing&#160;blocks&#160;and&#160;up&#160;through&#160;the&#160;call&#160;stack.&#160;At&#160;each&#160;begin&#160;statement,&#160;it<br/>looks&#160;for&#160;a&#160;rescue&#160;clause&#160;that&#160;can&#160;handle&#160;the&#160;exception.&#160;And&#160;it&#160;looks&#160;for&#160;associated<br/>ensure&#160;clauses, and executes all of them that it passes through.<br/>
An&#160;ensure&#160;clause&#160;can&#160;cancel&#160;the&#160;propagation&#160;of&#160;an&#160;exception&#160;by&#160;initiating&#160;some&#160;other<br/>transfer&#160;of&#160;control.&#160;If&#160;an&#160;ensure&#160;clause&#160;raises&#160;a&#160;new&#160;exception,&#160;then&#160;that&#160;new&#160;exception<br/>propagates&#160;in&#160;place&#160;of&#160;the&#160;original.&#160;If&#160;an&#160;ensure&#160;clause&#160;includes&#160;a&#160;return&#160;statement,&#160;then<br/>
&#160;<br/>
exception&#160;propagation&#160;stops,&#160;and&#160;the&#160;containing&#160;method&#160;returns.&#160;Control&#160;statements<br/>such as&#160;break&#160;and&#160;next&#160;have&#160;similar&#160;effects:&#160;exception&#160;propagation&#160;is&#160;abandoned,&#160;and<br/>the specified control transfer takes place.<br/>An&#160;&#160;ensure&#160;&#160;clause&#160;&#160;also&#160;&#160;complicates&#160;&#160;the&#160;&#160;idea&#160;&#160;of&#160;&#160;a&#160;&#160;method&#160;&#160;return&#160;&#160;value.&#160;&#160;Although<br/>ensure&#160;clauses&#160;are&#160;usually&#160;used&#160;to&#160;ensure&#160;that&#160;code&#160;will&#160;run&#160;even&#160;if&#160;an&#160;exception&#160;occurs,<br/>they&#160;also&#160;work&#160;to&#160;ensure&#160;that&#160;code&#160;will&#160;be&#160;run&#160;before&#160;a&#160;method&#160;returns.&#160;If&#160;the&#160;body&#160;of<br/>a&#160;begin&#160;statement&#160;includes&#160;a&#160;return&#160;statement,&#160;the&#160;code&#160;in&#160;the&#160;ensure&#160;clause&#160;will&#160;be&#160;run<br/>before&#160;the&#160;method&#160;can&#160;actually&#160;return&#160;to&#160;its&#160;caller.&#160;Furthermore,&#160;if&#160;an&#160;ensure&#160;clause<br/>contains&#160;a&#160;return&#160;statement&#160;of&#160;its&#160;own,&#160;it&#160;will&#160;change&#160;the&#160;return&#160;value&#160;of&#160;the&#160;method.<br/>The following code, for example, returns the value&#160;2:<br/>
begin<br/>&#160; return 1 &#160; &#160; # Skip to the ensure clause before returning to caller<br/>ensure<br/>&#160; return 2 &#160; &#160; # Replace the return value with this new value<br/>end<br/>
Note&#160;that&#160;an&#160;ensure&#160;clause&#160;does&#160;not&#160;alter&#160;the&#160;return&#160;value&#160;of&#160;a&#160;method&#160;unless&#160;it&#160;explicitly<br/>uses a&#160;return&#160;statement. The following method, for example, returns&#160;1, not&#160;2:<br/>
<b>5.6 &#160;Exceptions and Exception Handling&#160;|&#160;163</b><br/>
<hr/>
<a name=178></a>def test<br/>&#160; begin return 1 ensure 2 end<br/>end<br/>
If a&#160;begin&#160;statement&#160;does&#160;not&#160;propagate&#160;an&#160;exception,&#160;then&#160;the&#160;value&#160;of&#160;the&#160;statement<br/>is&#160;the&#160;value&#160;of&#160;the&#160;last&#160;expression&#160;evaluated&#160;in&#160;the&#160;begin,&#160;rescue,&#160;or&#160;else&#160;clauses.&#160;The<br/>code&#160;in&#160;the&#160;ensure&#160;clause&#160;is&#160;guaranteed&#160;to&#160;run,&#160;but&#160;it&#160;does&#160;not&#160;affect&#160;the&#160;value&#160;of&#160;the<br/>begin&#160;statement.<br/>
<b>5.6.6 &#160;rescue with Method, Class, and Module Definitions<br/></b>Throughout&#160;&#160;this&#160;&#160;discussion&#160;&#160;of&#160;&#160;exception&#160;&#160;handling,&#160;&#160;we&#160;&#160;have&#160;&#160;described&#160;&#160;the&#160;&#160;rescue,<br/>else,&#160;and&#160;ensure&#160;keywords&#160;as&#160;clauses&#160;of&#160;a&#160;begin&#160;statement.&#160;In&#160;fact,&#160;they&#160;can&#160;also&#160;be&#160;used<br/>as&#160;clauses&#160;of&#160;the&#160;def&#160;statement&#160;(defines&#160;a&#160;method),&#160;the&#160;class&#160;statement&#160;(defines&#160;a&#160;class),<br/>and&#160;the&#160;module&#160;statement&#160;(defines&#160;a&#160;module).&#160;Method&#160;definitions&#160;are&#160;covered&#160;<a href="Rubys.html#189">in&#160;Chap-<br/>ter 6; class and module definitions are covered in Chapter 7.<br/></a>The&#160;following&#160;code&#160;is&#160;a&#160;sketch&#160;of&#160;a&#160;method&#160;definition&#160;with&#160;rescue,&#160;else,&#160;and&#160;ensure<br/>clauses:<br/>
def method_name(x)<br/>&#160; # The body of the method goes here.<br/>&#160; # Usually, the method body runs to completion without exceptions<br/>&#160; # and returns to its caller normally.<br/>rescue&#160;<br/>&#160; # Exception-handling code goes here.<br/>&#160; # If an exception is raised within the body of the method, or if<br/>&#160; # one of the methods it calls raises an exception, then control<br/>&#160; # jumps to this block.<br/>else<br/>&#160; # If no exceptions occur in the body of the method<br/>&#160; # then the code in this clause is executed.<br/>ensure<br/>&#160; # The code in this clause is executed no matter what happens in the<br/>&#160; # body of the method. It is run if the method runs to completion, if&#160;<br/>&#160; # it throws an exception, or if it executes a return statement.<br/>end<br/>
<b>5.6.7 &#160;rescue As a Statement Modifier<br/></b>In addition&#160;to&#160;its&#160;use&#160;as&#160;a&#160;clause,&#160;rescue&#160;can&#160;also&#160;be&#160;used&#160;as&#160;a&#160;statement&#160;modifier.&#160;Any<br/>statement&#160;can&#160;be&#160;followed&#160;by&#160;the&#160;keyword&#160;rescue&#160;and&#160;another&#160;statement.&#160;If&#160;the&#160;first<br/>statement&#160;raises&#160;an&#160;exception,&#160;the&#160;second&#160;statement&#160;is&#160;executed&#160;instead.&#160;For&#160;example:<br/>
# Compute factorial of x, or use 0 if the method raises an exception<br/>y = factorial(x) rescue 0<br/>
This is equivalent to:<br/>
y = begin<br/>&#160; &#160; &#160; factorial(x)<br/>&#160; &#160; rescue<br/>
<b>164&#160;|&#160;Chapter 5:</b> <b>Statements and Control Structures</b><br/>
<hr/>
<a name=179></a>&#160; &#160; &#160; 0<br/>&#160; &#160; end<br/>
The&#160;advantage&#160;of&#160;the&#160;statement&#160;modifier&#160;syntax&#160;is&#160;that&#160;the&#160;begin&#160;and&#160;end&#160;keywords&#160;are<br/>not&#160;required.&#160;When&#160;used&#160;in&#160;this&#160;way,&#160;rescue&#160;must&#160;be&#160;used&#160;alone,&#160;with&#160;no&#160;exception<br/>class&#160;&#160;names&#160;&#160;and&#160;&#160;no&#160;&#160;variable&#160;&#160;name.&#160;&#160;A&#160;&#160;rescue&#160;&#160;modifier&#160;&#160;handles&#160;&#160;any&#160;&#160;StandardError<br/>exception&#160;but&#160;does&#160;not&#160;handle&#160;exceptions&#160;of&#160;other&#160;types.&#160;Unlike&#160;if&#160;and&#160;while&#160;modifiers,<br/>the&#160;rescue&#160;modifier&#160;has&#160;higher&#160;precedence&#160;<a href="Rubys.html#116">(see&#160;Table 4-2</a>&#160;in&#160;the&#160;previous&#160;chapter)&#160;than<br/>assignment&#160;operators.&#160;This&#160;means&#160;that&#160;it&#160;applies&#160;only&#160;to&#160;the&#160;righthand&#160;side&#160;of&#160;an&#160;as-<br/>signment&#160;(like&#160;the&#160;example&#160;above)&#160;rather&#160;than&#160;to&#160;the&#160;assignment&#160;expression&#160;as&#160;a&#160;whole.<br/>
<b>5.7 &#160;BEGIN and END<br/></b>BEGIN&#160;and&#160;ENDare&#160;reserved&#160;words&#160;in&#160;Ruby&#160;that&#160;declare&#160;code&#160;to&#160;be&#160;executed&#160;at&#160;the&#160;very<br/>beginning and very end of a Ruby program. (Note that&#160;BEGIN&#160;and&#160;END&#160;in capital letters<br/>are&#160;completely&#160;different&#160;from&#160;begin&#160;and&#160;end&#160;in&#160;lowercase.)&#160;If&#160;there&#160;is&#160;more&#160;than&#160;one<br/>BEGIN&#160;statement&#160;in&#160;a&#160;program,&#160;they&#160;are&#160;executed&#160;in&#160;the&#160;order&#160;in&#160;which&#160;the&#160;interpreter<br/>encounters&#160;them.&#160;If&#160;there&#160;is&#160;more&#160;than&#160;one&#160;END&#160;statement,&#160;they&#160;are&#160;executed&#160;in&#160;the<br/>reverse&#160;of&#160;the&#160;order&#160;in&#160;which&#160;they&#160;are&#160;encountered—that&#160;is,&#160;the&#160;first&#160;one&#160;is&#160;executed<br/>last.&#160;These&#160;statements&#160;are&#160;not&#160;commonly&#160;used&#160;in&#160;Ruby.&#160;They&#160;are&#160;inherited&#160;from&#160;Perl,<br/>which in turn inherited them from the awk text-processing language.<br/>
BEGIN&#160;and&#160;END&#160;must&#160;be&#160;followed&#160;by&#160;an&#160;open&#160;curly&#160;brace,&#160;any&#160;amount&#160;of&#160;Ruby&#160;code,&#160;and<br/>a&#160;close&#160;curly&#160;brace.&#160;The&#160;curly&#160;braces&#160;are&#160;required;&#160;do&#160;and&#160;end&#160;are&#160;not&#160;allowed&#160;here.&#160;For<br/>example:<br/>
BEGIN {<br/>&#160; # Global initialization code goes here<br/>}<br/>
END {<br/>&#160; # Global shutdown code goes here<br/>}<br/>
The&#160;BEGIN&#160;and&#160;END&#160;statements&#160;are&#160;different&#160;from&#160;each&#160;other&#160;in&#160;subtle&#160;ways.&#160;BEGIN&#160;state-<br/>ments&#160;are&#160;executed&#160;before&#160;anything&#160;else,&#160;including&#160;any&#160;surrounding&#160;code.&#160;This&#160;means<br/>that&#160;they&#160;define&#160;a&#160;local&#160;variable&#160;scope&#160;that&#160;is&#160;completely&#160;separate&#160;from&#160;the&#160;surrounding<br/>code.&#160;It&#160;only&#160;really&#160;makes&#160;sense&#160;to&#160;put&#160;BEGIN&#160;statements&#160;in&#160;top-level&#160;code;&#160;a&#160;BEGIN&#160;within<br/>a&#160;conditional&#160;or&#160;loop&#160;will&#160;be&#160;executed&#160;without&#160;regard&#160;for&#160;the&#160;conditions&#160;that&#160;surround<br/>it. Consider this code:<br/>
if (false)&#160;<br/>&#160; BEGIN {<br/>&#160; &#160; puts &#34;if&#34;; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # This will be printed<br/>&#160; &#160; a = 4; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # This variable only defined here<br/>&#160; }<br/>else<br/>&#160; BEGIN { puts &#34;else&#34; } &#160; &#160; &#160; &#160; &#160;# Also printed<br/>end<br/>
<b>5.7 &#160;BEGIN and END&#160;|&#160;165</b><br/>
<hr/>
<a name=180></a>10.times {BEGIN { puts &#34;loop&#34; }} # Only printed once<br/>
The&#160;code&#160;associated&#160;with&#160;all&#160;three&#160;BEGIN&#160;statements&#160;will&#160;be&#160;executed&#160;once,&#160;and&#160;only<br/>once,&#160;&#160;regardless&#160;&#160;of&#160;&#160;the&#160;&#160;context&#160;&#160;in&#160;&#160;which&#160;&#160;it&#160;&#160;appears.&#160;&#160;Variables&#160;&#160;defined&#160;&#160;within&#160;&#160;BEGIN<br/>blocks&#160;will&#160;not&#160;be&#160;visible&#160;outside&#160;the&#160;block,&#160;and&#160;no&#160;variables&#160;outside&#160;the&#160;block&#160;will&#160;have<br/>been defined yet.<br/>
END&#160;statements&#160;are&#160;different.&#160;They&#160;are&#160;executed&#160;during&#160;normal&#160;program&#160;execution,&#160;so<br/>they&#160;share&#160;local&#160;variables&#160;with&#160;the&#160;surrounding&#160;code.&#160;If&#160;an&#160;END&#160;statement&#160;is&#160;within&#160;a<br/>conditional&#160;that&#160;is&#160;not&#160;executed,&#160;then&#160;the&#160;code&#160;associated&#160;with&#160;it&#160;is&#160;never&#160;registered&#160;for<br/>execution&#160;at&#160;program&#160;termination.&#160;If&#160;an&#160;END&#160;statement&#160;is&#160;within&#160;a&#160;loop&#160;and&#160;is&#160;executed<br/>more than once, then the code associated with it is still only registered once:<br/>
a = 4;<br/>if (true)&#160;<br/>&#160; END { &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# This END is executed<br/>&#160; &#160; puts &#34;if&#34;; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # This code is registered<br/>&#160; &#160; puts a &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # The variable is visible; prints &#34;4&#34;<br/>&#160; }<br/>else<br/>&#160; END { puts &#34;else&#34; } &#160; &#160; &#160; &#160; &#160;# This is not executed<br/>end<br/>10.times {END { puts &#34;loop&#34; }} # Only executed once<br/>
The&#160;Kernel&#160;method&#160;at_exit&#160;provides&#160;an&#160;alternative&#160;to&#160;the&#160;END&#160;statement;&#160;it&#160;registers&#160;a<br/>block&#160;of&#160;code&#160;to&#160;be&#160;executed&#160;just&#160;before&#160;the&#160;interpreter&#160;exits.&#160;As&#160;with&#160;END&#160;blocks,&#160;the<br/>code associated with the first&#160;at_exit&#160;call&#160;will&#160;be&#160;executed&#160;last.&#160;If&#160;the&#160;at_exit&#160;method<br/>is&#160;called&#160;multiple&#160;times&#160;within&#160;a&#160;loop,&#160;then&#160;the&#160;block&#160;associated&#160;with&#160;it&#160;will&#160;be&#160;executed<br/>multiple times when the interpreter exits.<br/>
<b>5.8 &#160;Threads, Fibers, and Continuations<br/></b>This&#160;&#160;section&#160;&#160;introduces&#160;&#160;threads,&#160;&#160;which&#160;&#160;are&#160;&#160;Ruby’s&#160;&#160;control&#160;&#160;structure&#160;&#160;for&#160;&#160;concurrent<br/>execution,&#160;&#160;and&#160;&#160;also&#160;&#160;two&#160;&#160;more&#160;&#160;esoteric&#160;&#160;control&#160;&#160;structures,&#160;&#160;called&#160;&#160;fibers&#160;&#160;and<br/>continuations.<br/>
<b>5.8.1 &#160;Threads for Concurrency<br/></b>A&#160;<i>thread&#160;of&#160;execution</i>&#160;is&#160;a&#160;sequence&#160;of&#160;Ruby&#160;statements&#160;that&#160;run&#160;(or&#160;appear&#160;to&#160;run)&#160;in<br/>parallel with the main sequence of statements that the interpreter is running. Threads<br/>are&#160;represented&#160;by&#160;Thread&#160;objects,&#160;but&#160;they&#160;can&#160;also&#160;be&#160;thought&#160;of&#160;as&#160;control&#160;structures<br/>for&#160;concurrency.&#160;Concurrent&#160;programming&#160;in&#160;Ruby&#160;is&#160;covered&#160;in&#160;detail&#160;in&#160;<a href="Rubys.html#387">§9.9.&#160;</a>This<br/>section is just a simple overview that shows how to create threads.<br/>Ruby’s&#160;use&#160;of&#160;blocks&#160;makes&#160;it&#160;very&#160;easy&#160;to&#160;create&#160;new&#160;threads.&#160;Simply&#160;call&#160;Thread.new<br/>and&#160;associate&#160;a&#160;block&#160;with&#160;it.&#160;A&#160;new&#160;thread&#160;of&#160;execution&#160;will&#160;be&#160;created&#160;and&#160;will&#160;start<br/>running&#160;the&#160;code&#160;in&#160;the&#160;block.&#160;Meanwhile,&#160;the&#160;original&#160;thread&#160;will&#160;return&#160;from&#160;the<br/>
<b>166&#160;|&#160;Chapter 5:</b> <b>Statements and Control Structures</b><br/>
<hr/>
<a name=181></a>Thread.new&#160;&#160;call&#160;&#160;and&#160;&#160;will&#160;&#160;continue&#160;&#160;with&#160;&#160;the&#160;&#160;following&#160;&#160;statement.&#160;&#160;The&#160;&#160;newly&#160;&#160;created<br/>thread will exit when the block exits. The return value of the block becomes available<br/>through&#160;the&#160;value&#160;method&#160;of&#160;the&#160;Thread&#160;object.&#160;(If&#160;you&#160;call&#160;this&#160;method&#160;before&#160;the&#160;thread<br/>has completed, the caller will block until the thread returns a value.)<br/>The&#160;following&#160;code&#160;shows&#160;how&#160;you&#160;might&#160;use&#160;threads&#160;to&#160;read&#160;the&#160;contents&#160;of&#160;multiple<br/>files in parallel:<br/>
# This method expects an array of filenames.<br/># It returns an array of strings holding the content of the named files.<br/># The method creates one thread for each named file.<br/>def readfiles(filenames)<br/>&#160; # Create an array of threads from the array of filenames.<br/>&#160; # Each thread starts reading a file.<br/>&#160; threads = filenames.map do |f|<br/>&#160; &#160; Thread.new { File.read(f) }<br/>&#160; end<br/>
&#160; # Now create an array of file contents by calling the value<br/>&#160; # method of each thread. This method blocks, if necessary,<br/>&#160; # until the thread exits with a value.<br/>&#160; threads.map {|t| t.value }<br/>end<br/>
<a href="Rubys.html#387">See §9.9 for much more about threads and concurrency in Ruby.</a><br/>
<b>5.8.2 &#160;Fibers for Coroutines<br/></b>Ruby 1.9 introduces&#160;a&#160;control&#160;structure&#160;known&#160;as&#160;a&#160;<i>fiber</i>&#160;and&#160;represented&#160;by&#160;an&#160;object<br/>of&#160;class&#160;Fiber.&#160;The&#160;name&#160;“fiber”&#160;has&#160;been&#160;used&#160;elsewhere&#160;for&#160;a&#160;kind&#160;of&#160;lightweight<br/>thread,&#160;but&#160;Ruby’s&#160;fibers&#160;are&#160;better&#160;described&#160;as&#160;<i>coroutines</i>&#160;or,&#160;more&#160;accurately,&#160;<i>semi-<br/>coroutines</i>.&#160;The&#160;most&#160;common&#160;use&#160;for&#160;coroutines&#160;is&#160;to&#160;implement&#160;<i>generators</i>:&#160;objects<br/>that&#160;can&#160;compute&#160;a&#160;partial&#160;result,&#160;yield&#160;the&#160;result&#160;back&#160;to&#160;the&#160;caller,&#160;and&#160;save&#160;the&#160;state<br/>of&#160;the&#160;computation&#160;so&#160;that&#160;the&#160;caller&#160;can&#160;resume&#160;that&#160;computation&#160;to&#160;obtain&#160;the&#160;next<br/>result.&#160;In&#160;Ruby,&#160;the&#160;Fiber&#160;class&#160;is&#160;used&#160;to&#160;enable&#160;the&#160;automatic&#160;conversion&#160;of&#160;internal<br/>iterators, such as the&#160;each&#160;method, into enumerators or external iterators.<br/>Note&#160;that&#160;fibers&#160;are&#160;an&#160;advanced&#160;and&#160;relatively&#160;obscure&#160;control&#160;structure;&#160;the&#160;majority<br/>of&#160;Ruby&#160;programmers&#160;will&#160;never&#160;need&#160;to&#160;use&#160;the&#160;Fiber&#160;class&#160;directly.&#160;If&#160;you&#160;have&#160;never<br/>programed&#160;&#160;with&#160;&#160;coroutines&#160;&#160;or&#160;&#160;generators&#160;&#160;before,&#160;&#160;you&#160;&#160;may&#160;&#160;find&#160;&#160;them&#160;&#160;difficult&#160;&#160;to<br/>understand&#160;at&#160;first.&#160;If&#160;so,&#160;study&#160;the&#160;examples&#160;carefully&#160;and&#160;try&#160;out&#160;some&#160;examples&#160;of<br/>your own.<br/>A&#160;fiber&#160;has&#160;a&#160;body&#160;of&#160;code&#160;like&#160;a&#160;thread&#160;does.&#160;Create&#160;a&#160;fiber&#160;with&#160;Fiber.new,&#160;and&#160;associate<br/>a&#160;block&#160;with&#160;it&#160;to&#160;specify&#160;the&#160;code&#160;that&#160;the&#160;fiber&#160;is&#160;to&#160;run.&#160;Unlike&#160;a&#160;thread,&#160;the&#160;body&#160;of<br/>a&#160;fiber&#160;does&#160;not&#160;start&#160;executing&#160;right&#160;away.&#160;To&#160;run&#160;a&#160;fiber,&#160;call&#160;the&#160;resume&#160;method&#160;of<br/>the&#160;Fiber&#160;object&#160;that&#160;represents&#160;it.&#160;The&#160;first&#160;time&#160;resume&#160;is&#160;called&#160;on&#160;a&#160;fiber,&#160;control&#160;is<br/>transferred&#160;to&#160;the&#160;beginning&#160;of&#160;the&#160;fiber&#160;body.&#160;That&#160;fiber&#160;then&#160;runs&#160;until&#160;it&#160;reaches&#160;the<br/>end&#160;of&#160;the&#160;body,&#160;or&#160;until&#160;it&#160;executes&#160;the&#160;class&#160;method&#160;Fiber.yield.&#160;The&#160;Fiber.yield<br/>
<b>5.8 &#160;Threads, Fibers, and Continuations&#160;|&#160;167</b><br/>
<hr/>
<a name=182></a>method&#160;transfers&#160;control&#160;back&#160;to&#160;the&#160;caller&#160;and&#160;makes&#160;the&#160;call&#160;to&#160;resume&#160;return. It also<br/>saves&#160;the&#160;state&#160;of&#160;the&#160;fiber,&#160;so&#160;that&#160;the&#160;next&#160;call&#160;to&#160;resume&#160;makes&#160;the&#160;fiber&#160;pick&#160;up&#160;where<br/>it left off. Here is a simple example:<br/>
f = Fiber.new { &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Line &#160;1: Create a new fiber<br/>&#160; puts &#34;Fiber says Hello&#34; &#160; &#160;# Line &#160;2:<br/>&#160; Fiber.yield &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Line &#160;3: goto line 9&#160;<br/>&#160; puts &#34;Fiber says Goodbye&#34; &#160;# Line &#160;4:<br/>} &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Line &#160;5: goto line 11<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Line &#160;6:<br/>puts &#34;Caller says Hello&#34; &#160; &#160; # Line &#160;7:<br/>f.resume &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Line &#160;8: goto line 2<br/>puts &#34;Caller says Goodbye&#34; &#160; # Line &#160;9:<br/>f.resume &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Line 10: goto line 4<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Line 11:<br/>
The&#160;body&#160;of&#160;the&#160;fiber&#160;does&#160;not&#160;run&#160;when&#160;it&#160;is&#160;first&#160;created,&#160;so&#160;this&#160;code&#160;creates&#160;a&#160;fiber<br/>but&#160;does&#160;not&#160;produce&#160;any&#160;output&#160;until&#160;it&#160;reaches&#160;line&#160;7.&#160;The&#160;resume&#160;and&#160;Fiber.yield<br/>calls&#160;then&#160;transfer&#160;control&#160;back&#160;and&#160;forth&#160;so&#160;that&#160;the&#160;messages&#160;from&#160;the&#160;fiber&#160;and&#160;the<br/>caller are interleaved. The code produces the following output:<br/>
Caller says Hello<br/>Fiber says Hello<br/>Caller says Goodbye<br/>Fiber says Goodbye<br/>
It&#160;&#160;is&#160;&#160;worth&#160;&#160;noting&#160;&#160;here&#160;&#160;that&#160;&#160;the&#160;&#160;“yielding”&#160;&#160;performed&#160;&#160;by&#160;&#160;Fiber.yield&#160;&#160;is&#160;&#160;completely<br/>different&#160;than&#160;the&#160;yielding&#160;performed&#160;by&#160;the&#160;yield&#160;statement.&#160;Fiber.yield&#160;yields&#160;control<br/>from&#160;the&#160;current&#160;fiber&#160;back&#160;to&#160;the&#160;caller&#160;that&#160;invoked&#160;it.&#160;The&#160;yield&#160;statement,&#160;on&#160;the<br/>other&#160;hand,&#160;yields&#160;control&#160;from&#160;an&#160;iterator&#160;method&#160;to&#160;the&#160;block&#160;associated&#160;with&#160;the<br/>method.<br/>
<b>5.8.2.1 &#160;Fiber arguments and return values<br/></b>Fibers&#160;and&#160;their&#160;callers&#160;can&#160;exchange&#160;data&#160;through&#160;the&#160;arguments&#160;and&#160;return&#160;values&#160;of<br/>resume&#160;&#160;and&#160;&#160;yield.&#160;&#160;The&#160;&#160;arguments&#160;&#160;to&#160;&#160;the&#160;&#160;first&#160;&#160;call&#160;&#160;to&#160;&#160;resume&#160;&#160;are&#160;&#160;passed&#160;&#160;to&#160;&#160;the&#160;&#160;block<br/>associated&#160;&#160;with&#160;&#160;the&#160;&#160;fiber:&#160;&#160;they&#160;&#160;become&#160;&#160;the&#160;&#160;values&#160;&#160;of&#160;&#160;the&#160;&#160;block&#160;&#160;parameters.&#160;&#160;On<br/>subsequent&#160;calls,&#160;the&#160;arguments&#160;to&#160;resume&#160;become&#160;the&#160;return&#160;value&#160;of&#160;Fiber.yield.&#160;<br/>Conversely,&#160;any&#160;arguments&#160;to&#160;Fiber.yield&#160;become&#160;the&#160;return&#160;value&#160;of&#160;resume.&#160;And<br/>when&#160;the&#160;block&#160;exits,&#160;the&#160;value&#160;of&#160;the&#160;last&#160;expression&#160;evaluated&#160;also&#160;becomes&#160;the&#160;return<br/>value of&#160;resume. The following code demonstrates this:<br/>
f = Fiber.new do |message|<br/>&#160; puts &#34;Caller said: #{message}&#34;<br/>&#160; message2 = Fiber.yield(&#34;Hello&#34;) &#160; &#160;# &#34;Hello&#34; returned by first resume<br/>&#160; puts &#34;Caller said: #{message2}&#34;<br/>&#160; &#34;Fine&#34; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # &#34;Fine&#34; returned by second resume<br/>end<br/>
response = f.resume(&#34;Hello&#34;) &#160; &#160; &#160; &#160; # &#34;Hello&#34; passed to block&#160;<br/>puts &#34;Fiber said: #{response}&#34;<br/>
<b>168&#160;|&#160;Chapter 5:</b> <b>Statements and Control Structures</b><br/>
<hr/>
<a name=183></a>response2 = f.resume(&#34;How are you?&#34;) # &#34;How are you?&#34; returned by Fiber.yield<br/>puts &#34;Fiber said: #{response2}&#34;<br/>
The&#160;caller&#160;passes&#160;two&#160;messages&#160;to&#160;the&#160;fiber,&#160;and&#160;the&#160;fiber&#160;returns&#160;two&#160;responses&#160;to&#160;the<br/>caller. It prints:<br/>
Caller said: Hello<br/>Fiber said: Hello<br/>Caller said: How are you?<br/>Fiber said: Fine<br/>
In&#160;the&#160;caller’s&#160;code,&#160;the&#160;messages&#160;are&#160;always&#160;arguments&#160;to&#160;resume,&#160;and&#160;the&#160;responses<br/>are&#160;always&#160;the&#160;return&#160;value&#160;of&#160;that&#160;method.&#160;In&#160;the&#160;body&#160;of&#160;the&#160;fiber,&#160;all&#160;messages&#160;but<br/>the&#160;first&#160;are&#160;received&#160;as&#160;the&#160;return&#160;value&#160;of&#160;Fiber.yield,&#160;and&#160;all&#160;responses&#160;but&#160;the&#160;last<br/>are&#160;passed&#160;as&#160;arguments&#160;to&#160;Fiber.yield.&#160;The&#160;first&#160;message&#160;is&#160;received&#160;through&#160;block<br/>parameters, and the last response is the return value of the block itself.<br/>
<b>5.8.2.2 &#160;Implementing generators with fibers<br/></b>The&#160;fiber&#160;examples&#160;shown&#160;so&#160;far&#160;have&#160;not&#160;been&#160;terribly&#160;realistic.&#160;Here&#160;we&#160;demonstrate<br/>some&#160;more&#160;typical&#160;uses.&#160;First,&#160;we&#160;write&#160;a&#160;Fibonacci&#160;number&#160;generator—a&#160;Fiber&#160;object<br/>that returns successive members of the Fibonacci sequence on each call to&#160;resume:<br/>
# Return a Fiber to compute Fibonacci numbers<br/>def fibonacci_generator(x0,y0) &#160; # Base the sequence on x0,y0<br/>&#160; Fiber.new do<br/>&#160; &#160; x,y = x0, y0 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Initialize x and y<br/>&#160; &#160; loop do &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# This fiber runs forever<br/>&#160; &#160; &#160; Fiber.yield y &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Yield the next number in the sequence<br/>&#160; &#160; &#160; x,y = y,x+y &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Update x and y<br/>&#160; &#160; end<br/>&#160; end<br/>end<br/>
g = fibonacci_generator(0,1) &#160; &#160; # Create a generator&#160;<br/>10.times { print g.resume, &#34; &#34; } # And use it<br/>
The code above prints the first 10 Fibonacci numbers:<br/>
1 1 2 3 5 8 13 21 34 55<br/>
Because&#160;Fiber&#160;is&#160;a&#160;confusing&#160;control&#160;structure,&#160;we&#160;might&#160;prefer&#160;to&#160;hide&#160;its&#160;API&#160;when<br/>writing&#160;generators.&#160;Here&#160;is&#160;another&#160;version&#160;of&#160;a&#160;Fibonacci&#160;number&#160;generator.&#160;It&#160;defines<br/>its own class and implements the same&#160;next&#160;and&#160;rewind&#160;API that enumerators do:<br/>
class FibonacciGenerator<br/>&#160; def initialize<br/>&#160; &#160; @x,@y = 0,1<br/>&#160; &#160; @fiber = Fiber.new do<br/>&#160; &#160; &#160; loop do&#160;<br/>&#160; &#160; &#160; &#160; @x,@y = @y, @x+@y<br/>&#160; &#160; &#160; &#160; Fiber.yield @x<br/>&#160; &#160; &#160; end<br/>&#160; &#160; end<br/>&#160; end<br/>
<b>5.8 &#160;Threads, Fibers, and Continuations&#160;|&#160;169</b><br/>
<hr/>
<a name=184></a>&#160; def next &#160; &#160; &#160; &#160; &#160; # Return the next Fibonacci number<br/>&#160; &#160; @fiber.resume<br/>&#160; end<br/>
&#160; def rewind &#160; &#160; &#160; &#160; # Restart the sequence<br/>&#160; &#160; @x,@y = 0,1<br/>&#160; end<br/>end<br/>
g = FibonacciGenerator.new &#160; &#160; &#160;# Create a generator<br/>10.times { print g.next, &#34; &#34; } &#160;# Print first 10 numbers<br/>g.rewind; puts &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Start over, on a new line<br/>10.times { print g.next, &#34; &#34; } &#160;# Print the first 10 again<br/>
Note&#160;&#160;that&#160;&#160;we&#160;&#160;can&#160;&#160;make&#160;&#160;this&#160;&#160;FibonacciGenerator&#160;&#160;class&#160;&#160;Enumerable&#160;&#160;by&#160;&#160;including&#160;&#160;the<br/>Enumerable&#160;&#160;module&#160;&#160;and&#160;&#160;adding&#160;&#160;the&#160;&#160;following&#160;&#160;each&#160;&#160;method&#160;&#160;(which&#160;&#160;we&#160;&#160;first&#160;&#160;used&#160;&#160;in<br/><a href="Rubys.html#151">§5.3.5):</a><br/>
def each<br/>&#160; &#160;loop { yield self.next }<br/>end<br/>
Conversely, suppose we have an&#160;Enumerable&#160;object&#160;and&#160;want&#160;to&#160;make&#160;an&#160;enumerator-<br/>style generator out of it. We can use this class:<br/>
class Generator<br/>&#160; def initialize(enumerable)<br/>&#160; &#160; @enumerable = enumerable &#160;# Remember the enumerable object<br/>&#160; &#160; create_fiber &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Create a fiber to enumerate it<br/>&#160; end<br/>
&#160; def next &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Return the next element<br/>&#160; &#160; @fiber.resume &#160; &#160; &#160; &#160; &#160; &#160; # by resuming the fiber<br/>&#160; end<br/>
&#160; def rewind &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Start the enumeration over<br/>&#160; &#160; create_fiber &#160; &#160; &#160; &#160; &#160; &#160; &#160;# by creating a new fiber<br/>&#160; end<br/>
&#160; private<br/>&#160; def create_fiber &#160; &#160; &#160; &#160; &#160; &#160;# Create the fiber that does the enumeration<br/>&#160; &#160; @fiber = Fiber.new do &#160; &#160; # Create a new fiber<br/>&#160; &#160; &#160; @enumerable.each do |x| # Use the each method<br/>&#160; &#160; &#160; &#160; Fiber.yield(x) &#160; &#160; &#160; &#160;# But pause during enumeration to return values<br/>&#160; &#160; &#160; end &#160; &#160; &#160; &#160; &#160; &#160; &#160;<br/>&#160; &#160; &#160; raise StopIteration &#160; &#160; # Raise this when we're out of values<br/>&#160; &#160; end<br/>&#160; end<br/>end<br/>
g = Generator.new(1..10) &#160;# Create a generator from an Enumerable like this<br/>loop { print g.next } &#160; &#160; # And use it like an enumerator like this<br/>g.rewind &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Start over like this<br/>g = (1..10).to_enum &#160; &#160; &#160; # The to_enum method does the same thing<br/>loop { print g.next }<br/>
<b>170&#160;|&#160;Chapter 5:</b> <b>Statements and Control Structures</b><br/>
<hr/>
<a name=185></a>Although&#160;it&#160;is&#160;useful&#160;to&#160;study&#160;the&#160;implementation&#160;of&#160;this&#160;Generator&#160;class,&#160;the&#160;class&#160;itself<br/>doesn’t provide any functionality over that provided by the&#160;to_enum&#160;method.<br/>
<b>5.8.2.3 &#160;Advanced fiber features<br/></b>The&#160;fiber&#160;module&#160;in&#160;the&#160;standard&#160;library&#160;enables&#160;additional,&#160;more&#160;powerful&#160;features<br/>of the fibers. To use these features, you must:<br/>
require 'fiber'<br/>
However,&#160;you&#160;should&#160;avoid&#160;using&#160;these&#160;additional&#160;features&#160;wherever&#160;possible,&#160;because:<br/>
•&#160;They&#160;&#160;are&#160;&#160;not&#160;&#160;supported&#160;&#160;by&#160;&#160;all&#160;&#160;implementations.&#160;&#160;JRuby,&#160;&#160;for&#160;&#160;example,&#160;&#160;cannot<br/>
support them on current Java VMs.<br/>
•&#160;They are so powerful that misusing them can crash the Ruby VM.<br/>
The core features of the&#160;Fiber&#160;class implement semicoroutines. These are not true co-<br/>routines&#160;because&#160;there&#160;is&#160;a&#160;fundamental&#160;asymmetry&#160;between&#160;the&#160;caller&#160;and&#160;the&#160;fiber:<br/>the&#160;caller&#160;uses&#160;resume&#160;and&#160;the&#160;fiber&#160;uses&#160;yield.&#160;If&#160;you&#160;require&#160;the&#160;fiber&#160;library,&#160;however,<br/>the&#160;Fiber&#160;class&#160;gets&#160;a&#160;transfer&#160;method&#160;that&#160;allows&#160;any&#160;fiber&#160;to&#160;transfer&#160;control&#160;to&#160;any<br/>other&#160;fiber.&#160;Here&#160;is&#160;an&#160;example&#160;in&#160;which&#160;two&#160;fibers&#160;use&#160;the&#160;transfer&#160;method&#160;to&#160;pass<br/>control (and values) back and forth:<br/>
require 'fiber'<br/>
f = g = nil<br/>
f = Fiber.new {|x| &#160; &#160; &#160; &#160;# 1:&#160;<br/>&#160; puts &#34;f1: #{x}&#34; &#160; &#160; &#160; &#160; # 2: print &#34;f1: 1&#34;<br/>&#160; x = g.transfer(x+1) &#160; &#160; # 3: pass 2 to line 8<br/>&#160; puts &#34;f2: #{x}&#34; &#160; &#160; &#160; &#160; # 4: print &#34;f2: 3&#34;<br/>&#160; x = g.transfer(x+1) &#160; &#160; # 5: return 4 to line 10<br/>&#160; puts &#34;f3: #{x}&#34; &#160; &#160; &#160; &#160; # 6: print &#34;f3: 5&#34;<br/>&#160; x + 1 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # 7: return 6 to line 13<br/>}<br/>g = Fiber.new {|x| &#160; &#160; &#160; &#160;# 8:<br/>&#160; puts &#34;g1: #{x}&#34; &#160; &#160; &#160; &#160; # 9: print &#34;g1: 2&#34;<br/>&#160; x = f.transfer(x+1) &#160; &#160; #10: return 3 to line 3<br/>&#160; puts &#34;g2: #{x}&#34; &#160; &#160; &#160; &#160; #11: print &#34;g2: 4&#34;<br/>&#160; x = f.transfer(x+1) &#160; &#160; #12: return 5 to line 5<br/>}<br/>puts f.transfer(1) &#160; &#160; &#160; &#160;#13: pass 1 to line 1<br/>
This code produces the following output:<br/>
f1: 1<br/>g1: 2<br/>f2: 3<br/>g2: 4<br/>f3: 5<br/>6<br/>
You&#160;will&#160;probably&#160;never&#160;need&#160;to&#160;use&#160;this&#160;transfer&#160;method,&#160;but&#160;its&#160;existence&#160;helps&#160;ex-<br/>plain&#160;the&#160;name&#160;“fiber.”&#160;Fibers&#160;can&#160;be&#160;thought&#160;of&#160;as&#160;independent&#160;paths&#160;of&#160;execution<br/>
<b>5.8 &#160;Threads, Fibers, and Continuations&#160;|&#160;171</b><br/>
<hr/>
<a name=186></a>within&#160;a&#160;single&#160;thread&#160;of&#160;execution.&#160;Unlike&#160;threads,&#160;however,&#160;there&#160;is&#160;no&#160;scheduler&#160;to<br/>transfer&#160;control&#160;among&#160;fibers;&#160;fibers&#160;must&#160;explicitly&#160;schedule&#160;themselves&#160;with&#160;transfer.<br/>In addition to the&#160;transfer&#160;method, the&#160;fiber&#160;library also defines an instance method<br/>alive?,&#160;to&#160;determine&#160;if&#160;the&#160;body&#160;of&#160;a&#160;fiber&#160;is&#160;still&#160;running,&#160;and&#160;a&#160;class&#160;method&#160;current,<br/>to return the&#160;Fiber&#160;object that currently has control.<br/>
<b>5.8.3 &#160;Continuations<br/></b>A&#160;<i>continuation</i>&#160;is another&#160;&#160;complex&#160;and&#160;obscure&#160;control&#160;structure&#160;that&#160;most&#160;program-<br/>mers&#160;&#160;will&#160;&#160;never&#160;&#160;need&#160;&#160;to&#160;&#160;use.&#160;&#160;A&#160;&#160;continuation&#160;&#160;takes&#160;&#160;the&#160;&#160;form&#160;&#160;of&#160;&#160;the&#160;&#160;Kernel&#160;&#160;method<br/>callcc&#160;and&#160;the&#160;Continuation&#160;object.&#160;Continuations&#160;are&#160;part&#160;of&#160;the&#160;core&#160;platform&#160;in&#160;Ruby<br/>1.8,&#160;but&#160;they&#160;have&#160;been&#160;replaced&#160;by&#160;fibers&#160;and&#160;moved&#160;to&#160;the&#160;standard&#160;library&#160;in&#160;Ruby<br/>1.9. To use them in Ruby 1.9, you must explicitly require them with:<br/>
require 'continuation'<br/>
Implementation&#160;difficulties&#160;prevent&#160;other&#160;implementations&#160;of&#160;Ruby&#160;(such&#160;as&#160;JRuby,<br/>the&#160;Java-based&#160;implementation)&#160;from&#160;supporting&#160;continuations.&#160;Because&#160;they&#160;are&#160;no<br/>longer&#160;well&#160;supported,&#160;continuations&#160;should&#160;be&#160;considered&#160;a&#160;curiosity,&#160;and&#160;new&#160;Ruby<br/>code&#160;should&#160;not&#160;use&#160;them.&#160;If&#160;you&#160;have&#160;Ruby&#160;1.8&#160;code&#160;that&#160;relies&#160;on&#160;continuations,&#160;you<br/>may be able to convert it to use fibers in Ruby 1.9.<br/>The&#160;Kernel&#160;method&#160;callcc&#160;executes&#160;its&#160;block,&#160;passing&#160;a&#160;newly&#160;created&#160;Continuation<br/>object&#160;as&#160;the&#160;only&#160;argument.&#160;The&#160;Continuation&#160;object&#160;has&#160;a&#160;call&#160;method,&#160;which&#160;makes<br/>the&#160;callcc&#160;invocation&#160;return&#160;to&#160;its&#160;caller.&#160;The&#160;value&#160;passed&#160;to&#160;call&#160;becomes the return<br/>value&#160;of&#160;the&#160;callcc&#160;invocation.&#160;In&#160;this&#160;sense,&#160;callcc&#160;is&#160;like&#160;catch, and&#160;the&#160;call&#160;method<br/>of the&#160;Continuation&#160;object is like&#160;throw.<br/>Continuations&#160;are&#160;different,&#160;however,&#160;because&#160;the&#160;Continuation&#160;object&#160;can&#160;be&#160;saved<br/>into&#160;a&#160;variable&#160;outside&#160;of&#160;the&#160;callcc&#160;block.&#160;The&#160;call&#160;method&#160;of&#160;this&#160;object&#160;may&#160;be&#160;called<br/>repeatedly,&#160;&#160;and&#160;&#160;causes&#160;&#160;control&#160;&#160;to&#160;&#160;jump&#160;&#160;to&#160;&#160;the&#160;&#160;first&#160;&#160;statement&#160;&#160;following&#160;&#160;the&#160;&#160;callcc<br/>invocation.<br/>The&#160;following&#160;code&#160;demonstrates&#160;how&#160;continuations&#160;can&#160;be&#160;used&#160;to&#160;define&#160;a&#160;method<br/>that works like the&#160;goto&#160;statement in the BASIC programming language:<br/>
# Global hash for mapping line numbers (or symbols) to continuations<br/>$lines = {} &#160;<br/>
# Create a continuation and map it to the specified line number<br/>def line(symbol)<br/>&#160; callcc &#160;{|c| $lines[symbol] = c }<br/>end<br/>
# Look up the continuation associated with the number, and jump there<br/>def goto(symbol)<br/>&#160; $lines[symbol].call<br/>end<br/>
# Now we can pretend we're programming in BASIC<br/>
<b>172&#160;|&#160;Chapter 5:</b> <b>Statements and Control Structures</b><br/>
<hr/>
<a name=187></a>i = 0<br/>line 10 &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Declare this spot to be line 10<br/>puts i += 1<br/>goto 10 if i &lt; 5 &#160; &#160; # Jump back to line 10 if the condition is met<br/>
line 20 &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Declare this spot to be line 20<br/>puts i -= 1<br/>goto 20 if i &gt; 0<br/>
<b>5.8 &#160;Threads, Fibers, and Continuations&#160;|&#160;173</b><br/>
<hr/>
<a name=188></a><hr/>
<a name=189></a><img src="Ruby-189_1.jpg"/><br/>
<b>CHAPTER&#160;6</b><br/>
<b>Methods, Procs, Lambdas, and Closures</b><br/>
<b>175</b><br/>
<hr/>
<a name=190></a>A&#160;<i>method</i>&#160;is&#160;a&#160;named&#160;block&#160;of&#160;parameterized&#160;code&#160;associated&#160;with&#160;one&#160;or&#160;more&#160;objects.<br/>A&#160;method&#160;<i>invocation</i>&#160;specifies&#160;the&#160;method&#160;name,&#160;the&#160;object&#160;on&#160;which&#160;it&#160;is&#160;to&#160;be&#160;invoked<br/>(sometimes&#160;called&#160;the&#160;<i>receiver</i>),&#160;and&#160;zero&#160;or&#160;more&#160;argument&#160;values&#160;that&#160;are&#160;assigned&#160;to<br/>the&#160;named&#160;method&#160;parameters.&#160;The&#160;value&#160;of&#160;the&#160;last&#160;expression&#160;evaluated&#160;in&#160;the&#160;method<br/>becomes the value of the method invocation expression.<br/>Many&#160;languages&#160;distinguish&#160;between&#160;functions,&#160;which&#160;have&#160;no&#160;associated&#160;object,&#160;and<br/>methods,&#160;which&#160;are&#160;invoked&#160;on&#160;a&#160;receiver&#160;object.&#160;Because&#160;Ruby&#160;is&#160;a&#160;purely&#160;object-<br/>oriented&#160;language,&#160;all&#160;methods&#160;are&#160;true&#160;methods&#160;and&#160;are&#160;associated&#160;with&#160;at&#160;least&#160;one<br/>object.&#160;We&#160;have&#160;not&#160;covered&#160;class&#160;definitions&#160;in&#160;Ruby&#160;yet,&#160;so&#160;the&#160;example&#160;methods<br/>defined&#160;in&#160;this&#160;chapter&#160;look&#160;like&#160;global&#160;functions&#160;with&#160;no&#160;associated&#160;object.&#160;In&#160;fact,<br/>Ruby implicitly defines and invokes them as private methods of the&#160;Object&#160;class.<br/>Methods&#160;are&#160;a&#160;fundamental&#160;part&#160;of&#160;Ruby’s&#160;syntax,&#160;but&#160;they&#160;are&#160;not&#160;values&#160;that&#160;Ruby<br/>programs&#160;&#160;can&#160;&#160;operate&#160;&#160;on.&#160;&#160;That&#160;&#160;is,&#160;&#160;Ruby’s&#160;&#160;methods&#160;&#160;are&#160;&#160;not&#160;&#160;objects&#160;&#160;in&#160;&#160;the&#160;&#160;way&#160;&#160;that<br/>strings,&#160;numbers,&#160;and&#160;arrays&#160;are.&#160;It&#160;is&#160;possible,&#160;however,&#160;to&#160;obtain&#160;a&#160;Method&#160;object&#160;that<br/>represents&#160;&#160;a&#160;&#160;given&#160;&#160;method,&#160;&#160;and&#160;&#160;we&#160;&#160;can&#160;&#160;invoke&#160;&#160;methods&#160;&#160;indirectly&#160;&#160;through&#160;&#160;Method<br/>objects.<br/>Methods&#160;are&#160;not&#160;Ruby’s&#160;only&#160;form&#160;of&#160;parameterized&#160;executable&#160;code.&#160;Blocks,&#160;which<br/>we&#160;introduced&#160;<a href="Rubys.html#154">in&#160;§5.4,&#160;</a>are&#160;executable&#160;chunks&#160;of&#160;code&#160;and&#160;may&#160;have&#160;parameters.&#160;Unlike<br/>methods,&#160;blocks&#160;do&#160;not&#160;have&#160;names,&#160;and&#160;they&#160;can&#160;only&#160;be&#160;invoked&#160;indirectly&#160;through<br/>an iterator method.<br/>Blocks,&#160;like&#160;methods,&#160;are&#160;not&#160;objects&#160;that&#160;Ruby&#160;can&#160;manipulate.&#160;But&#160;it’s&#160;possible&#160;to<br/>create&#160;an&#160;object&#160;that&#160;represents&#160;a&#160;block,&#160;and&#160;this&#160;is&#160;actually&#160;done&#160;with&#160;some&#160;frequency<br/>in&#160;Ruby&#160;programs.&#160;A&#160;Proc&#160;object&#160;represents&#160;a&#160;block.&#160;Like&#160;a&#160;Method&#160;object,&#160;we&#160;can&#160;execute<br/>the code of a block through the&#160;Proc&#160;that represents it. There are two varieties of&#160;Proc<br/>objects,&#160;called&#160;<i>procs</i>&#160;and&#160;<i>lambdas</i>,&#160;which&#160;have&#160;slightly&#160;different&#160;behavior.&#160;Both&#160;procs<br/>and&#160;lambdas&#160;are&#160;functions&#160;rather&#160;than&#160;methods&#160;invoked&#160;on&#160;an&#160;object.&#160;An&#160;important<br/>feature&#160;of&#160;procs&#160;and&#160;lambdas&#160;is&#160;that&#160;they&#160;are&#160;<i>closures</i>:&#160;they&#160;retain&#160;access&#160;to&#160;the&#160;local<br/>variables&#160;that&#160;were&#160;in&#160;scope&#160;when&#160;they&#160;were&#160;defined,&#160;even&#160;when&#160;the&#160;proc&#160;or&#160;lambda&#160;is<br/>invoked from a different scope.<br/>Methods&#160;have&#160;a&#160;rich&#160;and&#160;fairly&#160;complex&#160;syntax&#160;in&#160;Ruby,&#160;and&#160;the&#160;first&#160;four&#160;sections&#160;of<br/>this&#160;chapter&#160;are&#160;dedicated&#160;to&#160;them.&#160;We&#160;begin&#160;by&#160;explaining&#160;how&#160;to&#160;define&#160;simple&#160;meth-<br/>ods,&#160;&#160;and&#160;&#160;then&#160;&#160;follow&#160;&#160;this&#160;&#160;introductory&#160;&#160;section&#160;&#160;with&#160;&#160;three&#160;&#160;more&#160;&#160;advanced&#160;&#160;sections<br/>covering&#160;&#160;methods&#160;&#160;names,&#160;&#160;method&#160;&#160;parentheses,&#160;&#160;and&#160;&#160;method&#160;&#160;parameters.&#160;&#160;Note&#160;&#160;that<br/>method&#160;invocation&#160;is&#160;a&#160;kind&#160;of&#160;expression,&#160;covered&#160;earlier&#160;in&#160;<a href="Rubys.html#103">§4.4.&#160;</a>Further&#160;details&#160;on<br/>method invocation are provided throughout the first four sections of this chapter.<br/>After&#160;covering&#160;methods,&#160;we&#160;turn&#160;our&#160;attention&#160;to&#160;procs&#160;and&#160;lambdas,&#160;explaining&#160;how<br/>to&#160;create&#160;and&#160;invoke&#160;them,&#160;and&#160;also&#160;detailing&#160;the&#160;somewhat&#160;subtle&#160;differences&#160;between<br/>them.&#160;A&#160;separate&#160;section&#160;covers&#160;the&#160;use&#160;of&#160;procs&#160;and&#160;lambdas&#160;as&#160;closures.&#160;This&#160;is&#160;fol-<br/>lowed&#160;by&#160;a&#160;section&#160;on&#160;the&#160;Method&#160;object,&#160;which&#160;actually&#160;behaves&#160;much&#160;like&#160;a&#160;lambda.<br/>The chapter ends with an advanced exploration of functional programming in Ruby.<br/>
<b>176&#160;|&#160;Chapter 6:</b> <b>Methods, Procs, Lambdas, and Closures</b><br/>
<hr/>
<a name=191></a><b>6.1 &#160;Defining Simple Methods<br/></b>You’ve&#160;seen&#160;many&#160;method&#160;invocations&#160;in&#160;examples&#160;throughout&#160;this&#160;book,&#160;and&#160;method<br/>invocation&#160;syntax&#160;was&#160;described&#160;in&#160;detail&#160;in&#160;<a href="Rubys.html#103">§4.4.&#160;</a>Now&#160;we&#160;turn&#160;to&#160;the&#160;syntax&#160;for&#160;de-<br/>fining&#160;methods.&#160;This&#160;section&#160;explains&#160;method&#160;definition&#160;basics.&#160;It&#160;is&#160;followed&#160;by&#160;three<br/>more&#160;sections&#160;that&#160;cover&#160;method&#160;names,&#160;method&#160;parentheses,&#160;and&#160;method&#160;arguments<br/>in&#160;&#160;more&#160;&#160;detail.&#160;&#160;These&#160;&#160;additional&#160;&#160;sections&#160;&#160;explain&#160;&#160;more&#160;&#160;advanced&#160;&#160;material&#160;&#160;and&#160;&#160;are<br/>relevant to both method definition and method invocation.<br/>Methods are defined with the&#160;def&#160;keyword.&#160;This is followed by the method name and<br/>an&#160;optional&#160;list&#160;of&#160;parameter&#160;names&#160;in&#160;parentheses.&#160;The&#160;Ruby&#160;code&#160;that&#160;constitutes&#160;the<br/>method&#160;body&#160;follows&#160;the&#160;parameter&#160;list,&#160;and&#160;the&#160;end&#160;of&#160;the&#160;method&#160;is&#160;marked&#160;with&#160;the<br/>end&#160;keyword.&#160;Parameter&#160;names&#160;can&#160;be&#160;used&#160;as&#160;variables&#160;within&#160;the&#160;method&#160;body,&#160;and<br/>the&#160;values&#160;of&#160;these&#160;named&#160;parameters&#160;come&#160;from&#160;the&#160;arguments&#160;to&#160;a&#160;method&#160;invocation.<br/>Here is an example method:<br/>
# Define a method named 'factorial' with a single parameter 'n'<br/>def factorial(n)<br/>&#160; if n &lt; 1 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Test the argument value for validity<br/>&#160; &#160; raise &#34;argument must be &gt; 0&#34;<br/>&#160; elsif n == 1 &#160; &#160; &#160; &#160; &#160; &#160;# If the argument is 1<br/>&#160; &#160; 1 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # then the value of the method invocation is 1<br/>&#160; else &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Otherwise, the factorial of n is n times<br/>&#160; &#160; n * factorial(n-1) &#160; &#160;# the factorial of n-1<br/>&#160; end<br/>end<br/>
This&#160;&#160;code&#160;&#160;defines&#160;&#160;a&#160;&#160;method&#160;&#160;named&#160;&#160;factorial.&#160;&#160;The&#160;&#160;method&#160;&#160;has&#160;&#160;a&#160;&#160;single&#160;&#160;parameter<br/>named&#160;n.&#160;The&#160;identifier&#160;n&#160;is&#160;used&#160;as&#160;a&#160;variable&#160;within&#160;the&#160;body&#160;of&#160;the&#160;method.&#160;This&#160;is&#160;a<br/>recursive&#160;method,&#160;so&#160;the&#160;body&#160;of&#160;the&#160;method&#160;includes&#160;an&#160;invocation&#160;of&#160;the&#160;method.<br/>The&#160;invocation&#160;is&#160;simply&#160;the&#160;name&#160;of&#160;the&#160;method&#160;followed&#160;by&#160;the&#160;argument&#160;value&#160;in<br/>parentheses.<br/>
<b>6.1.1 &#160;Method Return Value<br/></b>Methods may terminate normally or abnormally. Abnormal termination occurs when<br/>the&#160;method&#160;raises&#160;an&#160;exception.&#160;The&#160;factorial&#160;method&#160;shown&#160;earlier&#160;terminates&#160;ab-<br/>normally&#160;if&#160;we&#160;pass&#160;it&#160;an&#160;argument&#160;less&#160;than&#160;1.&#160;If&#160;a&#160;method&#160;terminates&#160;normally,&#160;then<br/>the&#160;value&#160;of&#160;the&#160;method&#160;invocation&#160;expression&#160;is&#160;the&#160;value&#160;of&#160;the&#160;last&#160;expression&#160;eval-<br/>uated&#160;within&#160;the&#160;method&#160;body.&#160;In&#160;the&#160;factorial&#160;method,&#160;that&#160;last&#160;expression&#160;will&#160;either<br/>be&#160;1&#160;or&#160;n*factorial(n-1).<br/>The&#160;return&#160;keyword&#160;is&#160;used&#160;to&#160;force&#160;a&#160;return&#160;prior&#160;to&#160;the&#160;end&#160;of&#160;the&#160;method.&#160;If&#160;an<br/>expression&#160;follows&#160;the&#160;return&#160;keyword,&#160;then&#160;the&#160;value&#160;of&#160;that&#160;expression&#160;is&#160;returned.<br/>If&#160;no&#160;expression&#160;follows,&#160;then&#160;the&#160;return&#160;value&#160;is&#160;nil.&#160;In&#160;the&#160;following&#160;variant&#160;of&#160;the<br/>factorial&#160;method, the&#160;return&#160;keyword is required:<br/>
def factorial(n)<br/>&#160; raise &#34;bad argument&#34; if n &lt; 1<br/>
<b>6.1 &#160;Defining Simple Methods&#160;|&#160;177</b><br/>
<hr/>
<a name=192></a>&#160; return 1 if n == 1<br/>&#160; n * factorial(n-1)<br/>end<br/>
We&#160;could&#160;also&#160;use&#160;return&#160;on&#160;the&#160;last&#160;line&#160;of&#160;this&#160;method&#160;body&#160;to&#160;emphasize&#160;that&#160;this<br/>expression&#160;&#160;is&#160;&#160;the&#160;&#160;method’s&#160;&#160;return&#160;&#160;value.&#160;&#160;In&#160;&#160;common&#160;&#160;practice,&#160;&#160;however,&#160;&#160;return&#160;&#160;is<br/>omitted where it is not required.<br/>Ruby&#160;methods&#160;may&#160;return&#160;more&#160;than&#160;one&#160;value.&#160;To&#160;do&#160;this,&#160;use&#160;an&#160;explicit&#160;return<br/>statement, and separate the values to be returned with commas:<br/>
# Convert the Cartesian point (x,y) to polar (magnitude, angle) coordinates<br/>def polar(x,y)<br/>&#160; return Math.hypot(y,x), Math.atan2(y,x)<br/>end<br/>
When&#160;there&#160;is&#160;more&#160;than&#160;one&#160;return&#160;value,&#160;the&#160;values&#160;are&#160;collected&#160;into&#160;an&#160;array,&#160;and<br/>the&#160;array&#160;becomes&#160;the&#160;single&#160;return&#160;value&#160;of&#160;the&#160;method.&#160;Instead&#160;of&#160;using&#160;the&#160;return<br/>statement with multiple values, we can simply create an array of values ourselves:<br/>
# Convert polar coordinates to Cartesian coordinates<br/>def cartesian(magnitude, angle)<br/>&#160; [magnitude*Math.cos(angle), magnitude*Math.sin(angle)]<br/>end<br/>
Methods&#160;&#160;of&#160;&#160;this&#160;&#160;form&#160;&#160;are&#160;&#160;typically&#160;&#160;intended&#160;&#160;for&#160;&#160;use&#160;&#160;with&#160;&#160;parallel&#160;&#160;assignment&#160;&#160;(see<br/><a href="Rubys.html#111">§4.5.5) so that each return value is assigned to a separate variable:</a><br/>
distance, theta = polar(x,y)<br/>x,y = cartesian(distance,theta)<br/>
<b>6.1.2 &#160;Methods and Exception Handling<br/></b>A&#160;def&#160;statement&#160;that&#160;defines&#160;a&#160;method&#160;may&#160;include&#160;exception-handling&#160;code&#160;in&#160;the<br/>form&#160;of&#160;rescue,&#160;else,&#160;and&#160;ensure&#160;clauses,&#160;just&#160;as&#160;a&#160;begin&#160;statement&#160;can.&#160;These&#160;exception-<br/>handling&#160;clauses&#160;go&#160;after&#160;the&#160;end&#160;of&#160;the&#160;method&#160;body&#160;but&#160;before&#160;the&#160;end&#160;of&#160;the&#160;def<br/>statement.&#160;In&#160;short&#160;methods,&#160;it&#160;can&#160;be&#160;particularly&#160;tidy&#160;to&#160;associate&#160;your&#160;rescue&#160;clauses<br/>with&#160;the&#160;def&#160;statement.&#160;This&#160;also&#160;means&#160;you&#160;don’t&#160;have&#160;to&#160;use&#160;a&#160;begin&#160;statement&#160;and<br/><a href="Rubys.html#178">the extra level of indentation that comes with it. See §5.6.6 for further details.</a><br/>
<b>6.1.3 &#160;Invoking a Method on an Object<br/></b>Methods&#160;&#160;are&#160;&#160;always&#160;&#160;invoked&#160;&#160;on&#160;&#160;an&#160;&#160;object.&#160;&#160;(This&#160;&#160;object&#160;&#160;is&#160;&#160;sometimes&#160;&#160;called&#160;&#160;the<br/>receiver&#160;in&#160;a&#160;reference&#160;to&#160;an&#160;object-oriented&#160;paradigm&#160;in&#160;which&#160;methods&#160;are&#160;called<br/>“messages”&#160;and&#160;are&#160;“sent&#160;to”&#160;receiver&#160;objects.)&#160;Within&#160;the&#160;body&#160;of&#160;a&#160;method,&#160;the&#160;key-<br/>word&#160;self&#160;refers&#160;to&#160;the&#160;object&#160;on&#160;which&#160;the&#160;method&#160;was&#160;invoked.&#160;If&#160;we&#160;don’t&#160;specify<br/>an object when invoking a method, then the method is implicitly invoked on&#160;self.<br/>You’ll&#160;learn&#160;how&#160;to&#160;define&#160;methods&#160;for&#160;classes&#160;of&#160;objects&#160;<a href="Rubys.html#227">in&#160;Chapter&#160;7.&#160;</a>Notice,&#160;however,<br/>that you’ve already seen examples of invoking methods on objects, in code like this:<br/>
first = text.index(pattern)<br/>
<b>178&#160;|&#160;Chapter 6:</b> <b>Methods, Procs, Lambdas, and Closures</b><br/>
<hr/>
<a name=193></a>Like&#160;most&#160;object-oriented&#160;languages,&#160;Ruby&#160;uses&#160;.&#160;to&#160;separate&#160;the&#160;object&#160;from&#160;the&#160;meth-<br/>od&#160;to&#160;be&#160;invoked&#160;on&#160;it.&#160;This&#160;code&#160;passes&#160;the&#160;value&#160;of&#160;the&#160;variable&#160;pattern&#160;to&#160;the&#160;method<br/>named&#160;index&#160;of&#160;the&#160;object&#160;stored&#160;in&#160;the&#160;variable&#160;text,&#160;and&#160;stores&#160;the&#160;return&#160;value&#160;in&#160;the<br/>variable&#160;first.<br/>
<b>6.1.4 &#160;Defining Singleton Methods<br/></b>The&#160;methods&#160;we’ve&#160;defined&#160;so&#160;far&#160;are&#160;all&#160;global&#160;methods.&#160;If&#160;we&#160;place&#160;a&#160;def&#160;statement<br/>like&#160;the&#160;ones&#160;shown&#160;earlier&#160;inside&#160;a&#160;class&#160;statement,&#160;then&#160;the&#160;methods&#160;that&#160;are&#160;defined<br/>are&#160;instance&#160;methods&#160;of&#160;the&#160;class;&#160;these&#160;methods&#160;are&#160;defined&#160;on&#160;all&#160;objects&#160;that&#160;are<br/><a href="Rubys.html#227">instances of the class. (Classes and instance methods are explained in Chapter 7.)<br/></a>It&#160;is&#160;also&#160;possible,&#160;however,&#160;to&#160;use&#160;the&#160;def&#160;statement&#160;to&#160;define&#160;a&#160;method&#160;on&#160;a&#160;single<br/>specified&#160;object.&#160;Simply&#160;follow&#160;the&#160;def&#160;keyword&#160;with&#160;an&#160;expression&#160;that&#160;evaluates&#160;to<br/>an&#160;object.&#160;This&#160;expression&#160;should&#160;be&#160;followed&#160;by&#160;a&#160;period&#160;and&#160;the&#160;name&#160;of&#160;the&#160;method<br/>to&#160;&#160;be&#160;&#160;defined.&#160;&#160;The&#160;&#160;resulting&#160;&#160;method&#160;&#160;is&#160;&#160;known&#160;&#160;as&#160;&#160;a&#160;&#160;<i>singleton&#160;&#160;method</i>&#160;&#160;because&#160;&#160;it&#160;&#160;is<br/>available only on a single object:<br/>
o = &#34;message&#34; &#160; &#160;# A string is an object<br/>def o.printme &#160; &#160;# Define a singleton method for this object<br/>&#160; puts self<br/>end<br/>o.printme &#160; &#160; &#160; &#160;# Invoke the singleton&#160;<br/>
Class&#160;methods&#160;(covered&#160;in&#160;<a href="Rubys.html#227">Chapter&#160;7)&#160;</a>such&#160;as&#160;Math.sin&#160;and&#160;File.delete&#160;are&#160;actually<br/>singleton&#160;methods.&#160;Math&#160;is&#160;a&#160;constant&#160;that&#160;refers&#160;to&#160;a&#160;Module&#160;object,&#160;and&#160;File&#160;is&#160;a&#160;constant<br/>that&#160;refers&#160;to&#160;a&#160;Class&#160;object.&#160;These&#160;two&#160;objects&#160;have&#160;singleton&#160;methods&#160;named&#160;sin&#160;and<br/>delete, respectively.<br/>
Ruby&#160;implementations&#160;typically&#160;treat&#160;Fixnum&#160;and&#160;Symbol&#160;values&#160;as&#160;immediate&#160;values<br/>rather&#160;than&#160;as&#160;true&#160;object&#160;references.&#160;<a href="Rubys.html#87">(See&#160;§3.8.1.1.)&#160;</a>For&#160;this&#160;reason,&#160;singleton&#160;methods<br/>may&#160;not&#160;be&#160;defined&#160;on&#160;Fixnum&#160;and&#160;Symbol&#160;objects.&#160;For&#160;consistency,&#160;singletons&#160;are&#160;also<br/>prohibited on other&#160;Numeric&#160;objects.<br/>
<b>6.1.5 &#160;Undefining Methods<br/></b>Methods&#160;&#160;are&#160;&#160;defined&#160;&#160;with&#160;&#160;the&#160;&#160;def&#160;&#160;statement&#160;&#160;and&#160;&#160;may&#160;&#160;be&#160;&#160;undefined&#160;&#160;with&#160;&#160;the&#160;&#160;undef<br/>statement:<br/>
def sum(x,y); x+y; end &#160; &#160; &#160;# Define a method<br/>puts sum(1,2) &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Use it<br/>undef sum &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # And undefine it<br/>
In&#160;this&#160;code,&#160;the&#160;def&#160;statement&#160;defines&#160;a&#160;global&#160;method,&#160;and&#160;undef&#160;undefines&#160;it.&#160;undef<br/>also&#160;works&#160;within&#160;classes&#160;(which&#160;are&#160;the&#160;subject&#160;<a href="Rubys.html#227">of&#160;Chapter 7)&#160;</a>to&#160;undefine&#160;the&#160;instance<br/>methods&#160;of&#160;the&#160;class.&#160;Interestingly,&#160;undef&#160;can&#160;be&#160;used&#160;to&#160;undefine&#160;inherited&#160;methods,<br/>without&#160;affecting&#160;the&#160;definition&#160;of&#160;the&#160;method&#160;in&#160;the&#160;class&#160;from&#160;which&#160;it&#160;is&#160;inherited.<br/>Suppose class&#160;A&#160;defines&#160;a&#160;method&#160;m,&#160;and&#160;class&#160;B&#160;is&#160;a&#160;subclass&#160;of&#160;A&#160;and&#160;therefore&#160;inherits<br/>m.&#160;(Subclasses&#160;and&#160;inheritance&#160;are&#160;also&#160;explained&#160;in&#160;<a href="Rubys.html#227">Chapter&#160;7.)&#160;</a>If&#160;you&#160;don’t&#160;want&#160;to<br/>
<b>6.1 &#160;Defining Simple Methods&#160;|&#160;179</b><br/>
<hr/>
<a name=194></a>allow&#160;instances&#160;of&#160;class&#160;B&#160;to&#160;be&#160;able&#160;to&#160;invoke&#160;m,&#160;you&#160;can&#160;use&#160;undef m&#160;within&#160;the&#160;body<br/>of the subclass.<br/>
undef&#160;&#160;is&#160;&#160;not&#160;&#160;a&#160;&#160;commonly&#160;&#160;used&#160;&#160;statement.&#160;&#160;In&#160;&#160;practice,&#160;&#160;it&#160;&#160;is&#160;&#160;much&#160;&#160;more&#160;&#160;common&#160;&#160;to<br/>redefine&#160;a&#160;method&#160;with&#160;a&#160;new&#160;def&#160;statement&#160;than&#160;it&#160;is&#160;to&#160;<i>undefine</i>&#160;or&#160;delete&#160;the&#160;method.<br/>Note&#160;that&#160;the&#160;undef&#160;statement&#160;must&#160;be&#160;followed&#160;by&#160;a&#160;single&#160;identifier&#160;that&#160;specifies&#160;the<br/>method&#160;name.&#160;It&#160;cannot&#160;be&#160;used&#160;to&#160;undefine&#160;a&#160;singleton&#160;method&#160;in&#160;the&#160;way&#160;that&#160;def<br/>can be used to define such a method.<br/>Within a class or module, you can also use&#160;undef_method&#160;(a private method of&#160;Module)<br/>to&#160;&#160;undefine&#160;&#160;methods.&#160;&#160;Pass&#160;&#160;a&#160;&#160;symbol&#160;&#160;representing&#160;&#160;the&#160;&#160;name&#160;&#160;of&#160;&#160;the&#160;&#160;method&#160;&#160;to&#160;&#160;be<br/>undefined.<br/>
<b>6.2 &#160;Method Names<br/></b>By&#160;convention,&#160;method&#160;names&#160;begin&#160;with&#160;a&#160;lowercase&#160;letter.&#160;(Method&#160;names&#160;can&#160;begin<br/>with&#160;a&#160;capital&#160;letter,&#160;but&#160;that&#160;makes&#160;them&#160;look&#160;like&#160;constants.)&#160;When&#160;a&#160;method&#160;name<br/>is&#160;longer&#160;than&#160;one&#160;word,&#160;the&#160;usual&#160;convention&#160;is&#160;to&#160;separate&#160;the&#160;words&#160;with&#160;underscores<br/>like_this&#160;rather than using mixed case&#160;likeThis.<br/>
<b>Method Name Resolution</b><br/>
This&#160;section&#160;describes&#160;the&#160;names&#160;you&#160;give&#160;to&#160;methods&#160;when&#160;you&#160;define&#160;them.&#160;A&#160;related<br/>topic&#160;is&#160;method&#160;name&#160;resolution:&#160;how&#160;does&#160;the&#160;Ruby&#160;interpreter&#160;find&#160;the&#160;definition&#160;of<br/>the&#160;method&#160;named&#160;in&#160;a&#160;method&#160;invocation&#160;expression?&#160;The&#160;answer&#160;to&#160;that&#160;question<br/><a href="Rubys.html#272">must wait until we’ve discussed classes in Ruby. It is covered in §7.8.</a><br/>
Method&#160;names&#160;may&#160;(but&#160;are&#160;not&#160;required&#160;to)&#160;end&#160;with&#160;an&#160;equals&#160;sign,&#160;a&#160;question&#160;mark,<br/>or&#160;an&#160;exclamation&#160;point.&#160;An&#160;equals&#160;sign&#160;suffix&#160;signifies&#160;that&#160;the&#160;method&#160;is&#160;a&#160;<i>setter</i>&#160;that<br/>can&#160;be&#160;invoked&#160;using&#160;assignment&#160;syntax.&#160;Setter&#160;methods&#160;are&#160;described&#160;in&#160;<a href="Rubys.html#108">§4.5.3&#160;</a>and<br/>additional&#160;examples&#160;are&#160;provided&#160;<a href="Rubys.html#231">in&#160;§7.1.5.&#160;</a>The&#160;question&#160;mark&#160;and&#160;exclamation&#160;point<br/>suffixes&#160;have&#160;no&#160;special&#160;meaning&#160;to&#160;the&#160;Ruby&#160;interpreter,&#160;but&#160;they&#160;are&#160;allowed&#160;because<br/>they enable two extraordinarily useful naming conventions.<br/>The&#160;first&#160;convention&#160;is&#160;that&#160;any&#160;method&#160;whose&#160;name&#160;ends&#160;with&#160;a&#160;question&#160;mark&#160;returns<br/>a&#160;value&#160;that&#160;answers&#160;the&#160;question&#160;posed&#160;by&#160;the&#160;method&#160;invocation.&#160;The&#160;empty?&#160;method<br/>of an array, for example, returns&#160;true&#160;if the array has no elements. Methods like these<br/>are&#160;&#160;called&#160;&#160;<i>predicates</i>.&#160;&#160;Predicates&#160;&#160;typically&#160;&#160;return&#160;&#160;one&#160;&#160;of&#160;&#160;the&#160;&#160;Boolean&#160;&#160;values&#160;&#160;true&#160;&#160;or<br/>false,&#160;but&#160;this&#160;is&#160;not&#160;required,&#160;as&#160;any&#160;value&#160;other&#160;than&#160;false&#160;or&#160;nil&#160;works&#160;like&#160;true<br/>when&#160;a&#160;Boolean&#160;value&#160;is&#160;required.&#160;(The&#160;Numeric&#160;method&#160;nonzero?,&#160;for&#160;example,&#160;returns<br/>nil&#160;if the number it is invoked on is zero, and just returns the number otherwise.)<br/>
The&#160;second&#160;convention&#160;is&#160;that&#160;any&#160;method&#160;whose&#160;name&#160;ends&#160;with&#160;an&#160;exclamation&#160;mark<br/>should&#160;be&#160;used&#160;with&#160;caution.&#160;The&#160;Array&#160;object,&#160;for&#160;example,&#160;has&#160;a&#160;sort&#160;method&#160;that<br/>makes&#160;a&#160;copy&#160;of&#160;the&#160;array,&#160;and&#160;then&#160;sorts&#160;that&#160;copy.&#160;It&#160;also&#160;has&#160;a&#160;sort!&#160;method&#160;that<br/>
<b>180&#160;|&#160;Chapter 6:</b> <b>Methods, Procs, Lambdas, and Closures</b><br/>
<hr/>
<a name=195></a>sorts&#160;the&#160;array&#160;in&#160;place.&#160;The&#160;exclamation&#160;mark&#160;indicates&#160;that&#160;you&#160;need&#160;to&#160;be&#160;more<br/>careful when using that version of the method.<br/>Often,&#160;methods&#160;that&#160;end&#160;with&#160;an&#160;exclamation&#160;mark&#160;are&#160;<i>mutators</i>,&#160;which&#160;alter&#160;the&#160;in-<br/>ternal&#160;state&#160;of&#160;an&#160;object.&#160;But&#160;this&#160;is&#160;not&#160;always&#160;the&#160;case;&#160;there&#160;are&#160;many&#160;mutators&#160;that<br/>do&#160;not&#160;end&#160;with&#160;an&#160;exclamation&#160;mark,&#160;and&#160;a&#160;number&#160;of&#160;nonmutators&#160;that&#160;do.&#160;Mutating<br/>methods&#160;(such&#160;as&#160;Array.fill)&#160;that&#160;do&#160;not&#160;have&#160;a&#160;nonmutating&#160;variant&#160;do&#160;not&#160;typically<br/>have an exclamation point.<br/>Consider&#160;the&#160;global&#160;function&#160;exit:&#160;it&#160;makes&#160;the&#160;Ruby&#160;program&#160;stop&#160;running&#160;in&#160;a&#160;con-<br/>trolled&#160;way.&#160;There&#160;is&#160;also&#160;a&#160;variant&#160;named&#160;exit!&#160;that aborts the program immediately<br/>without&#160;running&#160;any&#160;END&#160;blocks&#160;or&#160;shutdown&#160;hooks&#160;registered&#160;with&#160;at_exit.&#160;exit!&#160;isn’t<br/>a&#160;mutator;&#160;it’s&#160;the&#160;“dangerous”&#160;variant&#160;of&#160;the&#160;exit&#160;method&#160;and&#160;is&#160;flagged&#160;with&#160;!&#160;to<br/>remind a programmer using it to be careful.<br/>
<b>6.2.1 &#160;Operator Methods<br/></b>Many&#160;of&#160;Ruby’s&#160;operators,&#160;such&#160;as&#160;+,&#160;*,&#160;and&#160;even&#160;the&#160;array&#160;index&#160;operator&#160;[],&#160;are&#160;im-<br/>plemented&#160;&#160;with&#160;&#160;methods&#160;&#160;that&#160;&#160;you&#160;&#160;can&#160;&#160;define&#160;&#160;in&#160;&#160;your&#160;&#160;own&#160;&#160;classes.&#160;&#160;You&#160;&#160;define&#160;&#160;an<br/>operator&#160;by&#160;defining&#160;a&#160;method&#160;with&#160;the&#160;same&#160;“name”&#160;as&#160;the&#160;operator.&#160;(The&#160;only&#160;ex-<br/>ceptions&#160;are&#160;the&#160;unary&#160;plus&#160;and&#160;minus&#160;operators,&#160;which&#160;use&#160;method&#160;names&#160;+@&#160;and<br/>-@.)&#160;Ruby&#160;allows&#160;you&#160;to&#160;do&#160;this&#160;even&#160;though&#160;the&#160;method&#160;name&#160;is&#160;all&#160;punctuation.&#160;You<br/>might end up with a method definition like this:<br/>
def +(other) &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Define binary plus operator: x+y is x.+(y)<br/>&#160; self.concatenate(other)<br/>end &#160; &#160; &#160;&#160;<br/>
<a href="Rubys.html#116">Table&#160;4-2&#160;</a>in&#160;<a href="Rubys.html#99">Chapter&#160;4&#160;</a>specifies&#160;which&#160;of&#160;Ruby’s&#160;operators&#160;are&#160;defined&#160;as&#160;methods.<br/>These&#160;operators&#160;are&#160;the&#160;only&#160;punctuation-based&#160;method&#160;names&#160;that&#160;you&#160;can&#160;use:&#160;you<br/>
&#160;<br/>
can’t&#160;invent&#160;new&#160;operators&#160;or&#160;define&#160;methods&#160;whose&#160;names&#160;consist&#160;of&#160;other&#160;sequences<br/>of&#160;punctuation&#160;characters.&#160;There&#160;are&#160;additional&#160;examples&#160;of&#160;defining&#160;method-based<br/><a href="Rubys.html#233">operators in §7.1.6.<br/></a>Methods&#160;that&#160;define&#160;a&#160;unary&#160;operator&#160;are&#160;passed&#160;no&#160;arguments.&#160;Methods&#160;that&#160;define<br/>binary&#160;operators&#160;are&#160;passed&#160;one&#160;argument&#160;and&#160;should&#160;operate&#160;on&#160;self&#160;and&#160;the&#160;argu-<br/>ment.&#160;The&#160;array&#160;access&#160;operators&#160;[]&#160;and&#160;[]=&#160;are&#160;special&#160;because&#160;they&#160;can&#160;be&#160;invoked<br/>with&#160;any&#160;number&#160;of&#160;arguments.&#160;For&#160;[]=,&#160;the&#160;last&#160;argument&#160;is&#160;always&#160;the&#160;value&#160;being<br/>assigned.<br/>
<b>6.2.2 &#160;Method Aliases<br/></b>It is not uncommon&#160;for&#160;methods&#160;in&#160;Ruby&#160;to&#160;have&#160;more&#160;than&#160;one&#160;name.&#160;The&#160;language<br/>has&#160;a&#160;keyword&#160;alias&#160;that&#160;serves&#160;to&#160;define&#160;a&#160;new&#160;name&#160;for&#160;an&#160;existing&#160;method.&#160;Use&#160;it<br/>like this:<br/>
alias aka also_known_as &#160; # alias new_name existing_name<br/>
<b>6.2 &#160;Method Names&#160;|&#160;181</b><br/>
<hr/>
<a name=196></a>After&#160;executing&#160;this&#160;statement,&#160;the&#160;identifier&#160;aka&#160;will&#160;refer&#160;to&#160;the&#160;same&#160;method&#160;thats<br/>also_known_as&#160;does.<br/>
Method&#160;aliasing&#160;is&#160;one&#160;of&#160;the&#160;things&#160;that&#160;makes&#160;Ruby&#160;an&#160;expressive&#160;and&#160;natural&#160;lan-<br/>guage.&#160;When&#160;there&#160;are&#160;multiple&#160;names&#160;for&#160;a&#160;method,&#160;you&#160;can&#160;choose&#160;the&#160;one&#160;that&#160;seems<br/>most&#160;natural&#160;in&#160;your&#160;code.&#160;The&#160;Range&#160;class,&#160;for&#160;example,&#160;defines&#160;a&#160;method&#160;for&#160;testing<br/>whether&#160;&#160;a&#160;&#160;value&#160;&#160;falls&#160;&#160;within&#160;&#160;the&#160;&#160;range.&#160;&#160;You&#160;&#160;can&#160;&#160;call&#160;&#160;this&#160;&#160;method&#160;&#160;with&#160;&#160;the&#160;&#160;name<br/>include?&#160;or&#160;with&#160;the&#160;name&#160;member?.&#160;If&#160;you&#160;are&#160;treating&#160;a&#160;range&#160;as&#160;a&#160;kind&#160;of&#160;set,&#160;the&#160;name<br/>member?&#160;may be the most natural choice.<br/>
A&#160;&#160;more&#160;&#160;practical&#160;&#160;reason&#160;&#160;for&#160;&#160;aliasing&#160;&#160;methods&#160;&#160;is&#160;&#160;to&#160;&#160;insert&#160;&#160;new&#160;&#160;functionality&#160;&#160;into&#160;&#160;a<br/>method. The following is a common idiom for augmenting existing methods:<br/>
def hello &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # A nice simple method<br/>&#160; puts &#34;Hello World&#34; &#160; &#160; &#160; &#160; &#160; &#160;# Suppose we want to augment it...<br/>end<br/>
alias original_hello hello &#160; &#160; &#160;# Give the method a backup name<br/>
def hello &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Now we define a new method with the old name<br/>&#160; puts &#34;Your attention please&#34; &#160;# That does some stuff<br/>&#160; original_hello &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Then calls the original method<br/>&#160; puts &#34;This has been a test&#34; &#160; # Then does some more stuff<br/>end<br/>
In&#160;this&#160;code,&#160;we’re&#160;working&#160;on&#160;global&#160;methods.&#160;It&#160;is&#160;more&#160;common&#160;to&#160;use&#160;alias&#160;with<br/>the&#160;instance&#160;methods&#160;of&#160;a&#160;class.&#160;(We’ll&#160;learn&#160;about&#160;this&#160;<a href="Rubys.html#227">in&#160;Chapter 7</a>.)&#160;In&#160;this&#160;situation,<br/>alias&#160;must&#160;be&#160;used&#160;within&#160;the&#160;class&#160;whose&#160;method&#160;is&#160;to&#160;be&#160;renamed.&#160;Classes&#160;in&#160;Ruby<br/>can&#160;be&#160;“reopened”&#160;(again,&#160;this&#160;is&#160;discussed&#160;<a href="Rubys.html#227">in&#160;Chapter&#160;7)—which&#160;</a>means&#160;that&#160;your&#160;code<br/>can&#160;take&#160;an&#160;existing&#160;class,&#160;‘open’&#160;it&#160;with&#160;a&#160;class&#160;statement,&#160;and&#160;then&#160;use&#160;alias&#160;as&#160;shown<br/>in&#160;the&#160;example&#160;to&#160;augment&#160;or&#160;alter&#160;the&#160;existing&#160;methods&#160;of&#160;that&#160;class.&#160;This&#160;is&#160;called<br/><a href="Rubys.html#304">“alias chaining” and is covered in detail in §8.11.</a><br/>
<b>Aliasing Is Not Overloading</b><br/>
A&#160;Ruby&#160;method&#160;may&#160;have&#160;two&#160;names,&#160;but&#160;two&#160;methods&#160;cannot&#160;share&#160;a&#160;single&#160;name.&#160;In<br/>statically&#160;typed&#160;languages,&#160;methods&#160;can&#160;be&#160;distinguished&#160;by&#160;the&#160;number&#160;and&#160;type&#160;of<br/>their&#160;arguments,&#160;and&#160;two&#160;or&#160;more&#160;methods&#160;may&#160;share&#160;the&#160;same&#160;name&#160;as&#160;long&#160;as&#160;they<br/>expect&#160;different&#160;numbers&#160;or&#160;types&#160;of&#160;arguments.&#160;This&#160;kind&#160;of&#160;overloading&#160;is&#160;not&#160;possible<br/>in Ruby.<br/>
On&#160;the&#160;other&#160;hand,&#160;method&#160;overloading&#160;is&#160;not&#160;really&#160;necessary&#160;in&#160;Ruby.&#160;Methods&#160;can<br/>accept&#160;arguments&#160;of&#160;any&#160;class&#160;and&#160;can&#160;be&#160;written&#160;to&#160;do&#160;different&#160;things&#160;based&#160;on&#160;the<br/>type&#160;of&#160;the&#160;arguments&#160;they&#160;are&#160;passed.&#160;Also&#160;(as&#160;we’ll&#160;see&#160;later),&#160;Ruby’s&#160;method&#160;argu-<br/>ments can be declared with default values, and these arguments may be omitted form<br/>method&#160;invocations.&#160;This&#160;allows&#160;a&#160;single&#160;method&#160;to&#160;be&#160;invoked&#160;with&#160;differing&#160;numbers<br/>of arguments.<br/>
<b>182&#160;|&#160;Chapter 6:</b> <b>Methods, Procs, Lambdas, and Closures</b><br/>
<hr/>
<a name=197></a><b>6.3 &#160;Methods and Parentheses<br/></b>Ruby&#160;allows&#160;parentheses&#160;to&#160;be&#160;omitted&#160;from&#160;most&#160;method&#160;invocations.&#160;In&#160;simple&#160;cases,<br/>this&#160;results&#160;in&#160;clean-looking&#160;code.&#160;In&#160;complex&#160;cases,&#160;however,&#160;it&#160;causes&#160;syntactic&#160;am-<br/>biguities and confusing corner cases. We’ll consider these in the sections that follow.<br/>
<b>6.3.1 &#160;Optional Parentheses<br/></b>Parentheses&#160;are&#160;omitted&#160;from&#160;method&#160;invocations&#160;in&#160;many&#160;common&#160;Ruby&#160;idioms.&#160;The<br/>following two lines of code, for example, are equivalent:<br/>
puts &#34;Hello World&#34;<br/>puts(&#34;Hello World&#34;)<br/>
In&#160;&#160;the&#160;&#160;first&#160;&#160;line,&#160;&#160;puts&#160;&#160;looks&#160;&#160;like&#160;&#160;a&#160;&#160;keyword,&#160;&#160;statement,&#160;&#160;or&#160;&#160;command&#160;&#160;built&#160;&#160;in&#160;&#160;to&#160;&#160;the<br/>language.&#160;The&#160;equivalent&#160;second&#160;line&#160;demonstrates&#160;that&#160;it&#160;is&#160;simply&#160;the&#160;invocation&#160;of<br/>a&#160;global&#160;method,&#160;with&#160;the&#160;parentheses&#160;omitted.&#160;Although&#160;the&#160;second&#160;form&#160;is&#160;clearer,<br/>the first form is more concise, more commonly used, and arguably more natural.<br/>Next, consider this code:<br/>
greeting = &#34;Hello&#34;<br/>size = greeting.length<br/>
If&#160;you&#160;are&#160;accustomed&#160;to&#160;other&#160;object-oriented&#160;languages,&#160;you&#160;may&#160;think&#160;that&#160;length<br/>is&#160;a&#160;property,&#160;field,&#160;or&#160;variable&#160;of&#160;string&#160;objects.&#160;Ruby&#160;is&#160;strongly&#160;object&#160;oriented,&#160;how-<br/>ever,&#160;and&#160;its&#160;objects&#160;are&#160;fully&#160;encapsulated;&#160;the&#160;only&#160;way&#160;to&#160;interact&#160;with&#160;them&#160;is&#160;by<br/>invoking&#160;their&#160;methods.&#160;In&#160;this&#160;code,&#160;greeting.length&#160;is&#160;a&#160;method&#160;invocation.&#160;The<br/>length&#160;&#160;method&#160;&#160;expects&#160;&#160;no&#160;&#160;arguments&#160;&#160;and&#160;&#160;is&#160;&#160;invoked&#160;&#160;without&#160;&#160;parentheses.&#160;&#160;The<br/>following code is equivalent:<br/>
size = greeting.length()<br/>
Including&#160;the&#160;optional&#160;parentheses&#160;emphasizes&#160;that&#160;a&#160;method&#160;invocation is occurring.<br/>Omitting&#160;the&#160;parentheses&#160;in&#160;method&#160;invocations&#160;with&#160;no&#160;arguments&#160;gives&#160;the&#160;illusion<br/>of property access, and is a very common practice.<br/>Parentheses&#160;are&#160;very&#160;commonly&#160;omitted&#160;when&#160;there&#160;are&#160;zero&#160;or&#160;one&#160;arguments&#160;to&#160;the<br/>invoked&#160;method.&#160;Although&#160;it&#160;is&#160;less&#160;common,&#160;the&#160;parentheses&#160;may&#160;be&#160;omitted&#160;even<br/>when there are multiple arguments, as in the following code:<br/>
x = 3 &#160; &#160; &#160; &#160; &#160; &#160; &#160;# x is a number<br/>x.between? 1,5 &#160; &#160; # same as x.between?(1,5)<br/>
Parentheses&#160;&#160;may&#160;&#160;also&#160;&#160;be&#160;&#160;omitted&#160;&#160;around&#160;&#160;the&#160;&#160;parameter&#160;&#160;list&#160;&#160;in&#160;&#160;method&#160;&#160;definitions,<br/>though&#160;it&#160;is&#160;hard&#160;to&#160;argue&#160;that&#160;this&#160;makes&#160;your&#160;code&#160;clearer&#160;or&#160;more&#160;readable.&#160;The<br/>following code, for example, defines a method that returns the sum of its arguments:<br/>
def sum x, y<br/>&#160; x+y<br/>end<br/>
<b>6.3 &#160;Methods and Parentheses&#160;|&#160;183</b><br/>
<hr/>
<a name=198></a><b>6.3.2 &#160;Required Parentheses<br/></b>Some&#160;code&#160;is&#160;ambiguous&#160;if&#160;the&#160;parentheses&#160;are&#160;omitted,&#160;and&#160;here&#160;Ruby&#160;requires&#160;that<br/>you&#160;include&#160;them.&#160;The&#160;most&#160;common&#160;case&#160;is&#160;nested&#160;method&#160;invocations&#160;of&#160;the&#160;form<br/>f g x, y.&#160;In&#160;Ruby,&#160;invocations&#160;of&#160;that&#160;form&#160;mean&#160;f(g(x,y)).&#160;Ruby&#160;1.8&#160;issues&#160;a&#160;warning,<br/>however,&#160;because&#160;the&#160;code&#160;could&#160;also&#160;be&#160;interpreted&#160;as&#160;f(g(x),y).&#160;The&#160;warning&#160;has<br/>been&#160;removed&#160;in&#160;Ruby&#160;1.9.&#160;The&#160;following&#160;code,&#160;using&#160;the&#160;sum&#160;method&#160;defined&#160;above,<br/>prints&#160;4, but issues a warning in Ruby 1.8:<br/>
puts sum 2, 2<br/>
To remove the warning, rewrite the code with parentheses around the arguments:<br/>
puts sum(2,2)<br/>
Note&#160;that&#160;using&#160;parentheses&#160;around&#160;the&#160;outer&#160;method&#160;invocation&#160;does&#160;not&#160;resolve&#160;the<br/>ambiguity:<br/>
puts(sum 2,2) &#160; # Does this mean puts(sum(2,2)) or puts(sum(2), 2)?<br/>
An&#160;expression&#160;involving&#160;nested&#160;function&#160;calls&#160;is&#160;only&#160;ambiguous&#160;when&#160;there&#160;is&#160;more<br/>than&#160;one&#160;argument.&#160;The&#160;Ruby&#160;interpreter&#160;can&#160;only&#160;interpret&#160;the&#160;following&#160;code&#160;in&#160;one<br/>way:<br/>
puts factorial x &#160; # This can only mean puts(factorial(x))<br/>
Despite&#160;&#160;the&#160;&#160;lack&#160;&#160;of&#160;&#160;ambiguity&#160;&#160;here,&#160;&#160;Ruby&#160;&#160;1.8&#160;&#160;still&#160;&#160;issues&#160;&#160;a&#160;&#160;warning&#160;&#160;if&#160;&#160;you&#160;&#160;omit&#160;&#160;the<br/>parentheses around the&#160;x.<br/>Sometimes&#160;omitting&#160;parentheses&#160;is&#160;a&#160;true&#160;syntax&#160;error&#160;rather&#160;than&#160;a&#160;simple&#160;warning.<br/>The&#160;following&#160;expressions,&#160;for&#160;example,&#160;are&#160;completely&#160;ambiguous&#160;without&#160;parenthe-<br/>ses, and Ruby doesn’t even attempt to guess what you mean:<br/>
puts 4, sum 2,2 &#160; # Error: does the second comma go with the 1st or 2nd method?<br/>[sum 2,2] &#160; &#160; &#160; &#160; # Error: two array elements or one?<br/>
There&#160;is&#160;another&#160;wrinkle&#160;that&#160;arises&#160;from&#160;the&#160;fact&#160;that&#160;parentheses&#160;are&#160;optional.&#160;When<br/>you&#160;<i>do</i>&#160;use&#160;parentheses&#160;in&#160;a&#160;method&#160;invocation,&#160;the&#160;opening&#160;parenthesis&#160;<i>must</i>&#160;imme-<br/>diately&#160;follow&#160;the&#160;method&#160;name,&#160;with&#160;no&#160;intervening&#160;space.&#160;This&#160;is&#160;because&#160;parentheses<br/>do&#160;double-duty:&#160;they&#160;can&#160;be&#160;used&#160;around&#160;an&#160;argument&#160;list&#160;in&#160;a&#160;method&#160;invocation,&#160;and<br/>they&#160;can&#160;be&#160;used&#160;for&#160;grouping&#160;expressions.&#160;Consider&#160;the&#160;following&#160;two&#160;expressions,<br/>which differ only by a single space:<br/>
square(2+2)*2 &#160; &#160;# square(4)*2 = 16*2 = 32<br/>square (2+2)*2 &#160; # square(4*2) = square(8) = 64<br/>
In&#160;the&#160;first&#160;expression,&#160;the&#160;parentheses&#160;represent&#160;method&#160;invocation.&#160;In&#160;the&#160;second,<br/>they&#160;represent&#160;expression&#160;grouping.&#160;To&#160;reduce&#160;the&#160;potential&#160;for&#160;confusion,&#160;you&#160;should<br/>always&#160;&#160;use&#160;&#160;parentheses&#160;&#160;around&#160;&#160;a&#160;&#160;method&#160;&#160;invocation&#160;&#160;if&#160;&#160;any&#160;&#160;of&#160;&#160;the&#160;&#160;arguments&#160;&#160;use<br/>parentheses. The second expression would be written more clearly as:<br/>
square((2+2)*2)<br/>
<b>184&#160;|&#160;Chapter 6:</b> <b>Methods, Procs, Lambdas, and Closures</b><br/>
<hr/>
<a name=199></a>We’ll&#160;end&#160;this&#160;discussion&#160;of&#160;parentheses&#160;with&#160;one&#160;final&#160;twist.&#160;Recall&#160;that&#160;the&#160;following<br/>expression is ambiguous and causes a warning:<br/>
puts(sum 2,2) &#160; # Does this mean puts(sum(2,2)) or puts(sum(2), 2)?<br/>
The&#160;best&#160;way&#160;to&#160;resolve&#160;this&#160;ambiguity&#160;is&#160;to&#160;put&#160;parentheses&#160;around&#160;the&#160;arguments&#160;to<br/>the&#160;&#160;sum&#160;&#160;method.&#160;&#160;Another&#160;&#160;way&#160;&#160;is&#160;&#160;to&#160;&#160;add&#160;&#160;a&#160;&#160;space&#160;&#160;between&#160;&#160;puts&#160;&#160;and&#160;&#160;the&#160;&#160;opening<br/>parenthesis:<br/>
puts (sum 2,2) &#160;&#160;<br/>
Adding&#160;the&#160;space&#160;converts&#160;the&#160;method&#160;invocation&#160;parentheses&#160;into&#160;expression&#160;grouping<br/>parentheses.&#160;&#160;Because&#160;&#160;these&#160;&#160;parentheses&#160;&#160;group&#160;&#160;a&#160;&#160;subexpression,&#160;&#160;the&#160;&#160;comma&#160;&#160;can&#160;&#160;no<br/>longer be interpreted as an argument delimiter for the&#160;puts&#160;invocation.<br/>
<b>6.4 &#160;Method Arguments<br/></b>Simple&#160;method&#160;declarations&#160;include&#160;a&#160;comma-separated&#160;list&#160;of&#160;argument&#160;names&#160;(in<br/>optional&#160;parentheses)&#160;after&#160;the&#160;method&#160;name.&#160;But&#160;there&#160;is&#160;much&#160;more&#160;to&#160;Ruby’s&#160;method<br/>arguments. The subsections that follow explain:<br/>
•&#160;How&#160;to&#160;declare&#160;an&#160;argument&#160;that&#160;has&#160;a&#160;default&#160;value,&#160;so&#160;that&#160;the&#160;argument&#160;can&#160;be<br/>
omitted when the method is invoked<br/>
•&#160;How to declare a method that accepts any number of arguments<br/>•&#160;How&#160;to&#160;simulate&#160;named&#160;method&#160;arguments&#160;with&#160;special&#160;syntax&#160;for&#160;passing&#160;a&#160;hash<br/>
to a method<br/>
•&#160;How&#160;to&#160;declare&#160;a&#160;method&#160;so&#160;that&#160;the&#160;block&#160;associated&#160;with&#160;an&#160;invocation&#160;of&#160;the<br/>
method is treated as a method argument<br/>
<b>6.4.1 &#160;Parameter Defaults<br/></b>When&#160;&#160;you&#160;&#160;define&#160;&#160;a&#160;&#160;method,&#160;&#160;you&#160;&#160;can&#160;&#160;specify&#160;&#160;default&#160;&#160;values&#160;&#160;for&#160;&#160;some&#160;&#160;or&#160;&#160;all&#160;&#160;of&#160;&#160;the<br/>parameters.&#160;If&#160;you&#160;do&#160;this,&#160;then&#160;your&#160;method&#160;may&#160;be&#160;invoked&#160;with&#160;fewer&#160;argument<br/>values&#160;than&#160;the&#160;declared&#160;number&#160;of&#160;parameters.&#160;If&#160;arguments&#160;are&#160;omitted,&#160;then&#160;the<br/>default value of the parameter is used in its place. Specify a default value by following<br/>the parameter name with an equals sign and a value:<br/>
def prefix(s, len=1)<br/>&#160; s[0,len]<br/>end<br/>
This&#160;method&#160;declares&#160;two&#160;parameters,&#160;but&#160;the&#160;second&#160;one&#160;has&#160;a&#160;default.&#160;This&#160;means<br/>that we can invoke it with either one argument or two:<br/>
prefix(&#34;Ruby&#34;, 3) &#160; &#160;# =&gt; &#34;Rub&#34;<br/>prefix(&#34;Ruby&#34;) &#160; &#160; &#160; # =&gt; &#34;R&#34;<br/>
<b>6.4 &#160;Method Arguments&#160;|&#160;185</b><br/>
<hr/>
<a name=200></a>Argument&#160;defaults&#160;need&#160;not&#160;be&#160;constants:&#160;they&#160;may&#160;be&#160;arbitrary&#160;expressions,&#160;and&#160;can<br/>refer&#160;to&#160;instance&#160;variables&#160;and&#160;to&#160;previous&#160;parameters&#160;in&#160;the&#160;parameter&#160;list.&#160;For&#160;exam-<br/>ple:<br/>
# Return the last character of s or the substring from index to the end<br/>def suffix(s, index=s.size-1)<br/>&#160; s[index, s.size-index]<br/>end<br/>
Parameter&#160;&#160;defaults&#160;&#160;are&#160;&#160;evaluated&#160;&#160;when&#160;&#160;a&#160;&#160;method&#160;&#160;is&#160;&#160;invoked&#160;&#160;rather&#160;&#160;than&#160;&#160;when&#160;&#160;it&#160;&#160;is<br/>parsed.&#160;In&#160;the&#160;following&#160;method,&#160;the&#160;default&#160;value&#160;[]&#160;produces&#160;a&#160;new&#160;empty&#160;array&#160;on<br/>each&#160;invocation,&#160;rather&#160;than&#160;reusing&#160;a&#160;single&#160;array&#160;created&#160;when&#160;the&#160;method&#160;is&#160;defined:<br/>
# Append the value x to the array a, return a.<br/># If no array is specified, start with an empty one.<br/>def append(x, a=[])<br/>&#160; a &lt;&lt; x<br/>end<br/>
In&#160;Ruby&#160;1.8,&#160;method&#160;parameters&#160;with&#160;default&#160;values&#160;must&#160;appear&#160;after&#160;all&#160;ordinary<br/>parameters&#160;in&#160;the&#160;parameter&#160;list.&#160;Ruby&#160;1.9&#160;relaxes&#160;this&#160;restriction&#160;and&#160;allows&#160;ordinary<br/>parameters&#160;to&#160;appear&#160;after&#160;parameters&#160;with&#160;defaults.&#160;It&#160;still&#160;requires&#160;all&#160;parameters&#160;with<br/>defaults&#160;to&#160;be&#160;adjacent&#160;in&#160;the&#160;parameter&#160;list—you&#160;can’t&#160;declare&#160;two&#160;parameters&#160;with<br/>default&#160;values&#160;with&#160;an&#160;ordinary&#160;parameter&#160;between&#160;them,&#160;for&#160;example.&#160;When&#160;a&#160;method<br/>has&#160;more&#160;than&#160;one&#160;parameter&#160;with&#160;a&#160;default&#160;value,&#160;and&#160;you&#160;invoke&#160;the&#160;method&#160;with&#160;an<br/>argument&#160;for&#160;some,&#160;but&#160;not&#160;all,&#160;of&#160;these&#160;parameters,&#160;they&#160;are&#160;filled&#160;in&#160;from&#160;left&#160;to&#160;right.<br/>Suppose&#160;a&#160;method&#160;has&#160;two&#160;parameters,&#160;and&#160;both&#160;of&#160;those&#160;parameters&#160;have&#160;defaults.<br/>You&#160;can&#160;invoke&#160;this&#160;method&#160;with&#160;zero,&#160;one,&#160;or&#160;two&#160;arguments.&#160;If&#160;you&#160;specify&#160;one&#160;ar-<br/>gument,&#160;it&#160;is&#160;assigned&#160;to&#160;the&#160;first&#160;parameter&#160;and&#160;the&#160;second&#160;parameter&#160;uses&#160;its&#160;default<br/>value.&#160;There&#160;is&#160;no&#160;way,&#160;however,&#160;to&#160;specify&#160;a&#160;value&#160;for&#160;the&#160;second&#160;parameter&#160;and&#160;use<br/>the default value of the first parameter.<br/>
<b>6.4.2 &#160;Variable-Length Argument Lists and Arrays<br/></b>Sometimes&#160;we&#160;want&#160;to&#160;write&#160;methods&#160;that&#160;can&#160;accept&#160;an&#160;arbitrary&#160;number&#160;of&#160;argu-<br/>ments.&#160;To&#160;do&#160;this,&#160;we&#160;put&#160;an&#160;*&#160;before&#160;one&#160;of&#160;the&#160;method’s&#160;parameters.&#160;Within&#160;the&#160;body<br/>of&#160;the&#160;method,&#160;this&#160;parameter&#160;will&#160;refer&#160;to&#160;an&#160;array&#160;that&#160;contains&#160;the&#160;zero&#160;or&#160;more<br/>arguments passed at that position. For example:<br/>
# Return the largest of the one or more arguments passed<br/>def max(first, *rest)<br/>&#160; # Assume that the required first argument is the largest<br/>&#160; max = first<br/>&#160; # Now loop through each of the optional arguments looking for bigger ones<br/>&#160; rest.each {|x| max = x if x &gt; max }<br/>&#160; # Return the largest one we found<br/>&#160; max<br/>end<br/>
<b>186&#160;|&#160;Chapter 6:</b> <b>Methods, Procs, Lambdas, and Closures</b><br/>
<hr/>
<a name=201></a>The&#160;max&#160;method&#160;requires&#160;at&#160;least&#160;one&#160;argument,&#160;but&#160;it&#160;may&#160;accept&#160;any&#160;number&#160;of&#160;ad-<br/>ditional&#160;arguments.&#160;The&#160;first&#160;argument&#160;is&#160;available&#160;through&#160;the&#160;first&#160;parameter. Any<br/>additional arguments are stored in the&#160;rest&#160;array. We can invoke&#160;max&#160;like this:<br/>
max(1) &#160; &#160; &#160; # first=1, rest=[] &#160;&#160;<br/>max(1,2) &#160; &#160; # first=1, rest=[2] &#160;<br/>max(1,2,3) &#160; # first=1, rest=[2,3]<br/>
Note&#160;&#160;that&#160;&#160;in&#160;&#160;Ruby,&#160;&#160;all&#160;&#160;Enumerable&#160;&#160;objects&#160;&#160;automatically&#160;&#160;have&#160;&#160;a&#160;&#160;max&#160;&#160;method,&#160;&#160;so&#160;&#160;the<br/>method defined here is not particularly useful.<br/>No&#160;more&#160;than&#160;one&#160;parameter&#160;may&#160;be&#160;prefixed&#160;with&#160;an&#160;*.&#160;In&#160;Ruby&#160;1.8,&#160;this&#160;parameter<br/>must&#160;appear&#160;after&#160;all&#160;ordinary&#160;parameters&#160;and&#160;after&#160;all&#160;parameters&#160;with&#160;defaults&#160;speci-<br/>fied.&#160;&#160;It&#160;&#160;should&#160;&#160;be&#160;&#160;the&#160;&#160;last&#160;&#160;parameter&#160;&#160;of&#160;&#160;the&#160;&#160;method,&#160;&#160;unless&#160;&#160;the&#160;&#160;method&#160;&#160;also&#160;&#160;has&#160;&#160;a<br/>parameter&#160;with&#160;an&#160;&amp;&#160;prefix&#160;(see&#160;below).&#160;In&#160;Ruby&#160;1.9,&#160;a&#160;parameter&#160;with&#160;an&#160;*&#160;prefix&#160;must<br/>still&#160;appear&#160;after&#160;any&#160;parameters&#160;with&#160;defaults&#160;specified,&#160;but&#160;it&#160;may&#160;be&#160;followed&#160;by<br/>additional&#160;&#160;ordinary&#160;&#160;parameters.&#160;&#160;It&#160;&#160;must&#160;&#160;also&#160;&#160;still&#160;&#160;appear&#160;&#160;before&#160;&#160;any&#160;&#160;&amp;-prefixed<br/>parameter.<br/>
<b>6.4.2.1 &#160;Passing arrays to methods<br/></b>We’ve&#160;seen&#160;how&#160;*&#160;can&#160;be&#160;used&#160;in&#160;a&#160;method&#160;declaration&#160;to&#160;cause&#160;multiple&#160;arguments&#160;to<br/>be&#160;gathered&#160;or&#160;coalesced&#160;into&#160;a&#160;single&#160;array.&#160;It&#160;can&#160;also&#160;be&#160;used&#160;in&#160;a&#160;method&#160;invocation<br/>to&#160;scatter,&#160;expand,&#160;or&#160;explode&#160;the&#160;elements&#160;of&#160;an&#160;array&#160;(or&#160;range&#160;or&#160;enumerator)&#160;so&#160;that<br/>each&#160;element&#160;becomes&#160;a&#160;separate&#160;method&#160;argument.&#160;The&#160;*&#160;is&#160;sometimes&#160;called&#160;the&#160;splat<br/>operator,&#160;although&#160;it&#160;is&#160;not&#160;a&#160;true&#160;operator.&#160;We’ve&#160;seen&#160;it&#160;used&#160;before&#160;in&#160;the&#160;discussion<br/><a href="Rubys.html#111">of parallel assignment in §4.5.5.<br/></a>Suppose&#160;we&#160;wanted&#160;to&#160;find&#160;the&#160;maximum&#160;value&#160;in&#160;an&#160;array&#160;(and&#160;that&#160;we&#160;didn’t&#160;know<br/>that&#160;Ruby&#160;arrays&#160;have&#160;a&#160;built-in&#160;max&#160;method!).&#160;We&#160;could&#160;pass&#160;the&#160;elements&#160;of&#160;the&#160;array<br/>to the&#160;max&#160;method (defined earlier) like this:<br/>
data = [3, 2, 1]<br/>m = max(*data) &#160; # first = 3, rest=[2,1] =&gt; 3<br/>
Consider what happens without the&#160;*:<br/>
m = max(data) &#160; # first = [3,2,1], rest=[] =&gt; [3,2,1]<br/>
In&#160;this&#160;case,&#160;we’re&#160;passing&#160;an&#160;array&#160;as&#160;the&#160;first&#160;and&#160;only&#160;argument,&#160;and&#160;our&#160;max&#160;method<br/>returns that first argument without performing any comparisons on it.<br/>The&#160;*&#160;can&#160;also&#160;be&#160;used&#160;with&#160;methods&#160;that&#160;return&#160;arrays&#160;to&#160;expand&#160;those&#160;arrays&#160;for&#160;use<br/>in&#160;&#160;another&#160;&#160;method&#160;&#160;invocation.&#160;&#160;Consider&#160;&#160;the&#160;&#160;polar&#160;&#160;and&#160;&#160;cartesian&#160;&#160;methods&#160;&#160;defined<br/>earlier in this chapter:<br/>
# Convert the point (x,y) to Polar coordinates, then back to Cartesian<br/>x,y = cartesian(*polar(x, y))<br/>
In&#160;Ruby&#160;1.9,&#160;enumerators&#160;are&#160;splattable&#160;objects.&#160;To&#160;find&#160;the&#160;largest&#160;letter&#160;in&#160;a&#160;string,<br/>for example, we could write:<br/>
max(*&#34;hello world&#34;.each_char) &#160;# =&gt; 'w'<br/>
<b>6.4 &#160;Method Arguments&#160;|&#160;187</b><br/>
<hr/>
<a name=202></a><b>6.4.3 &#160;Mapping Arguments to Parameters<br/></b>When&#160;a&#160;method&#160;definition&#160;includes&#160;parameters&#160;with&#160;default&#160;values&#160;or&#160;a&#160;parameter&#160;pre-<br/>fixed&#160;&#160;with&#160;&#160;an&#160;&#160;*,&#160;&#160;the&#160;&#160;assignment&#160;&#160;of&#160;&#160;argument&#160;&#160;values&#160;&#160;to&#160;&#160;parameters&#160;&#160;during&#160;&#160;method<br/>invocation gets a little bit tricky.<br/>In&#160;Ruby&#160;1.8,&#160;the&#160;position&#160;of&#160;the&#160;special&#160;parameters&#160;is&#160;restricted&#160;so&#160;that&#160;argument&#160;values<br/>are&#160;assigned&#160;to&#160;parameters&#160;from&#160;left&#160;to&#160;right.&#160;The&#160;first&#160;arguments&#160;are&#160;assigned&#160;to&#160;the<br/>ordinary&#160;parameters.&#160;If&#160;there&#160;are&#160;any&#160;remaining&#160;arguments,&#160;they&#160;are&#160;assigned&#160;to&#160;the<br/>parameters&#160;that&#160;have&#160;defaults.&#160;And&#160;if&#160;there&#160;are&#160;still&#160;more&#160;arguments,&#160;they&#160;are&#160;assigned<br/>to the array argument.<br/>Ruby&#160;1.9&#160;has&#160;to&#160;be&#160;more&#160;clever&#160;about&#160;the&#160;way&#160;it&#160;maps&#160;arguments&#160;to&#160;parameters&#160;because<br/>the&#160;order&#160;of&#160;the&#160;parameters&#160;is&#160;no&#160;longer&#160;constrained.&#160;Suppose&#160;we&#160;have&#160;a&#160;method&#160;that<br/>is&#160;declared&#160;with&#160;o&#160;ordinary&#160;parameters,&#160;d&#160;parameters&#160;with&#160;default&#160;values,&#160;and&#160;one&#160;array<br/>parameter&#160;prefixed&#160;with&#160;*,&#160;and&#160;that&#160;these&#160;parameters&#160;appear&#160;in&#160;some&#160;arbitrary&#160;order.<br/>Now assume that we invoke this method with&#160;a&#160;arguments.<br/>If&#160;&#160;a&#160;&#160;is&#160;&#160;less&#160;&#160;than&#160;&#160;o,&#160;&#160;an&#160;&#160;ArgumentError&#160;&#160;is&#160;&#160;raised;&#160;&#160;we&#160;&#160;have&#160;&#160;not&#160;&#160;supplied&#160;&#160;the&#160;&#160;minimum<br/>required number of arguments.<br/>If&#160;a&#160;is&#160;greater&#160;than&#160;or&#160;equal&#160;to&#160;o&#160;and&#160;less&#160;than&#160;or&#160;equal&#160;to&#160;o+d,&#160;then&#160;the&#160;leftmost&#160;a–o<br/>parameters&#160;with&#160;defaults&#160;will&#160;have&#160;arguments&#160;assigned&#160;to&#160;them.&#160;The&#160;remaining&#160;(to&#160;the<br/>right)&#160;o+d–a&#160;parameters&#160;with&#160;defaults&#160;will&#160;not&#160;have&#160;arguments&#160;assigned&#160;to&#160;them,&#160;and<br/>will just use their default values.<br/>If&#160;a&#160;is&#160;greater&#160;than&#160;o+d,&#160;then&#160;the&#160;array&#160;parameter&#160;whose&#160;name&#160;is&#160;prefixed&#160;with&#160;an&#160;*&#160;will<br/>have&#160;a–o–d&#160;arguments stored in it; otherwise, it will be empty.<br/>Once&#160;these&#160;calculations&#160;are&#160;performed,&#160;the&#160;arguments&#160;are&#160;mapped&#160;to&#160;parameters&#160;from<br/>left to right, assigning the appropriate number of arguments to each parameter.<br/>
<b>6.4.4 &#160;Hashes for Named Arguments<br/></b>When a method&#160;requires&#160;more&#160;than&#160;two&#160;or&#160;three&#160;arguments,&#160;it&#160;can&#160;be&#160;difficult&#160;for&#160;the<br/>programmer&#160;invoking&#160;the&#160;method&#160;to&#160;remember&#160;the&#160;proper&#160;order&#160;for&#160;those&#160;arguments.<br/>Some&#160;languages&#160;allow&#160;you&#160;to&#160;write&#160;method&#160;invocations&#160;that&#160;explicitly&#160;specify&#160;a&#160;pa-<br/>rameter&#160;name&#160;for&#160;each&#160;argument&#160;that&#160;is&#160;passed.&#160;Ruby&#160;does&#160;not&#160;support&#160;this&#160;method<br/>invocation&#160;syntax,&#160;but&#160;it&#160;can&#160;be&#160;approximated&#160;if&#160;you&#160;write&#160;a&#160;method&#160;that&#160;expects&#160;a&#160;hash<br/>as its argument or as one of its arguments:<br/>
# This method returns an array a of n numbers. For any index i, 0 &lt;= i &lt; n,<br/># the value of element a[i] is m*i+c. Arguments n, m, and c are passed<br/># as keys in a hash, so that it is not necessary to remember their order.<br/>def sequence(args)<br/>&#160; # Extract the arguments from the hash.<br/>&#160; # Note the use of the || operator to specify defaults used<br/>&#160; # if the hash does not define a key that we are interested in.<br/>&#160; n = args[:n] || 0<br/>&#160; m = args[:m] || 1<br/>
<b>188&#160;|&#160;Chapter 6:</b> <b>Methods, Procs, Lambdas, and Closures</b><br/>
<hr/>
<a name=203></a>&#160; c = args[:c] || 0<br/>
&#160; a = [] &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Start with an empty array<br/>&#160; n.times {|i| a &lt;&lt; m*i+c } &#160; # Calculate the value of each array element<br/>&#160; a &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Return the array<br/>end<br/>
You might invoke this method with a hash literal argument like this:<br/>
sequence({:n=&gt;3, :m=&gt;5}) &#160; &#160; &#160;# =&gt; [0, 5, 10]<br/>
In&#160;order&#160;to&#160;better&#160;support&#160;this&#160;style&#160;of&#160;programming,&#160;Ruby&#160;allows&#160;you&#160;to&#160;omit&#160;the&#160;curly<br/>braces&#160;around&#160;the&#160;hash&#160;literal&#160;if&#160;it&#160;is&#160;the&#160;last&#160;argument&#160;to&#160;the&#160;method&#160;(or&#160;if&#160;the&#160;only<br/>argument&#160;that&#160;follows&#160;it&#160;is&#160;a&#160;block&#160;argument,&#160;prefixed&#160;with&#160;&amp;).&#160;A&#160;hash&#160;without&#160;braces<br/>is&#160;sometimes&#160;called&#160;a&#160;<i>bare&#160;hash</i>,&#160;and&#160;when&#160;we&#160;use&#160;one&#160;it&#160;looks&#160;like&#160;we&#160;are&#160;passing<br/>separate named arguments, which we can reorder however we like:<br/>
sequence(:m=&gt;3, :n=&gt;5) &#160; &#160; &#160; &#160;# =&gt; [0, 3, 6, 9, 12]<br/>
As with other ruby methods, we can omit the parentheses, too:<br/>
# Ruby 1.9 hash syntax<br/>sequence c:1, m:3, n:5 &#160; &#160; &#160; &#160;# =&gt; [1, 4, 7, 10, 13]<br/>
If&#160;you&#160;omit&#160;the&#160;parentheses,&#160;then&#160;you&#160;<i>must</i>&#160;omit&#160;the&#160;curly&#160;braces.&#160;If&#160;curly&#160;braces&#160;follow<br/>the&#160;method&#160;name&#160;outside&#160;of&#160;parentheses,&#160;Ruby&#160;thinks&#160;you’re&#160;passing&#160;a&#160;block&#160;to&#160;the<br/>method:<br/>
sequence {:m=&gt;3, :n=&gt;5} &#160; &#160; &#160; # Syntax error!<br/>
<b>6.4.5 &#160;Block Arguments<br/></b>Recall from&#160;<a href="Rubys.html#144">§5.3&#160;</a>that&#160;a&#160;block&#160;is&#160;a&#160;chunk&#160;of&#160;Ruby&#160;code&#160;associated&#160;with&#160;a&#160;method&#160;invo-<br/>cation,&#160;and&#160;that&#160;an&#160;iterator&#160;is&#160;a&#160;method&#160;that&#160;expects&#160;a&#160;block.&#160;Any&#160;method&#160;invocation<br/>may&#160;be&#160;followed&#160;by&#160;a&#160;block,&#160;and&#160;any&#160;method&#160;that&#160;has&#160;a&#160;block&#160;associated&#160;with&#160;it&#160;may<br/>invoke&#160;the&#160;code&#160;in&#160;that&#160;block&#160;with&#160;the&#160;yield&#160;statement.&#160;To&#160;refresh&#160;your&#160;memory,&#160;the<br/>following&#160;code&#160;is&#160;a&#160;block-oriented&#160;variant&#160;on&#160;the&#160;sequence&#160;method&#160;developed&#160;earlier&#160;in<br/>the chapter:<br/>
# Generate a sequence of n numbers m*i + c and pass them to the block<br/>def sequence2(n, m, c)&#160;<br/>&#160; i = 0<br/>&#160; while(i &lt; n) &#160; &#160; &#160; &#160; # loop n times<br/>&#160; &#160; yield i*m + c &#160; &#160; &#160;# pass next element of the sequence to the block<br/>&#160; &#160; i += 1<br/>&#160; end<br/>end<br/>
# Here is how you might use this version of the method<br/>sequence2(5, 2, 2) {|x| puts x } &#160;# Print numbers 2, 4, 6, 8, 10<br/>
One&#160;of&#160;the&#160;features&#160;of&#160;blocks&#160;is&#160;their&#160;anonymity.&#160;They&#160;are&#160;not&#160;passed&#160;to&#160;the&#160;method&#160;in<br/>a&#160;traditional&#160;sense,&#160;they&#160;have&#160;no&#160;name,&#160;and&#160;they&#160;are&#160;invoked&#160;with&#160;a&#160;keyword&#160;rather<br/>than&#160;with&#160;a&#160;method.&#160;If&#160;you&#160;prefer&#160;more&#160;explicit&#160;control&#160;over&#160;a&#160;block&#160;(so&#160;that&#160;you&#160;can<br/>
<b>6.4 &#160;Method Arguments&#160;|&#160;189</b><br/>
<hr/>
<a name=204></a>pass&#160;it&#160;on&#160;to&#160;some&#160;other&#160;method,&#160;for&#160;example),&#160;add&#160;a&#160;final&#160;argument&#160;to&#160;your&#160;method,<br/>and&#160;prefix&#160;the&#160;argument&#160;name&#160;with&#160;an&#160;ampersand.*&#160;&#160;If&#160;you&#160;do&#160;this,&#160;then&#160;that&#160;argument<br/>will&#160;refer&#160;to&#160;the&#160;block—if&#160;any—that&#160;is&#160;passed&#160;to&#160;the&#160;method.&#160;The&#160;value&#160;of&#160;the&#160;argument<br/>will&#160;be&#160;a&#160;Proc&#160;object,&#160;and&#160;instead&#160;of&#160;using&#160;yield,&#160;you&#160;invoke&#160;the&#160;call&#160;method&#160;of&#160;the&#160;Proc:<br/>
def sequence3(n, m, c, &amp;b) # Explicit argument to get block as a Proc<br/>&#160; i = 0<br/>&#160; while(i &lt; n)<br/>&#160; &#160; b.call(i*m + c) &#160; &#160; &#160; &#160;# Invoke the Proc with its call method<br/>&#160; &#160; i += 1<br/>&#160; end<br/>end<br/>
# Note that the block is still passed outside of the parentheses<br/>sequence3(5, 2, 2) {|x| puts x }<br/>
Notice that using the ampersand in this way changes only the method definition. The<br/>method&#160;&#160;invocation&#160;&#160;remains&#160;&#160;the&#160;&#160;same.&#160;&#160;We&#160;&#160;end&#160;&#160;up&#160;&#160;with&#160;&#160;the&#160;&#160;block&#160;&#160;argument&#160;&#160;being<br/>declared&#160;inside&#160;the&#160;parentheses&#160;of&#160;the&#160;method&#160;definition,&#160;but&#160;the&#160;block&#160;itself&#160;is&#160;still<br/>specified outside the parentheses of the method invocation.<br/>
<b>Passing Proc Objects Explicitly</b><br/>
If&#160;you&#160;create&#160;your&#160;own&#160;Proc&#160;object&#160;(we’ll&#160;see&#160;how&#160;to&#160;do&#160;this&#160;later&#160;in&#160;the&#160;chapter)&#160;and<br/>want&#160;to&#160;pass&#160;it&#160;explicitly&#160;to&#160;a&#160;method,&#160;you&#160;can&#160;do&#160;this&#160;as&#160;you&#160;would&#160;pass&#160;any&#160;other<br/>value—a&#160;Proc&#160;is&#160;an&#160;object&#160;like&#160;any&#160;other.&#160;In&#160;this&#160;case,&#160;you&#160;should&#160;not&#160;use&#160;an&#160;ampersand<br/>in the method definition:<br/>
# This version expects an explicitly-created Proc object, not a block<br/>def sequence4(n, m, c, b) &#160;# No ampersand used for argument b<br/>&#160; i = 0<br/>&#160; while(i &lt; n)<br/>&#160; &#160; b.call(i*m + c) &#160; &#160; &#160; &#160;# Proc is called explicitly<br/>&#160; &#160; i += 1<br/>&#160; end<br/>end<br/>
p = Proc.new {|x| puts x } &#160;# Explicitly create a Proc object&#160;<br/>sequence4(5, 2, 2, p) &#160; &#160; &#160; # And pass it as an ordinary argument<br/>
Twice&#160;before&#160;in&#160;this&#160;chapter,&#160;we’ve&#160;said&#160;that&#160;a&#160;special&#160;kind&#160;of&#160;parameter&#160;must&#160;be&#160;the<br/>last&#160;one&#160;in&#160;the&#160;parameter&#160;list.&#160;Block&#160;arguments&#160;prefixed&#160;with&#160;ampersands&#160;must&#160;<i>really<br/></i>be&#160;the&#160;last&#160;one.&#160;Because&#160;blocks&#160;are&#160;passed&#160;unusually&#160;in&#160;method&#160;invocations,&#160;named<br/>block&#160;arguments&#160;are&#160;different&#160;and&#160;do&#160;not&#160;interfere&#160;with&#160;array&#160;or&#160;hash&#160;parameters&#160;in<br/>which&#160;the&#160;brackets&#160;and&#160;braces&#160;have&#160;been&#160;omitted.&#160;The&#160;following&#160;two&#160;methods&#160;are&#160;legal,<br/>for example:<br/>
*&#160;We&#160;use&#160;the&#160;term&#160;“block&#160;argument”&#160;instead&#160;of&#160;“block&#160;parameter”&#160;for&#160;method&#160;parameters&#160;prefixed&#160;with&#160;&amp;.<br/>
This is because the phrase “block parameter” refers to the parameter list (such as&#160;|x|) of the block itself.<br/>
<b>190&#160;|&#160;Chapter 6:</b> <b>Methods, Procs, Lambdas, and Closures</b><br/>
<hr/>
<a name=205></a>def sequence5(args, &amp;b) # Pass arguments as a hash and follow with a block<br/>&#160; n, m, c = args[:n], args[:m], args[:c]<br/>&#160; i = 0<br/>&#160; while(i &lt; n)<br/>&#160; &#160; b.call(i*m + c)<br/>&#160; &#160; i += 1<br/>&#160; end<br/>end<br/>
# Expects one or more arguments, followed by a block<br/>def max(first, *rest, &amp;block)&#160;<br/>&#160; max = first<br/>&#160; rest.each {|x| max = x if x &gt; max }<br/>&#160; block.call(max)<br/>&#160; max<br/>end<br/>
These&#160;methods&#160;work&#160;fine,&#160;but&#160;notice&#160;that&#160;you&#160;can&#160;avoid&#160;the&#160;complexity&#160;of&#160;these&#160;cases<br/>by simply leaving your blocks anonymous and calling them with&#160;yield.<br/>It&#160;is&#160;also&#160;worth&#160;noting&#160;that&#160;the&#160;yield&#160;statement&#160;still&#160;works&#160;in&#160;a&#160;method&#160;defined&#160;with&#160;an<br/>&amp;&#160;parameter.&#160;Even&#160;if&#160;the&#160;block&#160;has&#160;been&#160;converted&#160;to&#160;a&#160;Proc&#160;object&#160;and&#160;passed&#160;as&#160;an<br/>argument,&#160;it&#160;can&#160;still&#160;be&#160;invoked&#160;as&#160;an&#160;anonymous&#160;block,&#160;as&#160;if&#160;the&#160;block&#160;argument&#160;was<br/>not there.<br/>
<b>6.4.5.1 &#160;Using &amp; in method invocation<br/></b>We&#160;saw&#160;earlier&#160;that&#160;you&#160;can&#160;use&#160;*&#160;in&#160;a&#160;method&#160;definition&#160;to&#160;specify&#160;that&#160;multiple&#160;argu-<br/>ments&#160;should&#160;be&#160;packed&#160;into&#160;an&#160;array,&#160;and&#160;that&#160;you&#160;can&#160;use&#160;*&#160;in a method invocation<br/>to&#160;&#160;specify&#160;&#160;that&#160;&#160;an&#160;&#160;array&#160;&#160;should&#160;&#160;be&#160;&#160;unpacked&#160;&#160;so&#160;&#160;that&#160;&#160;its&#160;&#160;elements&#160;&#160;become&#160;&#160;separate<br/>arguments.&#160;&amp;&#160;can&#160;also&#160;be&#160;used&#160;in&#160;definitions&#160;and&#160;invocations.&#160;We’ve&#160;just&#160;seen&#160;that&#160;&amp;&#160;in<br/>a&#160;method&#160;definition&#160;allows&#160;an&#160;ordinary&#160;block&#160;associated&#160;with&#160;a&#160;method&#160;invocation&#160;to<br/>be&#160;used&#160;as&#160;a&#160;named&#160;Proc&#160;object&#160;inside&#160;the&#160;method.&#160;When&#160;&amp;&#160;is&#160;used&#160;before&#160;a&#160;Proc&#160;object<br/>in&#160;a&#160;method&#160;invocation,&#160;it&#160;treats&#160;the&#160;Proc&#160;as&#160;if&#160;it&#160;was&#160;an&#160;ordinary&#160;block&#160;following&#160;the<br/>invocation.<br/>Consider the following code which sums the contents of two arrays:<br/>
a, b = [1,2,3], [4,5] &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Start with some data.<br/>sum = a.inject(0) {|total,x| total+x } &#160; &#160;# =&gt; 6. Sum elements of a.<br/>sum = b.inject(sum) {|total,x| total+x } &#160;# =&gt; 15. Add the elements of b in.<br/>
We&#160;described&#160;the&#160;inject&#160;iterator&#160;earlier&#160;<a href="Rubys.html#146">in&#160;§5.3.2.&#160;</a>If&#160;you&#160;don’t&#160;remember,&#160;you&#160;can&#160;look<br/>up&#160;its&#160;documentation&#160;with&#160;ri Enumerable.inject.&#160;The&#160;important&#160;thing&#160;to&#160;notice&#160;about<br/>this&#160;example&#160;is&#160;that&#160;the&#160;two&#160;blocks&#160;are&#160;identical.&#160;Rather&#160;than&#160;having&#160;the&#160;Ruby&#160;inter-<br/>preter&#160;parse&#160;the&#160;same&#160;block&#160;twice,&#160;we&#160;can&#160;create&#160;a&#160;Proc&#160;to&#160;represent&#160;the&#160;block,&#160;and&#160;use<br/>the single&#160;Proc&#160;object twice:<br/>
a, b = [1,2,3], [4,5] &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Start with some data.<br/>summation = Proc.new {|total,x| total+x } # A Proc object for summations.<br/>sum = a.inject(0, &amp;summation) &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; 6<br/>sum = b.inject(sum, &amp;summation) &#160; &#160; &#160; &#160; &#160; # =&gt; 15<br/>
<b>6.4 &#160;Method Arguments&#160;|&#160;191</b><br/>
<hr/>
<a name=206></a>If&#160;you&#160;use&#160;&amp;&#160;in&#160;a&#160;method&#160;invocation,&#160;it&#160;must&#160;appear&#160;before&#160;the&#160;last&#160;argument&#160;in&#160;the<br/>invocation.&#160;Blocks&#160;can&#160;be&#160;associated&#160;with&#160;any&#160;method&#160;call,&#160;even&#160;when&#160;the&#160;method&#160;is<br/>not expecting a block, and never uses&#160;yield. In the same way, any method invocation<br/>may have an&#160;&amp;&#160;argument as its last argument.<br/>In&#160;a&#160;method&#160;invocation&#160;an&#160;&amp;&#160;typically&#160;appears&#160;before&#160;a&#160;Proc&#160;object.&#160;But&#160;it&#160;is&#160;actually<br/>allowed&#160;before&#160;any&#160;object&#160;with&#160;a&#160;to_proc&#160;method.&#160;The&#160;Method&#160;class&#160;(covered&#160;later&#160;in<br/>this&#160;chapter)&#160;has&#160;such&#160;a&#160;method,&#160;so&#160;Method&#160;objects&#160;can&#160;be&#160;passed&#160;to&#160;iterators&#160;just&#160;as<br/>Proc&#160;objects can.<br/>
In&#160;Ruby&#160;1.9,&#160;the&#160;Symbol&#160;class&#160;defines&#160;a&#160;to_proc&#160;method,&#160;allowing&#160;symbols&#160;to&#160;be&#160;prefixed<br/>with&#160;&amp;&#160;and&#160;passed&#160;to&#160;iterators.&#160;When&#160;a&#160;symbol&#160;is&#160;passed&#160;like&#160;this,&#160;it&#160;is&#160;assumed&#160;to&#160;be<br/>the&#160;name&#160;of&#160;a&#160;method.&#160;The&#160;Proc&#160;object&#160;returned&#160;by&#160;the&#160;to_proc&#160;method&#160;invokes&#160;the<br/>named&#160;method&#160;of&#160;its&#160;first&#160;argument,&#160;passing&#160;any&#160;remaining&#160;arguments&#160;to&#160;that&#160;named<br/>method.&#160;The&#160;canonical&#160;case&#160;is&#160;this:&#160;given&#160;an&#160;array&#160;of&#160;strings,&#160;create&#160;a&#160;new&#160;array&#160;of&#160;those<br/>strings,&#160;converted&#160;to&#160;uppercase.&#160;Symbol.to_proc&#160;allows&#160;us&#160;to&#160;accomplish&#160;this&#160;elegantly<br/>as follows:<br/>
words = ['and', 'but', 'car'] &#160; &#160; # An array of words<br/>uppercase = words.map &amp;:upcase &#160; &#160;# Convert to uppercase with String.upcase<br/>upper = words.map {|w| w.upcase } # This is the equivalent code with a block<br/>
<b>6.5 &#160;Procs and Lambdas<br/></b>Blocks&#160;are&#160;syntactic&#160;structures&#160;in&#160;Ruby;&#160;they&#160;are&#160;not&#160;objects,&#160;and&#160;cannot&#160;be&#160;manipulated<br/>as&#160;objects.&#160;It&#160;is&#160;possible,&#160;however,&#160;to&#160;create&#160;an&#160;object&#160;that&#160;represents&#160;a&#160;block.&#160;Depending<br/>on&#160;&#160;how&#160;&#160;the&#160;&#160;object&#160;&#160;is&#160;&#160;created,&#160;&#160;it&#160;&#160;is&#160;&#160;called&#160;&#160;a&#160;&#160;<i>proc</i>&#160;&#160;or&#160;&#160;a&#160;&#160;<i>lambda</i>.&#160;&#160;Procs&#160;&#160;have&#160;&#160;block-like<br/>behavior&#160;and&#160;lambdas&#160;have&#160;method-like&#160;behavior.&#160;Both,&#160;however,&#160;are&#160;instances&#160;of&#160;class<br/>Proc.<br/>
The subsections that follow explain:<br/>
•&#160;How to create&#160;Proc&#160;objects in both proc and lambda forms<br/>•&#160;How to invoke&#160;Proc&#160;objects<br/>•&#160;How to determine how many arguments a&#160;Proc&#160;expects<br/>•&#160;How to determine if two&#160;Proc&#160;objects are the same<br/>•&#160;How procs and lambdas differ from each other<br/>
<b>6.5.1 &#160;Creating Procs<br/></b>We’ve&#160;already&#160;seen&#160;one&#160;way&#160;to&#160;create&#160;a&#160;Proc&#160;object:&#160;by&#160;associating&#160;a&#160;block&#160;with&#160;a&#160;method<br/>that&#160;is&#160;defined&#160;with&#160;an&#160;ampersand-prefixed&#160;block&#160;argument.&#160;There&#160;is&#160;nothing&#160;prevent-<br/>ing such a method from returning the&#160;Proc&#160;object for use outside the method:<br/>
# This method creates a proc from a block<br/>def makeproc(&amp;p) &#160;# Convert associated block to a Proc and store in p<br/>
<b>192&#160;|&#160;Chapter 6:</b> <b>Methods, Procs, Lambdas, and Closures</b><br/>
<hr/>
<a name=207></a>&#160; p &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Return the Proc object<br/>end<br/>
With a&#160;makeproc&#160;method like this defined, we can create a&#160;Proc&#160;object for ourselves:<br/>
adder = makeproc {|x,y| x+y }<br/>
The&#160;variable&#160;adder&#160;now&#160;refers&#160;to&#160;a&#160;Proc&#160;object.&#160;Proc&#160;objects&#160;created&#160;in&#160;this&#160;way&#160;are&#160;procs,<br/>not&#160;lambdas.&#160;All&#160;Proc&#160;objects&#160;have&#160;a&#160;call&#160;method&#160;that,&#160;when&#160;invoked,&#160;runs&#160;the&#160;code<br/>contained by the block from which the proc was created. For example:<br/>
sum = adder.call(2,2) &#160;# =&gt; 4<br/>
In&#160;addition&#160;to&#160;being&#160;invoked,&#160;Proc&#160;objects&#160;can&#160;be&#160;passed&#160;to&#160;methods,&#160;stored&#160;in&#160;data<br/>structures and otherwise manipulated like any other Ruby object.<br/>As&#160;well&#160;as&#160;creating&#160;procs&#160;by&#160;method&#160;invocation,&#160;there&#160;are&#160;three&#160;methods&#160;that&#160;create<br/>Proc&#160;objects&#160;(both&#160;procs&#160;and&#160;lambdas)&#160;in&#160;Ruby.&#160;These&#160;methods&#160;are&#160;commonly&#160;used,<br/>and&#160;it&#160;is&#160;not&#160;actually&#160;necessary&#160;to&#160;define&#160;a&#160;makeproc&#160;method&#160;like&#160;the&#160;one&#160;shown&#160;earlier.<br/>In&#160;addition&#160;to&#160;these&#160;Proc-creation&#160;methods,&#160;Ruby&#160;1.9&#160;also&#160;supports&#160;a&#160;new&#160;literal&#160;syntax<br/>for&#160;&#160;defining&#160;&#160;lambdas.&#160;&#160;The&#160;&#160;subsections&#160;&#160;that&#160;&#160;follow&#160;&#160;discuss&#160;&#160;the&#160;&#160;methods&#160;&#160;Proc.new,<br/>lambda, and&#160;proc, and also explain the Ruby 1.9 lambda literal syntax.<br/>
<b>6.5.1.1 &#160;Proc.new<br/></b>We’ve&#160;already&#160;seen&#160;Proc.new&#160;used&#160;in&#160;some&#160;of&#160;the&#160;previous&#160;examples&#160;in&#160;this&#160;chapter.<br/>This&#160;is&#160;the&#160;normal&#160;new&#160;method&#160;that&#160;most&#160;classes&#160;support,&#160;and&#160;it’s&#160;the&#160;most&#160;obvious&#160;way<br/>to&#160;create&#160;a&#160;new&#160;instance&#160;of&#160;the&#160;Proc&#160;class.&#160;Proc.new&#160;expects&#160;no&#160;arguments,&#160;and&#160;returns<br/>a&#160;Proc&#160;object&#160;that&#160;is&#160;a&#160;proc&#160;(not&#160;a&#160;lambda).&#160;When&#160;you&#160;invoke&#160;Proc.new&#160;with&#160;an&#160;associated<br/>block, it returns a proc that represents the block. For example:<br/>
p = Proc.new {|x,y| x+y }<br/>
If&#160;Proc.new&#160;is&#160;invoked&#160;without&#160;a&#160;block&#160;from&#160;within&#160;a&#160;method&#160;that&#160;does&#160;have&#160;an&#160;asso-<br/>ciated&#160;block,&#160;then&#160;it&#160;returns&#160;a&#160;proc&#160;representing&#160;the&#160;block&#160;associated&#160;with&#160;the&#160;containing<br/>method.&#160;Using&#160;Proc.new&#160;in&#160;this&#160;way&#160;provides&#160;an&#160;alternative&#160;to&#160;using&#160;an&#160;ampersand-<br/>prefixed&#160;&#160;block&#160;&#160;argument&#160;&#160;in&#160;&#160;a&#160;&#160;method&#160;&#160;definition.&#160;&#160;The&#160;&#160;following&#160;&#160;two&#160;&#160;methods&#160;&#160;are<br/>equivalent, for example:<br/>
def invoke(&amp;b) &#160; &#160; def invoke<br/>&#160; b.call &#160; &#160; &#160; &#160; &#160; &#160; Proc.new.call<br/>end &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;end<br/>
<b>6.5.1.2 &#160;Kernel.lambda<br/></b>Another&#160;&#160;technique&#160;&#160;for&#160;&#160;creating&#160;&#160;Proc&#160;&#160;objects&#160;&#160;is&#160;&#160;with&#160;&#160;the&#160;&#160;lambda&#160;&#160;method.&#160;&#160;lambda&#160;&#160;is&#160;&#160;a<br/>method&#160;of&#160;the&#160;Kernel&#160;module,&#160;so&#160;it&#160;behaves&#160;like&#160;a&#160;global&#160;function.&#160;As&#160;its&#160;name&#160;suggests,<br/>the&#160;Proc&#160;object&#160;returned&#160;by&#160;this&#160;method&#160;is&#160;a&#160;lambda&#160;rather&#160;than&#160;a&#160;proc.&#160;lambda&#160;expects<br/>no arguments, but there must be a block associated with the invocation:<br/>
is_positive = lambda {|x| x &gt; 0 }<br/>
<b>6.5 &#160;Procs and Lambdas&#160;|&#160;193</b><br/>
<hr/>
<a name=208></a><b>Lambda History</b><br/>
Lambdas&#160;and&#160;the&#160;lambda&#160;method&#160;are&#160;so&#160;named&#160;in&#160;reference&#160;to&#160;<i>lambda&#160;calculus</i>,&#160;a&#160;branch<br/>of&#160;mathematical&#160;logic&#160;that&#160;has&#160;been&#160;applied&#160;to&#160;functional&#160;programming&#160;languages.&#160;Lisp<br/>also uses the term “lambda” to refer to functions that can be manipulated as objects.<br/>
<b>6.5.1.3 &#160;Kernel.proc<br/></b>In&#160;Ruby&#160;1.8,&#160;the&#160;global&#160;proc&#160;method&#160;is&#160;a&#160;synonym&#160;for&#160;lambda.&#160;Despite&#160;its&#160;name,&#160;it&#160;returns<br/>a&#160;lambda,&#160;not&#160;a&#160;proc.&#160;Ruby&#160;1.9&#160;fixes&#160;this;&#160;in&#160;that&#160;version&#160;of&#160;the&#160;language,&#160;proc&#160;is&#160;a<br/>synonym for&#160;Proc.new.<br/>Because&#160;of&#160;this&#160;ambiguity,&#160;you&#160;should&#160;never&#160;use&#160;proc&#160;in&#160;Ruby&#160;1.8&#160;code.&#160;The&#160;behavior<br/>of&#160;your&#160;code&#160;might&#160;change&#160;if&#160;the&#160;interpreter&#160;was&#160;upgraded&#160;to&#160;a&#160;newer&#160;version.&#160;If&#160;you<br/>are&#160;using&#160;Ruby&#160;1.9&#160;code&#160;and&#160;are&#160;confident&#160;that&#160;it&#160;will&#160;never&#160;be&#160;run&#160;with&#160;a&#160;Ruby&#160;1.8<br/>interpreter, you can safely use&#160;proc&#160;as a more elegant shorthand for&#160;Proc.new.<br/>
<b>6.5.1.4 &#160;Lambda Literals<br/></b>Ruby 1.9 supports&#160;an&#160;entirely&#160;new&#160;syntax&#160;for&#160;defining&#160;lambdas&#160;as&#160;literals.&#160;We’ll&#160;begin<br/>with a Ruby 1.8 lambda, created with the&#160;lambda&#160;method:<br/>
succ = lambda {|x| x+1}<br/>
In Ruby 1.9, we can convert this to a literal as follows:<br/>
•&#160;Replace the method name&#160;lambda&#160;with the punctuation&#160;-&gt;.<br/>•&#160;Move the list of arguments outside of and just before the curly braces.<br/>•&#160;Change the argument list delimiters from&#160;||&#160;to&#160;().<br/>
With these changes, we get a Ruby 1.9 lambda literal:<br/>
succ = -&gt;(x){ x+1 }<br/>
succ&#160;now holds a&#160;Proc&#160;object, which we can use just like any other:<br/>
succ.call(2) &#160; &#160;# =&gt; 3<br/>
The&#160;introduction&#160;of&#160;this&#160;syntax&#160;into&#160;Ruby&#160;was&#160;controversial,&#160;and&#160;it&#160;takes&#160;some&#160;getting<br/>used&#160;to.&#160;Note&#160;that&#160;the&#160;arrow&#160;characters&#160;-&gt;&#160;are&#160;different&#160;from&#160;those&#160;used&#160;in&#160;hash&#160;literals.<br/>If&#160;you&#160;squint&#160;at&#160;the&#160;arrow,&#160;you&#160;may&#160;be&#160;able&#160;to&#160;convince&#160;yourself&#160;that&#160;the&#160;greater-than<br/>sign&#160;is&#160;the&#160;Greek&#160;letter&#160;lambda&#160;(λ)&#160;with&#160;its&#160;right-hand&#160;leg&#160;chopped&#160;off,&#160;turned&#160;into&#160;a<br/>hyphen and moved to the left!<br/>As with blocks in Ruby 1.9, the argument list of a lambda literal may include the dec-<br/>laration&#160;of&#160;block-local&#160;variables&#160;that&#160;are&#160;guaranteed&#160;not&#160;to&#160;overwrite&#160;variables&#160;with&#160;the<br/>same&#160;name&#160;in&#160;the&#160;enclosing&#160;scope.&#160;Simply&#160;follow&#160;the&#160;parameter&#160;list&#160;with&#160;a&#160;semicolon<br/>and a list of local variables:<br/>
<b>194&#160;|&#160;Chapter 6:</b> <b>Methods, Procs, Lambdas, and Closures</b><br/>
<hr/>
<a name=209></a># This lambda takes 2 args and declares 3 local vars<br/>f = -&gt;(x,y; i,j,k) { ... }<br/>
Lambda literals can be declared with argument defaults, just as methods can:<br/>
zoom = -&gt;(x,y,factor=2) { [x*factor, y*factor] }<br/>
The&#160;parentheses&#160;around&#160;the&#160;argument&#160;list&#160;of&#160;a&#160;lambda&#160;literal&#160;are&#160;only&#160;required&#160;if&#160;the<br/>argument&#160;list&#160;includes&#160;a&#160;semicolon&#160;and&#160;block-local&#160;variable&#160;names.&#160;Otherwise&#160;paren-<br/>theses may be omitted, resulting in a more compact syntax:<br/>
succ = -&gt;x { x+1 }<br/>zoom = -&gt;x,y,factor=2 { [x*factor, y*factor] }<br/>
If&#160;the&#160;argument&#160;list&#160;of&#160;a&#160;lambda&#160;literal&#160;has&#160;parentheses&#160;around&#160;it,&#160;there&#160;must&#160;not&#160;be&#160;a<br/>space between the&#160;-&gt;&#160;and the open parenthesis.<br/>Lambda&#160;parameters&#160;and&#160;local&#160;variables&#160;are&#160;optional,&#160;of&#160;course,&#160;and&#160;a&#160;lambda&#160;literal&#160;can<br/>omit&#160;&#160;this&#160;&#160;altogether.&#160;&#160;The&#160;&#160;minimal&#160;&#160;lambda,&#160;&#160;which&#160;&#160;takes&#160;&#160;no&#160;&#160;arguments&#160;&#160;and&#160;&#160;returns<br/>nil, is the following:<br/>
-&gt;{}<br/>
One&#160;benefit&#160;of&#160;this&#160;new&#160;syntax&#160;is&#160;its&#160;succinctness.&#160;It&#160;can&#160;be&#160;helpful&#160;when&#160;you&#160;want&#160;to<br/>pass a lambda as an argument to a method or to another lambda:<br/>
def compose(f,g) &#160; &#160; &#160; &#160; &#160; &#160;# Compose 2 lambdas&#160;<br/>&#160; -&gt;(x) { f.call(g.call(x)) }<br/>end<br/>succOfSquare = compose(-&gt;x{x+1}, -&gt;x{x*x})<br/>succOfSquare.call(4) &#160; &#160; &#160; &#160;# =&gt; 17: Computes (4*4)+1<br/>
Lambda&#160;literals&#160;create&#160;Proc&#160;objects&#160;and&#160;are&#160;not&#160;the&#160;same&#160;thing&#160;as&#160;blocks.&#160;If&#160;you&#160;want<br/>to&#160;pass&#160;a&#160;lambda&#160;literal&#160;to&#160;a&#160;method&#160;that&#160;expects&#160;a&#160;block,&#160;prefix&#160;the&#160;literal&#160;with&#160;&amp;, just<br/>as&#160;you&#160;would&#160;with&#160;any&#160;other&#160;Proc&#160;object.&#160;Here&#160;is&#160;how&#160;we&#160;might&#160;sort&#160;an&#160;array&#160;of&#160;numbers<br/>into descending order using both a block and a lambda literal:<br/>
data.sort {|a,b| b-a } &#160; # The block version<br/>data.sort &amp;-&gt;(a,b){ b-a } # The lambda literal version<br/>
In this case, as you can see, regular block syntax is simpler.<br/>
<b>6.5.2 &#160;Invoking Procs and Lambdas<br/></b>Procs&#160;and&#160;lambdas&#160;are&#160;objects,&#160;not&#160;methods,&#160;and&#160;they&#160;cannot&#160;be&#160;invoked&#160;in&#160;the&#160;same<br/>way&#160;that&#160;methods&#160;are.&#160;If&#160;p&#160;refers&#160;to&#160;a&#160;Proc&#160;object,&#160;you&#160;cannot&#160;invoke&#160;p&#160;as&#160;a&#160;method.&#160;But<br/>because&#160;p&#160;is&#160;an&#160;object,&#160;you&#160;can&#160;invoke&#160;a&#160;method&#160;of&#160;p.&#160;We’ve&#160;already&#160;mentioned&#160;that<br/>the&#160;Proc&#160;class&#160;defines&#160;a&#160;method&#160;named&#160;call.&#160;Invoking&#160;this&#160;method&#160;executes&#160;the&#160;code<br/>in&#160;the&#160;original&#160;block.&#160;The&#160;arguments&#160;you&#160;pass&#160;to&#160;the&#160;call&#160;method&#160;become&#160;arguments<br/>to&#160;the&#160;block,&#160;and&#160;the&#160;return&#160;value&#160;of&#160;the&#160;block&#160;becomes&#160;the&#160;return&#160;value&#160;of&#160;the&#160;call<br/>method:<br/>
f = Proc.new {|x,y| 1.0/(1.0/x + 1.0/y) }<br/>z = f.call(x,y)<br/>
<b>6.5 &#160;Procs and Lambdas&#160;|&#160;195</b><br/>
<hr/>
<a name=210></a>The&#160;Proc&#160;class&#160;also&#160;defines&#160;the&#160;array&#160;access&#160;operator&#160;to&#160;work&#160;the&#160;same&#160;way&#160;as&#160;call.&#160;This<br/>means&#160;&#160;that&#160;&#160;you&#160;&#160;can&#160;&#160;invoke&#160;&#160;a&#160;&#160;proc&#160;&#160;or&#160;&#160;lambda&#160;&#160;using&#160;&#160;a&#160;&#160;syntax&#160;&#160;that&#160;&#160;is&#160;&#160;like&#160;&#160;method<br/>invocation,&#160;&#160;where&#160;&#160;parentheses&#160;&#160;have&#160;&#160;been&#160;&#160;replaced&#160;&#160;with&#160;&#160;square&#160;&#160;brackets.&#160;&#160;The&#160;&#160;proc<br/>invocation above, for example, could be replaced with this code:<br/>
z = f[x,y]<br/>
Ruby&#160;1.9&#160;offers&#160;an&#160;additional&#160;way&#160;to&#160;invoke&#160;a&#160;Proc&#160;object;&#160;as&#160;an&#160;alternative&#160;to&#160;square<br/>brackets, you can use parentheses prefixed with a period:<br/>
z = f.(x,y)<br/>
.()&#160;looks&#160;like&#160;a&#160;method&#160;invocation&#160;missing&#160;the&#160;method&#160;name.&#160;This&#160;is&#160;not&#160;an&#160;operator<br/>that&#160;can&#160;be&#160;defined,&#160;but&#160;rather&#160;is&#160;syntactic-sugar&#160;that&#160;invokes&#160;the&#160;call&#160;method.&#160;It&#160;can<br/>be used with any object that defines a&#160;call&#160;method and is not limited to&#160;Proc&#160;objects.<br/>Ruby&#160;1.9&#160;adds&#160;a&#160;curry&#160;method&#160;to&#160;the&#160;Proc&#160;class.&#160;Calling&#160;&#160;&#160;this&#160;method&#160;returns&#160;a&#160;curried<br/>version&#160;of&#160;a&#160;proc&#160;or&#160;lambda.&#160;When&#160;a&#160;curried&#160;proc&#160;or&#160;lambda&#160;is&#160;invoked&#160;with&#160;insufficient<br/>arguments&#160;it&#160;returns&#160;a&#160;new&#160;Proc&#160;object&#160;(also&#160;curried)&#160;with&#160;the&#160;given&#160;arguments&#160;applied.<br/>Currying is a common technique in the functional programming paradigm:<br/>
product = -&gt;(x,y){ x*y } &#160;# Define a lambda<br/>triple = product.curry[3] # Curry it, then specify the first argument<br/>[triple[10],triple[20]] &#160; # =&gt; [30,60]:&#160;<br/>lambda {|w,x,y,z| w+x+y+z}.curry[1][2,3][4] # =&gt; 10<br/>&#160; &#160; &#160; &#160;&#160;<br/>
<b>6.5.3 &#160;The Arity of a Proc<br/></b>The&#160;<i>arity</i>&#160;of&#160;a&#160;proc&#160;or&#160;lambda&#160;is&#160;the&#160;number&#160;of&#160;arguments&#160;it&#160;expects.&#160;(The&#160;word&#160;is<br/>derived&#160;&#160;from&#160;&#160;the&#160;&#160;“ary”&#160;&#160;suffix&#160;&#160;of&#160;&#160;unary,&#160;&#160;binary,&#160;&#160;ternary,&#160;&#160;etc.)&#160;&#160;Proc&#160;&#160;objects&#160;&#160;have&#160;&#160;an<br/>arity&#160;method that returns the number of arguments they expect. For example:<br/>
lambda{||}.arity &#160; &#160; &#160; &#160;# =&gt; 0. No arguments expected<br/>lambda{|x| x}.arity &#160; &#160; # =&gt; 1. One argument expected<br/>lambda{|x,y| x+y}.arity # =&gt; 2. Two arguments expected<br/>
The&#160;notion&#160;of&#160;arity&#160;gets&#160;confusing&#160;when&#160;a&#160;Proc&#160;accepts&#160;an&#160;arbitrary&#160;number&#160;of&#160;argu-<br/>ments&#160;in&#160;an&#160;*-prefixed&#160;final&#160;argument.&#160;When&#160;a&#160;Proc&#160;allows&#160;optional&#160;arguments,&#160;the<br/>arity&#160;method&#160;returns&#160;a&#160;negative&#160;number&#160;of&#160;the&#160;form&#160;-n-1. A return value of this form<br/>indicates&#160;that&#160;the&#160;Proc&#160;requires&#160;n&#160;arguments,&#160;but&#160;it&#160;may&#160;optionally&#160;take&#160;additional&#160;ar-<br/>guments&#160;as&#160;well.&#160;-n-1&#160;is&#160;known&#160;as&#160;the&#160;one’s-complement&#160;of&#160;n,&#160;and&#160;you&#160;can&#160;invert&#160;it<br/>with&#160;the&#160;~&#160;operator.&#160;So&#160;if&#160;arity&#160;returns&#160;a&#160;negative&#160;number&#160;m,&#160;then&#160;~m&#160;(or&#160;-m-1)&#160;gives&#160;you<br/>the number of required arguments:<br/>
lambda {|*args|}.arity &#160; &#160; &#160; &#160;# =&gt; -1. &#160;~-1 = -(-1)-1 = 0 arguments required<br/>lambda {|first, *rest|}.arity # =&gt; -2. &#160;~-2 = -(-2)-1 = 1 argument required<br/>
There&#160;is&#160;one&#160;final&#160;wrinkle&#160;to&#160;the&#160;arity&#160;method.&#160;In&#160;Ruby&#160;1.8,&#160;a&#160;Proc&#160;declared&#160;without<br/>any&#160;argument&#160;clause&#160;at&#160;all&#160;(that&#160;is,&#160;without&#160;any&#160;||&#160;characters)&#160;may&#160;be&#160;invoked&#160;with&#160;any<br/>number&#160;of&#160;arguments&#160;(and&#160;these&#160;arguments&#160;are&#160;ignored).&#160;The&#160;arity&#160;method&#160;returns<br/>–1&#160;to&#160;indicate&#160;that&#160;there&#160;are&#160;no&#160;required&#160;arguments.&#160;This&#160;has&#160;changed&#160;in&#160;Ruby&#160;1.9:&#160;a<br/>
<b>196&#160;|&#160;Chapter 6:</b> <b>Methods, Procs, Lambdas, and Closures</b><br/>
<hr/>
<a name=211></a>Proc&#160;declared like this has an arity of&#160;0. If it is a lambda, then it is an error to invoke it<br/>with any arguments:<br/>
puts lambda {}.arity &#160;# –1 in Ruby 1.8; 0 in Ruby 1.9<br/>
<b>6.5.4 &#160;Proc Equality<br/></b>The&#160;Proc&#160;class defines&#160;an&#160;==&#160;method&#160;to determine whether two&#160;Proc&#160;objects are equal.<br/>It&#160;is&#160;important&#160;to&#160;understand,&#160;however,&#160;that&#160;merely&#160;having&#160;the&#160;same&#160;source&#160;code&#160;is&#160;not<br/>enough to make two procs or lambdas equal to each other:<br/>
lambda {|x| x*x } == lambda {|x| x*x } &#160;# =&gt; false<br/>
The&#160;==&#160;method only returns&#160;true&#160;if one&#160;Proc&#160;is a clone or duplicate of the other:<br/>
p = lambda {|x| x*x }<br/>q = p.dup<br/>p == q &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; true: the two procs are equal<br/>p.object_id == q.object_id &#160;# =&gt; false: they are not the same object<br/>
<b>6.5.5 &#160;How Lambdas Differ from Procs<br/></b>A&#160;proc&#160;is&#160;the&#160;object&#160;form&#160;of&#160;a&#160;block,&#160;and&#160;it&#160;behaves&#160;like&#160;a&#160;block.&#160;A&#160;lambda&#160;has&#160;slightly<br/>modified&#160;behavior&#160;and&#160;behaves&#160;more&#160;like&#160;a&#160;method&#160;than&#160;a&#160;block.&#160;Calling&#160;a&#160;proc&#160;is&#160;like<br/>yielding&#160;to&#160;a&#160;block,&#160;whereas&#160;calling&#160;a&#160;lambda&#160;is&#160;like&#160;invoking&#160;a&#160;method.&#160;In&#160;Ruby&#160;1.9,<br/>you&#160;can&#160;determine&#160;whether&#160;a&#160;Proc&#160;object&#160;is&#160;a&#160;proc&#160;or&#160;a&#160;lambda&#160;with&#160;the&#160;instance&#160;method<br/>lambda?.&#160;This&#160;predicate&#160;returns&#160;true&#160;for&#160;lambdas&#160;and&#160;false&#160;for&#160;procs.&#160;The&#160;subsections<br/>that follow explain the differences between procs and lambdas in detail.<br/>
<b>6.5.5.1 &#160;Return in blocks, procs, and lambdas<br/></b>Recall&#160;from&#160;<a href="Rubys.html#131">Chapter&#160;5&#160;</a>that&#160;the&#160;return&#160;statement&#160;returns&#160;from&#160;the&#160;lexically&#160;enclosing<br/>method,&#160;even&#160;when&#160;the&#160;statement&#160;is&#160;contained&#160;within&#160;a&#160;block.&#160;The&#160;return&#160;statement<br/>in&#160;a&#160;block&#160;does&#160;not&#160;just&#160;return&#160;from&#160;the&#160;block&#160;to&#160;the&#160;invoking&#160;iterator,&#160;it&#160;returns&#160;from<br/>the method that invoked the iterator. For example:<br/>
def test<br/>&#160; puts &#34;entering method&#34;<br/>&#160; 1.times { puts &#34;entering block&#34;; return } &#160;# Makes test method return<br/>&#160; puts &#34;exiting method&#34; &#160;# This line is never executed<br/>end<br/>test<br/>
A&#160;proc&#160;is&#160;like&#160;a&#160;block,&#160;so&#160;if&#160;you&#160;call&#160;a&#160;proc&#160;that&#160;executes&#160;a&#160;return&#160;statement,&#160;it&#160;attempts<br/>to&#160;return&#160;from&#160;the&#160;method&#160;that&#160;encloses&#160;the&#160;block&#160;that&#160;was&#160;converted&#160;to&#160;the&#160;proc.&#160;For<br/>example:<br/>
def test<br/>&#160; puts &#34;entering method&#34;<br/>&#160; p = Proc.new { puts &#34;entering proc&#34;; return }&#160;<br/>&#160; p.call &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Invoking the proc makes method return<br/>&#160; puts &#34;exiting method&#34; &#160;# This line is never executed<br/>
<b>6.5 &#160;Procs and Lambdas&#160;|&#160;197</b><br/>
<hr/>
<a name=212></a>end<br/>test<br/>
Using&#160;a&#160;return&#160;statement&#160;in&#160;a&#160;proc&#160;is&#160;tricky,&#160;however,&#160;because&#160;procs&#160;are&#160;often&#160;passed<br/>around&#160;between&#160;methods.&#160;By&#160;the&#160;time&#160;a&#160;proc&#160;is&#160;invoked,&#160;the&#160;lexically&#160;enclosing&#160;method<br/>may already have returned:<br/>
def procBuilder(message) &#160; &#160; &#160; &#160; &#160; &#160;# Create and return a proc<br/>&#160; Proc.new { puts message; return } # return returns from procBuilder<br/>&#160; # but procBuilder has already returned here!<br/>end<br/>
def test<br/>&#160; puts &#34;entering method&#34;<br/>&#160; p = procBuilder(&#34;entering proc&#34;)<br/>&#160; p.call &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Prints &#34;entering proc&#34; and raises LocalJumpError!<br/>&#160; puts &#34;exiting method&#34; &#160;# This line is never executed<br/>end<br/>test<br/>
By&#160;converting&#160;a&#160;block&#160;into&#160;an&#160;object,&#160;we&#160;are&#160;able&#160;to&#160;pass&#160;that&#160;object&#160;around&#160;and&#160;use&#160;it<br/>“out&#160;of&#160;context.”&#160;If&#160;we&#160;do&#160;this,&#160;we&#160;run&#160;the&#160;risk&#160;of&#160;returning&#160;from&#160;a&#160;method&#160;that&#160;has<br/>already&#160;&#160;returned,&#160;&#160;as&#160;&#160;was&#160;&#160;the&#160;&#160;case&#160;&#160;here.&#160;&#160;When&#160;&#160;this&#160;&#160;happens,&#160;&#160;Ruby&#160;&#160;raises&#160;&#160;a<br/>LocalJumpError.<br/>
The&#160;fix&#160;for&#160;this&#160;contrived&#160;example&#160;is&#160;to&#160;remove&#160;the&#160;unnecessary&#160;return&#160;statement,&#160;of<br/>course.&#160;But&#160;a&#160;return&#160;statement&#160;is&#160;not&#160;always&#160;unnecessary,&#160;and&#160;another&#160;fix&#160;is&#160;to&#160;use&#160;a<br/>lambda&#160;instead&#160;of&#160;a&#160;proc.&#160;As&#160;we&#160;said&#160;earlier,&#160;lambdas&#160;work&#160;more&#160;like&#160;methods&#160;than<br/>blocks. A&#160;return&#160;statement in a lambda, therefore, returns from the lambda itself, not<br/>from the method that surrounds the creation site of the lambda:<br/>
def test<br/>&#160; puts &#34;entering method&#34;<br/>&#160; p = lambda { puts &#34;entering lambda&#34;; return }&#160;<br/>&#160; p.call &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Invoking the lambda does not make the method return<br/>&#160; puts &#34;exiting method&#34; &#160;# This line *is* executed now<br/>end<br/>test<br/>
The&#160;fact&#160;that&#160;return&#160;in&#160;a&#160;lambda&#160;only&#160;returns&#160;from&#160;the&#160;lambda&#160;itself&#160;means&#160;that&#160;we<br/>never have to worry about&#160;LocalJumpError:<br/>
def lambdaBuilder(message) &#160; &#160; &#160; &#160;# Create and return a lambda<br/>&#160; lambda { puts message; return } # return returns from the lambda<br/>end<br/>
def test<br/>&#160; puts &#34;entering method&#34;<br/>&#160; l = lambdaBuilder(&#34;entering lambda&#34;)<br/>&#160; l.call &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Prints &#34;entering lambda&#34;&#160;<br/>&#160; puts &#34;exiting method&#34; &#160;# This line is executed<br/>end<br/>test<br/>
<b>198&#160;|&#160;Chapter 6:</b> <b>Methods, Procs, Lambdas, and Closures</b><br/>
<hr/>
<a name=213></a><b>6.5.5.2 &#160;Break in blocks, procs and lambdas<br/></b><a href="Rubys.html#163">Figure&#160;5-3&#160;</a>illustrated&#160;the&#160;behavior&#160;of&#160;the&#160;break&#160;statement&#160;in&#160;a&#160;block;&#160;it&#160;causes&#160;the&#160;block<br/>to&#160;return&#160;to&#160;its&#160;iterator&#160;and&#160;the&#160;iterator&#160;to&#160;return&#160;to&#160;the&#160;method&#160;that&#160;invoked&#160;it.&#160;Because<br/>procs&#160;work&#160;like&#160;blocks,&#160;we&#160;expect&#160;break&#160;to&#160;do&#160;the&#160;same&#160;thing&#160;in&#160;a&#160;proc.&#160;We&#160;can’t&#160;easily<br/>test&#160;this,&#160;however.&#160;When&#160;we&#160;create&#160;a&#160;proc&#160;with&#160;Proc.new,&#160;Proc.new&#160;is&#160;the&#160;iterator&#160;that<br/>break&#160;would&#160;return&#160;from.&#160;And&#160;by&#160;the&#160;time&#160;we&#160;can&#160;invoke&#160;the&#160;proc&#160;object,&#160;the&#160;iterator<br/>has&#160;already&#160;returned.&#160;So&#160;it&#160;never&#160;makes&#160;sense&#160;to&#160;have&#160;a&#160;top-level&#160;break&#160;statement&#160;in&#160;a<br/>proc created with&#160;Proc.new:<br/>
def test<br/>&#160; puts &#34;entering test method&#34;<br/>&#160; proc = Proc.new { puts &#34;entering proc&#34;; break }<br/>&#160; proc.call &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# LocalJumpError: iterator has already returned<br/>&#160; puts &#34;exiting test method&#34;<br/>end<br/>test<br/>
If&#160;we&#160;create&#160;a&#160;proc&#160;object&#160;with&#160;an&#160;&amp;&#160;argument&#160;to&#160;the&#160;iterator&#160;method,&#160;then&#160;we&#160;can&#160;invoke<br/>it and make the iterator return:<br/>
def iterator(&amp;proc)<br/>&#160; puts &#34;entering iterator&#34;<br/>&#160; proc.call &#160;# invoke the proc<br/>&#160; puts &#34;exiting iterator&#34; &#160; # Never executed if the proc breaks<br/>end<br/>
def test<br/>&#160; iterator { puts &#34;entering proc&#34;; break }<br/>end<br/>test<br/>
Lambdas&#160;are&#160;method-like,&#160;so&#160;putting&#160;a&#160;break&#160;statement&#160;at&#160;the&#160;top-level&#160;of&#160;a&#160;lambda,<br/>without&#160;an&#160;enclosing&#160;loop&#160;or&#160;iteration&#160;to&#160;break&#160;out&#160;of,&#160;doesn’t&#160;actually&#160;make&#160;any&#160;sense!<br/>We might expect the following code to fail because there is nothing to break out of in<br/>the lambda. In fact, the top-level&#160;break&#160;just acts like a&#160;return:<br/>
def test<br/>&#160; puts &#34;entering test method&#34;<br/>&#160; lambda = lambda { puts &#34;entering lambda&#34;; break; puts &#34;exiting lambda&#34; }<br/>&#160; lambda.call &#160;<br/>&#160; puts &#34;exiting test method&#34;<br/>end<br/>test<br/>
<b>6.5.5.3 &#160;Other control-flow statements<br/></b>A&#160;top-level&#160;next&#160;statement&#160;works&#160;the&#160;same&#160;in&#160;a&#160;block,&#160;proc,&#160;or&#160;lambda:&#160;it&#160;causes&#160;the<br/>yield&#160;statement&#160;or&#160;call&#160;method&#160;that&#160;invoked&#160;the&#160;block,&#160;proc,&#160;or&#160;lambda&#160;to&#160;return.&#160;If<br/>next&#160;is&#160;followed&#160;by&#160;an&#160;expression,&#160;then&#160;the&#160;value&#160;of&#160;that&#160;expression&#160;becomes&#160;the&#160;<i>return<br/>value</i>&#160;of the block, proc, or lambda.<br/>
<b>6.5 &#160;Procs and Lambdas&#160;|&#160;199</b><br/>
<hr/>
<a name=214></a>redo&#160;also&#160;works&#160;the&#160;same&#160;in&#160;procs&#160;and&#160;lambdas:&#160;it&#160;transfers&#160;control&#160;back&#160;to&#160;the&#160;begin-<br/>ning of the proc or lambda.<br/>
retry&#160;is&#160;never&#160;allowed&#160;in&#160;procs&#160;or&#160;lambdas:&#160;using&#160;it&#160;always&#160;results&#160;in&#160;a&#160;LocalJumpError.<br/>
raise&#160;behaves&#160;the&#160;same&#160;in&#160;blocks,&#160;procs,&#160;and&#160;lambdas.&#160;Exceptions&#160;always&#160;propagate<br/>up&#160;the&#160;call&#160;stack.&#160;If&#160;a&#160;block,&#160;proc,&#160;or&#160;lambda&#160;raises&#160;an&#160;exception&#160;and&#160;there&#160;is&#160;no&#160;local<br/>rescue&#160;clause,&#160;the&#160;exception&#160;first&#160;propagates&#160;to&#160;the&#160;method&#160;that&#160;invoked&#160;the&#160;block&#160;with<br/>yield&#160;or that invoked the proc or lambda with&#160;call.<br/>
<b>6.5.5.4 &#160;Argument passing to procs and lambdas<br/></b>Invoking&#160;a&#160;block&#160;with&#160;yield&#160;is&#160;similar&#160;to,&#160;but&#160;not&#160;the&#160;same&#160;as,&#160;invoking&#160;a&#160;method.&#160;There<br/>are&#160;differences&#160;in&#160;the&#160;way&#160;argument&#160;values&#160;in&#160;the&#160;invocation&#160;are&#160;assigned&#160;to&#160;the&#160;argu-<br/>ment&#160;&#160;variables&#160;&#160;declared&#160;&#160;in&#160;&#160;the&#160;&#160;block&#160;&#160;or&#160;&#160;method.&#160;&#160;The&#160;&#160;yield&#160;&#160;statement&#160;&#160;uses&#160;&#160;<i>yield<br/>semantics</i>,&#160;whereas&#160;method&#160;invocation&#160;uses&#160;<i>invocation semantics</i>.&#160;Yield&#160;semantics&#160;are<br/>similar&#160;&#160;to&#160;&#160;parallel&#160;&#160;assignment&#160;&#160;and&#160;&#160;are&#160;&#160;described&#160;&#160;in&#160;&#160;<a href="Rubys.html#157">§5.4.4.&#160;&#160;</a>As&#160;&#160;you&#160;&#160;might&#160;&#160;expect,<br/>invoking&#160;a&#160;proc&#160;uses&#160;yield&#160;semantics&#160;and&#160;invoking&#160;a&#160;lambda&#160;uses&#160;invocation&#160;semantics:<br/>
p = Proc.new {|x,y| print x,y }<br/>p.call(1) &#160; &#160; &#160; # x,y=1: &#160; &#160; nil used for missing rvalue: &#160;Prints 1nil<br/>p.call(1,2) &#160; &#160; # x,y=1,2: &#160; 2 lvalues, 2 rvalues: &#160; &#160; &#160; &#160; Prints 12<br/>p.call(1,2,3) &#160; # x,y=1,2,3: extra rvalue discarded: &#160; &#160; &#160; Prints 12<br/>p.call([1,2]) &#160; # x,y=[1,2]: array automatically unpacked: Prints 12<br/>
This&#160;&#160;code&#160;&#160;demonstrates&#160;&#160;that&#160;&#160;the&#160;&#160;call&#160;&#160;method&#160;&#160;of&#160;&#160;a&#160;&#160;proc&#160;&#160;handles&#160;&#160;the&#160;&#160;arguments&#160;&#160;it<br/>receives flexibly: silently discarding extras, silently adding&#160;nil&#160;for omitted arguments,<br/>and&#160;even&#160;unpacking&#160;arrays.&#160;(Or,&#160;not&#160;demonstrated&#160;here,&#160;packing&#160;multiple&#160;arguments<br/>into a single array when the proc expects only a single argument.)<br/>Lambdas&#160;are&#160;not&#160;flexible&#160;in&#160;this&#160;way;&#160;like&#160;methods,&#160;they&#160;must&#160;be&#160;invoked&#160;with&#160;precisely<br/>
&#160;<br/>
the number of arguments they are declared with:<br/>
l = lambda {|x,y| print x,y }<br/>l.call(1,2) &#160; &#160; # This works<br/>l.call(1) &#160; &#160; &#160; # Wrong number of arguments<br/>l.call(1,2,3) &#160; # Wrong number of arguments<br/>l.call([1,2]) &#160; # Wrong number of arguments<br/>l.call(*[1,2]) &#160;# Works: explicit splat to unpack the array<br/>
<b>6.6 &#160;Closures<br/></b>In&#160;Ruby,&#160;procs&#160;and&#160;lambdas&#160;are&#160;<i>closures</i>.&#160;The&#160;term&#160;“closure”&#160;comes&#160;from&#160;the&#160;early&#160;days<br/>of&#160;computer&#160;science;&#160;it&#160;refers&#160;to&#160;an&#160;object&#160;that&#160;is&#160;both&#160;an&#160;invocable&#160;function&#160;and&#160;a<br/>variable&#160;binding&#160;for&#160;that&#160;function.&#160;When&#160;you&#160;create&#160;a&#160;proc&#160;or&#160;a&#160;lambda,&#160;the&#160;resulting<br/>Proc&#160;object&#160;holds&#160;not&#160;just&#160;the&#160;executable&#160;block&#160;but&#160;also&#160;bindings&#160;for&#160;all&#160;the&#160;variables<br/>used by the block.<br/>
<b>200&#160;|&#160;Chapter 6:</b> <b>Methods, Procs, Lambdas, and Closures</b><br/>
<hr/>
<a name=215></a>You&#160;already&#160;know&#160;that&#160;blocks&#160;can&#160;use&#160;local&#160;variables&#160;and&#160;method&#160;arguments&#160;that&#160;are<br/>defined&#160;outside&#160;the&#160;block.&#160;In&#160;the&#160;following&#160;code,&#160;for&#160;example,&#160;the&#160;block&#160;associated&#160;with<br/>the&#160;collect&#160;iterator uses the method argument&#160;n:<br/>
# multiply each element of the data array by n<br/>def multiply(data, n)<br/>&#160; data.collect {|x| x*n }<br/>end<br/>
puts multiply([1,2,3], 2) &#160; # Prints 2,4,6<br/>
What&#160;is&#160;more&#160;interesting,&#160;and&#160;possibly&#160;even&#160;surprising,&#160;is&#160;that&#160;if&#160;the&#160;block&#160;were&#160;turned<br/>into&#160;a&#160;proc&#160;or&#160;lambda,&#160;it&#160;could&#160;access&#160;n&#160;even&#160;after&#160;the&#160;method&#160;to&#160;which&#160;it&#160;is&#160;an&#160;argument<br/>had returned. The following code demonstrates:<br/>
# Return a lambda that retains or &#34;closes over&#34; the argument n<br/>def multiplier(n)&#160;<br/>&#160; lambda {|data| data.collect{|x| x*n } }<br/>end<br/>doubler = multiplier(2) &#160; &#160; # Get a lambda that knows how to double<br/>puts doubler.call([1,2,3]) &#160;# Prints 2,4,6<br/>
The&#160;multiplier&#160;method&#160;returns&#160;a&#160;lambda.&#160;Because&#160;this&#160;lambda&#160;is&#160;used&#160;outside&#160;of&#160;the<br/>scope&#160;in&#160;which&#160;it&#160;is&#160;defined,&#160;we&#160;call&#160;it&#160;a&#160;closure;&#160;it&#160;encapsulates&#160;or&#160;“closes&#160;over”&#160;(or&#160;just<br/>retains) the binding for the method argument&#160;n.<br/>
<b>6.6.1 &#160;Closures and Shared Variables<br/></b>It&#160;is&#160;important&#160;to&#160;understand&#160;that&#160;a&#160;closure&#160;does&#160;not&#160;just&#160;retain&#160;the&#160;value&#160;of&#160;the&#160;variables<br/>it&#160;refers&#160;to—it&#160;retains&#160;the&#160;actual&#160;variables&#160;and&#160;extends&#160;their&#160;lifetime.&#160;Another&#160;way&#160;to<br/>say&#160;this&#160;is&#160;that&#160;the&#160;variables&#160;used&#160;in&#160;a&#160;lambda&#160;or&#160;proc&#160;are&#160;not&#160;statically&#160;bound&#160;when&#160;the<br/>lambda&#160;or&#160;proc&#160;is&#160;created.&#160;Instead,&#160;the&#160;bindings&#160;are&#160;dynamic,&#160;and&#160;the&#160;values&#160;of&#160;the<br/>variables are looked up when the lambda or proc is executed.<br/>As&#160;an&#160;example,&#160;the&#160;following&#160;code&#160;defines&#160;a&#160;method&#160;that&#160;returns&#160;two&#160;lambdas.&#160;Because<br/>the&#160;lambdas&#160;are&#160;defined&#160;in&#160;the&#160;same&#160;scope,&#160;they&#160;share&#160;access&#160;to&#160;the&#160;variables&#160;in&#160;that<br/>scope.&#160;When&#160;one&#160;lambda&#160;alters&#160;the&#160;value&#160;of&#160;a&#160;shared&#160;variable,&#160;the&#160;new&#160;value&#160;is&#160;available<br/>to the other lambda:<br/>
# Return a pair of lambdas that share access to a local variable.<br/>def accessor_pair(initialValue=nil)<br/>&#160; value = initialValue &#160;# A local variable shared by the returned lambdas.<br/>&#160; getter = lambda { value } &#160; &#160; &#160; &#160; &#160;# Return value of local variable.<br/>&#160; setter = lambda {|x| value = x } &#160; # Change value of local variable.<br/>&#160; return getter,setter &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Return pair of lambdas to caller.<br/>end<br/>
getX, setX = accessor_pair(0) # Create accessor lambdas for initial value 0.<br/>puts getX[] &#160; &#160; &#160; &#160;# Prints 0. Note square brackets instead of call.<br/>setX[10] &#160; &#160; &#160; &#160; &#160; # Change the value through one closure.<br/>puts getX[] &#160; &#160; &#160; &#160;# Prints 10. The change is visible through the other.<br/>
<b>6.6 &#160;Closures&#160;|&#160;201</b><br/>
<hr/>
<a name=216></a>The&#160;fact&#160;that&#160;lambdas&#160;created&#160;in&#160;the&#160;same&#160;scope&#160;share&#160;access&#160;to&#160;variables&#160;can&#160;be&#160;a&#160;feature<br/>or&#160;a&#160;source&#160;of&#160;bugs.&#160;Any&#160;time&#160;you&#160;have&#160;a&#160;method&#160;that&#160;returns&#160;more&#160;than&#160;one&#160;closure,<br/>you&#160;should&#160;pay&#160;particular&#160;attention&#160;to&#160;the&#160;variables&#160;they&#160;use.&#160;Consider&#160;the&#160;following<br/>code:<br/>
# Return an array of lambdas that multiply by the arguments<br/>def multipliers(*args)<br/>&#160; x = nil<br/>&#160; args.map {|x| lambda {|y| x*y }}<br/>end<br/>
double,triple = multipliers(2,3)<br/>puts double.call(2) &#160; &#160;# Prints 6 in Ruby 1.8<br/>
This&#160;multipliers&#160;method&#160;uses&#160;the&#160;map&#160;iterator&#160;and&#160;a&#160;block&#160;to&#160;return&#160;an&#160;array&#160;of&#160;lambdas<br/>(created&#160;inside&#160;the&#160;block).&#160;In&#160;Ruby&#160;1.8,&#160;block&#160;arguments&#160;are&#160;not&#160;always&#160;local&#160;to&#160;the<br/><a href="Rubys.html#156">block (see&#160;§5.4.3),&#160;</a>and&#160;so&#160;all&#160;of&#160;the&#160;lambdas&#160;that&#160;are&#160;created&#160;end&#160;up&#160;sharing&#160;access&#160;to<br/>x, which is a local variable of the&#160;multipliers&#160;method. As noted above, closures don't<br/>capture&#160;the&#160;current&#160;value&#160;of&#160;the&#160;variable:&#160;they&#160;capture&#160;the&#160;variable&#160;itself.&#160;Each&#160;of&#160;the<br/>lambdas created here share the variable&#160;x. That variable has only one value, and all of<br/>the&#160;returned&#160;lambdas&#160;use&#160;that&#160;same&#160;value.&#160;That&#160;is&#160;why&#160;the&#160;lambda&#160;we&#160;name&#160;double<br/>ends up tripling its argument instead of doubling it.<br/>In&#160;this&#160;particular&#160;code,&#160;the&#160;issue&#160;goes&#160;away&#160;in&#160;Ruby&#160;1.9&#160;because&#160;block&#160;arguments&#160;are<br/>always&#160;block-local&#160;in&#160;that&#160;version&#160;of&#160;the&#160;language.&#160;Still,&#160;you&#160;can&#160;get&#160;yourself&#160;in&#160;trouble<br/>any&#160;time&#160;you&#160;create&#160;lambdas&#160;within&#160;a&#160;loop&#160;and&#160;use&#160;loop&#160;variables&#160;(such&#160;as&#160;an&#160;array<br/>index) within the lambda.<br/>
<b>6.6.2 &#160;Closures and Bindings<br/></b>The&#160;&#160;Proc&#160;&#160;class&#160;&#160;defines&#160;&#160;a&#160;&#160;method&#160;&#160;named&#160;&#160;binding.&#160;&#160;Calling&#160;&#160;this&#160;&#160;method&#160;&#160;on&#160;&#160;a&#160;&#160;proc&#160;&#160;or<br/>lambda returns a&#160;Binding&#160;object that represents the bindings in effect for that closure.<br/>
<b>More About Bindings</b><br/>
We’ve&#160;been&#160;discussing&#160;the&#160;bindings&#160;of&#160;a&#160;closure&#160;as&#160;if&#160;they&#160;were&#160;simply&#160;a&#160;mapping&#160;from<br/>variable&#160;names&#160;to&#160;variable&#160;values.&#160;In&#160;fact,&#160;bindings&#160;involve&#160;more&#160;than&#160;just&#160;variables.<br/>They&#160;&#160;hold&#160;&#160;all&#160;&#160;the&#160;&#160;information&#160;&#160;necessary&#160;&#160;to&#160;&#160;execute&#160;&#160;a&#160;&#160;method,&#160;&#160;such&#160;&#160;as&#160;&#160;the&#160;&#160;value&#160;&#160;of<br/>self, and the block, if any, that would be invoked by a&#160;yield.<br/>
A&#160;Binding&#160;object&#160;doesn’t&#160;have&#160;interesting&#160;methods&#160;of&#160;its&#160;own,&#160;but&#160;it&#160;can&#160;be&#160;used&#160;as&#160;the<br/>second&#160;argument&#160;to&#160;the&#160;global&#160;eval&#160;function&#160;(see&#160;<a href="Rubys.html#282">§8.2), providing</a>&#160;a&#160;context&#160;in&#160;which<br/>to&#160;evaluate&#160;a&#160;string&#160;of&#160;Ruby&#160;code.&#160;In&#160;Ruby&#160;1.9,&#160;Binding&#160;has&#160;its&#160;own&#160;eval&#160;method,&#160;which<br/>you may prefer to use. (Use&#160;ri&#160;to learn more about&#160;Kernel.eval&#160;and&#160;Binding.eval.)<br/>The&#160;use&#160;of&#160;a&#160;Binding&#160;object&#160;and&#160;the&#160;eval&#160;method&#160;gives&#160;us&#160;a&#160;back&#160;door&#160;through&#160;which<br/>we&#160;can&#160;manipulate&#160;the&#160;behavior&#160;of&#160;a&#160;closure.&#160;Take&#160;another&#160;look&#160;at&#160;this&#160;code&#160;from&#160;earlier:<br/>
<b>202&#160;|&#160;Chapter 6:</b> <b>Methods, Procs, Lambdas, and Closures</b><br/>
<hr/>
<a name=217></a># Return a lambda that retains or &#34;closes over&#34; the argument n<br/>def multiplier(n)&#160;<br/>&#160; lambda {|data| data.collect{|x| x*n } }<br/>end<br/>doubler = multiplier(2) &#160; &#160; # Get a lambda that knows how to double<br/>puts doubler.call([1,2,3]) &#160;# Prints 2,4,6<br/>
Now suppose we want to alter the behavior of&#160;doubler:<br/>
eval(&#34;n=3&#34;, doubler.binding) # Or doubler.binding.eval(&#34;n=3&#34;) in Ruby 1.9<br/>puts doubler.call([1,2,3]) &#160; # Now this prints 3,6,9!<br/>
As&#160;a&#160;shortcut,&#160;the&#160;eval&#160;method&#160;allows&#160;you&#160;to&#160;pass&#160;a&#160;Proc&#160;object&#160;directly&#160;instead&#160;of<br/>passing the&#160;Binding&#160;object&#160;of&#160;the&#160;Proc.&#160;So&#160;we&#160;could&#160;replace&#160;the&#160;eval&#160;invocation above<br/>with:<br/>
eval(&#34;n=3&#34;, doubler)<br/>
Bindings&#160;&#160;are&#160;&#160;not&#160;&#160;only&#160;&#160;a&#160;&#160;feature&#160;&#160;of&#160;&#160;closures.&#160;&#160;The&#160;&#160;Kernel.binding&#160;&#160;method&#160;&#160;returns&#160;&#160;a<br/>Binding&#160;object&#160;that&#160;represents&#160;the&#160;bindings&#160;in&#160;effect&#160;at&#160;whatever&#160;point&#160;you&#160;happen&#160;to<br/>call it.<br/>
<b>6.7 &#160;Method Objects<br/></b>Ruby’s&#160;methods&#160;and&#160;blocks&#160;are&#160;executable&#160;language&#160;constructs,&#160;but&#160;they&#160;are&#160;not&#160;ob-<br/>jects.&#160;Procs&#160;and&#160;lambdas&#160;are&#160;object&#160;versions&#160;of&#160;blocks;&#160;they&#160;can&#160;be&#160;executed&#160;and&#160;also<br/>manipulated&#160;as&#160;data.&#160;Ruby&#160;has&#160;powerful&#160;metaprogramming&#160;(or&#160;<i>reflection</i>)&#160;capabilities,<br/>and&#160;methods&#160;can&#160;actually&#160;be&#160;represented&#160;as&#160;instances&#160;of&#160;the&#160;Method&#160;class.&#160;(Metaprog-<br/>ramming&#160;is&#160;covered&#160;<a href="Rubys.html#279">in&#160;Chapter 8,&#160;</a>but&#160;Method&#160;objects&#160;are&#160;introduced&#160;here.)&#160;You&#160;should<br/>note&#160;that&#160;invoking&#160;a&#160;method&#160;through&#160;a&#160;Method&#160;object&#160;is&#160;less&#160;efficient&#160;than&#160;invoking&#160;it<br/>directly.&#160;Method&#160;objects are not typically used as often as lambdas and procs.<br/>The&#160;Object&#160;class&#160;defines&#160;a&#160;method&#160;named&#160;method.&#160;Pass&#160;it&#160;a&#160;method&#160;name,&#160;as&#160;a&#160;string&#160;or<br/>a&#160;symbol,&#160;and&#160;it&#160;returns&#160;a&#160;Method&#160;object&#160;representing&#160;the&#160;named&#160;method&#160;of&#160;the&#160;receiver<br/>(or throws a&#160;NameError&#160;if there is no such method). For example:<br/>
m = 0.method(:succ) &#160;# A Method representing the succ method of Fixnum 0<br/>
In&#160;Ruby&#160;1.9,&#160;you&#160;can&#160;also&#160;use&#160;public_method&#160;&#160;to&#160;obtain&#160;a&#160;Method&#160;object.&#160;It&#160;works&#160;like<br/>method<a href="Rubys.html#246">&#160;does but ignores protected and private methods (see §7.2).</a><br/>
The&#160;Method&#160;class&#160;is&#160;not&#160;a&#160;subclass&#160;of&#160;Proc,&#160;but&#160;it&#160;behaves&#160;much&#160;like&#160;it.&#160;Method&#160;objects<br/>are&#160;invoked&#160;with&#160;the&#160;call&#160;method&#160;(or&#160;the&#160;[]&#160;operator),&#160;just&#160;as&#160;Proc&#160;objects&#160;are.&#160;And<br/>Method&#160;defines&#160;an&#160;arity&#160;method&#160;just&#160;like&#160;the&#160;arity&#160;method&#160;of&#160;Proc.&#160;To&#160;invoke&#160;the&#160;Method<br/>m:<br/>
puts m.call &#160; &#160;# Same as puts 0.succ. Or use puts m[].<br/>
Invoking&#160;a&#160;method&#160;through&#160;a&#160;Method&#160;object&#160;does&#160;not&#160;change&#160;the&#160;invocation&#160;semantics,<br/>nor&#160;does&#160;it&#160;alter&#160;the&#160;meaning&#160;of&#160;control-flow&#160;statements&#160;such&#160;as&#160;return&#160;and&#160;break. The<br/>
<b>6.7 &#160;Method Objects&#160;|&#160;203</b><br/>
<hr/>
<a name=218></a>call&#160;method&#160;of&#160;a&#160;Method&#160;object&#160;uses&#160;method-invocation&#160;semantics,&#160;not&#160;yield&#160;semantics.<br/>Method&#160;objects, therefore, behave more like lambdas than like procs.<br/>
Method&#160;objects&#160;work&#160;very&#160;much&#160;like&#160;Proc&#160;objects&#160;and&#160;can&#160;usually&#160;be&#160;used&#160;in&#160;place&#160;of<br/>them.&#160;When&#160;a&#160;true&#160;Proc&#160;is&#160;required,&#160;you&#160;can&#160;use&#160;Method.to_proc&#160;to&#160;convert&#160;a&#160;Method&#160;to<br/>a&#160;Proc. This is why&#160;Method&#160;objects can be prefixed with an ampersand and passed to a<br/>method in place of a block. For example:<br/>
def square(x); x*x; end<br/>puts (1..10).map(&amp;method(:square))<br/>
<b>Defining Methods with Procs</b><br/>
In addition to obtaining a&#160;Method&#160;object&#160;that&#160;represents&#160;a&#160;method&#160;and&#160;converting&#160;it&#160;to<br/>a&#160;Proc,&#160;we&#160;can&#160;also&#160;go&#160;in&#160;the&#160;other&#160;direction.&#160;The&#160;define_method&#160;method&#160;(of&#160;Module)<br/>expects a&#160;Symbol&#160;as&#160;an&#160;argument,&#160;and&#160;creates&#160;a&#160;method&#160;with&#160;that&#160;name&#160;using&#160;the&#160;asso-<br/>ciated&#160;block&#160;as&#160;the&#160;method&#160;body.&#160;Instead&#160;of&#160;using&#160;a&#160;block,&#160;you&#160;can&#160;also&#160;pass&#160;a&#160;Proc&#160;or<br/>a&#160;Method&#160;object as the second argument.<br/>
One&#160;important&#160;difference&#160;between&#160;Method&#160;objects&#160;and&#160;Proc&#160;objects&#160;is&#160;that&#160;Method&#160;objects<br/>are&#160;not&#160;closures.&#160;Ruby’s&#160;methods&#160;are&#160;intended&#160;to&#160;be&#160;completely&#160;self-contained,&#160;and<br/>they never have access to local variables outside of their own scope. The only binding<br/>retained&#160;by&#160;a&#160;Method&#160;object,&#160;therefore,&#160;is&#160;the&#160;value&#160;of&#160;self—the&#160;object&#160;on&#160;which&#160;the<br/>method is to be invoked.<br/>In&#160;Ruby&#160;1.9,&#160;the&#160;Method&#160;class&#160;defines&#160;three&#160;methods&#160;that&#160;are&#160;not&#160;available&#160;in&#160;1.8:&#160;name<br/>returns&#160;the&#160;name&#160;of&#160;the&#160;method&#160;as&#160;a&#160;string;&#160;owner&#160;returns&#160;the&#160;class&#160;in&#160;which&#160;the&#160;method<br/>was&#160;defined;&#160;and&#160;receiver&#160;returns&#160;the&#160;object&#160;to&#160;which&#160;the&#160;method&#160;is&#160;bound.&#160;For&#160;any<br/>method object&#160;m,&#160;m.receiver.class&#160;must be equal to or a subclass of&#160;m.owner.<br/>
<b>6.7.1 &#160;Unbound Method Objects<br/></b>In&#160;addition&#160;to&#160;the&#160;Method&#160;class,&#160;Ruby&#160;also&#160;defines&#160;an&#160;UnboundMethod&#160;class.&#160;As&#160;its&#160;name<br/>suggests,&#160;an&#160;UnboundMethod&#160;object&#160;represents&#160;a&#160;method,&#160;without&#160;a&#160;binding&#160;to&#160;the&#160;object<br/>on&#160;&#160;which&#160;&#160;it&#160;&#160;is&#160;&#160;to&#160;&#160;be&#160;&#160;invoked.&#160;&#160;Because&#160;&#160;an&#160;&#160;UnboundMethod&#160;&#160;is&#160;&#160;unbound,&#160;&#160;it&#160;&#160;cannot&#160;&#160;be<br/>invoked, and the&#160;UnboundMethod&#160;class does not define a&#160;call&#160;or&#160;[]&#160;method.<br/>To&#160;obtain&#160;an&#160;UnboundMethod&#160;object,&#160;use&#160;the&#160;instance_method&#160;method&#160;of&#160;any&#160;class&#160;or<br/>module:<br/>
unbound_plus = Fixnum.instance_method(&#34;+&#34;)<br/>
In&#160;&#160;Ruby&#160;&#160;1.9,&#160;&#160;you&#160;&#160;can&#160;&#160;also&#160;&#160;use&#160;&#160;public_instance_method&#160;&#160;&#160;&#160;to&#160;&#160;obtain&#160;&#160;an&#160;&#160;UnboundMethod<br/>object.&#160;It&#160;works&#160;like&#160;instance_method&#160;does,&#160;but&#160;it&#160;ignores&#160;protected&#160;and&#160;private&#160;methods<br/><a href="Rubys.html#246">(see §7.2).<br/></a>In&#160;order&#160;to&#160;invoke&#160;an&#160;unbound&#160;method,&#160;you&#160;must&#160;first&#160;bind&#160;it&#160;to&#160;an&#160;object&#160;using&#160;the<br/>bind&#160;method:<br/>
<b>204&#160;|&#160;Chapter 6:</b> <b>Methods, Procs, Lambdas, and Closures</b><br/>
<hr/>
<a name=219></a>plus_2 = unbound_plus.bind(2) &#160; # Bind the method to the object 2<br/>
The&#160;bind&#160;method&#160;returns a&#160;Method&#160;object,&#160;which&#160;can&#160;be&#160;invoked&#160;with&#160;its&#160;call&#160;method:<br/>
sum = plus_2.call(2) &#160; &#160;# =&gt; 4<br/>
Another&#160;&#160;way&#160;&#160;to&#160;&#160;obtain&#160;&#160;an&#160;&#160;UnboundMethod&#160;&#160;object&#160;&#160;is&#160;&#160;with&#160;&#160;the&#160;&#160;unbind&#160;&#160;method&#160;&#160;of&#160;&#160;the<br/>Method&#160;class:<br/>
plus_3 = plus_2.unbind.bind(3)<br/>
In&#160;Ruby&#160;1.9,&#160;UnboundMethod&#160;has&#160;name&#160;and&#160;owner&#160;methods&#160;that&#160;work&#160;just&#160;as&#160;they&#160;do&#160;for<br/>the&#160;Method&#160;class.<br/>
<b>6.8 &#160;Functional Programming<br/></b>Ruby&#160;is&#160;not&#160;a&#160;functional&#160;programming&#160;language&#160;in&#160;the&#160;way&#160;that&#160;languages&#160;like&#160;Lisp&#160;and<br/>Haskell&#160;are,&#160;but&#160;Ruby’s&#160;blocks,&#160;procs,&#160;and&#160;lambdas&#160;lend&#160;themselves&#160;nicely&#160;to&#160;a&#160;func-<br/>tional&#160;programming&#160;style.&#160;Any&#160;time&#160;you&#160;use&#160;a&#160;block&#160;with&#160;an&#160;Enumerable&#160;iterator&#160;like<br/>map&#160;or&#160;inject,&#160;you’re&#160;programming&#160;in&#160;a&#160;functional&#160;style.&#160;Here&#160;are&#160;examples&#160;using&#160;the<br/>map&#160;and&#160;inject&#160;iterators:<br/>
# Compute the average and standard deviation of an array of numbers<br/>mean = a.inject {|x,y| x+y } / a.size<br/>sumOfSquares = a.map{|x| (x-mean)**2 }.inject{|x,y| x+y }<br/>standardDeviation = Math.sqrt(sumOfSquares/(a.size-1))<br/>
If&#160;the&#160;functional&#160;programming&#160;style&#160;is&#160;attractive&#160;to&#160;you,&#160;it&#160;is&#160;easy&#160;to&#160;add&#160;features&#160;to<br/>Ruby’s&#160;built-in&#160;classes&#160;to&#160;facilitate&#160;functional&#160;programming.&#160;The&#160;rest&#160;of&#160;this&#160;chapter<br/>explores&#160;some&#160;possibilities&#160;for&#160;working&#160;with&#160;functions.&#160;The&#160;code&#160;in&#160;this&#160;section&#160;is&#160;dense<br/>and&#160;&#160;is&#160;&#160;presented&#160;&#160;as&#160;&#160;a&#160;&#160;mind-expanding&#160;&#160;exploration,&#160;&#160;not&#160;&#160;as&#160;&#160;a&#160;&#160;prescription&#160;&#160;for&#160;&#160;good<br/>programming&#160;style.&#160;In&#160;particular,&#160;redefining&#160;operators&#160;as&#160;heavily&#160;as&#160;the&#160;code&#160;in&#160;the&#160;next<br/>section&#160;&#160;does&#160;&#160;is&#160;&#160;likely&#160;&#160;to&#160;&#160;result&#160;&#160;in&#160;&#160;programs&#160;&#160;that&#160;&#160;are&#160;&#160;difficult&#160;&#160;for&#160;&#160;others&#160;&#160;to&#160;&#160;read&#160;&#160;and<br/>maintain!<br/>This&#160;is&#160;advanced&#160;material&#160;and&#160;the&#160;code&#160;that&#160;follows&#160;assumes&#160;familiarity&#160;with&#160;<a href="Rubys.html#227">Chap-<br/>ter&#160;7.&#160;</a>You&#160;may,&#160;therefore,&#160;want&#160;to&#160;skip&#160;the&#160;rest&#160;of&#160;this&#160;chapter&#160;the&#160;first&#160;time&#160;through<br/>the book.<br/>
<b>6.8.1 &#160;Applying a Function to an Enumerable<br/></b>mapand&#160;inject&#160;are&#160;two&#160;of&#160;the&#160;most&#160;important&#160;iterators&#160;defined&#160;by&#160;&#160;Enumerable.&#160;Each<br/>expects&#160;a&#160;block.&#160;If&#160;we&#160;are&#160;to&#160;write&#160;programs&#160;in&#160;a&#160;function-centric&#160;way,&#160;we&#160;might&#160;like<br/>methods&#160;&#160;on&#160;&#160;our&#160;&#160;functions&#160;&#160;that&#160;&#160;allow&#160;&#160;us&#160;&#160;to&#160;&#160;apply&#160;&#160;those&#160;&#160;functions&#160;&#160;to&#160;&#160;a&#160;&#160;specified<br/>Enumerable&#160;object:<br/>
# This module defines methods and operators for functional programming.<br/>module Functional<br/>
&#160; # Apply this function to each element of the specified Enumerable,<br/>&#160; # returning an array of results. This is the reverse of Enumerable.map.<br/>
<b>6.8 &#160;Functional Programming&#160;|&#160;205</b><br/>
<hr/>
<a name=220></a>&#160; # Use | as an operator alias. Read &#34;|&#34; as &#34;over&#34; or &#34;applied over&#34;.<br/>&#160; #&#160;<br/>&#160; # Example:<br/>&#160; # &#160; a = [[1,2],[3,4]]<br/>&#160; # &#160; sum = lambda {|x,y| x+y}<br/>&#160; # &#160; sums = sum|a &#160; # =&gt; [3,7]<br/>&#160; def apply(enum)<br/>&#160; &#160; enum.map &amp;self<br/>&#160; end<br/>&#160; alias | apply<br/>
&#160; # Use this function to &#34;reduce&#34; an enumerable to a single quantity.<br/>&#160; # This is the inverse of Enumerable.inject.<br/>&#160; # Use &lt;= as an operator alias.<br/>&#160; # Mnemonic: &lt;= looks like a needle for injections<br/>&#160; # Example:<br/>&#160; # &#160; data = [1,2,3,4]<br/>&#160; # &#160; sum = lambda {|x,y| x+y}<br/>&#160; # &#160; total = sum&lt;=data &#160; # =&gt; 10<br/>&#160; def reduce(enum)<br/>&#160; &#160; enum.inject &amp;self<br/>&#160; end<br/>&#160; alias &lt;= reduce<br/>end<br/>
# Add these functional programming methods to Proc and Method classes.<br/>class Proc; include Functional; end<br/>class Method; include Functional; end<br/>
Notice&#160;that&#160;we&#160;define&#160;methods&#160;in&#160;a&#160;module&#160;named&#160;Functional,&#160;and&#160;then&#160;we&#160;include<br/>this module into both the&#160;Proc&#160;and&#160;Method&#160;classes. In this way,&#160;apply&#160;and&#160;reduce&#160;work<br/>for&#160;both&#160;proc&#160;and&#160;method&#160;objects.&#160;Most&#160;of&#160;the&#160;methods&#160;that&#160;follow&#160;also&#160;define&#160;methods<br/>in this&#160;Functional&#160;module, so that they work for both&#160;Proc&#160;and&#160;Method.<br/>With&#160;apply&#160;and&#160;reduce&#160;defined&#160;as&#160;above,&#160;we&#160;could&#160;refactor&#160;our&#160;statistical&#160;computations<br/>as follows:<br/>
sum = lambda {|x,y| x+y } &#160; &#160; &#160; &#160;# A function to add two numbers<br/>mean = (sum&lt;=a)/a.size &#160; &#160; &#160; &#160; &#160; # Or sum.reduce(a) or a.inject(&amp;sum)<br/>deviation = lambda {|x| x-mean } # Function to compute difference from mean<br/>square = lambda {|x| x*x } &#160; &#160; &#160; # Function to square a number<br/>standardDeviation = Math.sqrt((sum&lt;=square|(deviation|a))/(a.size-1))<br/>
Notice&#160;that&#160;the&#160;last&#160;line&#160;is&#160;succinct&#160;but&#160;that&#160;all&#160;the&#160;nonstandard&#160;operators&#160;make&#160;it&#160;hard<br/>to&#160;read.&#160;Also&#160;notice&#160;that&#160;the&#160;|&#160;operator&#160;is&#160;left-associative,&#160;even&#160;when&#160;we&#160;define&#160;it&#160;our-<br/>selves.&#160;The&#160;syntax,&#160;therefore,&#160;for&#160;applying&#160;multiple&#160;functions&#160;to&#160;an&#160;Enumerable&#160;requires<br/>parentheses.&#160;&#160;That&#160;&#160;is,&#160;&#160;we&#160;&#160;must&#160;&#160;write&#160;&#160;square|(deviation|a)&#160;&#160;instead&#160;&#160;of<br/>square|deviation|a.<br/>
<b>206&#160;|&#160;Chapter 6:</b> <b>Methods, Procs, Lambdas, and Closures</b><br/>
<hr/>
<a name=221></a><b>6.8.2 &#160;Composing Functions<br/></b>If&#160;we&#160;have&#160;two&#160;functions&#160;f&#160;and&#160;g,&#160;we&#160;sometimes&#160;want&#160;to&#160;define&#160;a&#160;new&#160;function&#160;h&#160;which<br/>is&#160;&#160;f(g()),&#160;&#160;or&#160;&#160;<i>f&#160;&#160;composed&#160;&#160;with&#160;&#160;g</i>.&#160;&#160;We&#160;&#160;can&#160;&#160;write&#160;&#160;a&#160;&#160;method&#160;&#160;that&#160;&#160;performs&#160;&#160;function<br/>composition automatically, as follows:<br/>
module Functional<br/>&#160; # Return a new lambda that computes self[f[args]].<br/>&#160; # Use * as an operator alias for compose.<br/>&#160; # Examples, using the * alias for this method.<br/>&#160; #&#160;<br/>&#160; # f = lambda {|x| x*x }<br/>&#160; # g = lambda {|x| x+1 }<br/>&#160; # (f*g)[2] &#160; # =&gt; 9<br/>&#160; # (g*f)[2] &#160; # =&gt; 5<br/>&#160; #&#160;<br/>&#160; # def polar(x,y)<br/>&#160; # &#160; [Math.hypot(y,x), Math.atan2(y,x)]<br/>&#160; # end<br/>&#160; # def cartesian(magnitude, angle)<br/>&#160; # &#160; [magnitude*Math.cos(angle), magnitude*Math.sin(angle)]<br/>&#160; # end<br/>&#160; # p,c = method :polar, method :cartesian<br/>&#160; # (c*p)[3,4] &#160;# =&gt; [3,4]<br/>&#160; #&#160;<br/>&#160; def compose(f)<br/>&#160; &#160; if self.respond_to?(:arity) &amp;&amp; self.arity == 1<br/>&#160; &#160; &#160; lambda {|*args| self[f[*args]] }<br/>&#160; &#160; else<br/>&#160; &#160; &#160; lambda {|*args| self[*f[*args]] }<br/>&#160; &#160; end<br/>&#160; end<br/>
&#160; # * is the natural operator for function composition.<br/>&#160; alias * compose<br/>end<br/>
The&#160;example&#160;code&#160;in&#160;the&#160;comment&#160;demonstrates&#160;the&#160;use&#160;of&#160;compose&#160;with&#160;Method&#160;objects<br/>as&#160;well&#160;as&#160;lambdas.&#160;We&#160;can&#160;use&#160;this&#160;new&#160;*&#160;function&#160;composition&#160;operator&#160;to&#160;slightly<br/>simplify&#160;&#160;our&#160;&#160;computation&#160;&#160;of&#160;&#160;standard&#160;&#160;deviation.&#160;&#160;Using&#160;&#160;the&#160;&#160;same&#160;&#160;definitions&#160;&#160;of&#160;&#160;the<br/>lambdas&#160;sum,&#160;square, and&#160;deviation, the computation becomes:<br/>
standardDeviation = Math.sqrt((sum&lt;=square*deviation|a)/(a.size-1))<br/>
The&#160;difference&#160;is&#160;that&#160;we&#160;compose&#160;square&#160;and&#160;deviation&#160;into&#160;a&#160;single&#160;function&#160;before<br/>applying it to the array&#160;a.<br/>
<b>6.8.3 &#160;Partially Applying Functions<br/></b>In functional programming,&#160;<i>partial application</i>&#160;is&#160;the&#160;process&#160;of&#160;taking&#160;a&#160;function&#160;and<br/>a&#160;partial&#160;set&#160;of&#160;argument&#160;values&#160;and&#160;producing&#160;a&#160;new&#160;function&#160;that&#160;is&#160;equivalent&#160;to&#160;the<br/>original&#160;function&#160;with&#160;the&#160;specified&#160;arguments&#160;fixed.&#160;This&#160;is&#160;similar&#160;to,&#160;but&#160;not&#160;quite<br/>the same as currying with the&#160;Proc.curry&#160;method. For example:<br/>
<b>6.8 &#160;Functional Programming&#160;|&#160;207</b><br/>
<hr/>
<a name=222></a>product = lambda {|x, y| x*y } &#160; &#160; &#160; # A function of two arguments<br/>double = lambda {|x| product(2,x) } &#160;# Apply one argument<br/>
Partial application can be simplified with appropriate methods (and operators) in our<br/>Functional&#160;module:<br/>
module Functional<br/>&#160; #<br/>&#160; # Return a lambda equivalent to this one with one or more initial&#160;<br/>&#160; # arguments applied. When only a single argument<br/>&#160; # is being specified, the &gt;&gt; alias may be simpler to use.<br/>&#160; # Example:<br/>&#160; # &#160; product = lambda {|x,y| x*y}<br/>&#160; # &#160; doubler = product &gt;&gt; 2<br/>&#160; #<br/>&#160; def apply_head(*first)<br/>&#160; &#160; lambda {|*rest| self[*first.concat(rest)]}<br/>&#160; end<br/>
&#160; #<br/>&#160; # Return a lambda equivalent to this one with one or more final arguments<br/>&#160; # applied. When only a single argument is being specified,<br/>&#160; # the &lt;&lt; alias may be simpler.<br/>&#160; # Example:<br/>&#160; # &#160;difference = lambda {|x,y| x-y }<br/>&#160; # &#160;decrement = difference &lt;&lt; 1<br/>&#160; #<br/>&#160; def apply_tail(*last)<br/>&#160; &#160; lambda {|*rest| self[*rest.concat(last)]}<br/>&#160; end<br/>
&#160; # Here are operator alternatives for these methods. The angle brackets<br/>&#160; # point to the side on which the argument is shifted in.<br/>&#160; alias &gt;&gt; apply_head &#160; &#160;# g = f &gt;&gt; 2 -- set first arg to 2<br/>&#160; alias &lt;&lt; apply_tail &#160; &#160;# g = f &lt;&lt; 2 -- set last arg to 2<br/>end<br/>
Using&#160;&#160;these&#160;&#160;methods&#160;&#160;and&#160;&#160;operators,&#160;&#160;we&#160;&#160;can&#160;&#160;define&#160;&#160;our&#160;&#160;double&#160;&#160;function&#160;&#160;simply&#160;&#160;as<br/>product&gt;&gt;2.&#160;We&#160;can&#160;use&#160;partial&#160;application&#160;to&#160;make&#160;our&#160;standard&#160;deviation&#160;computa-<br/>tion&#160;somewhat&#160;more&#160;abstract,&#160;by&#160;building&#160;our&#160;deviation&#160;function&#160;from&#160;a&#160;more&#160;general-<br/>purpose&#160;difference&#160;function:<br/>
difference = lambda {|x,y| x-y } &#160;# Compute difference of two numbers<br/>deviation = difference&lt;&lt;mean &#160; &#160; &#160;# Apply second argument<br/>
<b>6.8.4 &#160;Memoizing Functions<br/></b><i>Memoization</i>&#160;is&#160;a&#160;functional&#160;programming&#160;term&#160;for&#160;caching&#160;the&#160;results&#160;of&#160;a&#160;function<br/>invocation.&#160;If&#160;a&#160;function&#160;always&#160;returns&#160;the&#160;same&#160;value&#160;when&#160;passed&#160;the&#160;same&#160;argu-<br/>ments,&#160;if&#160;there&#160;is&#160;reason&#160;to&#160;believe&#160;that&#160;the&#160;same&#160;arguments&#160;will&#160;be&#160;used&#160;repeatedly,<br/>and if the computation it performs is somewhat expensive, then memoization may be<br/>a&#160;useful&#160;optimization.&#160;We&#160;can&#160;automate&#160;memoization&#160;for&#160;Proc&#160;and&#160;Method&#160;objects&#160;with<br/>the following method:<br/>
<b>208&#160;|&#160;Chapter 6:</b> <b>Methods, Procs, Lambdas, and Closures</b><br/>
<hr/>
<a name=223></a>module Functional<br/>&#160; #<br/>&#160; # Return a new lambda that caches the results of this function and&#160;<br/>&#160; # only calls the function when new arguments are supplied.<br/>&#160; #<br/>&#160; def memoize<br/>&#160; &#160; cache = {} &#160;# An empty cache. The lambda captures this in its closure.<br/>&#160; &#160; lambda {|*args|<br/>&#160; &#160; &#160; # notice that the hash key is the entire array of arguments!<br/>&#160; &#160; &#160; unless cache.has_key?(args) &#160;# If no cached result for these args<br/>&#160; &#160; &#160; &#160; cache[args] = self[*args] &#160;# Compute and cache the result<br/>&#160; &#160; &#160; end<br/>&#160; &#160; &#160; cache[args] &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Return result from cache<br/>&#160; &#160; }<br/>&#160; end<br/>&#160; # A (probably unnecessary) unary + operator for memoization<br/>&#160; # Mnemonic: the + operator means &#34;improved&#34;<br/>&#160; alias +@ memoize &#160; &#160; &#160; &#160;# cached_f = +f<br/>end<br/>
Here’s how we might use the&#160;memoize&#160;method or the unary&#160;+&#160;operator:<br/>
# A memoized recursive factorial function<br/>factorial = lambda {|x| return 1 if x==0; x*factorial[x-1]; }.memoize<br/># Or, using the unary operator syntax<br/>factorial = +lambda {|x| return 1 if x==0; x*factorial[x-1]; }<br/>
Note&#160;that&#160;the&#160;factorial&#160;function&#160;here&#160;is&#160;a&#160;recursive&#160;function.&#160;It&#160;calls&#160;the&#160;memoized<br/>version&#160;of&#160;itself,&#160;which&#160;produces&#160;optimal&#160;caching.&#160;It&#160;would&#160;not&#160;work&#160;as&#160;well&#160;if&#160;you<br/>defined&#160;a&#160;recursive&#160;nonmemoized&#160;version&#160;of&#160;the&#160;function&#160;and&#160;then&#160;defined&#160;a&#160;distinct<br/>memoized version of that:<br/>
factorial = lambda {|x| return 1 if x==0; x*factorial[x-1]; }<br/>cached_factorial = +factorial # Recursive calls aren't cached!<br/>
<b>6.8.5 &#160;Symbols, Methods, and Procs<br/></b>There&#160;is&#160;a&#160;close&#160;relationship&#160;between&#160;the&#160;Symbol,&#160;Method,&#160;and&#160;Proc&#160;classes.&#160;We’ve&#160;already<br/>seen the&#160;method&#160;method, which takes a&#160;Symbol&#160;argument and returns a&#160;Method&#160;object.<br/>Ruby&#160;1.9&#160;adds&#160;a&#160;useful&#160;to_proc&#160;method&#160;to&#160;the&#160;Symbol&#160;class.&#160;This&#160;method&#160;allows&#160;a&#160;symbol<br/>to&#160;be&#160;prefixed&#160;with&#160;&amp;&#160;and&#160;passed&#160;as&#160;a&#160;block&#160;to&#160;an&#160;iterator.&#160;The&#160;symbol&#160;is&#160;assumed&#160;to<br/>name&#160;a&#160;method.&#160;When&#160;the&#160;Proc&#160;created&#160;with&#160;this&#160;to_proc&#160;method&#160;is&#160;invoked,&#160;it&#160;calls<br/>the&#160;&#160;named&#160;&#160;method&#160;&#160;of&#160;&#160;its&#160;&#160;first&#160;&#160;argument,&#160;&#160;passing&#160;&#160;any&#160;&#160;remaining&#160;&#160;arguments&#160;&#160;to&#160;&#160;that<br/>named method. Here’s how you might use it:<br/>
# Increment an array of integers with the Fixnum.succ method<br/>[1,2,3].map(&amp;:succ) &#160;# =&gt; [2,3,4]<br/>
Without&#160;Symbol.to_proc, we’d have to be slightly more verbose:<br/>
[1,2,3].map {|n| n.succ }<br/>
<b>6.8 &#160;Functional Programming&#160;|&#160;209</b><br/>
<hr/>
<a name=224></a>Symbol.to_proc&#160;was&#160;originally&#160;devised&#160;as&#160;an&#160;extension&#160;for&#160;Ruby&#160;1.8,&#160;and&#160;it&#160;is&#160;typically<br/>implemented like this:<br/>
class Symbol<br/>&#160; def to_proc<br/>&#160; &#160; lambda {|receiver, *args| receiver.send(self, *args)}<br/>&#160; end<br/>end<br/>
This&#160;implementation&#160;uses&#160;the&#160;send&#160;method&#160;<a href="Rubys.html#288">(see&#160;§8.4.3)&#160;</a>to&#160;invoke&#160;a&#160;method&#160;named&#160;by<br/>a symbol. We could also do it like this:<br/>
class Symbol<br/>&#160; def to_proc<br/>&#160; &#160; lambda {|receiver, *args| receiver.method(self)[*args]}<br/>&#160; end<br/>end<br/>
In&#160;addition&#160;to&#160;to_proc,&#160;we&#160;can&#160;define&#160;some&#160;related&#160;and&#160;possibly&#160;useful&#160;utilities.&#160;Let’s<br/>start with the&#160;Module&#160;class:<br/>
class Module<br/>&#160; # Access instance methods with array notation. Returns UnboundMethod,<br/>&#160; alias [] instance_method<br/>end<br/>
Here,&#160;&#160;we’re&#160;&#160;simply&#160;&#160;defining&#160;&#160;a&#160;&#160;shorthand&#160;&#160;for&#160;&#160;the&#160;&#160;instance_method&#160;&#160;method&#160;&#160;of&#160;&#160;the<br/>Module&#160;class.&#160;Recall&#160;that&#160;that&#160;method&#160;returns&#160;an&#160;UnboundMethod&#160;object,&#160;that&#160;cannot&#160;be<br/>invoked&#160;until&#160;bound&#160;to&#160;a&#160;particular&#160;instance&#160;of&#160;its&#160;class.&#160;Here’s&#160;an&#160;example&#160;using&#160;this<br/>new notation (notice the appeal of indexing a class with the names of its methods!):<br/>
String[:reverse].bind(&#34;hello&#34;).call &#160; # =&gt; &#34;olleh&#34;<br/>
Binding&#160;an&#160;unbound&#160;method&#160;can&#160;also&#160;be&#160;made&#160;simpler&#160;with&#160;a&#160;bit&#160;of&#160;the&#160;same&#160;syntactic<br/>sugar:<br/>
class UnboundMethod<br/>&#160; # Allow [] as an alternative to bind. &#160;<br/>&#160; alias [] bind<br/>end<br/>
With&#160;this&#160;alias&#160;in&#160;place,&#160;and&#160;using&#160;the&#160;existing&#160;[]&#160;alias&#160;for&#160;calling&#160;a&#160;method,&#160;this&#160;code<br/>becomes:<br/>
String[:reverse][&#34;hello&#34;][] &#160; # =&gt; &#34;olleh&#34;<br/>
The&#160;first&#160;pair&#160;of&#160;brackets&#160;indexes&#160;the&#160;method,&#160;the&#160;second&#160;pair&#160;binds&#160;it,&#160;and&#160;the&#160;third<br/>pair calls it.<br/>Next,&#160;if&#160;we’re&#160;going&#160;to&#160;use&#160;the&#160;[]&#160;operator&#160;for&#160;looking&#160;up&#160;the&#160;instance&#160;methods&#160;of&#160;a<br/>class, how about using&#160;[]=&#160;for defining instance methods:<br/>
class Module<br/>&#160; # Define a instance method with name sym and body f.<br/>&#160; # Example: String[:backwards] = lambda { reverse }<br/>&#160; def []=(sym, f)<br/>
<b>210&#160;|&#160;Chapter 6:</b> <b>Methods, Procs, Lambdas, and Closures</b><br/>
<hr/>
<a name=225></a>&#160; &#160; self.instance_eval { define_method(sym, f) }<br/>&#160; end<br/>end<br/>
The&#160;&#160;definition&#160;&#160;of&#160;&#160;this&#160;&#160;[]=&#160;&#160;operator&#160;&#160;may&#160;&#160;be&#160;&#160;confusing—this&#160;&#160;is&#160;&#160;advanced&#160;&#160;Ruby.<br/>define_method&#160;is&#160;a&#160;private&#160;method&#160;of&#160;Module.&#160;We&#160;use&#160;instance_eval&#160;(a&#160;public&#160;method<br/>of&#160;Object)&#160;to&#160;run&#160;a&#160;block&#160;(including&#160;the&#160;invocation&#160;of&#160;a&#160;private&#160;method)&#160;as&#160;if&#160;it&#160;were<br/>inside&#160;the&#160;module&#160;on&#160;which&#160;the&#160;method&#160;is&#160;being&#160;defined.&#160;We’ll&#160;see&#160;instance_eval&#160;and<br/>define_method<a href="Rubys.html#279">&#160;again in Chapter 8.</a><br/>
Let’s use this new&#160;[]=&#160;operator to define a new&#160;Enumerable.average&#160;method:<br/>
Enumerable[:average] = lambda do<br/>&#160; sum, n = 0.0, 0<br/>&#160; self.each {|x| sum += x; n += 1 }<br/>&#160; if n == 0<br/>&#160; &#160; nil<br/>&#160; else<br/>&#160; &#160; sum/n<br/>&#160; end<br/>end<br/>
We’ve&#160;used&#160;the&#160;[]&#160;and&#160;[]=&#160;operators&#160;here&#160;to&#160;get&#160;and&#160;set&#160;instance&#160;methods&#160;of&#160;a&#160;class&#160;or<br/>module.&#160;We&#160;can&#160;do&#160;something&#160;similar&#160;for&#160;the&#160;singleton&#160;methods&#160;of&#160;an&#160;object&#160;(which<br/>include&#160;the&#160;class&#160;methods&#160;of&#160;a&#160;class&#160;or&#160;module).&#160;Any&#160;object&#160;can&#160;have&#160;a&#160;singleton&#160;method,<br/>but&#160;it&#160;doesn’t&#160;make&#160;sense&#160;to&#160;define&#160;an&#160;[]&#160;operator&#160;on&#160;the&#160;Object&#160;class,&#160;as&#160;so&#160;many<br/>subclasses&#160;define&#160;that&#160;operator.&#160;For&#160;singleton&#160;methods,&#160;therefore,&#160;we&#160;could&#160;take&#160;the<br/>opposite approach and define operators on the&#160;Symbol&#160;class:<br/>
#<br/># Add [] and []= operators to the Symbol class for accessing and setting<br/># singleton methods of objects. Read : as &#34;method&#34; and [] as &#34;of&#34;.<br/># So :m[o] reads &#34;method m of o&#34;.<br/>#<br/>class Symbol<br/>&#160; # Return the Method of obj named by this symbol. This may be a singleton<br/>&#160; # method of obj (such as a class method) or an instance method defined<br/>&#160; # by obj.class or inherited from a superclass.<br/>&#160; # Examples:<br/>&#160; # &#160; creator = :new[Object] &#160;# Class method Object.new<br/>&#160; # &#160; doubler = :*[2] &#160; &#160; &#160; &#160; # * method of Fixnum 2<br/>&#160; #<br/>&#160; def [](obj)<br/>&#160; &#160; obj.method(self)<br/>&#160; end<br/>&#160;&#160;<br/>&#160; # Define a singleton method on object o, using Proc or Method f as its body.<br/>&#160; # This symbol is used as the name of the method.<br/>&#160; # Examples:<br/>&#160; #<br/>&#160; # &#160;:singleton[o] = lambda { puts &#34;this is a singleton method of o&#34; }<br/>&#160; # &#160;:class_method[String] = lambda { puts &#34;this is a class method&#34; }<br/>&#160; #&#160;<br/>&#160; # Note that you can't create instance methods this way. See Module.[]=<br/>
<b>6.8 &#160;Functional Programming&#160;|&#160;211</b><br/>
<hr/>
<a name=226></a>&#160; #<br/>&#160; def []=(o,f)<br/>&#160; &#160; # We can't use self in the block below, as it is evaluated in the&#160;<br/>&#160; &#160; # context of a different object. So we have to assign self to a variable.<br/>&#160; &#160; sym = self<br/>&#160; &#160; # This is the object we define singleton methods on.<br/>&#160; &#160; eigenclass = (class &lt;&lt; o; self end)<br/>&#160; &#160; # define_method is private, so we have to use instance_eval to execute it.<br/>&#160; &#160; eigenclass.instance_eval { define_method(sym, f) }<br/>&#160; end<br/>end<br/>
With&#160;&#160;this&#160;&#160;Symbol.[]&#160;&#160;method&#160;&#160;defined,&#160;&#160;along&#160;&#160;with&#160;&#160;the&#160;&#160;Functional&#160;&#160;module&#160;&#160;described<br/>previously, we can write clever (and unreadable) code like this:<br/>
dashes = :*['-'] &#160; &#160; &#160; # Method * of '-'<br/>puts dashes[10] &#160; &#160; &#160; &#160;# Prints &#34;----------&#34;<br/>
y = (:+[1]*:*[2])[x] &#160; # Another way to write y = 2*x + 1<br/>
The&#160;&#160;definition&#160;&#160;of&#160;&#160;[]=&#160;&#160;for&#160;&#160;Symbol&#160;&#160;is&#160;&#160;like&#160;&#160;that&#160;&#160;of&#160;&#160;[]=&#160;&#160;for&#160;&#160;Module,&#160;&#160;in&#160;&#160;that&#160;&#160;it&#160;&#160;uses<br/>instance_eval&#160;to&#160;invoke&#160;the&#160;define_method&#160;method.&#160;The&#160;difference&#160;is&#160;that&#160;singleton<br/>methods&#160;are&#160;not&#160;defined&#160;within&#160;a&#160;class,&#160;as&#160;instance&#160;methods&#160;are,&#160;but&#160;in&#160;the&#160;<i>eigenclass<br/></i><a href="Rubys.html#227">of the object. We’ll encounter the eigenclass again in Chapter 7.</a><br/>
<b>212&#160;|&#160;Chapter 6:</b> <b>Methods, Procs, Lambdas, and Closures</b><br/>
<hr/>
<a name=227></a><img src="Ruby-227_1.jpg"/><br/>
<b>CHAPTER&#160;7</b><br/>
<b>Classes and Modules</b><br/>
<b>213</b><br/>
<hr/>
<a name=228></a>Ruby&#160;is&#160;an&#160;object-oriented&#160;language&#160;in&#160;a&#160;very&#160;pure&#160;sense:&#160;every&#160;value&#160;in&#160;Ruby&#160;is&#160;(or&#160;at<br/>least&#160;behaves&#160;like)&#160;an&#160;object.&#160;Every&#160;object&#160;is&#160;an&#160;instance&#160;of&#160;a&#160;class.&#160;A&#160;class&#160;defines&#160;a&#160;set<br/>of&#160;methods&#160;that&#160;an&#160;object&#160;responds&#160;to.&#160;Classes&#160;may&#160;extend&#160;or&#160;subclass&#160;other&#160;classes,<br/>and&#160;inherit&#160;or&#160;override&#160;the&#160;methods&#160;of&#160;their&#160;superclass.&#160;Classes&#160;can&#160;also&#160;include—or<br/>inherit methods from—modules.<br/>Ruby’s&#160;objects&#160;are&#160;strictly&#160;encapsulated:&#160;their&#160;state&#160;can&#160;be&#160;accessed&#160;only&#160;through&#160;the<br/>methods&#160;they&#160;define.&#160;The&#160;instance&#160;variables&#160;manipulated&#160;by&#160;those&#160;methods&#160;cannot&#160;be<br/>directly&#160;accessed&#160;from&#160;outside&#160;of&#160;the&#160;object.&#160;It&#160;is&#160;possible&#160;to&#160;define&#160;getter&#160;and&#160;setter<br/>accessor&#160;methods&#160;that&#160;appear&#160;to&#160;access&#160;object&#160;state&#160;directly.&#160;These&#160;pairs&#160;of&#160;accessor<br/>methods&#160;are&#160;known&#160;as&#160;<i>attributes</i>&#160;and&#160;are&#160;distinct&#160;from&#160;instance&#160;variables.&#160;The&#160;methods<br/>defined&#160;by&#160;a&#160;class&#160;may&#160;have&#160;“public,”&#160;“protected,”&#160;or&#160;“private”&#160;visibility,&#160;which&#160;affects<br/>how and where they may be invoked.<br/>In&#160;contrast&#160;to&#160;the&#160;strict&#160;encapsulation&#160;of&#160;object&#160;state,&#160;Ruby’s&#160;classes&#160;are&#160;very&#160;open.&#160;Any<br/>Ruby&#160;&#160;program&#160;&#160;can&#160;&#160;add&#160;&#160;methods&#160;&#160;to&#160;&#160;existing&#160;&#160;classes,&#160;&#160;and&#160;&#160;it&#160;&#160;is&#160;&#160;even&#160;&#160;possible&#160;&#160;to&#160;&#160;add<br/>“singleton methods” to individual objects.<br/>Much&#160;of&#160;Ruby’s&#160;OO&#160;architecture&#160;is&#160;part&#160;of&#160;the&#160;core&#160;language.&#160;Other&#160;parts,&#160;such&#160;as&#160;the<br/>creation&#160;of&#160;attributes&#160;and&#160;the&#160;declaration&#160;of&#160;method&#160;visibility,&#160;are&#160;done&#160;with&#160;methods<br/>rather&#160;than&#160;true&#160;language&#160;keywords.&#160;This&#160;chapter&#160;begins&#160;with&#160;an&#160;extended&#160;tutorial&#160;that<br/>demonstrates&#160;how&#160;to&#160;define&#160;a&#160;class&#160;and&#160;add&#160;methods&#160;to&#160;it.&#160;This&#160;tutorial&#160;is&#160;followed&#160;by<br/>sections on more advanced topics, including:<br/>
•&#160;Method visibility<br/>•&#160;Subclassing and inheritance<br/>•&#160;Object creation and initialization<br/>•&#160;Modules, both as namespaces and as includable “mixins”<br/>•&#160;Singleton methods and the eigenclass<br/>•&#160;The method name resolution algorithm<br/>•&#160;The constant name resolution algorithm<br/>
<b>7.1 &#160;Defining a Simple Class<br/></b>We&#160;begin&#160;our&#160;coverage&#160;of&#160;classes&#160;with&#160;an&#160;extended&#160;tutorial&#160;that&#160;develops&#160;a&#160;class&#160;named<br/>Point&#160;to&#160;represent&#160;a&#160;geometric&#160;point&#160;with&#160;X&#160;and&#160;Y&#160;coordinates.&#160;The&#160;subsections&#160;that<br/>follow demonstrate how to:<br/>
•&#160;Define a new class<br/>•&#160;Create instances of that class<br/>•&#160;Write an initializer method for the class<br/>•&#160;Add attribute accessor methods to the class<br/>•&#160;Define operators for the class<br/>
<b>214&#160;|&#160;Chapter 7:</b> <b>Classes and Modules</b><br/>
<hr/>
<a name=229></a>•&#160;Define an iterator method and make the class&#160;Enumerable<br/>•&#160;Override important&#160;Object&#160;methods such as&#160;to_s,&#160;==,&#160;hash, and&#160;&lt;=&gt;<br/>•&#160;Define class methods, class variables, class instance variables, and constants<br/>
<b>7.1.1 &#160;Creating the Class<br/></b>Classes are created in Ruby with the&#160;class&#160;keyword:<br/>
class Point<br/>end<br/>
Like&#160;most&#160;Ruby&#160;constructs,&#160;a&#160;class&#160;definition&#160;is&#160;delimited&#160;with&#160;an&#160;end.&#160;In&#160;addition&#160;to<br/>defining&#160;a&#160;new&#160;class,&#160;the&#160;class&#160;keyword&#160;creates&#160;a&#160;new&#160;constant&#160;to&#160;refer&#160;to&#160;the&#160;class.&#160;The<br/>class&#160;name&#160;and&#160;the&#160;constant&#160;name&#160;are&#160;the&#160;same,&#160;so&#160;all&#160;class&#160;names&#160;must&#160;begin&#160;with&#160;a<br/>capital letter.<br/>Within the body of a&#160;class, but outside of any instance methods defined by the class,<br/>the&#160;self&#160;keyword refers to the class being defined.<br/>Like&#160;most&#160;statements&#160;in&#160;Ruby,&#160;class&#160;is&#160;an&#160;expression.&#160;The&#160;value&#160;of&#160;a&#160;class&#160;expression<br/>is&#160;the&#160;value&#160;of&#160;the&#160;last&#160;expression&#160;within&#160;the&#160;class&#160;body.&#160;Typically,&#160;the&#160;last&#160;expression<br/>within&#160;a&#160;class&#160;is&#160;a&#160;def&#160;statement&#160;that&#160;defines&#160;a&#160;method.&#160;The&#160;value&#160;of&#160;a&#160;def&#160;statement is<br/>always&#160;nil.<br/>
<b>7.1.2 &#160;Instantiating a Point<br/></b>Even though we haven’t put anything in our&#160;Point&#160;class yet, we can still instantiate it:<br/>
p = Point.new<br/>
The constant&#160;Point&#160;holds&#160;a&#160;class&#160;object&#160;that&#160;represents&#160;our&#160;new&#160;class.&#160;All&#160;class&#160;objects<br/>have a method named&#160;new&#160;that creates a new instance.<br/>We&#160;can’t&#160;do&#160;anything&#160;very&#160;interesting&#160;with&#160;the&#160;newly&#160;created&#160;Point&#160;object&#160;we’ve&#160;stored<br/>in&#160;the&#160;local&#160;variable&#160;p,&#160;because&#160;we&#160;haven’t&#160;yet&#160;defined&#160;any&#160;methods&#160;for&#160;the&#160;class.&#160;We<br/>can, however, ask the new object what kind of object it is:<br/>
p.class &#160; &#160; &#160; # =&gt; Point<br/>p.is_a? Point # =&gt; true<br/>
<b>7.1.3 &#160;Initializing a Point<br/></b>When we create new&#160;Point&#160;objects, we want to initialize them with two numbers that<br/>represent&#160;their&#160;X&#160;and&#160;Y&#160;coordinates.&#160;In&#160;many&#160;object-oriented&#160;languages,&#160;this&#160;is&#160;done<br/>with a “constructor.” In Ruby, it is done with an&#160;initialize&#160;method:<br/>
class Point<br/>&#160; def initialize(x,y)<br/>&#160; &#160; @x, @y = x, y<br/>
<b>7.1 &#160;Defining a Simple Class&#160;|&#160;215</b><br/>
<hr/>
<a name=230></a>&#160; end<br/>end<br/>
This&#160;is&#160;only&#160;three&#160;new&#160;lines&#160;of&#160;code,&#160;but&#160;there&#160;are&#160;a&#160;couple&#160;of&#160;important&#160;things&#160;to&#160;point<br/>out&#160;here.&#160;We&#160;explained&#160;the&#160;def&#160;keyword&#160;in&#160;detail&#160;<a href="Rubys.html#189">in&#160;Chapter&#160;6.&#160;</a>But&#160;that&#160;chapter&#160;focused<br/>on&#160;defining&#160;global&#160;functions&#160;that&#160;could&#160;be&#160;used&#160;from&#160;anywhere.&#160;When&#160;def&#160;is&#160;used&#160;like<br/>this&#160;with&#160;an&#160;unqualified&#160;method&#160;name&#160;inside&#160;of&#160;a&#160;class&#160;definition,&#160;it&#160;defines&#160;an&#160;<i>instance<br/>method</i>&#160;for&#160;the&#160;class.&#160;An&#160;instance&#160;method&#160;is&#160;a&#160;method&#160;that&#160;is&#160;invoked&#160;on&#160;an&#160;instance&#160;of<br/>the&#160;class.&#160;When&#160;an&#160;instance&#160;method&#160;is&#160;called,&#160;the&#160;value&#160;of&#160;self&#160;is&#160;an&#160;instance&#160;of&#160;the<br/>class in which the method is defined.<br/>The&#160;next&#160;point&#160;to&#160;understand&#160;is&#160;that&#160;the&#160;initialize&#160;method&#160;has&#160;a&#160;special&#160;purpose&#160;in<br/>Ruby.&#160;The&#160;new&#160;method&#160;of&#160;the&#160;class&#160;object&#160;creates&#160;a&#160;new&#160;instance&#160;object,&#160;and&#160;then&#160;it<br/>automatically&#160;invokes&#160;the&#160;initialize&#160;method&#160;on&#160;that&#160;instance.&#160;Whatever&#160;arguments<br/>you&#160;passed&#160;to&#160;new&#160;are&#160;passed&#160;on&#160;to&#160;initialize.&#160;Because&#160;our&#160;initialize&#160;method&#160;expects<br/>two arguments, we must now supply two values when we invoke&#160;Point.new:<br/>
p = Point.new(0,0)<br/>
In&#160;addition&#160;to&#160;being&#160;automatically&#160;invoked&#160;by&#160;Point.new,&#160;the&#160;initialize&#160;method&#160;is<br/>automatically&#160;made&#160;private.&#160;An&#160;object&#160;can&#160;call&#160;initialize&#160;on&#160;itself,&#160;but&#160;you&#160;cannot<br/>explicitly call&#160;initialize&#160;on&#160;p&#160;to reinitialize its state.<br/>Now,&#160;let’s&#160;look&#160;at&#160;the&#160;body&#160;of&#160;the&#160;initialize&#160;method.&#160;It&#160;takes&#160;the&#160;two&#160;values&#160;we’ve<br/>passed&#160;it,&#160;stored&#160;in&#160;local&#160;variables&#160;x&#160;and&#160;y,&#160;and&#160;assigns&#160;them&#160;to&#160;instance&#160;variables&#160;@x<br/>and&#160;@y.&#160;Instance&#160;variables&#160;always&#160;begin&#160;with&#160;@,&#160;and&#160;they&#160;always&#160;“belong&#160;to”&#160;whatever<br/>object&#160;self&#160;refers&#160;to.&#160;Each&#160;instance&#160;of&#160;our&#160;Point&#160;class&#160;has&#160;its&#160;own&#160;copy&#160;of&#160;these&#160;two<br/>variables, which hold its own X and Y coordinates.<br/>
<b>Instance Variable Encapsulation</b><br/>
The&#160;instance&#160;variables&#160;of&#160;an&#160;object&#160;can&#160;only&#160;be&#160;accessed&#160;by&#160;the&#160;instance&#160;methods&#160;of<br/>that&#160;object.&#160;Code&#160;that&#160;is&#160;not&#160;inside&#160;an&#160;instance&#160;method&#160;cannot&#160;read&#160;or&#160;set&#160;the&#160;value&#160;of<br/>an&#160;instance&#160;variable&#160;(unless&#160;it&#160;uses&#160;one&#160;of&#160;the&#160;reflective&#160;techniques&#160;that&#160;are&#160;described<br/><a href="Rubys.html#279">in Chapter 8).</a><br/>
Finally,&#160;a&#160;caution&#160;for&#160;programmers&#160;who&#160;are&#160;used&#160;to&#160;Java&#160;and&#160;related&#160;languages.&#160;In<br/>statically&#160;typed&#160;languages,&#160;you&#160;must&#160;declare&#160;your&#160;variables,&#160;including&#160;instance&#160;varia-<br/>bles. You know that Ruby variables don’t need to be declared, but you might still feel<br/>that you have to write something like this:<br/>
# Incorrect code!<br/>class Point<br/>&#160; @x = 0 &#160; # Create instance variable @x and assign a default. WRONG!<br/>&#160; @y = 0 &#160; # Create instance variable @y and assign a default. WRONG!<br/>
&#160; def initialize(x,y)<br/>&#160; &#160; @x, @y = x, y &#160; # Now initialize previously created @x and @y.<br/>&#160; end<br/>end<br/>
<b>216&#160;|&#160;Chapter 7:</b> <b>Classes and Modules</b><br/>
<hr/>
<a name=231></a>This&#160;code&#160;does&#160;not&#160;do&#160;at&#160;all&#160;what&#160;a&#160;Java&#160;programmer&#160;expects.&#160;Instance&#160;variables&#160;are<br/>always&#160;resolved&#160;in&#160;the&#160;context&#160;of&#160;self. When the&#160;initialize&#160;method&#160;is&#160;invoked,&#160;self<br/>holds&#160;an&#160;instance&#160;of&#160;the&#160;Point&#160;class.&#160;But&#160;the&#160;code&#160;outside&#160;of&#160;that&#160;method&#160;is&#160;executed<br/>as&#160;part&#160;of&#160;the&#160;definition&#160;of&#160;the&#160;Point&#160;class.&#160;When&#160;those&#160;first&#160;two&#160;assignments&#160;are&#160;exe-<br/>cuted,&#160;self&#160;refers&#160;to&#160;the&#160;Point&#160;class&#160;itself,&#160;not&#160;to&#160;an&#160;instance&#160;of&#160;the&#160;class.&#160;The&#160;@x&#160;and<br/>@y&#160;variables inside the&#160;initialize&#160;method are completely different from those outside<br/>it.<br/>
<b>7.1.4 &#160;Defining a to_s Method<br/></b>Just&#160;about&#160;any&#160;class&#160;you&#160;define&#160;should&#160;have&#160;a&#160;to_s&#160;instance&#160;method&#160;to&#160;return&#160;a&#160;string<br/>representation&#160;of&#160;the&#160;object.&#160;This&#160;ability&#160;proves&#160;invaluable&#160;when&#160;debugging.&#160;Here’s<br/>how we might do this for&#160;Point:<br/>
class Point<br/>&#160; def initialize(x,y)<br/>&#160; &#160; @x, @y = x, y<br/>&#160; end<br/>
&#160; def to_s &#160; &#160; &#160; &#160;# Return a String that represents this point<br/>&#160; &#160; &#34;(#@x,#@y)&#34; &#160; # Just interpolate the instance variables into a string<br/>&#160; end<br/>end<br/>
With this new method defined, we can create points and print them out:<br/>
p = Point.new(1,2) &#160; # Create a new Point object<br/>puts p &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Displays &#34;(1,2)&#34;<br/>
<b>7.1.5 &#160;Accessors and Attributes<br/></b>Our&#160;Point&#160;class&#160;uses&#160;two&#160;instance&#160;variables.&#160;As&#160;we’ve&#160;noted,&#160;however,&#160;the&#160;value&#160;of&#160;these<br/>variables&#160;are&#160;only&#160;accessible&#160;to&#160;other&#160;instance&#160;methods.&#160;If&#160;we&#160;want&#160;users&#160;of&#160;the&#160;Point<br/>class&#160;to&#160;be&#160;able&#160;to&#160;use&#160;the&#160;X&#160;and&#160;Y&#160;coordinates&#160;of&#160;a&#160;point,&#160;we’ve&#160;got&#160;to&#160;provide&#160;accessor<br/>methods that return the value of the variables:<br/>
class Point<br/>&#160; def initialize(x,y)<br/>&#160; &#160; @x, @y = x, y<br/>&#160; end<br/>
&#160; def x &#160; &#160; &#160; &#160; &#160; # The accessor (or getter) method for @x<br/>&#160; &#160; @x<br/>&#160; end<br/>
&#160; def y &#160; &#160; &#160; &#160; &#160; # The accessor method for @y<br/>&#160; &#160; @y<br/>&#160; end<br/>end<br/>
With these methods defined, we can write code like this:<br/>
<b>7.1 &#160;Defining a Simple Class&#160;|&#160;217</b><br/>
<hr/>
<a name=232></a>p = Point.new(1,2)<br/>q = Point.new(p.x*2, p.y*3)<br/>
The&#160;expressions&#160;p.x&#160;and&#160;p.y&#160;may&#160;look&#160;like&#160;variable&#160;references,&#160;but&#160;they&#160;are,&#160;in&#160;fact,<br/>method invocations without parentheses.<br/>If&#160;we&#160;wanted&#160;our&#160;Point&#160;class&#160;to&#160;be&#160;mutable&#160;(which&#160;is&#160;probably&#160;not&#160;a&#160;good&#160;idea),&#160;we<br/>would also add setter methods to set the value of the instance variables:<br/>
class MutablePoint<br/>&#160; def initialize(x,y); @x, @y = x, y; end<br/>
&#160; def x; @x; end &#160; &#160; &#160; # The getter method for @x<br/>&#160; def y; @y; end &#160; &#160; &#160; # The getter method for @y<br/>
&#160; def x=(value) &#160; &#160; &#160; &#160;# The setter method for @x<br/>&#160; &#160; @x = value<br/>&#160; end<br/>
&#160; def y=(value) &#160; &#160; &#160; &#160;# The setter method for @y<br/>&#160; &#160; @y = value<br/>&#160; end<br/>end<br/>
Recall&#160;that&#160;assignment&#160;expressions&#160;can&#160;be&#160;used&#160;to&#160;invoke&#160;setter&#160;methods&#160;like&#160;these.&#160;So<br/>with these methods defined, we can write:<br/>
p = Point.new(1,1)<br/>p.x = 0<br/>p.y = 0<br/>
<b>Using Setters Inside a Class</b><br/>
&#160;<br/>
Once&#160;you’ve&#160;defined&#160;a&#160;setter&#160;method&#160;like&#160;x=&#160;for&#160;your&#160;class,&#160;you&#160;might&#160;be&#160;tempted&#160;to<br/>use&#160;it&#160;within&#160;other&#160;instance&#160;methods&#160;of&#160;your&#160;class.&#160;That&#160;is,&#160;instead&#160;of&#160;writing&#160;@x=2, you<br/>might&#160;write&#160;x=2,&#160;intending&#160;to&#160;invoke&#160;x=(2)&#160;implicitly&#160;on&#160;self.&#160;It&#160;doesn’t&#160;work,&#160;of&#160;course;<br/>x=2&#160;simply creates a new local variable.<br/>
This&#160;is&#160;a&#160;not-uncommon&#160;mistake&#160;for&#160;novices&#160;who&#160;are&#160;just&#160;learning&#160;about&#160;setter&#160;methods<br/>and&#160;assignment&#160;in&#160;Ruby.&#160;The&#160;rule&#160;is&#160;that&#160;assignment&#160;expressions&#160;will&#160;only&#160;invoke&#160;a<br/>setter&#160;method&#160;when&#160;invoked&#160;through&#160;an&#160;object.&#160;If&#160;you&#160;want&#160;to&#160;use&#160;a&#160;setter&#160;from&#160;within<br/>the class that defines it, invoke it explicitly through&#160;self. For example:&#160;self.x=2.<br/>
This&#160;combination&#160;of&#160;instance&#160;variable&#160;with&#160;trivial&#160;getter&#160;and&#160;setter&#160;methods&#160;is&#160;so&#160;com-<br/>mon&#160;that&#160;Ruby&#160;provides&#160;a&#160;way&#160;to&#160;automate&#160;it.&#160;The&#160;&#160;attr_reader&#160;and&#160;attr_accessor<br/>methods&#160;are&#160;defined&#160;by&#160;the&#160;Module&#160;class.&#160;All&#160;classes&#160;are&#160;modules,&#160;(the&#160;Class&#160;class&#160;is&#160;a<br/>subclass&#160;of&#160;Module)&#160;so&#160;you&#160;can&#160;invoke&#160;these&#160;methods&#160;inside&#160;any&#160;class&#160;definition.&#160;Both<br/>methods&#160;take&#160;any&#160;number&#160;of&#160;symbols&#160;naming&#160;attributes.&#160;attr_reader&#160;creates&#160;trivial<br/>getter&#160;methods&#160;for&#160;the&#160;instance&#160;variables&#160;with&#160;the&#160;same&#160;name.&#160;attr_accessor&#160;creates<br/>getter&#160;and&#160;setter&#160;methods.&#160;(The&#160;infrequently&#160;used&#160;attr_writer&#160;creates&#160;setter&#160;methods<br/>only.) Thus, if we were defining a mutable&#160;Point&#160;class, we could write:<br/>
<b>218&#160;|&#160;Chapter 7:</b> <b>Classes and Modules</b><br/>
<hr/>
<a name=233></a>class Point<br/>&#160; attr_accessor :x, :y # Define accessor methods for our instance variables<br/>end<br/>
And if we were defining an immutable version of the class, we’d write:<br/>
class Point<br/>&#160; attr_reader :x, :y &#160;# Define reader methods for our instance variables<br/>end<br/>
Each&#160;of&#160;these&#160;methods&#160;can&#160;accept&#160;an&#160;attribute&#160;name&#160;or&#160;names&#160;as&#160;a&#160;string&#160;rather&#160;than<br/>as&#160;a&#160;symbol.&#160;The&#160;accepted&#160;style&#160;is&#160;to&#160;use&#160;symbols,&#160;but&#160;we&#160;can&#160;also&#160;write&#160;code&#160;like&#160;this:<br/>
attr_reader &#34;x&#34;, &#34;y&#34;<br/>
attr&#160;is&#160;a&#160;similar&#160;method&#160;with&#160;a&#160;shorter&#160;name&#160;&#160;but&#160;with&#160;behavior&#160;that&#160;differs&#160;in&#160;Ruby<br/>1.8&#160;and&#160;Ruby&#160;1.9.&#160;In&#160;1.8,&#160;attr&#160;can&#160;define&#160;only&#160;a&#160;single&#160;attribute&#160;at&#160;a&#160;time.&#160;With&#160;a&#160;single<br/>symbol&#160;argument,&#160;it&#160;defines&#160;a&#160;getter&#160;method.&#160;If&#160;the&#160;symbol&#160;is&#160;followed&#160;by&#160;the&#160;value<br/>true, then it defines a setter method as well:<br/>
attr :x &#160; &#160; &#160; &#160;# Define a trivial getter method x for @x<br/>attr :y, true &#160;# Define getter and setter methods for @y<br/>
In&#160;&#160;Ruby&#160;&#160;1.9,&#160;&#160;attr&#160;&#160;can&#160;&#160;be&#160;&#160;used&#160;&#160;as&#160;&#160;it&#160;&#160;is&#160;&#160;in&#160;&#160;1.8,&#160;&#160;or&#160;&#160;it&#160;&#160;can&#160;&#160;be&#160;&#160;used&#160;&#160;as&#160;&#160;a&#160;&#160;synonym&#160;&#160;for<br/>attr_reader.<br/>
The&#160;attr,&#160;attr_reader,&#160;and&#160;attr_accessor&#160;methods&#160;create&#160;instance&#160;methods&#160;for&#160;us.<br/>This&#160;is&#160;an&#160;example&#160;of&#160;<i>metaprogramming</i>,&#160;and&#160;the&#160;ability&#160;to&#160;do&#160;it&#160;is&#160;a&#160;powerful&#160;feature<br/><a href="Rubys.html#279">of Ruby. There are more examples of metaprogramming in&#160;Chapter 8. Note that&#160;</a>attr<br/>and&#160;its&#160;related&#160;methods&#160;are&#160;invoked&#160;within&#160;a&#160;class&#160;definition&#160;but&#160;outside&#160;of&#160;any&#160;method<br/>definitions.&#160;They&#160;are&#160;only&#160;executed&#160;once,&#160;when&#160;the&#160;class&#160;is&#160;being&#160;defined.&#160;There&#160;are&#160;no<br/>efficiency&#160;concerns&#160;here:&#160;the&#160;getter&#160;and&#160;setter&#160;methods&#160;they&#160;create&#160;are&#160;just&#160;as&#160;fast&#160;as<br/>handcoded&#160;ones.&#160;Remember&#160;that&#160;these&#160;methods&#160;are&#160;only&#160;able&#160;to&#160;create&#160;trivial&#160;getters<br/>and&#160;setters&#160;that&#160;map&#160;directly&#160;to&#160;the&#160;value&#160;of&#160;an&#160;instance&#160;variable&#160;with&#160;the&#160;same&#160;name.<br/>If&#160;you&#160;need&#160;more&#160;complicated&#160;accessors,&#160;such&#160;as&#160;setters&#160;that&#160;set&#160;a&#160;differently&#160;named<br/>variable,&#160;or&#160;getters&#160;that&#160;return&#160;a&#160;value&#160;computed&#160;from&#160;two&#160;different&#160;variables,&#160;then<br/>you’ll have to define those yourself.<br/>
<b>7.1.6 &#160;Defining Operators<br/></b>We’d&#160;like&#160;the&#160;+&#160;operator&#160;to&#160;perform&#160;vector&#160;addition&#160;of&#160;two&#160;Point&#160;objects,&#160;the&#160;*&#160;operator<br/>to&#160;multiply&#160;a&#160;Point&#160;by&#160;a&#160;scalar,&#160;and&#160;the&#160;unary&#160;–&#160;operator&#160;to&#160;do&#160;the&#160;equivalent&#160;of&#160;mul-<br/>tiplying&#160;by&#160;–1.&#160;Method-based&#160;operators&#160;such&#160;as&#160;+&#160;are&#160;simply&#160;methods&#160;with&#160;punctuation<br/>for&#160;names.&#160;Because&#160;there&#160;are&#160;unary&#160;and&#160;binary&#160;forms&#160;of&#160;the&#160;–&#160;operator,&#160;Ruby&#160;uses&#160;the<br/>method&#160;name&#160;–@&#160;for&#160;unary&#160;minus.&#160;Here&#160;is&#160;a&#160;version&#160;of&#160;the&#160;Point&#160;class&#160;with&#160;mathematical<br/>operators defined:<br/>
class Point<br/>&#160; attr_reader :x, :y &#160; # Define accessor methods for our instance variables<br/>
&#160; def initialize(x,y)<br/>
<b>7.1 &#160;Defining a Simple Class&#160;|&#160;219</b><br/>
<hr/>
<a name=234></a>&#160; &#160; @x,@y = x, y<br/>&#160; end<br/>
&#160; def +(other) &#160; &#160; &#160; &#160; # Define + to do vector addition<br/>&#160; &#160; Point.new(@x + other.x, @y + other.y)<br/>&#160; end<br/>
&#160; def -@ &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Define unary minus to negate both coordinates<br/>&#160; &#160; Point.new(-@x, -@y)<br/>&#160; end<br/>
&#160; def *(scalar) &#160; &#160; &#160; &#160;# Define * to perform scalar multiplication<br/>&#160; &#160; Point.new(@x*scalar, @y*scalar)<br/>&#160; end<br/>end<br/>
Take&#160;a&#160;look&#160;at&#160;the&#160;body&#160;of&#160;the&#160;+&#160;method.&#160;It&#160;is&#160;able&#160;to&#160;use&#160;the&#160;@x&#160;instance&#160;variable&#160;of&#160;self<br/>—the&#160;object&#160;that&#160;the&#160;method&#160;is&#160;invoked&#160;on.&#160;But&#160;it&#160;cannot&#160;access&#160;@x&#160;in the other&#160;Point<br/>object.&#160;Ruby&#160;simply&#160;does&#160;not&#160;have&#160;a&#160;syntax&#160;for&#160;this;&#160;all&#160;instance&#160;variable&#160;references<br/>implicitly use&#160;self. Our&#160;+&#160;method,&#160;therefore,&#160;is&#160;dependent&#160;on&#160;the&#160;x&#160;and&#160;y&#160;getter meth-<br/>ods.&#160;(We’ll&#160;see&#160;later&#160;that&#160;it&#160;is&#160;possible&#160;to&#160;restrict&#160;the&#160;visibility&#160;of&#160;methods&#160;so&#160;that&#160;objects<br/>of&#160;the&#160;same&#160;class&#160;can&#160;use&#160;each&#160;other’s&#160;methods,&#160;but&#160;code&#160;outside&#160;the&#160;class&#160;cannot&#160;use<br/>them.)<br/>
<b>Type Checking and Duck Typing</b><br/>
Our&#160;+&#160;method&#160;does&#160;not&#160;do&#160;any&#160;type&#160;checking;&#160;it&#160;simply&#160;assumes&#160;that&#160;it&#160;has&#160;been&#160;passed<br/>a&#160;suitable&#160;object.&#160;It&#160;is&#160;fairly&#160;common&#160;in&#160;Ruby&#160;programming&#160;to&#160;be&#160;loose&#160;about&#160;the&#160;def-<br/>inition of “suitable.” In the case of our&#160;+&#160;method, any object that has methods named<br/>x&#160;and&#160;y&#160;will&#160;do,&#160;as&#160;long&#160;as&#160;those&#160;methods&#160;expect&#160;no&#160;arguments&#160;and&#160;return&#160;a&#160;number&#160;of<br/>some&#160;sort.&#160;We&#160;don’t&#160;care&#160;if&#160;the&#160;argument&#160;actually&#160;<i>is</i>&#160;a&#160;point,&#160;as&#160;long&#160;as&#160;it&#160;looks&#160;and<br/>behaves&#160;like&#160;a&#160;point.&#160;This&#160;approach&#160;is&#160;sometimes&#160;called&#160;“duck&#160;typing,”&#160;after&#160;the&#160;adage<br/>“if it walks like a duck and quacks like a duck, it must be a duck.”<br/>
If we pass an object to&#160;+&#160;that is not suitable, Ruby will raise an exception. Attempting<br/>to add&#160;3&#160;to a point, for example, results in this error message:<br/>
NoMethodError: undefined method `x' for 3:Fixnum<br/>&#160; &#160; &#160; &#160; from ./point.rb:37:in `+'<br/>
Translated,&#160;this&#160;tells&#160;us&#160;that&#160;the&#160;Fixnum&#160;3&#160;does&#160;not&#160;have&#160;a&#160;method&#160;named&#160;x,&#160;and&#160;that<br/>this&#160;error&#160;arose&#160;in&#160;the&#160;+&#160;method of the&#160;Point&#160;class.&#160;This&#160;is&#160;all&#160;the&#160;information&#160;we&#160;need<br/>to&#160;figure&#160;out&#160;the&#160;source&#160;of&#160;the&#160;problem,&#160;but&#160;it&#160;is&#160;somewhat&#160;obscure.&#160;Checking&#160;the&#160;class<br/>of&#160;method&#160;arguments&#160;may&#160;make&#160;it&#160;easier&#160;to&#160;debug&#160;code&#160;that&#160;uses&#160;that&#160;method.&#160;Here&#160;is<br/>a version of the method with class verification:<br/>
def +(other)<br/>&#160; raise TypeError, &#34;Point argument expected&#34; unless other.is_a? Point<br/>&#160; Point.new(@x + other.x, @y + other.y)<br/>end<br/>
Here&#160;is&#160;a&#160;looser&#160;version&#160;of&#160;type&#160;checking&#160;that&#160;provides&#160;improved&#160;error&#160;messages&#160;but<br/>still allows duck typing:<br/>
<b>220&#160;|&#160;Chapter 7:</b> <b>Classes and Modules</b><br/>
<hr/>
<a name=235></a>def +(other)<br/>&#160; raise TypeError, &#34;Point-like argument expected&#34; unless<br/>&#160; &#160; other.respond_to? :x and other.respond_to? :y<br/>&#160; Point.new(@x + other.x, @y + other.y)<br/>end<br/>
Note&#160;that&#160;this&#160;version&#160;of&#160;the&#160;method&#160;still&#160;assumes&#160;that&#160;the&#160;x&#160;and&#160;y&#160;methods&#160;return<br/>numbers.&#160;We’d&#160;get&#160;an&#160;obscure&#160;error&#160;message&#160;if&#160;one&#160;of&#160;these&#160;methods&#160;returned&#160;a&#160;string,<br/>for example.<br/>
Another&#160;approach&#160;to&#160;type&#160;checking&#160;occurs&#160;after&#160;the&#160;fact.&#160;We&#160;can&#160;simply&#160;handle&#160;any<br/>exceptions&#160;that&#160;occur&#160;during&#160;execution&#160;of&#160;the&#160;method&#160;and&#160;raise&#160;a&#160;more&#160;appropriate<br/>exception of our own:<br/>
def +(other) &#160; &#160; &#160; &#160; # Assume that other looks like a Point<br/>&#160; Point.new(@x + other.x, @y + other.y)<br/>rescue &#160; &#160; &#160; &#160; &#160; &#160; &#160; # If anything goes wrong above<br/>&#160; raise TypeError, &#160; # Then raise our own exception<br/>&#160; &#160; &#34;Point addition with an argument that does not quack like a Point!&#34;<br/>end<br/>
Note that our&#160;*&#160;method expects a numeric operand, not a&#160;Point. If&#160;p&#160;is point, then we<br/>can&#160;&#160;write&#160;&#160;p*2.&#160;&#160;As&#160;&#160;our&#160;&#160;class&#160;&#160;is&#160;&#160;written,&#160;&#160;however,&#160;&#160;we&#160;&#160;cannot&#160;&#160;write&#160;&#160;2*p.&#160;&#160;That&#160;&#160;second<br/>expression&#160;invokes&#160;the&#160;*&#160;method&#160;of&#160;the&#160;Integer&#160;class,&#160;which&#160;doesn’t&#160;know&#160;how&#160;to&#160;work<br/>with&#160;&#160;Point&#160;&#160;objects.&#160;&#160;Because&#160;&#160;the&#160;&#160;Integer&#160;&#160;class&#160;&#160;doesn’t&#160;&#160;know&#160;&#160;how&#160;&#160;to&#160;&#160;multiply&#160;&#160;by&#160;&#160;a<br/>Point,&#160;it&#160;asks&#160;the&#160;point&#160;for&#160;help&#160;by&#160;calling&#160;its&#160;coerce&#160;method.&#160;(See&#160;<a href="Rubys.html#95">§3.8.7.4&#160;</a>for&#160;more<br/>details.)&#160;If&#160;we&#160;want&#160;the&#160;expression&#160;2*p&#160;to&#160;return&#160;the&#160;same&#160;result&#160;as&#160;p*2,&#160;we&#160;can&#160;define<br/>a&#160;coerce&#160;method:<br/>
# If we try passing a Point to the * method of an Integer, it will call<br/># this method on the Point and then will try to multiply the elements of&#160;<br/># the array. Instead of doing type conversion, we switch the order of<br/># the operands, so that we invoke the * method defined above.<br/>def coerce(other)<br/>&#160; [self, other]<br/>end<br/>
<b>7.1.7 &#160;Array and Hash Access with [ ]<br/></b>Ruby&#160;uses&#160;square&#160;brackets&#160;for&#160;array&#160;and&#160;hash&#160;access,&#160;and&#160;allows&#160;any&#160;class&#160;to&#160;define&#160;a<br/>[]&#160;method&#160;and&#160;use&#160;these&#160;brackets&#160;itself.&#160;Let’s&#160;define&#160;a&#160;[]&#160;method&#160;for&#160;our&#160;class&#160;to&#160;allow<br/>Point&#160;objects to be treated as read-only arrays of length&#160;2, or as read-only hashes with<br/>keys&#160;:x&#160;and&#160;:y:<br/>
# Define [] method to allow a Point to look like an array or<br/># a hash with keys :x and :y<br/>def [](index)<br/>&#160; case index<br/>&#160; when 0, -2: @x &#160; &#160; &#160; &#160; # Index 0 (or -2) is the X coordinate<br/>&#160; when 1, -1: @y &#160; &#160; &#160; &#160; # Index 1 (or -1) is the Y coordinate<br/>&#160; when :x, &#34;x&#34;: @x &#160; &#160; &#160; # Hash keys as symbol or string for X<br/>&#160; when :y, &#34;y&#34;: @y &#160; &#160; &#160; # Hash keys as symbol or string for Y<br/>
<b>7.1 &#160;Defining a Simple Class&#160;|&#160;221</b><br/>
<hr/>
<a name=236></a>&#160; else nil &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Arrays and hashes just return nil on bad indexes<br/>&#160; end<br/>end<br/>
<b>7.1.8 &#160;Enumerating Coordinates<br/></b>If&#160;a&#160;Point&#160;object&#160;can&#160;behave&#160;like&#160;an&#160;array&#160;with&#160;two&#160;elements,&#160;then&#160;perhaps&#160;we&#160;ought&#160;to<br/>be&#160;able&#160;to&#160;iterate&#160;through&#160;those&#160;elements&#160;as&#160;we&#160;can&#160;with&#160;a&#160;true&#160;array.&#160;Here&#160;is&#160;a&#160;definition<br/>of&#160;the&#160;each&#160;iterator&#160;for&#160;our&#160;Point&#160;class.&#160;Because&#160;a&#160;Point&#160;always&#160;has&#160;exactly&#160;two&#160;elements,<br/>our iterator doesn’t have to loop; it can simply call&#160;yield&#160;twice:<br/>
# This iterator passes the X coordinate to the associated block, and then<br/># passes the Y coordinate, and then returns. It allows us to enumerate<br/># a point as if it were an array with two elements. This each method is<br/># required by the Enumerable module.<br/>def each<br/>&#160; yield @x<br/>&#160; yield @y<br/>end<br/>
With this iterator defined, we can write code like this:<br/>
p = Point.new(1,2)<br/>p.each {|x| print x } &#160; # Prints &#34;12&#34;<br/>
More&#160;importantly,&#160;defining&#160;the&#160;each&#160;iterator&#160;allows&#160;us&#160;to&#160;mix&#160;in&#160;the&#160;methods&#160;of&#160;the<br/>Enumerable&#160;module,&#160;all&#160;of&#160;which&#160;are&#160;defined&#160;in&#160;terms&#160;of&#160;each.&#160;Our&#160;class&#160;gains&#160;over&#160;20<br/>iterators by adding a single line:<br/>
include Enumerable<br/>
If we do this, then we can write interesting code like this:<br/>
# Is the point P at the origin?<br/>p.all? {|x| x == 0 } # True if the block is true for all elements<br/>
<b>7.1.9 &#160;Point Equality<br/></b>As&#160;our&#160;class&#160;is&#160;currently&#160;defined,&#160;two&#160;distinct&#160;Point&#160;instances&#160;are&#160;never&#160;equal&#160;to&#160;each<br/>other,&#160;even&#160;if&#160;their&#160;X&#160;and&#160;Y&#160;coordinates&#160;are&#160;the&#160;same.&#160;To&#160;remedy&#160;this,&#160;we&#160;must&#160;provide<br/>an&#160;implementation&#160;of&#160;the&#160;==&#160;operator.&#160;(You&#160;may&#160;want&#160;to&#160;<a href="Rubys.html#90">reread&#160;§3.8.5&#160;</a><a href="Rubys.html#55">in&#160;Chapter 3&#160;to<br/></a>refresh your memory about Ruby’s various notions of equality.)<br/>Here is an&#160;==&#160;method for&#160;Point:<br/>
def ==(o) &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Is self == o?<br/>&#160; if o.is_a? Point &#160; &#160; &#160;# If o is a Point object<br/>&#160; &#160; @x==o.x &amp;&amp; @y==o.y &#160;# then compare the fields.<br/>&#160; else &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# If o is not a Point<br/>&#160; &#160; false &#160; &#160; &#160; &#160; &#160; &#160; &#160; # then, by definition, self != o.<br/>&#160; end<br/>end<br/>
<b>222&#160;|&#160;Chapter 7:</b> <b>Classes and Modules</b><br/>
<hr/>
<a name=237></a><b>Duck Typing and Equality</b><br/>
The&#160;+&#160;operator&#160;we&#160;defined&#160;earlier&#160;did&#160;no&#160;type&#160;checking&#160;at&#160;all:&#160;it&#160;works&#160;with&#160;any&#160;argument<br/>object&#160;with&#160;x&#160;and&#160;y&#160;methods&#160;that&#160;return&#160;numbers.&#160;This&#160;==&#160;method&#160;is&#160;implemented<br/>differently;&#160;instead&#160;of&#160;allowing&#160;duck&#160;typing,&#160;it&#160;requires&#160;that&#160;the&#160;argument&#160;is&#160;a&#160;Point.<br/>This&#160;is&#160;an&#160;implementation&#160;choice.&#160;The&#160;implementation&#160;of&#160;==&#160;above&#160;chooses&#160;to&#160;define<br/>equality so that an object cannot be equal to a&#160;Point&#160;unless it is itself a&#160;Point.<br/>
Implementations&#160;may&#160;be&#160;stricter&#160;or&#160;more&#160;liberal&#160;than&#160;this.&#160;The&#160;implementation&#160;above<br/>uses the&#160;is_a?&#160;predicate&#160;to&#160;test&#160;the&#160;class&#160;of&#160;the&#160;argument.&#160;This&#160;allows&#160;an&#160;instance&#160;of&#160;a<br/>subclass&#160;&#160;of&#160;&#160;Point&#160;&#160;to&#160;&#160;be&#160;&#160;equal&#160;&#160;to&#160;&#160;a&#160;&#160;Point.&#160;&#160;A&#160;&#160;stricter&#160;&#160;implementation&#160;&#160;would&#160;&#160;use<br/>instance_of?&#160;to&#160;disallow&#160;subclass&#160;instances.&#160;Similarly,&#160;the&#160;implementation&#160;above&#160;uses<br/>==&#160;&#160;to&#160;&#160;compare&#160;&#160;the&#160;&#160;X&#160;&#160;and&#160;&#160;Y&#160;&#160;coordinates.&#160;&#160;For&#160;&#160;numbers,&#160;&#160;the&#160;&#160;==&#160;&#160;operator&#160;&#160;allows&#160;&#160;type<br/>conversion,&#160;which&#160;means&#160;that&#160;the&#160;point&#160;(1,1)&#160;is&#160;equal&#160;to&#160;(1.0,1.0).&#160;This&#160;is&#160;probably<br/>as&#160;&#160;it&#160;&#160;should&#160;&#160;be,&#160;&#160;but&#160;&#160;a&#160;&#160;stricter&#160;&#160;definition&#160;&#160;of&#160;&#160;equality&#160;&#160;could&#160;&#160;use&#160;&#160;eql?&#160;&#160;to&#160;&#160;compare&#160;&#160;the<br/>coordinates.<br/>
A&#160;&#160;more&#160;&#160;liberal&#160;&#160;definition&#160;&#160;of&#160;&#160;equality&#160;&#160;would&#160;&#160;support&#160;&#160;duck&#160;&#160;typing.&#160;&#160;Some&#160;&#160;caution&#160;&#160;is<br/>required,&#160;however.&#160;Our&#160;==&#160;method&#160;should&#160;not&#160;raise&#160;a&#160;NoMethodError&#160;if&#160;the&#160;argument<br/>object does not have&#160;x&#160;and&#160;y&#160;methods. Instead, it should simply return&#160;false:<br/>
def ==(o) &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Is self == o?<br/>&#160; @x == o.x &amp;&amp; @y == o.y &#160; # Assume o has proper x and y methods<br/>rescue &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # If that assumption fails<br/>&#160; false &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Then self != o<br/>end<br/>
Recall&#160;from&#160;<a href="Rubys.html#90">§3.8.5&#160;</a>that&#160;Ruby&#160;objects&#160;also&#160;define&#160;an&#160;eql?&#160;method&#160;for&#160;testing&#160;equality.<br/>By&#160;&#160;default,&#160;&#160;the&#160;&#160;eql?&#160;&#160;method,&#160;&#160;like&#160;&#160;the&#160;&#160;==&#160;&#160;operator,&#160;&#160;tests&#160;&#160;object&#160;&#160;identity&#160;&#160;rather&#160;&#160;than<br/>equality&#160;of&#160;object&#160;content.&#160;Often,&#160;we&#160;want&#160;eql?&#160;to&#160;work&#160;just&#160;like&#160;the&#160;==&#160;operator, and<br/>we can accomplish this with an alias:<br/>
class Point<br/>&#160; alias eql? ==<br/>end<br/>
On&#160;the&#160;other&#160;hand,&#160;there&#160;are&#160;two&#160;reasons&#160;we&#160;might&#160;want&#160;eql?&#160;to be different from&#160;==.<br/>First,&#160;some&#160;classes&#160;define&#160;eql?&#160;to&#160;perform&#160;a&#160;stricter&#160;comparison&#160;than&#160;==.&#160;In&#160;Numeric&#160;and<br/>its subclasses, for example,&#160;==&#160;allows type conversion and&#160;eql?&#160;does not. If we believe<br/>that&#160;the&#160;users&#160;of&#160;our&#160;Point&#160;class&#160;might&#160;want&#160;to&#160;be&#160;able&#160;to&#160;compare&#160;instances&#160;in&#160;two<br/>different&#160;ways,&#160;then&#160;we&#160;might&#160;follow&#160;this&#160;example.&#160;Because&#160;points&#160;are&#160;just&#160;two&#160;num-<br/>bers,&#160;it&#160;would&#160;make&#160;sense&#160;to&#160;follow&#160;the&#160;example&#160;set&#160;by&#160;Numeric&#160;here.&#160;Our&#160;eql?&#160;method<br/>would&#160;look&#160;much&#160;like&#160;the&#160;==&#160;method,&#160;but&#160;it&#160;would&#160;use&#160;eql?&#160;to&#160;compare&#160;point&#160;coordi-<br/>nates instead of&#160;==:<br/>
def eql?(o) &#160; &#160; &#160; &#160; &#160; &#160;&#160;<br/>&#160; if o.instance_of? Point &#160; &#160; &#160;<br/>&#160; &#160; @x.eql?(o.x) &amp;&amp; @y.eql?(o.y)<br/>&#160; else<br/>&#160; &#160; false<br/>
<b>7.1 &#160;Defining a Simple Class&#160;|&#160;223</b><br/>
<hr/>
<a name=238></a>&#160; end<br/>end<br/>
As&#160;an&#160;aside,&#160;note&#160;that&#160;this&#160;is&#160;the&#160;right&#160;approach&#160;for&#160;any&#160;classes&#160;that&#160;implement&#160;collec-<br/>tions&#160;&#160;(sets,&#160;&#160;lists,&#160;&#160;trees)&#160;&#160;of&#160;&#160;arbitrary&#160;&#160;objects.&#160;&#160;The&#160;&#160;==&#160;&#160;operator&#160;&#160;should&#160;&#160;compare&#160;&#160;the<br/>members&#160;&#160;of&#160;&#160;the&#160;&#160;collection&#160;&#160;using&#160;&#160;their&#160;&#160;==&#160;&#160;operators,&#160;&#160;and&#160;&#160;the&#160;&#160;eql?&#160;&#160;method&#160;&#160;should<br/>compare the members using their&#160;eql?&#160;methods.<br/>The&#160;second&#160;reason&#160;to&#160;implement&#160;an&#160;eql?&#160;method&#160;that&#160;is&#160;different&#160;from&#160;the&#160;==&#160;operator<br/>is&#160;if&#160;you&#160;want&#160;instances&#160;of&#160;your&#160;class&#160;to&#160;behave&#160;specially&#160;when&#160;used&#160;as&#160;a&#160;hash&#160;key.&#160;The<br/>Hash&#160;class&#160;uses&#160;eql?&#160;to&#160;compare&#160;hash&#160;keys&#160;(but&#160;not&#160;values).&#160;If&#160;you&#160;leave&#160;eql?&#160;undefined,<br/>then&#160;hashes&#160;will&#160;compare&#160;instances&#160;of&#160;your&#160;class&#160;by&#160;object&#160;identity.&#160;This&#160;means&#160;that&#160;if<br/>you associate a value with a key&#160;p, you will only be able to retrieve that value with the<br/>exact&#160;same&#160;object&#160;p.&#160;An&#160;object&#160;q&#160;won’t&#160;work,&#160;even&#160;if&#160;p == q.&#160;Mutable&#160;objects&#160;do&#160;not<br/>work well as hash keys, but leaving&#160;eql?&#160;undefined neatly sidesteps the problem. (See<br/><a href="Rubys.html#82">§3.4.2 for more on hashes and mutable keys.)<br/></a>Because&#160;eql?&#160;is&#160;used&#160;for&#160;hashes,&#160;you&#160;must&#160;never&#160;implement&#160;this&#160;method&#160;by&#160;itself.&#160;If&#160;you<br/>define&#160;an&#160;eql?&#160;method,&#160;you&#160;must&#160;also&#160;define&#160;a&#160;hash&#160;method&#160;to&#160;compute&#160;a&#160;hashcode&#160;for<br/>your&#160;object.&#160;If&#160;two&#160;objects&#160;are&#160;equal&#160;according&#160;to&#160;eql?,&#160;then&#160;their&#160;hash&#160;methods&#160;<i>must<br/></i>return&#160;the&#160;same&#160;value.&#160;(Two&#160;unequal&#160;objects&#160;may&#160;return&#160;the&#160;same&#160;hashcode,&#160;but&#160;you<br/>should avoid this to the extent possible.)<br/>Implementing optimal&#160;hash&#160;methods&#160;can&#160;be&#160;very&#160;tricky.&#160;Fortunately,&#160;there&#160;is&#160;a&#160;simple<br/>way&#160;to&#160;compute&#160;perfectly&#160;adequate&#160;hashcodes&#160;for&#160;just&#160;about&#160;any&#160;class:&#160;simply&#160;combine<br/>the&#160;hashcodes&#160;of&#160;all&#160;the&#160;objects&#160;referenced&#160;by&#160;your&#160;class.&#160;(More&#160;precisely:&#160;combine&#160;the<br/>hashcodes&#160;of&#160;all&#160;the&#160;objects&#160;compared&#160;by&#160;your&#160;eql?&#160;method.)&#160;The&#160;trick&#160;is&#160;to&#160;combine<br/>the hashcodes in the proper way. The following&#160;hash&#160;method is&#160;<i>not</i>&#160;a good one:<br/>
def hash<br/>&#160; @x.hash + @y.hash<br/>end<br/>
The&#160;&#160;problem&#160;&#160;with&#160;&#160;this&#160;&#160;method&#160;&#160;is&#160;&#160;that&#160;&#160;it&#160;&#160;returns&#160;&#160;the&#160;&#160;same&#160;&#160;hashcode&#160;&#160;for&#160;&#160;the&#160;&#160;point<br/>(1,0)&#160;as&#160;it&#160;does&#160;for&#160;the&#160;point&#160;(0,1).&#160;This&#160;is&#160;legal,&#160;but&#160;it&#160;leads&#160;to&#160;poor&#160;performance&#160;when<br/>points are used as hash keys. Instead, we should mix things up a bit:<br/>
def hash<br/>&#160; code = 17<br/>&#160; code = 37*code + @x.hash<br/>&#160; code = 37*code + @y.hash<br/>&#160; # Add lines like this for each significant instance variable<br/>&#160; code &#160;# Return the resulting code<br/>end<br/>
This&#160;general-purpose&#160;hashcode&#160;recipe&#160;should&#160;be&#160;suitable&#160;for&#160;most&#160;Ruby&#160;classes.&#160;It,&#160;and<br/>its&#160;&#160;constants&#160;&#160;17&#160;&#160;and&#160;&#160;37,&#160;&#160;are&#160;&#160;adapted&#160;&#160;from&#160;&#160;the&#160;&#160;book&#160;&#160;<i>Effective&#160;&#160;Java</i>&#160;&#160;by&#160;&#160;Joshua&#160;&#160;Bloch<br/>(Prentice Hall).<br/>
<b>224&#160;|&#160;Chapter 7:</b> <b>Classes and Modules</b><br/>
<hr/>
<a name=239></a><b>7.1.10 &#160;Ordering Points<br/></b>Suppose&#160;we&#160;wish&#160;to&#160;define&#160;an&#160;ordering&#160;for&#160;Point&#160;objects&#160;so&#160;that&#160;we&#160;can&#160;compare&#160;them<br/>and&#160;sort&#160;them.&#160;There&#160;are&#160;a&#160;number&#160;of&#160;ways&#160;to&#160;order&#160;points,&#160;but&#160;we’ll&#160;chose&#160;to&#160;arrange<br/>them&#160;based&#160;on&#160;their&#160;distance&#160;from&#160;the&#160;origin.&#160;This&#160;distance&#160;(or&#160;magnitude)&#160;is&#160;computed<br/>by the Pythagorean theorem: the square root of the sum of the squares of the X and Y<br/>coordinates.<br/>To&#160;define&#160;this&#160;ordering&#160;for&#160;Point&#160;objects,&#160;we&#160;need&#160;only&#160;define&#160;the&#160;&lt;=&gt;&#160;operator&#160;(see<br/><a href="Rubys.html#119">§4.6.6)&#160;</a>and&#160;include&#160;the&#160;Comparable&#160;module.&#160;Doing&#160;this&#160;mixes&#160;in&#160;implementations&#160;of<br/>the&#160;equality&#160;and&#160;relational&#160;operators&#160;that&#160;are&#160;based&#160;on&#160;our&#160;implementation&#160;of&#160;the&#160;gen-<br/>eral&#160;&lt;=&gt;&#160;operator we defined. The&#160;&lt;=&gt;&#160;operator should compare&#160;self&#160;to the object it is<br/>passed.&#160;If&#160;self&#160;is&#160;less&#160;than&#160;that&#160;object&#160;(closer&#160;to&#160;the&#160;origin,&#160;in&#160;this&#160;case),&#160;it&#160;should&#160;return<br/>–1.&#160;If&#160;the&#160;two&#160;objects&#160;are&#160;equal,&#160;it&#160;should&#160;return&#160;0.&#160;And&#160;if&#160;self&#160;is&#160;greater&#160;than&#160;the&#160;argu-<br/>ment&#160;&#160;object,&#160;&#160;the&#160;&#160;method&#160;&#160;should&#160;&#160;return&#160;&#160;1.&#160;&#160;(The&#160;&#160;method&#160;&#160;should&#160;&#160;return&#160;&#160;nil&#160;&#160;if&#160;&#160;the<br/>argument&#160;object&#160;and&#160;self&#160;are&#160;of&#160;incomparable&#160;types.)&#160;The&#160;following&#160;code&#160;is&#160;our&#160;im-<br/>plementation&#160;of&#160;&lt;=&gt;.&#160;There&#160;are&#160;two&#160;things&#160;to&#160;note&#160;about&#160;it.&#160;First,&#160;it&#160;doesn’t&#160;bother&#160;with<br/>the&#160;Math.sqrt&#160;method&#160;and&#160;instead&#160;simply&#160;compares&#160;the&#160;sum&#160;of&#160;the&#160;squares&#160;of&#160;the&#160;co-<br/>ordinates.&#160;Second,&#160;after&#160;computing&#160;the&#160;sums&#160;of&#160;the&#160;squares,&#160;it&#160;simply&#160;delegates&#160;to&#160;the<br/>&lt;=&gt;&#160;operator of the&#160;Float&#160;class:<br/>
include Comparable &#160; # Mix in methods from the Comparable module.<br/>
# Define an ordering for points based on their distance from the origin.<br/># This method is required by the Comparable module.<br/>def &lt;=&gt;(other)<br/>&#160; return nil unless other.instance_of? Point<br/>&#160; @x**2 + @y**2 &lt;=&gt; other.x**2 + other.y**2<br/>end<br/>
Note&#160;&#160;that&#160;&#160;the&#160;&#160;Comparable&#160;&#160;module&#160;&#160;defines&#160;&#160;an&#160;&#160;==&#160;&#160;method&#160;&#160;that&#160;&#160;uses&#160;&#160;our&#160;&#160;definition&#160;&#160;of<br/>&lt;=&gt;.&#160;Our&#160;distance-based&#160;comparison&#160;operator&#160;results&#160;in&#160;an&#160;==&#160;method&#160;that&#160;considers<br/>the&#160;points&#160;(1,0)&#160;and&#160;(0,1)&#160;to&#160;be&#160;equal.&#160;Because&#160;our&#160;Point&#160;class&#160;explicitly&#160;defines&#160;its<br/>own&#160;==&#160;method,&#160;however,&#160;the&#160;==&#160;method&#160;of&#160;Comparable&#160;is&#160;never&#160;invoked.&#160;Ideally,&#160;the<br/>==&#160;and&#160;&lt;=&gt;&#160;operators should have consistent definitions of equality. This was not pos-<br/>sible in our&#160;Point&#160;class, and we end up with operators that allow the following:<br/>
p,q = Point.new(1,0), Point.new(0,1)<br/>p == q &#160; &#160; &#160; &#160;# =&gt; false: p is not equal to q<br/>p &lt; q &#160; &#160; &#160; &#160; # =&gt; false: p is not less than q<br/>p &gt; q &#160; &#160; &#160; &#160; # =&gt; false: p is not greater than q<br/>
Finally,&#160;It&#160;is&#160;worth&#160;noting&#160;here&#160;that&#160;the&#160;Enumerable&#160;module&#160;defines&#160;several&#160;methods,<br/>such&#160;as&#160;sort,&#160;min,&#160;and&#160;max,&#160;that&#160;only&#160;work&#160;if&#160;the&#160;objects&#160;being&#160;enumerated&#160;define&#160;the<br/>&lt;=&gt;&#160;operator.<br/>
<b>7.1 &#160;Defining a Simple Class&#160;|&#160;225</b><br/>
<hr/>
<a name=240></a><b>7.1.11 &#160;A Mutable Point<br/></b>The&#160;Point&#160;class&#160;we’ve&#160;been&#160;developing&#160;is&#160;<i>immutable</i>:&#160;once&#160;a&#160;point&#160;object&#160;has&#160;been&#160;cre-<br/>ated,&#160;there&#160;is&#160;no&#160;public&#160;API&#160;to&#160;change&#160;the&#160;X&#160;and&#160;Y&#160;coordinates&#160;of&#160;that&#160;point.&#160;This&#160;is<br/>probably&#160;as&#160;it&#160;should&#160;be.&#160;But&#160;let’s&#160;detour&#160;and&#160;investigate&#160;some&#160;methods&#160;we might add<br/>if we wanted points to be mutable.<br/>First&#160;of&#160;all,&#160;we’d&#160;need&#160;x=&#160;and&#160;y=&#160;setter&#160;methods&#160;to&#160;allow&#160;the&#160;X&#160;and&#160;Y&#160;coordinates&#160;to&#160;be<br/>set&#160;&#160;directly.&#160;&#160;We&#160;&#160;could&#160;&#160;define&#160;&#160;these&#160;&#160;methods&#160;&#160;explicitly,&#160;&#160;or&#160;&#160;simply&#160;&#160;change&#160;&#160;our<br/>attr_reader&#160;line to&#160;attr_accessor:<br/>
attr_accessor :x, :y<br/>
Next,&#160;we’d&#160;like&#160;an&#160;alternative&#160;to&#160;the&#160;+&#160;operator&#160;for&#160;when&#160;we&#160;want&#160;to&#160;add&#160;the&#160;coordinates<br/>of&#160;point&#160;q&#160;to&#160;the&#160;coordinates&#160;of&#160;point&#160;p,&#160;and&#160;modify&#160;point&#160;p&#160;rather&#160;than&#160;creating&#160;and<br/>returning a new&#160;Point&#160;object.&#160;We’ll&#160;call&#160;this&#160;method&#160;add!, with the exclamation mark<br/>indicating that it alters the internal state of the object on which it is invoked:<br/>
def add!(p) &#160; &#160; &#160; &#160; &#160;# Add p to self, return modified self<br/>&#160; @x += p.x<br/>&#160; @y += p.y<br/>&#160; self<br/>end<br/>
When&#160;defining&#160;a&#160;mutator&#160;method,&#160;we&#160;normally&#160;only&#160;add&#160;an&#160;exclamation&#160;mark&#160;to&#160;the<br/>name&#160;if&#160;there&#160;is&#160;a&#160;nonmutating&#160;version&#160;of&#160;the&#160;same&#160;method.&#160;In&#160;this&#160;case,&#160;the&#160;name<br/>add!&#160;makes&#160;sense&#160;if&#160;we&#160;also&#160;define&#160;an&#160;add&#160;method&#160;that&#160;returns&#160;a&#160;new&#160;object,&#160;rather&#160;than<br/>altering&#160;its&#160;receiver.&#160;A&#160;nonmutating&#160;version&#160;of&#160;a&#160;mutator&#160;method&#160;is&#160;often&#160;written&#160;simply<br/>by creating a copy of&#160;self&#160;and invoking the mutator on the copied object:<br/>
def add(p) &#160; &#160; &#160; &#160; &#160; # A nonmutating version of add!<br/>&#160; q = self.dup &#160; &#160; &#160; # Make a copy of self<br/>&#160; q.add!(p) &#160; &#160; &#160; &#160; &#160;# Invoke the mutating method on the copy<br/>end<br/>
In&#160;this&#160;trivial&#160;example,&#160;our&#160;add&#160;method&#160;works&#160;just&#160;like&#160;the&#160;+&#160;operator&#160;we’ve&#160;already<br/>defined,&#160;and&#160;it’s&#160;not&#160;really&#160;necessary.&#160;So&#160;if&#160;we&#160;don’t&#160;define&#160;a&#160;nonmutating&#160;add,&#160;we&#160;should<br/>consider&#160;&#160;dropping&#160;&#160;the&#160;&#160;exclamation&#160;&#160;mark&#160;&#160;from&#160;&#160;add!&#160;&#160;and&#160;&#160;allowing&#160;&#160;the&#160;&#160;name&#160;&#160;of&#160;&#160;the<br/>method itself (“add” instead of “plus”) to indicate that it is a mutator.<br/>
<b>7.1.12 &#160;Quick and Easy Mutable Classes<br/></b>If&#160;you&#160;want&#160;a&#160;mutable&#160;Point&#160;class,&#160;one&#160;way&#160;to&#160;create&#160;it&#160;is&#160;with&#160;Struct.&#160;Struct&#160;is a core<br/>Ruby&#160;class&#160;that&#160;generates&#160;other&#160;classes.&#160;These&#160;generated&#160;classes&#160;have&#160;accessor&#160;methods<br/>for&#160;&#160;the&#160;&#160;named&#160;&#160;fields&#160;&#160;you&#160;&#160;specify.&#160;&#160;There&#160;&#160;are&#160;&#160;two&#160;&#160;ways&#160;&#160;to&#160;&#160;create&#160;&#160;a&#160;&#160;new&#160;&#160;class&#160;&#160;with<br/>Struct.new:<br/>
Struct.new(&#34;Point&#34;, :x, :y) &#160;# Creates new class Struct::Point<br/>Point = Struct.new(:x, :y) &#160; # Creates new class, assigns to Point<br/>
<b>226&#160;|&#160;Chapter 7:</b> <b>Classes and Modules</b><br/>
<hr/>
<a name=241></a><b>Naming Anonymous Classes</b><br/>
The&#160;second&#160;line&#160;in&#160;the&#160;code&#160;relies&#160;on&#160;a&#160;curious&#160;fact&#160;about&#160;Ruby&#160;classes:&#160;if&#160;you&#160;assign&#160;an<br/>unnamed class object to a constant, the name of that constant becomes the name of a<br/>class. You can observe this same behavior if you use the&#160;Class.new&#160;constructor:<br/>
C = Class.new &#160; # A new class with no body, assigned to a constant<br/>c = C.new &#160; &#160; &#160; # Create an instance of the class<br/>c.class.to_s &#160; &#160;# =&gt; &#34;C&#34;: constant name becomes class name<br/>
Once&#160;a&#160;class&#160;has&#160;been&#160;created&#160;with&#160;Struct.new,&#160;you&#160;can&#160;use&#160;it&#160;like&#160;any&#160;other&#160;class.&#160;Its<br/>new&#160;method&#160;will&#160;expect&#160;values&#160;for&#160;each&#160;of&#160;the&#160;named&#160;fields&#160;you&#160;specify,&#160;and&#160;its&#160;instance<br/>methods provide read and write accessors for those fields:<br/>
p = Point.new(1,2) &#160; # =&gt; #&lt;struct Point x=1, y=2&gt;<br/>p.x &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; 1&#160;<br/>p.y &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; 2<br/>p.x = 3 &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; 3<br/>p.x &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; 3<br/>
Structs&#160;also&#160;define&#160;the&#160;[]&#160;and&#160;[]=&#160;operators&#160;for&#160;array&#160;and&#160;hash-style&#160;indexing,&#160;and&#160;even<br/>provide&#160;each&#160;and&#160;each_pair&#160;iterators&#160;for&#160;looping&#160;through&#160;the&#160;values&#160;held&#160;in&#160;an&#160;instance<br/>of the struct:<br/>
p[:x] = 4 &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; 4: same as p.x =<br/>p[:x] &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; 4: same as p.x<br/>p[1] &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; 2: same as p.y<br/>p.each {|c| print c} &#160;# prints &#34;42&#34;<br/>p.each_pair {|n,c| print n,c } &#160; # prints &#34;x4y2&#34;<br/>
Struct-based&#160;classes&#160;have&#160;a&#160;working&#160;==&#160;operator,&#160;can&#160;be&#160;used&#160;as&#160;hash&#160;keys&#160;(though<br/>caution&#160;is&#160;necessary&#160;because&#160;they&#160;are&#160;mutable),&#160;and&#160;even&#160;define&#160;a&#160;helpful&#160;to_s&#160;method:<br/>
q = Point.new(4,2)<br/>q == p &#160; &#160; &#160; &#160;# =&gt; true<br/>h = {q =&gt; 1} &#160;# Create a hash using q as a key<br/>h[p] &#160; &#160; &#160; &#160; &#160;# =&gt; 1: extract value using p as key<br/>q.to_s &#160; &#160; &#160; &#160;# =&gt; &#34;#&lt;struct Point x=4, y=2&gt;&#34;<br/>
A&#160;Point&#160;class&#160;defined&#160;as&#160;a&#160;struct&#160;does&#160;not&#160;have&#160;point-specific&#160;methods&#160;like&#160;add!&#160;or the<br/>&lt;=&gt;&#160;&#160;operator&#160;&#160;defined&#160;&#160;earlier&#160;&#160;in&#160;&#160;this&#160;&#160;chapter.&#160;&#160;There&#160;&#160;is&#160;&#160;no&#160;&#160;reason&#160;&#160;we&#160;&#160;can’t&#160;&#160;add&#160;&#160;them,<br/>though.&#160;Ruby&#160;class&#160;definitions&#160;are&#160;not&#160;static.&#160;Any&#160;class&#160;(including&#160;classes&#160;defined&#160;with<br/>Struct.new)&#160;can&#160;be&#160;“opened”&#160;and&#160;have&#160;methods&#160;added&#160;to&#160;it.&#160;Here’s&#160;a&#160;Point&#160;class&#160;initially<br/>defined as a&#160;Struct, with point-specific methods added:<br/>
Point = Struct.new(:x, :y) &#160; # Create new class, assign to Point<br/>class Point &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Open Point class for new methods<br/>&#160; def add!(other) &#160; &#160; &#160; &#160; &#160; &#160;# Define an add! method<br/>&#160; &#160; self.x += other.x<br/>&#160; &#160; self.y += other.y<br/>&#160; &#160; self<br/>&#160; end<br/>
<b>7.1 &#160;Defining a Simple Class&#160;|&#160;227</b><br/>
<hr/>
<a name=242></a>&#160; include Comparable &#160; &#160; &#160; &#160; # Include a module for the class<br/>&#160; def &lt;=&gt;(other) &#160; &#160; &#160; &#160; &#160; &#160; # Define the &lt;=&gt; operator<br/>&#160; &#160; return nil unless other.instance_of? Point<br/>&#160; &#160; self.x**2 + self.y**2 &lt;=&gt; other.x**2 + other.y**2<br/>&#160; end<br/>end<br/>
As&#160;noted&#160;at&#160;the&#160;beginning&#160;of&#160;this&#160;section,&#160;the&#160;Struct&#160;class&#160;is&#160;designed&#160;to&#160;create&#160;mutable<br/>classes.&#160;With&#160;just&#160;a&#160;bit&#160;of&#160;work,&#160;however,&#160;we&#160;can&#160;make&#160;a&#160;Struct-based&#160;class&#160;immutable:<br/>
Point = Struct.new(:x, :y) &#160;# Define mutable class<br/>class Point &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Open the class<br/>&#160; undef x=,y=,[]= &#160; &#160; &#160; &#160; &#160; # Undefine mutator methods<br/>end<br/>
<b>7.1.13 &#160;A Class Method<br/></b>Let’s&#160;take&#160;another&#160;approach&#160;to&#160;adding&#160;Point&#160;objects&#160;together.&#160;Instead&#160;of&#160;invoking&#160;an<br/>instance&#160;method&#160;of&#160;one&#160;point&#160;and&#160;passing&#160;another&#160;point&#160;to&#160;that&#160;method,&#160;let’s&#160;write&#160;a<br/>method&#160;named&#160;sum&#160;that&#160;takes&#160;any&#160;number&#160;of&#160;Point&#160;objects,&#160;adds&#160;them&#160;together,&#160;and<br/>returns&#160;a&#160;new&#160;Point.&#160;This&#160;method&#160;is&#160;not&#160;an&#160;instance&#160;method&#160;invoked&#160;on&#160;a&#160;Point&#160;object.<br/>Rather,&#160;it&#160;is&#160;a&#160;<i>class&#160;method</i>,&#160;invoked&#160;through&#160;the&#160;Point&#160;class&#160;itself.&#160;We&#160;might&#160;invoke&#160;the<br/>sum&#160;method like this:<br/>
total = Point.sum(p1, p2, p3) &#160;# p1, p2 and p3 are Point objects<br/>
Keep&#160;in&#160;mind&#160;that&#160;the&#160;expression&#160;Point&#160;refers&#160;to&#160;a&#160;Class&#160;object&#160;that&#160;represents&#160;our&#160;point<br/>class.&#160;To&#160;define&#160;a&#160;class&#160;method&#160;for&#160;the&#160;Point&#160;class,&#160;what&#160;we&#160;are&#160;really&#160;doing&#160;is&#160;defining<br/>a&#160;singleton&#160;method&#160;of&#160;the&#160;Point&#160;object.&#160;(We&#160;covered&#160;singleton&#160;methods&#160;<a href="Rubys.html#193">in&#160;§6.1.4.) To<br/></a>define&#160;a&#160;singleton&#160;method,&#160;use&#160;the&#160;def&#160;statement&#160;as&#160;usual,&#160;but&#160;specify&#160;the&#160;object&#160;on<br/>which&#160;the&#160;method&#160;is&#160;to&#160;be&#160;defined&#160;as&#160;well&#160;as&#160;the&#160;name&#160;of&#160;the&#160;method.&#160;Our&#160;class&#160;method<br/>sum&#160;is defined like this:<br/>
class Point<br/>&#160; attr_reader :x, :y &#160; &#160; # Define accessor methods for our instance variables<br/>
&#160; def Point.sum(*points) # Return the sum of an arbitrary number of points<br/>&#160; &#160; x = y = 0<br/>&#160; &#160; points.each {|p| x += p.x; y += p.y }<br/>&#160; &#160; Point.new(x,y)<br/>&#160; end<br/>
&#160; # ...the rest of class omitted here...<br/>end<br/>
This&#160;definition&#160;of&#160;the&#160;class&#160;method&#160;names&#160;the&#160;class&#160;explicitly,&#160;and&#160;mirrors&#160;the&#160;syntax<br/>used&#160;to&#160;invoke&#160;the&#160;method.&#160;Class&#160;methods&#160;can&#160;also&#160;be&#160;defined&#160;using&#160;self&#160;instead&#160;of<br/>the class name. Thus, this method could also be written like this:<br/>
def self.sum(*points) &#160;# Return the sum of an arbitrary number of points<br/>&#160; x = y = 0<br/>&#160; points.each {|p| x += p.x; y += p.y }<br/>
<b>228&#160;|&#160;Chapter 7:</b> <b>Classes and Modules</b><br/>
<hr/>
<a name=243></a>&#160; Point.new(x,y)<br/>end<br/>
Using&#160;self&#160;instead&#160;of&#160;Point&#160;makes&#160;the&#160;code&#160;slightly&#160;less&#160;clear,&#160;but&#160;it’s&#160;an&#160;application&#160;of<br/>the&#160;DRY&#160;(Don’t&#160;Repeat&#160;Yourself)&#160;principle.&#160;If&#160;you&#160;use&#160;self&#160;instead&#160;of&#160;the&#160;class&#160;name,<br/>you&#160;can&#160;change&#160;the&#160;name&#160;of&#160;a&#160;class&#160;without&#160;having&#160;to&#160;edit&#160;the&#160;definition&#160;of&#160;its&#160;class<br/>methods.<br/>There is yet another technique for defining class methods. Though it is less clear than<br/>the&#160;previously&#160;shown&#160;technique,&#160;it&#160;can&#160;be&#160;handy&#160;when&#160;defining&#160;multiple&#160;class&#160;methods,<br/>and you are likely to see it used in existing code:<br/>
# Open up the Point object so we can add methods to it<br/>class &lt;&lt; Point &#160; &#160; &#160;# Syntax for adding methods to a single object<br/>&#160; def sum(*points) &#160;# This is the class method Point.sum<br/>&#160; &#160; x = y = 0<br/>&#160; &#160; points.each {|p| x += p.x; y += p.y }<br/>&#160; &#160; Point.new(x,y)<br/>&#160; end<br/>
&#160; # Other class methods can be defined here<br/>end<br/>
This&#160;technique&#160;can&#160;also&#160;be&#160;used&#160;inside&#160;the&#160;class&#160;definition,&#160;where&#160;we&#160;can&#160;use&#160;&#160;self<br/>instead of repeating the class name:<br/>
class Point<br/>&#160; # Instance methods go here<br/>
&#160; class &lt;&lt; self<br/>&#160; &#160; # Class methods go here<br/>&#160; end<br/>end<br/>
<a href="Rubys.html#271">We’ll learn more about this syntax in §7.7.</a><br/>
<b>7.1.14 &#160;Constants<br/></b>Many&#160;classes&#160;can&#160;benefit&#160;from&#160;the&#160;definition&#160;of&#160;some&#160;associated&#160;constants.&#160;Here&#160;are<br/>some constants that might be useful for our&#160;Point&#160;class:<br/>
class Point<br/>&#160; def initialize(x,y) &#160;# Initialize method<br/>&#160; &#160; @x,@y = x, y&#160;<br/>&#160; end<br/>
&#160; ORIGIN = Point.new(0,0)<br/>&#160; UNIT_X = Point.new(1,0)<br/>&#160; UNIT_Y = Point.new(0,1)<br/>
&#160; # Rest of class definition goes here<br/>end<br/>
<b>7.1 &#160;Defining a Simple Class&#160;|&#160;229</b><br/>
<hr/>
<a name=244></a>Inside&#160;the&#160;class&#160;definition,&#160;these&#160;constants&#160;can&#160;be&#160;referred&#160;to&#160;by&#160;their&#160;unqualified&#160;names.<br/>Outside the definition, they must be prefixed by the name of the class, of course:<br/>
Point::UNIT_X + Point::UNIT_Y &#160; # =&gt; (1,1)<br/>
Note&#160;that&#160;because&#160;our&#160;constants&#160;in&#160;this&#160;example&#160;refer&#160;to&#160;instances&#160;of&#160;the&#160;class,&#160;we<br/>cannot&#160;define&#160;the&#160;constants&#160;until&#160;after&#160;we’ve&#160;defined&#160;the&#160;initialize&#160;method&#160;of&#160;the&#160;class.<br/>Also,&#160;keep&#160;in&#160;mind&#160;that&#160;it&#160;is&#160;perfectly&#160;legal&#160;to&#160;define&#160;constants&#160;in&#160;the&#160;Point&#160;class from<br/>outside the class:<br/>
Point::NEGATIVE_UNIT_X = Point.new(-1,0)<br/>
<b>7.1.15 &#160;Class Variables<br/></b>Class&#160;variables&#160;are&#160;visible&#160;to,&#160;and&#160;shared&#160;by,&#160;the&#160;class&#160;methods&#160;and&#160;the&#160;instance&#160;methods<br/>of&#160;a&#160;class,&#160;and&#160;also&#160;by&#160;the&#160;class&#160;definition&#160;itself.&#160;Like&#160;instance&#160;variables,&#160;class&#160;variables<br/>are&#160;encapsulated;&#160;they&#160;can&#160;be&#160;used&#160;by&#160;the&#160;implementation&#160;of&#160;a&#160;class,&#160;but&#160;they&#160;are&#160;not<br/>visible to the users of a class. Class variables have names that begin with&#160;@@.<br/>There&#160;is&#160;no&#160;real&#160;need&#160;to&#160;use&#160;class&#160;variables&#160;in&#160;our&#160;Point&#160;class,&#160;but&#160;for&#160;the&#160;purposes&#160;of<br/>this&#160;&#160;tutorial,&#160;&#160;let’s&#160;&#160;suppose&#160;&#160;that&#160;&#160;we&#160;&#160;want&#160;&#160;to&#160;&#160;collect&#160;&#160;data&#160;&#160;about&#160;&#160;the&#160;&#160;number&#160;&#160;of&#160;&#160;Point<br/>objects that are created and their average coordinates. Here’s how we might write the<br/>code:<br/>
class Point<br/>&#160; # Initialize our class variables in the class definition itself<br/>&#160; @@n = 0 &#160; &#160; &#160; &#160; &#160; &#160; &#160;# How many points have been created<br/>&#160; @@totalX = 0 &#160; &#160; &#160; &#160; # The sum of all X coordinates<br/>&#160; @@totalY = 0 &#160; &#160; &#160; &#160; # The sum of all Y coordinates<br/>
&#160; def initialize(x,y) &#160;# Initialize method<br/>&#160; &#160; @x,@y = x, y &#160; &#160; &#160; # Sets initial values for instance variables<br/>
&#160; &#160; # Use the class variables in this instance method to collect data<br/>&#160; &#160; @@n += 1 &#160; &#160; &#160; &#160; &#160; # Keep track of how many Points have been created<br/>&#160; &#160; @@totalX += x &#160; &#160; &#160;# Add these coordinates to the totals<br/>&#160; &#160; @@totalY += y<br/>&#160; end<br/>
&#160; # A class method to report the data we collected<br/>&#160; def self.report<br/>&#160; &#160; # Here we use the class variables in a class method<br/>&#160; &#160; puts &#34;Number of points created: #@@n&#34;<br/>&#160; &#160; puts &#34;Average X coordinate: #{@@totalX.to_f/@@n}&#34;<br/>&#160; &#160; puts &#34;Average Y coordinate: #{@@totalY.to_f/@@n}&#34;<br/>&#160; end<br/>end<br/>
The&#160;thing&#160;to&#160;notice&#160;about&#160;this&#160;code&#160;is&#160;that&#160;class&#160;variables&#160;are&#160;used&#160;in&#160;instance&#160;methods,<br/>class&#160;methods,&#160;and&#160;in&#160;the&#160;class&#160;definition&#160;itself,&#160;outside&#160;of&#160;any&#160;method.&#160;Class&#160;variables<br/>are&#160;fundamentally&#160;different&#160;than&#160;instance&#160;variables.&#160;We’ve&#160;seen&#160;that&#160;instance&#160;variables<br/>are&#160;always&#160;evaluated&#160;in&#160;reference&#160;to&#160;self.&#160;That&#160;is&#160;why&#160;an&#160;instance&#160;variable&#160;reference&#160;in<br/>
<b>230&#160;|&#160;Chapter 7:</b> <b>Classes and Modules</b><br/>
<hr/>
<a name=245></a>a&#160;&#160;class&#160;&#160;definition&#160;&#160;or&#160;&#160;class&#160;&#160;method&#160;&#160;is&#160;&#160;completely&#160;&#160;different&#160;&#160;from&#160;&#160;an&#160;&#160;instance&#160;&#160;variable<br/>reference in an instance method. Class variables, on the other hand, are always evalu-<br/>ated&#160;in&#160;reference&#160;to&#160;the&#160;class&#160;object&#160;created&#160;by&#160;the&#160;enclosing&#160;class&#160;definition&#160;statement.<br/>
<b>7.1.16 &#160;Class Instance Variables<br/></b>Classes&#160;&#160;are&#160;&#160;objects&#160;&#160;and&#160;&#160;can&#160;&#160;have&#160;&#160;instance&#160;&#160;variables&#160;&#160;just&#160;&#160;as&#160;&#160;other&#160;&#160;objects&#160;&#160;can.&#160;&#160;The<br/>instance&#160;variables&#160;of&#160;a&#160;class—often&#160;called&#160;class&#160;instance&#160;variables—are&#160;not&#160;the&#160;same&#160;as<br/>class&#160;variables.&#160;But&#160;they&#160;are&#160;similar&#160;enough&#160;that&#160;they&#160;can&#160;often&#160;be&#160;used&#160;instead&#160;of&#160;class<br/>variables.<br/>An&#160;instance&#160;variable&#160;used&#160;inside&#160;a&#160;class&#160;definition&#160;but&#160;outside&#160;an&#160;instance&#160;method<br/>definition&#160;is&#160;a&#160;class&#160;instance&#160;variable.&#160;Like&#160;class&#160;variables,&#160;class&#160;instance&#160;variables&#160;are<br/>associated&#160;&#160;with&#160;&#160;the&#160;&#160;class&#160;&#160;rather&#160;&#160;than&#160;&#160;with&#160;&#160;any&#160;&#160;particular&#160;&#160;instance&#160;&#160;of&#160;&#160;the&#160;&#160;class.&#160;&#160;A<br/>disadvantage&#160;of&#160;class&#160;instance&#160;variables&#160;is&#160;that&#160;they&#160;cannot&#160;be&#160;used&#160;within&#160;instance<br/>methods&#160;as&#160;class&#160;variables&#160;can.&#160;Another&#160;disadvantage&#160;is&#160;the&#160;potential&#160;for&#160;confusing<br/>them&#160;with&#160;ordinary&#160;instance&#160;variables.&#160;Without&#160;the&#160;distinctive&#160;punctuation&#160;prefixes,&#160;it<br/>may&#160;be&#160;more&#160;difficult&#160;to&#160;remember&#160;whether&#160;a&#160;variable&#160;is&#160;associated&#160;with&#160;instances&#160;or<br/>with the class object.<br/>One&#160;of&#160;the&#160;most&#160;important&#160;advantages&#160;of&#160;class&#160;instance&#160;variables&#160;over&#160;class&#160;variables<br/>has&#160;to&#160;do&#160;with&#160;the&#160;confusing&#160;behavior&#160;of&#160;class&#160;variables&#160;when&#160;subclassing&#160;an&#160;existing<br/>class. We’ll return to this point later in the chapter.<br/>Let’s&#160;port&#160;our&#160;statistics-gathering&#160;version&#160;of&#160;the&#160;Point&#160;class&#160;to&#160;use&#160;class&#160;instance&#160;varia-<br/>bles&#160;instead&#160;of&#160;class&#160;variables.&#160;The&#160;only&#160;difficulty&#160;is&#160;that&#160;because&#160;class&#160;instance&#160;variables<br/>cannot&#160;be&#160;used&#160;from&#160;instance&#160;methods,&#160;we&#160;must&#160;move&#160;the&#160;statistics&#160;gathering&#160;code&#160;out<br/>of&#160;the&#160;initialize&#160;method&#160;(which&#160;is&#160;an&#160;instance&#160;method)&#160;and&#160;into&#160;the&#160;new&#160;class&#160;method<br/>used to create points:<br/>
class Point<br/>&#160; # Initialize our class instance variables in the class definition itself<br/>&#160; @n = 0 &#160; &#160; &#160; &#160; &#160; &#160; &#160;# How many points have been created<br/>&#160; @totalX = 0 &#160; &#160; &#160; &#160; # The sum of all X coordinates<br/>&#160; @totalY = 0 &#160; &#160; &#160; &#160; # The sum of all Y coordinates<br/>
&#160; def initialize(x,y) # Initialize method&#160;<br/>&#160; &#160; @x,@y = x, y &#160; &#160; &#160;# Sets initial values for instance variables<br/>&#160; end<br/>
&#160; def self.new(x,y) &#160; # Class method to create new Point objects<br/>&#160; &#160; # Use the class instance variables in this class method to collect data<br/>&#160; &#160; @n += 1 &#160; &#160; &#160; &#160; &#160; # Keep track of how many Points have been created<br/>&#160; &#160; @totalX += x &#160; &#160; &#160;# Add these coordinates to the totals<br/>&#160; &#160; @totalY += y<br/>
&#160; &#160; super &#160; &#160; &#160; &#160; &#160; &#160; # Invoke the real definition of new to create a Point<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # More about super later in the chapter<br/>&#160; end<br/>
<b>7.1 &#160;Defining a Simple Class&#160;|&#160;231</b><br/>
<hr/>
<a name=246></a>&#160; # A class method to report the data we collected<br/>&#160; def self.report<br/>&#160; &#160; # Here we use the class instance variables in a class method<br/>&#160; &#160; puts &#34;Number of points created: #@n&#34;<br/>&#160; &#160; puts &#34;Average X coordinate: #{@totalX.to_f/@n}&#34;<br/>&#160; &#160; puts &#34;Average Y coordinate: #{@totalY.to_f/@n}&#34;<br/>&#160; end<br/>end<br/>
Because class instance variables are just instance variables of class objects, we can use<br/>attr,&#160;attr_reader, and&#160;attr_accessor&#160;to&#160;create&#160;accessor&#160;methods&#160;for&#160;them.&#160;The&#160;trick,<br/>however,&#160;is&#160;to&#160;invoke&#160;these&#160;metaprogramming&#160;methods&#160;in&#160;the&#160;right&#160;context.&#160;Recall&#160;that<br/>one&#160;way&#160;to&#160;define&#160;class&#160;methods&#160;uses&#160;the&#160;syntax&#160;class &lt;&lt; self.&#160;This&#160;same&#160;syntax&#160;allows<br/>us to define attribute accessor methods for class instance variables:<br/>
class &lt;&lt; self<br/>&#160; attr_accessor :n, :totalX, :totalY<br/>end<br/>
With&#160;these&#160;accessors&#160;defined,&#160;we&#160;can&#160;refer&#160;to&#160;our&#160;raw&#160;data&#160;as&#160;Point.n,&#160;Point.totalX,<br/>and&#160;Point.totalY.<br/>
<b>7.2 &#160;Method Visibility: Public, Protected, Private<br/></b>Instance&#160;methods&#160;may&#160;be&#160;<i>public</i>,&#160;<i>private</i>,&#160;or&#160;<i>protected</i>.&#160;If&#160;you’ve&#160;programmed&#160;with&#160;other<br/>object-oriented&#160;languages,&#160;you&#160;may&#160;already&#160;be&#160;familiar&#160;with&#160;these&#160;terms.&#160;Pay&#160;attention<br/>anyway,&#160;because&#160;these&#160;words&#160;have&#160;a&#160;somewhat&#160;different&#160;meaning&#160;in&#160;Ruby&#160;than&#160;they<br/>do in other languages.<br/>Methods&#160;are&#160;normally&#160;public&#160;unless&#160;they&#160;are&#160;explicitly&#160;declared&#160;to&#160;be&#160;private&#160;or&#160;pro-<br/>tected.&#160;One&#160;exception&#160;is&#160;the&#160;initialize&#160;method,&#160;which&#160;is&#160;always&#160;implicitly&#160;private.<br/>Another&#160;exception&#160;is&#160;any&#160;“global”&#160;method&#160;declared&#160;outside&#160;of&#160;a&#160;class&#160;definition—those<br/>methods&#160;are&#160;defined&#160;as&#160;private&#160;instance&#160;methods&#160;of&#160;Object.&#160;A&#160;public&#160;method&#160;can&#160;be<br/>invoked from anywhere—there are no restrictions on its use.<br/>A&#160;private&#160;method&#160;is&#160;internal&#160;to&#160;the&#160;implementation&#160;of&#160;a&#160;class,&#160;and&#160;it&#160;can&#160;only&#160;be&#160;called<br/>by&#160;other&#160;instance&#160;methods&#160;of&#160;the&#160;class&#160;(or,&#160;as&#160;we’ll&#160;see&#160;later,&#160;its&#160;subclasses).&#160;Private<br/>methods&#160;are&#160;implicitly&#160;invoked&#160;on&#160;self,&#160;and&#160;may&#160;not&#160;be&#160;explicitly&#160;invoked&#160;on&#160;an&#160;object.<br/>If&#160;m&#160;is&#160;a&#160;private&#160;method,&#160;then&#160;you&#160;must&#160;invoke&#160;it&#160;in&#160;<i>functional&#160;style</i>&#160;as&#160;m.&#160;You&#160;cannot<br/>write&#160;o.m&#160;or even&#160;self.m.<br/>A&#160;protected&#160;method&#160;is&#160;like&#160;a&#160;private&#160;method&#160;in&#160;that&#160;it&#160;can&#160;only&#160;be&#160;invoked&#160;from&#160;within<br/>the&#160;implementation&#160;of&#160;a&#160;class&#160;or&#160;its&#160;subclasses.&#160;It&#160;differs&#160;from&#160;a&#160;private&#160;method&#160;in&#160;that<br/>it&#160;may&#160;be&#160;explicitly&#160;invoked&#160;on&#160;any&#160;instance&#160;of&#160;the&#160;class,&#160;and&#160;it&#160;is&#160;not&#160;restricted&#160;to<br/>implicit&#160;invocation&#160;on&#160;self.&#160;A&#160;protected&#160;method&#160;can&#160;be&#160;used,&#160;for&#160;example,&#160;to&#160;define<br/>an accessor that allows instances of a class to share internal state with each other, but<br/>does not allow users of the class to access that state.<br/>
<b>232&#160;|&#160;Chapter 7:</b> <b>Classes and Modules</b><br/>
<hr/>
<a name=247></a>Protected&#160;&#160;methods&#160;&#160;are&#160;&#160;the&#160;&#160;least&#160;&#160;commonly&#160;&#160;defined&#160;&#160;and&#160;&#160;also&#160;&#160;the&#160;&#160;most&#160;&#160;difficult&#160;&#160;to<br/>understand.&#160;The&#160;rule&#160;about&#160;when&#160;a&#160;protected&#160;method&#160;can&#160;be&#160;invoked&#160;can&#160;be&#160;more<br/>formally&#160;described&#160;as&#160;follows:&#160;a&#160;protected&#160;method&#160;defined&#160;by&#160;a&#160;class&#160;C&#160;may&#160;be&#160;invoked<br/>on&#160;an&#160;object&#160;o&#160;by&#160;a&#160;method&#160;in&#160;an&#160;object&#160;p&#160;if&#160;and&#160;only&#160;if&#160;the&#160;classes&#160;of&#160;o&#160;and&#160;p&#160;are both<br/>subclasses of, or equal to, the class&#160;C.<br/>Method&#160;&#160;visibility&#160;&#160;is&#160;&#160;declared&#160;&#160;with&#160;&#160;three&#160;&#160;methods&#160;&#160;named&#160;&#160;public,&#160;&#160;private,&#160;&#160;and<br/>protected.&#160;These&#160;are&#160;instance&#160;methods&#160;of&#160;the&#160;Module&#160;class.&#160;All&#160;classes&#160;are&#160;modules,&#160;and<br/>inside&#160;a&#160;class&#160;definition&#160;(but&#160;outside&#160;method&#160;definitions),&#160;self&#160;refers&#160;to&#160;the&#160;class&#160;being<br/>defined.&#160;Thus,&#160;public,&#160;private,&#160;and&#160;protected&#160;may&#160;be&#160;used&#160;bare&#160;as&#160;if&#160;they&#160;were&#160;key-<br/>words&#160;of&#160;the&#160;language.&#160;In&#160;fact,&#160;however,&#160;they&#160;are&#160;method&#160;invocations&#160;on&#160;self. There<br/>are&#160;two&#160;ways&#160;to&#160;invoke&#160;these&#160;methods.&#160;With&#160;no&#160;arguments,&#160;they&#160;specify&#160;that&#160;all&#160;sub-<br/>sequent&#160;method&#160;definitions&#160;will&#160;have&#160;the&#160;specified&#160;visibility.&#160;A&#160;class&#160;might&#160;use&#160;them<br/>like this:<br/>
class Point<br/>&#160; # public methods go here<br/>
&#160; # The following methods are protected<br/>&#160; protected<br/>
&#160; # protected methods go here<br/>
&#160; # The following methods are private<br/>&#160; private<br/>
&#160; # private methods go here<br/>end<br/>
The&#160;methods&#160;may&#160;also&#160;be&#160;invoked&#160;with&#160;the&#160;names&#160;of&#160;one&#160;or&#160;more&#160;methods&#160;(as&#160;symbols<br/>or&#160;strings)&#160;as&#160;arguments.&#160;When&#160;invoked&#160;like&#160;this,&#160;they&#160;alter&#160;the&#160;visibility&#160;of&#160;the&#160;named<br/>
&#160;<br/>
methods.&#160;In&#160;this&#160;usage,&#160;the&#160;visibility&#160;declaration&#160;must&#160;come&#160;after&#160;the&#160;definition&#160;of&#160;the<br/>method.&#160;One&#160;approach&#160;is&#160;to&#160;declare&#160;all&#160;private&#160;and&#160;protected&#160;methods&#160;at&#160;once,&#160;at&#160;the<br/>end&#160;of&#160;a&#160;class.&#160;Another&#160;approach&#160;is&#160;to&#160;declare&#160;the&#160;visibility&#160;of&#160;each&#160;private&#160;or&#160;protected<br/>method&#160;immediately&#160;after&#160;it&#160;is&#160;defined.&#160;Here,&#160;for&#160;example,&#160;is&#160;a&#160;class&#160;with&#160;a&#160;private&#160;utility<br/>method and a protected accessor method:<br/>
class Widget<br/>&#160; def x &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Accessor method for @x<br/>&#160; &#160; @x<br/>&#160; end<br/>&#160; protected :x &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Make it protected<br/>
&#160; def utility_method &#160; &#160; &#160; &#160; &#160;# Define a method<br/>&#160; &#160; nil<br/>&#160; end<br/>&#160; private :utility_method &#160; &#160; # And make it private<br/>end<br/>
Remember&#160;that&#160;public,&#160;private,&#160;and&#160;protected&#160;apply&#160;only&#160;to&#160;methods&#160;in&#160;Ruby.&#160;Instance<br/>and&#160;class&#160;variables&#160;are&#160;encapsulated&#160;and&#160;effectively&#160;private,&#160;and&#160;constants&#160;are&#160;effectively<br/>
<b>7.2 &#160;Method Visibility: Public, Protected, Private&#160;|&#160;233</b><br/>
<hr/>
<a name=248></a>public.&#160;There&#160;is&#160;no&#160;way&#160;to&#160;make&#160;an&#160;instance&#160;variable&#160;accessible&#160;from&#160;outside&#160;a&#160;class<br/>(except&#160;by&#160;defining&#160;an&#160;accessor&#160;method,&#160;of&#160;course).&#160;And&#160;there&#160;is&#160;no&#160;way&#160;to&#160;define&#160;a<br/>constant that is inaccessible to outside use.<br/>Occasionally,&#160;it&#160;is&#160;useful&#160;to&#160;specify&#160;that&#160;a&#160;class&#160;method&#160;should&#160;be&#160;private.&#160;If&#160;your&#160;class<br/>defines&#160;factory&#160;methods,&#160;for&#160;example,&#160;you&#160;might&#160;want&#160;to&#160;make&#160;the&#160;new&#160;method&#160;private.<br/>To&#160;&#160;do&#160;&#160;this,&#160;&#160;use&#160;&#160;the&#160;&#160;private_class_method&#160;&#160;method,&#160;&#160;specifying&#160;&#160;one&#160;&#160;or&#160;&#160;more&#160;&#160;method<br/>names as symbols:<br/>
private_class_method :new<br/>
You&#160;can&#160;make&#160;a&#160;private&#160;class&#160;method&#160;public&#160;again&#160;with&#160;public_class_method. Neither<br/>method&#160;&#160;can&#160;&#160;be&#160;&#160;invoked&#160;&#160;without&#160;&#160;arguments&#160;&#160;in&#160;&#160;the&#160;&#160;way&#160;&#160;that&#160;&#160;public,&#160;&#160;protected,&#160;&#160;and<br/>private&#160;can be.<br/>
Ruby&#160;is,&#160;by&#160;design,&#160;a&#160;very&#160;open&#160;language.&#160;The&#160;ability&#160;to&#160;specify&#160;that&#160;some&#160;methods&#160;are<br/>private&#160;and&#160;protected&#160;encourages&#160;good&#160;programming&#160;style,&#160;and&#160;prevents&#160;inadvertent<br/>use&#160;of&#160;methods&#160;that&#160;are&#160;not&#160;part&#160;of&#160;the&#160;public&#160;API&#160;of&#160;a&#160;class.&#160;It&#160;is&#160;important&#160;to&#160;under-<br/>stand,&#160;however,&#160;that&#160;Ruby’s&#160;metaprogramming&#160;capabilities&#160;make&#160;it&#160;trivial&#160;to&#160;invoke<br/>private&#160;and&#160;protected&#160;methods&#160;and&#160;even&#160;to&#160;access&#160;encapsulated&#160;instance&#160;variables.&#160;To<br/>invoke&#160;the&#160;private&#160;utility&#160;method&#160;defined&#160;in&#160;the&#160;previous&#160;code,&#160;you&#160;can&#160;use&#160;the&#160;send<br/>method,&#160;or&#160;you&#160;can&#160;use&#160;instance_eval&#160;to&#160;evaluate&#160;a&#160;block&#160;in&#160;the&#160;context&#160;of&#160;the&#160;object:<br/>
w = Widget.new &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Create a Widget<br/>w.send :utility_method &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Invoke private method!<br/>w.instance_eval { utility_method } &#160;# Another way to invoke it<br/>w.instance_eval { @x } &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Read instance variable of w<br/>
If&#160;you&#160;want&#160;to&#160;invoke&#160;a&#160;method&#160;by&#160;name,&#160;but&#160;you&#160;don’t&#160;want&#160;to&#160;inadvertently&#160;invoke<br/>a&#160;private&#160;method&#160;that&#160;you&#160;don’t&#160;know&#160;about,&#160;you&#160;can&#160;(in&#160;Ruby&#160;1.9)&#160;use&#160;public_send<br/>instead&#160;of&#160;send.&#160;It&#160;works&#160;like&#160;send,&#160;but&#160;does&#160;not&#160;invoke&#160;private&#160;methods&#160;when&#160;called<br/>with&#160;&#160;an&#160;&#160;explicit&#160;&#160;receiver.&#160;&#160;public_send&#160;&#160;is&#160;&#160;covered&#160;&#160;in&#160;&#160;<a href="Rubys.html#279">Chapter&#160;&#160;8,&#160;&#160;</a>as&#160;&#160;are&#160;&#160;send&#160;&#160;and<br/>instance_eval.<br/>
<b>7.3 &#160;Subclassing and Inheritance<br/></b>Most&#160;object-oriented&#160;programming&#160;languages,&#160;including&#160;Ruby,&#160;provide&#160;a&#160;<i>subclassing<br/></i>mechanism&#160;that&#160;allows&#160;us&#160;to&#160;create&#160;new&#160;classes&#160;whose&#160;behavior&#160;is&#160;based&#160;on,&#160;but&#160;modi-<br/>fied&#160;from,&#160;the&#160;behavior&#160;of&#160;an&#160;existing&#160;class.&#160;We’ll&#160;begin&#160;this&#160;discussion&#160;of&#160;subclassing<br/>with&#160;definitions&#160;of&#160;basic&#160;terminology.&#160;If&#160;you’ve&#160;programmed&#160;in&#160;Java,&#160;C++,&#160;or&#160;a&#160;similar<br/>language, you are probably already familiar with these terms.<br/>When&#160;we&#160;define&#160;a&#160;class,&#160;we&#160;may&#160;specify&#160;that&#160;it&#160;<i>extends</i>—or&#160;<i>inherits&#160;from</i>—another<br/>class,&#160;known&#160;as&#160;the&#160;<i>superclass</i>.&#160;If&#160;we&#160;define&#160;a&#160;class&#160;Ruby&#160;that&#160;extends&#160;a&#160;class&#160;Gem,&#160;we&#160;say<br/>that&#160;Ruby&#160;is&#160;a&#160;<i>subclass</i>&#160;of&#160;Gem,&#160;and&#160;that&#160;Gem&#160;is&#160;the&#160;<i>superclass</i>&#160;of&#160;Ruby.&#160;If&#160;you&#160;do&#160;not&#160;specify<br/>a&#160;superclass&#160;when&#160;you&#160;define&#160;a&#160;class,&#160;then&#160;your&#160;class&#160;implicitly&#160;extends&#160;Object.&#160;A&#160;class<br/>may&#160;&#160;have&#160;&#160;any&#160;&#160;number&#160;&#160;of&#160;&#160;subclasses,&#160;&#160;and&#160;&#160;every&#160;&#160;class&#160;&#160;has&#160;&#160;a&#160;&#160;single&#160;&#160;superclass&#160;&#160;except<br/>Object, which has none.<br/>
<b>234&#160;|&#160;Chapter 7:</b> <b>Classes and Modules</b><br/>
<hr/>
<a name=249></a>The&#160;fact&#160;that&#160;classes&#160;may&#160;have&#160;multiple&#160;subclasses&#160;but&#160;only&#160;a&#160;single&#160;superclass&#160;means<br/>that&#160;they&#160;can&#160;be&#160;arranged&#160;in&#160;a&#160;tree&#160;structure,&#160;which&#160;we&#160;call&#160;the&#160;Ruby&#160;<i>class&#160;hierarchy</i>.<br/>The&#160;Object&#160;class&#160;is&#160;the&#160;root&#160;of&#160;this&#160;hierarchy,&#160;and&#160;every&#160;class&#160;inherits&#160;directly&#160;or&#160;indi-<br/>rectly&#160;&#160;from&#160;&#160;it.&#160;&#160;The&#160;&#160;<i>descendants</i>&#160;&#160;of&#160;&#160;a&#160;&#160;class&#160;&#160;are&#160;&#160;the&#160;&#160;subclasses&#160;&#160;of&#160;&#160;the&#160;&#160;class&#160;&#160;plus&#160;&#160;the<br/>subclasses&#160;of&#160;the&#160;subclasses,&#160;and&#160;so&#160;on&#160;recursively.&#160;The&#160;&#160;<i>ancestors</i>&#160;of&#160;a&#160;class&#160;are&#160;the<br/>superclass,&#160;plus&#160;the&#160;superclass&#160;of&#160;the&#160;superclass,&#160;and&#160;so&#160;on&#160;up&#160;to&#160;Object<a href="Rubys.html#169">.&#160;Figure 5-5&#160;in<br/></a><a href="Rubys.html#131">Chapter&#160;5&#160;</a>illustrates&#160;the&#160;portion&#160;of&#160;the&#160;Ruby&#160;class&#160;hierarchy&#160;that&#160;includes&#160;Exception<br/>and&#160;all&#160;of&#160;its&#160;descendants.&#160;In&#160;that&#160;figure,&#160;you&#160;can&#160;see&#160;that&#160;the&#160;ancestors&#160;of&#160;EOFError<br/>are&#160;IOError,&#160;StandardError,&#160;Exception, and&#160;Object.<br/>
<b>BasicObject in Ruby 1.9</b><br/>
In&#160;Ruby&#160;1.9,&#160;Object&#160;is&#160;no&#160;longer&#160;the&#160;root&#160;of&#160;the&#160;class&#160;hierarchy.&#160;A&#160;new&#160;class&#160;named<br/>BasicObject&#160;serves&#160;that&#160;purpose,&#160;and&#160;Object&#160;is&#160;a&#160;subclass&#160;of&#160;BasicObject.&#160;BasicObject<br/>is&#160;a&#160;very&#160;simple&#160;class,&#160;with&#160;almost&#160;no&#160;methods&#160;of&#160;its&#160;own,&#160;and&#160;it&#160;is&#160;useful&#160;as&#160;the&#160;superclass<br/><a href="Rubys.html#301">of delegating wrapper classes (like the one shown in Example 8-5 in Chapter 8).</a><br/>
When&#160;you&#160;create&#160;a&#160;class&#160;in&#160;Ruby&#160;1.9,&#160;you&#160;still&#160;extend&#160;Object&#160;unless&#160;you&#160;explicitly&#160;specify<br/>the&#160;superclass,&#160;and&#160;most&#160;programmers&#160;will&#160;never&#160;need&#160;to&#160;use&#160;or&#160;extend&#160;BasicObject.<br/>Methods&#160;such&#160;as&#160;==,&#160;equal?,&#160;instance_eval,&#160;and&#160;__send__&#160;are&#160;normally&#160;considered&#160;to<br/>be&#160;Object&#160;methods even though they are actually defined by&#160;BasicObject.<br/>
The&#160;syntax&#160;for&#160;extending&#160;a&#160;class&#160;is&#160;simple.&#160;Just&#160;add&#160;a&#160;&lt;&#160;character&#160;and&#160;the&#160;name&#160;of&#160;the<br/>superclass to your&#160;class&#160;statement. For example:<br/>
class Point3D &lt; Point &#160; &#160;# Define class Point3D as a subclass of Point<br/>end<br/>
We’ll&#160;flesh&#160;out&#160;this&#160;three-dimensional&#160;Point&#160;class&#160;in&#160;the&#160;subsections&#160;that&#160;follow,&#160;show-<br/>ing&#160;how&#160;methods&#160;are&#160;inherited&#160;from&#160;the&#160;superclass,&#160;and&#160;how&#160;to&#160;override&#160;or&#160;augment<br/>the inherited methods to define new behavior for the subclass.<br/>
<b>Subclassing a Struct</b><br/>
Earlier&#160;in&#160;this&#160;chapter,&#160;we&#160;saw&#160;how&#160;to&#160;use&#160;Struct.new&#160;to&#160;automatically&#160;generate&#160;simple<br/>classes.&#160;It&#160;is&#160;also&#160;possible&#160;to&#160;subclass&#160;a&#160;struct-based&#160;class,&#160;so&#160;that&#160;methods&#160;other&#160;than<br/>the automatically generated ones can be added:<br/>
class Point3D &lt; Struct.new(&#34;Point3D&#34;, :x, :y, :z)<br/>&#160; # Superclass struct gives us accessor methods, ==, to_s, etc.<br/>&#160; # Add point-specific methods here<br/>end<br/>
<b>7.3.1 &#160;Inheriting Methods<br/></b>The&#160;Point3D&#160;class&#160;we&#160;have&#160;defined&#160;is&#160;a&#160;trivial&#160;subclass&#160;of&#160;Point.&#160;It&#160;declares&#160;itself&#160;an<br/>extension&#160;&#160;of&#160;&#160;Point,&#160;&#160;but&#160;&#160;there&#160;&#160;is&#160;&#160;no&#160;&#160;class&#160;&#160;body,&#160;&#160;so&#160;&#160;it&#160;&#160;adds&#160;&#160;nothing&#160;&#160;to&#160;&#160;that&#160;&#160;class.&#160;&#160;A<br/>
<b>7.3 &#160;Subclassing and Inheritance&#160;|&#160;235</b><br/>
<hr/>
<a name=250></a>Point3D&#160;object&#160;is&#160;effectively&#160;the&#160;same&#160;thing&#160;as&#160;a&#160;Point&#160;object.&#160;One&#160;of&#160;the&#160;only&#160;observable<br/>differences is in the value returned by the&#160;class&#160;method:<br/>
p2 = Point.new(1,2)<br/>p3 = Point3D.new(1,2)<br/>print p2.to_s, p2.class &#160; # prints &#34;(1,2)Point&#34;<br/>print p3.to_s, p3.class &#160; # prints &#34;(1,2)Point3D&#34;<br/>
The&#160;value&#160;returned&#160;by&#160;the&#160;class&#160;method&#160;is&#160;different,&#160;but&#160;what’s&#160;more&#160;striking&#160;about<br/>this&#160;example&#160;is&#160;what&#160;is&#160;the&#160;same.&#160;Our&#160;Point3D&#160;object&#160;has&#160;inherited&#160;the&#160;to_s&#160;method<br/>defined by&#160;Point.&#160;It&#160;has&#160;also&#160;inherited&#160;the&#160;initialize&#160;method—this&#160;is&#160;what&#160;allows&#160;us<br/>to&#160;create&#160;a&#160;Point3D&#160;object&#160;with&#160;the&#160;same&#160;new&#160;call&#160;that&#160;we&#160;use&#160;to&#160;create&#160;a&#160;Point&#160;object.*<br/>There&#160;is&#160;another&#160;example&#160;of&#160;method&#160;inheritance&#160;in&#160;this&#160;code:&#160;both&#160;Point&#160;and&#160;Point3D<br/>inherit the&#160;class&#160;method from&#160;Object.<br/>
<b>7.3.2 &#160;Overriding Methods<br/></b>When&#160;we&#160;define&#160;a&#160;new&#160;class,&#160;we&#160;add&#160;new&#160;behavior&#160;to&#160;it&#160;by&#160;defining&#160;new&#160;methods.&#160;Just<br/>as&#160;&#160;importantly,&#160;&#160;however,&#160;&#160;we&#160;&#160;can&#160;&#160;customize&#160;&#160;the&#160;&#160;inherited&#160;&#160;behavior&#160;&#160;of&#160;&#160;the&#160;&#160;class&#160;&#160;by<br/>redefining inherited methods.<br/>For example, the&#160;Object&#160;class&#160;defines&#160;a&#160;to_s&#160;method&#160;to&#160;convert&#160;an&#160;object&#160;to&#160;a&#160;string&#160;in<br/>a very generic way:<br/>
o = Object.new<br/>puts o.to_s &#160; &#160; &#160;# Prints something like &#34;#&lt;Object:0xb7f7fce4&gt;&#34;<br/>
When&#160;we&#160;defined&#160;a&#160;to_s&#160;method&#160;in&#160;the&#160;Point&#160;class,&#160;we&#160;were&#160;<i>overriding</i>&#160;the&#160;to_s&#160;method<br/>inherited from&#160;Object.<br/>One&#160;of&#160;the&#160;important&#160;things&#160;to&#160;understand&#160;about&#160;object-oriented&#160;programming&#160;and<br/>subclassing&#160;is&#160;that&#160;when&#160;methods&#160;are&#160;invoked,&#160;they&#160;are&#160;looked&#160;up&#160;dynamically&#160;so&#160;that<br/>the&#160;appropriate&#160;definition&#160;or&#160;redefinition&#160;of&#160;the&#160;method&#160;is&#160;found.&#160;That&#160;is,&#160;method&#160;in-<br/>vocations&#160;are&#160;not&#160;bound&#160;statically&#160;at&#160;the&#160;time&#160;they&#160;are&#160;parsed,&#160;but&#160;rather,&#160;are&#160;looked<br/>up&#160;at&#160;the&#160;time&#160;they&#160;are&#160;executed.&#160;Here&#160;is&#160;an&#160;example&#160;to&#160;demonstrate&#160;this&#160;important<br/>point:<br/>
# Greet the World<br/>class WorldGreeter<br/>&#160; def greet &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Display a greeting<br/>&#160; &#160; puts &#34;#{greeting} #{who}&#34;<br/>&#160; end<br/>
&#160; def greeting &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # What greeting to use<br/>&#160; &#160; &#34;Hello&#34;<br/>&#160; end<br/>
*&#160;If&#160;you’re&#160;a&#160;Java&#160;programmer,&#160;this&#160;may&#160;be&#160;surprising&#160;to&#160;you.&#160;Java&#160;classes&#160;define&#160;special&#160;constructor&#160;methods<br/>
for&#160;initialization,&#160;and&#160;those&#160;methods&#160;are&#160;not&#160;inherited.&#160;In&#160;Ruby,&#160;initialize&#160;is&#160;an&#160;ordinary&#160;method&#160;and&#160;is<br/>inherited like any other.<br/>
<b>236&#160;|&#160;Chapter 7:</b> <b>Classes and Modules</b><br/>
<hr/>
<a name=251></a>&#160; def who &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Who to greet<br/>&#160; &#160; &#34;World&#34;<br/>&#160; end<br/>end<br/>
# Greet the world in Spanish<br/>class SpanishWorldGreeter &lt; WorldGreeter<br/>&#160; def greeting &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Override the greeting<br/>&#160; &#160; &#34;Hola&#34;<br/>&#160; end<br/>end<br/>
# We call a method defined in WorldGreeter, which calls the overridden<br/># version of greeting in SpanishWorldGreeter, and prints &#34;Hola World&#34;<br/>SpanishWorldGreeter.new.greet<br/>
If&#160;you’ve&#160;done&#160;object-oriented&#160;programming&#160;before,&#160;the&#160;behavior&#160;of&#160;this&#160;program&#160;is<br/>probably&#160;obvious&#160;and&#160;trivial&#160;to&#160;you.&#160;But&#160;if&#160;you’re&#160;new&#160;to&#160;it,&#160;it&#160;may&#160;be&#160;profound.&#160;We<br/>call&#160;&#160;the&#160;&#160;greet&#160;&#160;method&#160;&#160;inherited&#160;&#160;from&#160;&#160;WorldGreeter.&#160;&#160;This&#160;&#160;greet&#160;&#160;method&#160;&#160;calls&#160;&#160;the<br/>greeting&#160;method.&#160;At&#160;the&#160;time&#160;that&#160;greet&#160;was&#160;defined,&#160;the&#160;greeting&#160;method&#160;returned<br/>“Hello”.&#160;But&#160;we’ve&#160;subclassed&#160;WorldGreeter,&#160;and&#160;the&#160;object&#160;we’re&#160;calling&#160;greet&#160;on has<br/>a&#160;new&#160;definition&#160;of&#160;greeting.&#160;When&#160;we&#160;invoke&#160;greeting,&#160;Ruby&#160;looks&#160;up&#160;the&#160;appropriate<br/>definition&#160;of&#160;that&#160;method&#160;for&#160;the&#160;object&#160;it&#160;is&#160;being&#160;invoked&#160;on,&#160;and&#160;we&#160;end&#160;up&#160;with&#160;a<br/>proper&#160;Spanish&#160;greeting&#160;rather&#160;than&#160;an&#160;English&#160;one.&#160;This&#160;runtime&#160;lookup&#160;of&#160;the&#160;ap-<br/>propriate&#160;definition&#160;of&#160;a&#160;method&#160;is&#160;called&#160;<i>method name resolution</i>,&#160;and&#160;is&#160;described&#160;in<br/><a href="Rubys.html#272">detail in §7.8 at the end of this chapter.<br/></a>Notice&#160;that&#160;it&#160;is&#160;also&#160;perfectly&#160;reasonable&#160;to&#160;define&#160;an&#160;<i>abstract</i>&#160;class&#160;that&#160;invokes&#160;certain<br/>undefined&#160;“abstract”&#160;methods,&#160;which&#160;are&#160;left&#160;for&#160;subclasses&#160;to&#160;define.&#160;The&#160;opposite&#160;of<br/>abstract is&#160;<i>concrete</i>. A class that extends an abstract class is concrete if it defines all of<br/>the abstract methods of its ancestors. For example:<br/>
# This class is abstract; it doesn't define greeting or who<br/># No special syntax is required: any class that invokes methods that are<br/># intended for a subclass to implement is abstract.<br/>class AbstractGreeter<br/>&#160; def greet<br/>&#160; &#160; puts &#34;#{greeting} #{who}&#34;<br/>&#160; end<br/>end<br/>
# A concrete subclass<br/>class WorldGreeter &lt; AbstractGreeter<br/>&#160; def greeting; &#34;Hello&#34;; end<br/>&#160; def who; &#34;World&#34;; end<br/>end<br/>
WorldGreeter.new.greet &#160;# Displays &#34;Hello World&#34;<br/>
<b>7.3 &#160;Subclassing and Inheritance&#160;|&#160;237</b><br/>
<hr/>
<a name=252></a><b>7.3.2.1 &#160;Overriding private methods<br/></b>Private methods&#160;cannot be invoked from outside the class that defines them. But they<br/>are&#160;&#160;inherited&#160;&#160;by&#160;&#160;subclasses.&#160;&#160;This&#160;&#160;means&#160;&#160;that&#160;&#160;subclasses&#160;&#160;can&#160;&#160;invoke&#160;&#160;them&#160;&#160;and&#160;&#160;can<br/>override them.<br/>Be&#160;careful&#160;when&#160;you&#160;subclass&#160;a&#160;class&#160;that&#160;you&#160;did&#160;not&#160;write&#160;yourself.&#160;Classes&#160;often&#160;use<br/>private&#160;methods&#160;as&#160;internal&#160;helper&#160;methods.&#160;They&#160;are&#160;not&#160;part&#160;of&#160;the&#160;public&#160;API&#160;of&#160;the<br/>class&#160;and&#160;are&#160;not&#160;intended&#160;to&#160;be&#160;visible.&#160;If&#160;you&#160;haven’t&#160;read&#160;the&#160;source&#160;code&#160;of&#160;the&#160;class,<br/>you&#160;won’t&#160;even&#160;know&#160;the&#160;names&#160;of&#160;the&#160;private&#160;methods&#160;it&#160;defines&#160;for&#160;its&#160;own&#160;use.&#160;If<br/>you&#160;happen&#160;to&#160;define&#160;a&#160;method&#160;(whatever&#160;its&#160;visibility)&#160;in&#160;your&#160;subclass&#160;that&#160;has&#160;the<br/>same&#160;name&#160;as&#160;a&#160;private&#160;method&#160;in&#160;the&#160;superclass,&#160;you&#160;will&#160;have&#160;inadvertently&#160;overridden<br/>the&#160;superclass’s&#160;internal&#160;utility&#160;method,&#160;and&#160;this&#160;will&#160;almost&#160;certainly&#160;cause&#160;unintended<br/>behavior.<br/>The&#160;upshot&#160;is&#160;that,&#160;in&#160;Ruby,&#160;you&#160;should&#160;only&#160;subclass&#160;when&#160;you&#160;are&#160;familiar&#160;with&#160;the<br/>implementation&#160;of&#160;the&#160;superclass.&#160;If&#160;you&#160;only&#160;want&#160;to&#160;depend&#160;on&#160;the&#160;public&#160;API&#160;of&#160;a<br/>class&#160;and&#160;not&#160;on&#160;its&#160;implementation,&#160;then&#160;you&#160;should&#160;extend&#160;the&#160;functionality&#160;of&#160;the<br/>class by encapsulating and delegating to it, not by inheriting from it.<br/>
<b>7.3.3 &#160;Augmenting Behavior by Chaining<br/></b>Sometimes&#160;when&#160;we&#160;override&#160;a&#160;method,&#160;we&#160;don’t&#160;want&#160;to&#160;replace&#160;it&#160;altogether,&#160;we&#160;just<br/>want&#160;to&#160;augment&#160;its&#160;behavior&#160;by&#160;adding&#160;some&#160;new&#160;code.&#160;In&#160;order&#160;to&#160;do&#160;this,&#160;we&#160;need<br/>a&#160;way&#160;to&#160;invoke&#160;the&#160;overridden&#160;method&#160;from&#160;the&#160;overriding&#160;method.&#160;This&#160;is&#160;known<br/>as&#160;<i>chaining</i>, and it is accomplished with the keyword&#160;super.<br/>
super&#160;works&#160;like&#160;a&#160;special&#160;method&#160;invocation:&#160;it&#160;invokes&#160;a&#160;method&#160;with&#160;the&#160;same&#160;name<br/>as&#160;the&#160;current&#160;one,&#160;in&#160;the&#160;superclass&#160;of&#160;the&#160;current&#160;class.&#160;(Note&#160;that&#160;the&#160;superclass&#160;need<br/>not&#160;define&#160;that&#160;method&#160;itself—it&#160;can&#160;inherit&#160;it&#160;from&#160;one&#160;of&#160;its&#160;ancestors.)&#160;You&#160;may<br/>specify&#160;arguments&#160;for&#160;super&#160;just&#160;as&#160;you&#160;would&#160;for&#160;a&#160;normal&#160;method&#160;invocation.&#160;One<br/>common&#160;and&#160;important&#160;place&#160;for&#160;method&#160;chaining&#160;is&#160;the&#160;initialize&#160;method&#160;of&#160;a&#160;class.<br/>Here is how we might write the&#160;initialize&#160;method of our&#160;Point3D&#160;class:<br/>
class Point3D &lt; Point<br/>&#160; def initialize(x,y,z)<br/>&#160; &#160; # Pass our first two arguments along to the superclass initialize method<br/>&#160; &#160; super(x,y)<br/>&#160; &#160; # And deal with the third argument ourself<br/>&#160; &#160; @z = z<br/>&#160; end<br/>end<br/>
If&#160;you&#160;use&#160;super&#160;as&#160;a&#160;bare&#160;keyword—with&#160;no&#160;arguments&#160;and&#160;no&#160;parentheses—then&#160;all<br/>of&#160;the&#160;arguments&#160;that&#160;were&#160;passed&#160;to&#160;the&#160;current&#160;method&#160;are&#160;passed&#160;to&#160;the&#160;superclass<br/>method.&#160;Note,&#160;however,&#160;that&#160;it’s&#160;the&#160;current&#160;values&#160;of&#160;the&#160;method&#160;parameters&#160;that&#160;are<br/>passed&#160;to&#160;the&#160;superclass&#160;method.&#160;If&#160;the&#160;method&#160;has&#160;modified&#160;the&#160;values&#160;in&#160;its&#160;parameter<br/>variables,&#160;&#160;then&#160;&#160;the&#160;&#160;modified&#160;&#160;values&#160;&#160;are&#160;&#160;passed&#160;&#160;to&#160;&#160;the&#160;&#160;invocation&#160;&#160;of&#160;&#160;the&#160;&#160;superclass<br/>method.<br/>
<b>238&#160;|&#160;Chapter 7:</b> <b>Classes and Modules</b><br/>
<hr/>
<a name=253></a>As with normal method invocations, the parentheses around&#160;super&#160;arguments are op-<br/>tional.&#160;Because&#160;a&#160;bare&#160;super&#160;has&#160;special&#160;meaning,&#160;however,&#160;you&#160;must&#160;explicitly&#160;use&#160;a<br/>pair&#160;of&#160;empty&#160;parentheses&#160;if&#160;you&#160;want&#160;to&#160;pass&#160;zero&#160;arguments&#160;from&#160;a&#160;method&#160;that&#160;itself<br/>has one or more arguments.<br/>
<b>7.3.4 &#160;Inheritance of Class Methods<br/></b>Class&#160;methods&#160;may&#160;be&#160;inherited&#160;and&#160;overridden&#160;just&#160;as&#160;instance&#160;methods&#160;can&#160;be.&#160;If&#160;our<br/>Point&#160;class&#160;defines&#160;a&#160;class&#160;method&#160;sum,&#160;then&#160;our&#160;Point3D&#160;subclass&#160;inherits&#160;that&#160;method.<br/>That&#160;is,&#160;if&#160;Point3D&#160;does&#160;not&#160;define&#160;its&#160;own&#160;class&#160;method&#160;named&#160;sum,&#160;then&#160;the&#160;expression<br/>Point3D.sum&#160;invokes the same method as the expression&#160;Point.sum.<br/>
As&#160;a&#160;stylistic&#160;matter,&#160;it&#160;is&#160;preferable&#160;to&#160;invoke&#160;class&#160;methods&#160;through&#160;the&#160;class&#160;object<br/>on&#160;which&#160;they&#160;are&#160;defined.&#160;A&#160;code&#160;maintainer&#160;seeing&#160;an&#160;expression&#160;Point3D.sum&#160;would<br/>go&#160;looking&#160;for&#160;a&#160;definition&#160;of&#160;the&#160;sum&#160;method&#160;in&#160;the&#160;Point3D&#160;class,&#160;and&#160;he&#160;might&#160;have&#160;a<br/>hard time finding it in the&#160;Point&#160;class. When invoking a class method with an explicit<br/>receiver,&#160;you&#160;should&#160;avoid&#160;relying&#160;on&#160;inheritance—always&#160;invoke&#160;the&#160;class&#160;method<br/>through the class that defines it.*<br/>Within&#160;the&#160;body&#160;of&#160;a&#160;class&#160;method,&#160;you&#160;may&#160;invoke&#160;the&#160;other&#160;class&#160;methods&#160;of&#160;the&#160;class<br/>without&#160;&#160;an&#160;&#160;explicit&#160;&#160;receiver—they&#160;&#160;are&#160;&#160;invoked&#160;&#160;implicitly&#160;&#160;on&#160;&#160;self,&#160;&#160;and&#160;&#160;the&#160;&#160;value&#160;&#160;of<br/>self&#160;in&#160;a&#160;class&#160;method&#160;is&#160;the&#160;class&#160;on&#160;which&#160;it&#160;was&#160;invoked.&#160;It&#160;is&#160;here,&#160;inside&#160;the&#160;body<br/>of&#160;&#160;a&#160;&#160;class&#160;&#160;method,&#160;&#160;that&#160;&#160;the&#160;&#160;inheritance&#160;&#160;of&#160;&#160;class&#160;&#160;methods&#160;&#160;is&#160;&#160;useful:&#160;&#160;it&#160;&#160;allows&#160;&#160;you&#160;&#160;to<br/>implicitly&#160;invoke&#160;a&#160;class&#160;method&#160;even&#160;when&#160;that&#160;class&#160;method&#160;is&#160;defined&#160;by&#160;a&#160;superclass.<br/>Finally,&#160;note&#160;that&#160;class&#160;methods&#160;can&#160;use&#160;super&#160;just&#160;as&#160;instance&#160;methods&#160;can&#160;to&#160;invoke<br/>the same-named method in the superclass.<br/>
<b>7.3.5 &#160;Inheritance and Instance Variables<br/></b>Instance&#160;&#160;variables&#160;&#160;often&#160;&#160;appear&#160;&#160;to&#160;&#160;be&#160;&#160;inherited&#160;&#160;in&#160;&#160;Ruby.&#160;&#160;Consider&#160;&#160;this&#160;&#160;code,&#160;&#160;for<br/>example:<br/>
class Point3D &lt; Point<br/>&#160; def initialize(x,y,z)<br/>&#160; &#160; super(x,y)<br/>&#160; &#160; @z = z<br/>&#160; end<br/>
&#160; def to_s<br/>&#160; &#160; &#34;(#@x, #@y, #@z)&#34; &#160;# Variables @x and @y inherited?<br/>&#160; end<br/>end<br/>
The&#160;&#160;to_s&#160;&#160;method&#160;&#160;in&#160;&#160;Point3D&#160;&#160;references&#160;&#160;the&#160;&#160;@x&#160;&#160;and&#160;&#160;@y&#160;&#160;variables&#160;&#160;from&#160;&#160;the&#160;&#160;superclass<br/>Point. This code works as you probably expect it to:<br/>
*&#160;The&#160;Class.new&#160;method&#160;is&#160;an&#160;exception—it&#160;is&#160;inherited&#160;by&#160;and&#160;invoked&#160;on&#160;just&#160;about&#160;every&#160;new&#160;class&#160;we&#160;define.<br/>
<b>7.3 &#160;Subclassing and Inheritance&#160;|&#160;239</b><br/>
<hr/>
<a name=254></a>Point3D.new(1,2,3).to_s &#160;# =&gt; &#34;(1, 2, 3)&#34;<br/>
Because&#160;this&#160;code&#160;behaves&#160;as&#160;expected,&#160;you&#160;may&#160;be&#160;tempted&#160;to&#160;say&#160;that&#160;these&#160;variables<br/>are&#160;inherited.&#160;That&#160;is&#160;not&#160;how&#160;Ruby&#160;works,&#160;though.&#160;All&#160;Ruby&#160;objects&#160;have&#160;a&#160;set&#160;of<br/>instance&#160;variables.&#160;These&#160;are&#160;not&#160;defined&#160;by&#160;the&#160;object’s&#160;class—they&#160;are&#160;simply&#160;created<br/>when&#160;a&#160;value&#160;is&#160;assigned&#160;to&#160;them.&#160;Because&#160;instance&#160;variables&#160;are&#160;not&#160;defined&#160;by&#160;a&#160;class,<br/>they are unrelated to subclassing and the inheritance mechanism.<br/>In&#160;this&#160;code,&#160;Point3D&#160;defines&#160;an&#160;initialize&#160;method&#160;that&#160;chains&#160;to&#160;the&#160;initialize&#160;meth-<br/>od&#160;of&#160;its&#160;superclass.&#160;The&#160;chained&#160;method&#160;assigns&#160;values&#160;to&#160;the&#160;variables&#160;@x&#160;and&#160;@y,&#160;which<br/>makes those variables come into existence for a particular instance of&#160;Point3D.<br/>Programmers&#160;coming&#160;from&#160;Java—or&#160;from&#160;other&#160;strongly&#160;typed&#160;languages&#160;in&#160;which&#160;a<br/>class&#160;defines&#160;a&#160;set&#160;of&#160;fields&#160;for&#160;its&#160;instances—may&#160;find&#160;that&#160;this&#160;takes&#160;some&#160;getting&#160;used<br/>to.&#160;Really,&#160;though,&#160;it&#160;is&#160;quite&#160;simple:&#160;Ruby’s&#160;instance&#160;variables&#160;are&#160;not&#160;inherited&#160;and<br/>have&#160;nothing&#160;to&#160;do&#160;with&#160;the&#160;inheritance&#160;mechanism.&#160;The&#160;reason&#160;that&#160;they&#160;sometimes<br/>appear&#160;to&#160;be&#160;inherited&#160;is&#160;that&#160;instance&#160;variables&#160;are&#160;created&#160;by&#160;the&#160;methods&#160;that&#160;first<br/>assign values to them, and those&#160;<i>methods</i>&#160;are often inherited or chained.<br/>There&#160;is&#160;an&#160;important&#160;corollary.&#160;Because&#160;instance&#160;variables&#160;have&#160;nothing&#160;to&#160;do&#160;with<br/>inheritance,&#160;it&#160;follows&#160;that&#160;an&#160;instance&#160;variable&#160;used&#160;by&#160;a&#160;subclass&#160;cannot&#160;“shadow”&#160;an<br/>instance&#160;variable&#160;in&#160;the&#160;superclass.&#160;If&#160;a&#160;subclass&#160;uses&#160;an&#160;instance&#160;variable&#160;with&#160;the&#160;same<br/>name&#160;as&#160;a&#160;variable&#160;used&#160;by&#160;one&#160;of&#160;its&#160;ancestors,&#160;it&#160;will&#160;overwrite&#160;the&#160;value&#160;of&#160;its&#160;ancestor’s<br/>variable.&#160;This&#160;can&#160;be&#160;done&#160;intentionally,&#160;to&#160;alter&#160;the&#160;behavior&#160;of&#160;the&#160;ancestor,&#160;or&#160;it&#160;can<br/>be&#160;done&#160;inadvertently.&#160;In&#160;the&#160;latter&#160;case,&#160;it&#160;is&#160;almost&#160;certain&#160;to&#160;cause&#160;bugs.&#160;As&#160;with&#160;the<br/>inheritance&#160;of&#160;private&#160;methods&#160;described&#160;earlier,&#160;this&#160;is&#160;another&#160;reason&#160;why&#160;it&#160;is&#160;only<br/>safe&#160;&#160;to&#160;&#160;extend&#160;&#160;Ruby&#160;&#160;classes&#160;&#160;when&#160;&#160;you&#160;&#160;are&#160;&#160;familiar&#160;&#160;with&#160;&#160;(and&#160;&#160;in&#160;&#160;control&#160;&#160;of)&#160;&#160;the<br/>implementation of the superclass.<br/>Finally,&#160;recall&#160;that&#160;class&#160;instance&#160;variables&#160;are&#160;simply&#160;instance&#160;variables&#160;of&#160;the&#160;Class<br/>object&#160;that&#160;represents&#160;a&#160;class.&#160;As&#160;such,&#160;they&#160;are&#160;not&#160;inherited.&#160;Furthermore,&#160;the&#160;Point<br/>and&#160;Point3D&#160;objects&#160;(we’re&#160;talking&#160;about&#160;the&#160;Class&#160;objects&#160;themselves,&#160;not&#160;the&#160;classes<br/>they&#160;represent)&#160;are&#160;both&#160;just&#160;instances&#160;of&#160;Class.&#160;There&#160;is&#160;no&#160;relationship&#160;between&#160;them,<br/>and no way that one could inherit variables from the other.<br/>
<b>7.3.6 &#160;Inheritance and Class Variables<br/></b>Class&#160;variables&#160;are&#160;shared&#160;by&#160;a&#160;class&#160;and&#160;all&#160;of&#160;its&#160;subclasses.&#160;If&#160;a&#160;class&#160;A&#160;defines&#160;a&#160;variable<br/>@@a,&#160;then&#160;subclass&#160;B&#160;can&#160;use&#160;that&#160;variable.&#160;Although&#160;this&#160;may&#160;appear,&#160;superficially,&#160;to<br/>be inheritance, it is actually something different.<br/>The&#160;difference&#160;becomes&#160;clear&#160;when&#160;we&#160;think&#160;about&#160;setting&#160;the&#160;value&#160;of&#160;a&#160;class&#160;variable.<br/>If&#160;a&#160;subclass&#160;assigns&#160;a&#160;value&#160;to&#160;a&#160;class&#160;variable&#160;already&#160;in&#160;use&#160;by&#160;a&#160;superclass,&#160;it&#160;does&#160;not<br/>create&#160;its&#160;own&#160;private&#160;copy&#160;of&#160;the&#160;class&#160;variable,&#160;but&#160;instead&#160;alters&#160;the&#160;value&#160;seen&#160;by&#160;the<br/>superclass.&#160;It&#160;also&#160;alters&#160;the&#160;shared&#160;value&#160;seen&#160;by&#160;all&#160;other&#160;subclasses&#160;of&#160;the&#160;superclass.&#160;<br/>Ruby&#160;1.8&#160;prints&#160;a&#160;warning&#160;about&#160;this&#160;if&#160;you&#160;run&#160;it&#160;with&#160;-w.&#160;Ruby&#160;1.9&#160;does&#160;not&#160;issue&#160;this<br/>warning.<br/>
<b>240&#160;|&#160;Chapter 7:</b> <b>Classes and Modules</b><br/>
<hr/>
<a name=255></a>If&#160;a&#160;class&#160;uses&#160;class&#160;variables,&#160;then&#160;any&#160;subclass&#160;can&#160;alter&#160;the&#160;behavior&#160;of&#160;the&#160;class&#160;and<br/>all&#160;its&#160;descendants&#160;by&#160;changing&#160;the&#160;value&#160;of&#160;the&#160;shared&#160;class&#160;variable.&#160;This&#160;is&#160;a&#160;strong<br/>argument for the use of class instance variables instead of class variables.<br/>The following code demonstrates the sharing of class variables. It outputs&#160;123:<br/>
class A<br/>&#160; @@value = 1 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # A class variable<br/>&#160; def A.value; @@value; end &#160; &#160; # An accessor method for it<br/>end<br/>print A.value &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Display value of A's class variable<br/>class B &lt; A; @@value = 2; end &#160; # Subclass alters shared class variable<br/>print A.value &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Superclass sees altered value<br/>class C &lt; A; @@value = 3; end &#160; # Another alters shared variable again<br/>print B.value &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # 1st subclass sees value from 2nd subclass<br/>
<b>7.3.7 &#160;Inheritance of Constants<br/></b>Constants&#160;are&#160;inherited&#160;and&#160;can&#160;be&#160;overridden,&#160;much&#160;like&#160;instance&#160;methods&#160;can.&#160;There<br/>is,&#160;however,&#160;a&#160;very&#160;important&#160;difference&#160;between&#160;the&#160;inheritance&#160;of&#160;methods&#160;and&#160;the<br/>inheritance of constants.<br/>Our&#160;Point3D&#160;class&#160;can&#160;use&#160;the&#160;ORIGIN&#160;constant&#160;defined&#160;by&#160;its&#160;Point&#160;superclass,&#160;for&#160;ex-<br/>ample.&#160;&#160;Although&#160;&#160;the&#160;&#160;clearest&#160;&#160;style&#160;&#160;is&#160;&#160;to&#160;&#160;qualify&#160;&#160;constants&#160;&#160;with&#160;&#160;their&#160;&#160;defining&#160;&#160;class,<br/>Point3D&#160;&#160;could&#160;&#160;also&#160;&#160;refer&#160;&#160;to&#160;&#160;this&#160;&#160;constant&#160;&#160;with&#160;&#160;an&#160;&#160;unqualified&#160;&#160;ORIGIN&#160;&#160;or&#160;&#160;even&#160;&#160;as<br/>Point3D::ORIGIN.<br/>
Where&#160;&#160;inheritance&#160;&#160;of&#160;&#160;constants&#160;&#160;becomes&#160;&#160;interesting&#160;&#160;is&#160;&#160;when&#160;&#160;a&#160;&#160;class&#160;&#160;like&#160;&#160;Point3D<br/>redefines&#160;a&#160;constant.&#160;A&#160;three-dimensional&#160;point&#160;class&#160;probably&#160;wants&#160;a&#160;constant&#160;named<br/>ORIGIN&#160;to&#160;refer&#160;to&#160;a&#160;three-dimensional&#160;point,&#160;so&#160;Point3D&#160;is&#160;likely&#160;to&#160;include&#160;a&#160;line&#160;like&#160;this:<br/>
ORIGIN = Point3D.new(0,0,0)<br/>
As&#160;you&#160;know,&#160;Ruby&#160;issues&#160;a&#160;warning&#160;when&#160;a&#160;constant&#160;is&#160;redefined.&#160;In&#160;this&#160;case,&#160;however,<br/>this&#160;&#160;is&#160;&#160;a&#160;&#160;newly&#160;&#160;created&#160;&#160;constant.&#160;&#160;We&#160;&#160;now&#160;&#160;have&#160;&#160;two&#160;&#160;constants&#160;&#160;Point::ORIGIN&#160;&#160;and<br/>Point3D::ORIGIN.<br/>
The&#160;important&#160;difference&#160;between&#160;constants&#160;and&#160;methods&#160;is&#160;that&#160;constants&#160;are&#160;looked<br/>up&#160;in&#160;the&#160;lexical&#160;scope&#160;of&#160;the&#160;place&#160;they&#160;are&#160;used&#160;before&#160;they&#160;are&#160;looked&#160;up&#160;in&#160;the<br/>inheritance&#160;hierarchy&#160;(<a href="Rubys.html#275">§7.9&#160;</a>has&#160;details).&#160;This&#160;means&#160;that&#160;if&#160;Point3D&#160;inherits&#160;methods<br/>that use the constant&#160;ORIGIN,&#160;the&#160;behavior&#160;of&#160;those&#160;inherited&#160;methods&#160;will&#160;not&#160;change<br/>when&#160;Point3D&#160;defines its own version of&#160;ORIGIN.<br/>
<b>7.4 &#160;Object Creation and Initialization<br/></b>Objects&#160;are&#160;typically&#160;created&#160;in&#160;Ruby&#160;by&#160;calling&#160;the&#160;new&#160;method&#160;of&#160;their&#160;class.&#160;This<br/>section explains exactly how that works, and it also explains other mechanisms (such<br/>as&#160;cloning&#160;and&#160;unmarshaling)&#160;that&#160;create&#160;objects.&#160;Each&#160;subsection&#160;explains&#160;how&#160;you<br/>can customize the initialization of the newly created objects.<br/>
<b>7.4 &#160;Object Creation and Initialization&#160;|&#160;241</b><br/>
<hr/>
<a name=256></a><b>7.4.1 &#160;new, allocate, and initialize<br/></b>Every class&#160;inherits&#160;the&#160;class&#160;method&#160;new.&#160;This&#160;method&#160;has&#160;two&#160;jobs:&#160;it&#160;must&#160;allocate&#160;a<br/>new&#160;object—actually&#160;bring&#160;the&#160;object&#160;into&#160;existence—and&#160;it&#160;must&#160;initialize&#160;the&#160;object.<br/>It&#160;delegates&#160;these&#160;two&#160;jobs&#160;to&#160;the&#160;allocate&#160;and&#160;initialize&#160;methods,&#160;respectively.&#160;If&#160;the<br/>new&#160;method were actually written in Ruby, it would look something like this:<br/>
def new(*args)<br/>&#160; o = self.allocate &#160; # Create a new object of this class<br/>&#160; o.initialize(*args) # Call the object's initialize method with our args<br/>&#160; o &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Return new object; ignore return value of initialize<br/>end<br/>
allocate&#160;&#160;is&#160;&#160;an&#160;&#160;instance&#160;&#160;method&#160;&#160;of&#160;&#160;Class,&#160;&#160;and&#160;&#160;it&#160;&#160;is&#160;&#160;inherited&#160;&#160;by&#160;&#160;all&#160;&#160;class&#160;&#160;objects.&#160;&#160;Its<br/>purpose&#160;is&#160;to&#160;create&#160;a&#160;new&#160;instance&#160;of&#160;the&#160;class.&#160;You&#160;can&#160;call&#160;this&#160;method&#160;yourself&#160;to<br/>create&#160;uninitialized&#160;instances&#160;of&#160;a&#160;class.&#160;But&#160;don’t&#160;try&#160;to&#160;override&#160;it;&#160;Ruby&#160;always&#160;invokes<br/>this method directly, ignoring any overriding versions you may have defined.<br/>
initialize&#160;is&#160;an&#160;instance&#160;method.&#160;Most&#160;classes&#160;need&#160;one,&#160;and&#160;every&#160;class&#160;that&#160;extends<br/>a&#160;class&#160;other&#160;than&#160;Object&#160;should&#160;use&#160;super&#160;to&#160;chain&#160;to&#160;the&#160;initialize&#160;method&#160;of&#160;the<br/>superclass.&#160;The&#160;usual&#160;job&#160;of&#160;the&#160;initialize&#160;method&#160;is&#160;to&#160;create&#160;instance&#160;variables&#160;for<br/>the&#160;object&#160;and&#160;set&#160;them&#160;to&#160;their&#160;initial&#160;values.&#160;Typically,&#160;the&#160;value&#160;of&#160;these&#160;instance<br/>variables&#160;are&#160;derived&#160;from&#160;the&#160;arguments&#160;that&#160;the&#160;client&#160;code&#160;passed&#160;to&#160;new&#160;and&#160;that<br/>new&#160;passed to&#160;initialize.&#160;initialize&#160;does&#160;not&#160;need&#160;to&#160;return&#160;the&#160;initialized&#160;object.&#160;In<br/>fact,&#160;the&#160;return&#160;value&#160;of&#160;initialize&#160;is&#160;ignored.&#160;Ruby&#160;implicitly&#160;makes&#160;the&#160;initialize<br/>method private, which means that you cannot explicitly invoke it on an object.<br/>
<b>Class::new and Class#new</b><br/>
Class&#160;defines&#160;two&#160;methods&#160;named&#160;new.&#160;One,&#160;Class#new,&#160;is&#160;an&#160;instance&#160;method,&#160;and&#160;the<br/>other,&#160;Class::new,&#160;is&#160;a&#160;class&#160;method&#160;(we&#160;use&#160;the&#160;disambiguating&#160;naming&#160;convention&#160;of<br/>the&#160;<i>ri</i>&#160;tool here). The first is the instance method that we’ve been describing here; it is<br/>inherited&#160;by&#160;all&#160;class&#160;objects,&#160;becoming&#160;a&#160;class&#160;method&#160;of&#160;the&#160;class,&#160;and&#160;is&#160;used&#160;to&#160;create<br/>and initialize new instances.<br/>
The class method&#160;Class::new&#160;is the&#160;Class&#160;class’&#160;own&#160;version&#160;of&#160;the&#160;method,&#160;and&#160;it&#160;can<br/>be used to create new classes.<br/>
<b>7.4.2 &#160;Factory Methods<br/></b>It&#160;is&#160;often&#160;useful&#160;to&#160;allow&#160;instances&#160;of&#160;a&#160;class&#160;to&#160;be&#160;initialized&#160;in&#160;more&#160;than&#160;one&#160;way.<br/>You&#160;can&#160;often&#160;do&#160;this&#160;by&#160;providing&#160;parameter&#160;defaults&#160;on&#160;the&#160;initialize&#160;method.&#160;With<br/>an&#160;initialize&#160;method&#160;defined&#160;as&#160;follows,&#160;for&#160;example,&#160;you&#160;can&#160;invoke&#160;new&#160;with either<br/>two or three arguments:<br/>
class Point<br/>&#160; # Initialize a Point with two or three coordinates<br/>&#160; def initialize(x, y, z=nil)<br/>
<b>242&#160;|&#160;Chapter 7:</b> <b>Classes and Modules</b><br/>
<hr/>
<a name=257></a>&#160; &#160; @x,@y,@z = x, y, z<br/>&#160; end<br/>end<br/>
Sometimes,&#160;however,&#160;parameter&#160;defaults&#160;are&#160;not&#160;enough,&#160;and&#160;we&#160;need&#160;to&#160;write&#160;<i>factory<br/>methods</i>&#160;other&#160;than&#160;new&#160;for&#160;creating&#160;instances&#160;of&#160;our&#160;class.&#160;Suppose&#160;that&#160;we&#160;want&#160;to&#160;be<br/>able to initialize&#160;Point&#160;objects using either Cartesian or polar coordinates:<br/>
class Point<br/>&#160; # Define an initialize method as usual...<br/>&#160; def initialize(x,y) &#160;# Expects Cartesian coordinates<br/>&#160; &#160; @x,@y = x,y<br/>&#160; end<br/>
&#160; # But make the factory method new private<br/>&#160; private_class_method :new<br/>
&#160; def Point.cartesian(x,y) &#160;# Factory method for Cartesian coordinates<br/>&#160; &#160; new(x,y) &#160;# We can still call new from other class methods<br/>&#160; end<br/>
&#160; def Point.polar(r, theta) # Factory method for polar coordinates<br/>&#160; &#160; new(r*Math.cos(theta), r*Math.sin(theta))<br/>&#160; end<br/>end<br/>
This&#160;code&#160;still&#160;relies&#160;on&#160;new&#160;and&#160;initialize,&#160;but&#160;it&#160;makes&#160;new&#160;private,&#160;so&#160;that&#160;users&#160;of<br/>the&#160;Point&#160;class&#160;can’t&#160;call&#160;it&#160;directly.&#160;Instead,&#160;they&#160;must&#160;use&#160;one&#160;of&#160;the&#160;custom&#160;factory<br/>methods.<br/>
<b>7.4.3 &#160;dup, clone, and initialize_copy<br/></b>Another&#160;way&#160;that&#160;new&#160;objects&#160;come&#160;into&#160;existence&#160;is&#160;as&#160;a&#160;result&#160;of&#160;the&#160;dup&#160;and&#160;clone<br/><a href="Rubys.html#96">methods (see&#160;§3.8.8).&#160;</a>These&#160;methods&#160;allocate&#160;a&#160;new&#160;instance&#160;of&#160;the&#160;class&#160;of&#160;the&#160;object<br/>on&#160;which&#160;they&#160;are&#160;invoked.&#160;They&#160;then&#160;copy&#160;all&#160;the&#160;instance&#160;variables&#160;and&#160;the&#160;taintedness<br/>of&#160;the&#160;receiver&#160;object&#160;to&#160;the&#160;newly&#160;allocated&#160;object.&#160;clone&#160;takes&#160;this&#160;copying&#160;a&#160;step<br/>further&#160;than&#160;dup—it&#160;also&#160;copies&#160;singleton&#160;methods&#160;of&#160;the&#160;receiver&#160;object&#160;and&#160;freezes<br/>the copy object if the original is frozen.<br/>If&#160;a&#160;class&#160;defines&#160;a&#160;method&#160;named&#160;initialize_copy,&#160;then&#160;clone&#160;and&#160;dup&#160;will&#160;invoke&#160;that<br/>method&#160;on&#160;the&#160;copied&#160;object&#160;after&#160;copying&#160;the&#160;instance&#160;variables&#160;from&#160;the&#160;original.<br/>(clone&#160;calls&#160;initialize_copy&#160;before&#160;freezing&#160;the&#160;copy&#160;object,&#160;so&#160;that&#160;initialize_copy<br/>is&#160;still&#160;allowed&#160;to&#160;modify&#160;it.)&#160;The&#160;initialize_copy&#160;method&#160;is&#160;passed&#160;the&#160;original&#160;object<br/>as&#160;an&#160;argument&#160;and&#160;has&#160;the&#160;opportunity&#160;to&#160;make&#160;any&#160;changes&#160;it&#160;desires&#160;to&#160;the&#160;copied<br/>object.&#160;&#160;It&#160;&#160;cannot&#160;&#160;create&#160;&#160;its&#160;&#160;own&#160;&#160;copy&#160;&#160;object,&#160;&#160;however;&#160;&#160;the&#160;&#160;return&#160;&#160;value&#160;&#160;of<br/>initialize_copy&#160;&#160;is&#160;&#160;ignored.&#160;&#160;Like&#160;&#160;initialize,&#160;&#160;Ruby&#160;&#160;ensures&#160;&#160;that&#160;&#160;initialize_copy&#160;&#160;is<br/>always private.<br/>When&#160;clone&#160;and&#160;dup&#160;copy&#160;instance&#160;variables&#160;from&#160;the&#160;original&#160;object&#160;to&#160;the&#160;copy,&#160;they<br/>copy references to the values of those variables; they do not copy the actual values. In<br/>
<b>7.4 &#160;Object Creation and Initialization&#160;|&#160;243</b><br/>
<hr/>
<a name=258></a>other&#160;words,&#160;these&#160;methods&#160;perform&#160;a&#160;shallow&#160;copy.&#160;And&#160;this&#160;is&#160;one&#160;reason&#160;that&#160;many<br/>classes&#160;might&#160;want&#160;to&#160;alter&#160;the&#160;behavior&#160;of&#160;these&#160;methods.&#160;Here&#160;is&#160;code&#160;that&#160;defines&#160;an<br/>initialize_copy&#160;method to do a deeper copy of internal state:<br/>
class Point &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # A point in n-space<br/>&#160; def initialize(*coords) &#160; # Accept an arbitrary # of coordinates<br/>&#160; &#160; @coords = coords &#160; &#160; &#160; &#160;# Store the coordinates in an array<br/>&#160; end<br/>
&#160; def initialize_copy(orig) # If someone copies this Point object<br/>&#160; &#160; @coords = @coords.dup &#160; # Make a copy of the coordinates array, too<br/>&#160; end<br/>end<br/>
The&#160;&#160;class&#160;&#160;shown&#160;&#160;here&#160;&#160;stores&#160;&#160;its&#160;&#160;internal&#160;&#160;state&#160;&#160;in&#160;&#160;an&#160;&#160;array.&#160;&#160;Without&#160;&#160;an<br/>initialize_copy&#160;method,&#160;if&#160;an&#160;object&#160;were&#160;copied&#160;using&#160;clone&#160;or&#160;dup,&#160;the&#160;copied&#160;object<br/>would&#160;refer&#160;to&#160;the&#160;same&#160;array&#160;of&#160;state&#160;that&#160;the&#160;original&#160;object&#160;did.&#160;Mutations&#160;performed<br/>on the copy would affect the state of the original. As this is not the behavior we want,<br/>we must define&#160;initialize_copy&#160;to create a copy of the array as well.<br/>Some&#160;classes,&#160;such&#160;as&#160;those&#160;that&#160;define&#160;enumerated&#160;types,&#160;may&#160;want&#160;to&#160;strictly&#160;limit&#160;the<br/>number&#160;of&#160;instances&#160;that&#160;exist.&#160;Classes&#160;like&#160;these&#160;need&#160;to&#160;make&#160;their&#160;new&#160;method&#160;private<br/>and&#160;&#160;also&#160;&#160;probably&#160;&#160;want&#160;&#160;to&#160;&#160;prevent&#160;&#160;copies&#160;&#160;from&#160;&#160;being&#160;&#160;made.&#160;&#160;The&#160;&#160;following&#160;&#160;code<br/>demonstrates one way to do that:<br/>
class Season<br/>&#160; NAMES = %w{ Spring Summer Autumn Winter } &#160;# Array of season names<br/>&#160; INSTANCES = [] &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Array of Season objects<br/>
&#160; def initialize(n) &#160;# The state of a season is just its&#160;<br/>&#160; &#160; @n = n &#160; &#160; &#160; &#160; &#160; # index in the NAMES and INSTANCES arrays<br/>&#160; end<br/>
&#160; def to_s &#160; &#160; &#160; &#160; &#160; # Return the name of a season&#160;<br/>&#160; &#160; NAMES[@n]<br/>&#160; end<br/>
&#160; # This code creates instances of this class to represent the seasons&#160;<br/>&#160; # and defines constants to refer to those instances.<br/>&#160; # Note that we must do this after initialize is defined.<br/>&#160; NAMES.each_with_index do |name,index|<br/>&#160; &#160; instance = new(index) &#160; &#160; &#160; &#160; # Create a new instance<br/>&#160; &#160; INSTANCES[index] = instance &#160; # Save it in an array of instances<br/>&#160; &#160; const_set name, instance &#160; &#160; &#160;# Define a constant to refer to it<br/>&#160; end<br/>
&#160; # Now that we have created all the instances we'll ever need, we must<br/>&#160; # prevent any other instances from being created<br/>&#160; private_class_method :new,:allocate &#160;# Make the factory methods private<br/>&#160; private :dup, :clone &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Make copying methods private<br/>end<br/>
<b>244&#160;|&#160;Chapter 7:</b> <b>Classes and Modules</b><br/>
<hr/>
<a name=259></a>This&#160;code&#160;involves&#160;some&#160;metaprogramming&#160;techniques&#160;that&#160;will&#160;make&#160;more&#160;sense&#160;after<br/><a href="Rubys.html#279">you have read Chapter 8</a>. The main point of the code is the line at the end that makes<br/>the&#160;dup&#160;and&#160;clone&#160;methods private.<br/>Another&#160;technique&#160;to&#160;prevent&#160;copying&#160;of&#160;objects&#160;is&#160;to&#160;use&#160;undef&#160;to&#160;simply&#160;remove&#160;the<br/>clone&#160;and&#160;dup&#160;methods.&#160;Yet&#160;another&#160;approach&#160;is&#160;to&#160;redefine&#160;the&#160;clone&#160;and&#160;dup&#160;methods<br/>so&#160;that&#160;they&#160;raise&#160;an&#160;exception&#160;with&#160;an&#160;error&#160;message&#160;that&#160;specifically&#160;says&#160;that&#160;copies<br/>are&#160;not&#160;permitted.&#160;Such&#160;an&#160;error&#160;message&#160;might&#160;be&#160;helpful&#160;to&#160;programmers&#160;who&#160;are<br/>using your class.<br/>
<b>7.4.4 &#160;marshal_dump and marshal_load<br/></b>A&#160;third&#160;way&#160;that&#160;objects&#160;are&#160;created&#160;is&#160;when&#160;Marshal.load&#160;is called to re-create objects<br/>previously&#160;marshaled&#160;(or&#160;“serialized”)&#160;with&#160;Marshal.dump.&#160;Marshal.dump&#160;saves&#160;the&#160;class<br/>of&#160;an&#160;object&#160;and&#160;recursively&#160;marshals&#160;the&#160;value&#160;of&#160;each&#160;of&#160;its&#160;instance&#160;variables.&#160;This<br/>works well—most objects can be saved and restored using these two methods.<br/>Some&#160;classes&#160;need&#160;to&#160;alter&#160;the&#160;way&#160;marshaling&#160;(and&#160;unmarshaling)&#160;is&#160;done.&#160;One&#160;reason<br/>is&#160;to&#160;provide&#160;a&#160;more&#160;compact&#160;representation&#160;of&#160;an&#160;object’s&#160;state.&#160;Another&#160;reason&#160;is&#160;to<br/>avoid&#160;saving&#160;volatile&#160;data,&#160;such&#160;as&#160;the&#160;contents&#160;of&#160;a&#160;cache&#160;that&#160;would&#160;just&#160;need&#160;to&#160;be<br/>cleared&#160;when&#160;the&#160;object&#160;was&#160;unmarshaled.&#160;You&#160;can&#160;customize&#160;the&#160;way&#160;an&#160;object&#160;is<br/>marshaled&#160;by&#160;defining&#160;a&#160;marshal_dump&#160;instance&#160;method&#160;in&#160;the&#160;class;&#160;it&#160;should&#160;return&#160;a<br/>different&#160;object&#160;(such&#160;as&#160;a&#160;string&#160;or&#160;an&#160;array&#160;of&#160;selected&#160;instance&#160;variable&#160;values)&#160;to&#160;be<br/>marshaled in place of the receiver object.<br/>If&#160;&#160;you&#160;&#160;define&#160;&#160;a&#160;&#160;custom&#160;&#160;marshal_dump&#160;&#160;method,&#160;&#160;you&#160;&#160;must&#160;&#160;define&#160;&#160;a&#160;&#160;matching<br/>marshal_load&#160;method,&#160;of&#160;course.&#160;marshal_load&#160;will&#160;be&#160;invoked&#160;on&#160;a&#160;newly&#160;allocated<br/>(with&#160;allocate)&#160;but&#160;uninitialized&#160;instance&#160;of&#160;the&#160;class.&#160;It&#160;will&#160;be&#160;passed&#160;a&#160;reconstituted<br/>copy&#160;&#160;of&#160;&#160;the&#160;&#160;object&#160;&#160;returned&#160;&#160;by&#160;&#160;marshal_dump,&#160;&#160;and&#160;&#160;it&#160;&#160;must&#160;&#160;initialize&#160;&#160;the&#160;&#160;state&#160;&#160;of&#160;&#160;the<br/>receiver object based on the state of the object it is passed.<br/>As&#160;an&#160;example,&#160;let’s&#160;return&#160;to&#160;the&#160;multidimensional&#160;Point&#160;class&#160;we&#160;started&#160;earlier.&#160;If&#160;we<br/>add&#160;the&#160;constraint&#160;that&#160;all&#160;coordinates&#160;are&#160;integers,&#160;then&#160;we&#160;can&#160;shave&#160;a&#160;few&#160;bytes&#160;off<br/>the&#160;size&#160;of&#160;the&#160;marshaled&#160;object&#160;by&#160;packing&#160;the&#160;array&#160;of&#160;integer&#160;coordinates&#160;into&#160;a&#160;string<br/>(you may want to use&#160;<i>ri</i>&#160;to read about&#160;Array.pack&#160;to help you understand this code):<br/>
class Point &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# A point in n-space<br/>&#160; def initialize(*coords) &#160; &#160;# Accept an arbitrary # of coordinates<br/>&#160; &#160; @coords = coords &#160; &#160; &#160; &#160; # Store the coordinates in an array<br/>&#160; end<br/>
&#160; def marshal_dump &#160; &#160; &#160; &#160; &#160; # Pack coords into a string and marshal that<br/>&#160; &#160; @coords.pack(&#34;w*&#34;)<br/>&#160; end<br/>
&#160; def marshal_load(s) &#160; &#160; &#160; &#160;# Unpack coords from unmarshaled string<br/>&#160; &#160; @coords = s.unpack(&#34;w*&#34;) # and use them to initialize the object<br/>&#160; end<br/>end<br/>
<b>7.4 &#160;Object Creation and Initialization&#160;|&#160;245</b><br/>
<hr/>
<a name=260></a>If&#160;you&#160;are&#160;writing&#160;a&#160;class—such&#160;as&#160;the&#160;Season&#160;class&#160;shown&#160;previously—for&#160;which&#160;you<br/>have&#160;disabled&#160;the&#160;clone&#160;and&#160;dup&#160;methods,&#160;you&#160;will&#160;also&#160;need&#160;to&#160;implement&#160;custom<br/>marshaling&#160;methods&#160;because&#160;dumping&#160;and&#160;loading&#160;an&#160;object&#160;is&#160;an&#160;easy&#160;way&#160;to&#160;create<br/>a&#160;&#160;copy&#160;&#160;of&#160;&#160;it.&#160;&#160;You&#160;&#160;can&#160;&#160;prevent&#160;&#160;marshaling&#160;&#160;completely&#160;&#160;by&#160;&#160;defining&#160;&#160;marshal_dump&#160;&#160;and<br/>marshal_load&#160;methods&#160;that&#160;raise&#160;an&#160;exception,&#160;but&#160;that&#160;is&#160;rather&#160;heavy-handed.&#160;A&#160;more<br/>elegant&#160;&#160;solution&#160;&#160;is&#160;&#160;to&#160;&#160;customize&#160;&#160;the&#160;&#160;unmarshaling&#160;&#160;so&#160;&#160;that&#160;&#160;Marshal.load&#160;&#160;returns&#160;&#160;an<br/>existing object rather than creating a copy.<br/>To&#160;accomplish&#160;this,&#160;we&#160;must&#160;define&#160;a&#160;different&#160;pair&#160;of&#160;custom&#160;marshaling&#160;methods<br/>because&#160;the&#160;return&#160;value&#160;of&#160;marshal_load&#160;is&#160;ignored.&#160;_dump&#160;is&#160;an&#160;instance&#160;method&#160;that<br/>must&#160;return&#160;the&#160;state&#160;of&#160;the&#160;object&#160;as&#160;a&#160;string.&#160;The&#160;matching&#160;_load&#160;method&#160;is&#160;a&#160;class<br/>method&#160;that&#160;accepts&#160;the&#160;string&#160;returned&#160;by&#160;_dump&#160;and&#160;returns&#160;an&#160;object.&#160;_load&#160;is&#160;allowed<br/>to create a new object or return a reference to an existing one.<br/>To&#160;allow&#160;marshaling,&#160;but&#160;prevent&#160;copying,&#160;of&#160;Season&#160;objects,&#160;we&#160;add&#160;these&#160;methods&#160;to<br/>the class:<br/>
class Season<br/>&#160; # We want to allow Season objects to be marshaled, but we don't<br/>&#160; # want new instances to be created when they are unmarshaled.<br/>&#160; def _dump(limit) &#160; &#160; &#160; &#160; # Custom marshaling method<br/>&#160; &#160; @n.to_s &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Return index as a string<br/>&#160; end<br/>
&#160; def self._load(s) &#160; &#160; &#160; &#160;# Custom unmarshaling method<br/>&#160; &#160; INSTANCES[Integer(s)] &#160;# Return an existing instance<br/>&#160; end<br/>end<br/>
<b>7.4.5 &#160;The Singleton Pattern<br/></b>A&#160;<i>singleton</i>&#160;is&#160;a&#160;class&#160;that&#160;has&#160;only&#160;a&#160;single&#160;instance.&#160;Singletons&#160;can&#160;be&#160;used&#160;to&#160;store<br/>global&#160;&#160;program&#160;&#160;state&#160;&#160;within&#160;&#160;an&#160;&#160;object-oriented&#160;&#160;framework&#160;&#160;and&#160;&#160;can&#160;&#160;be&#160;&#160;useful<br/>alternatives to class methods and class variables.<br/>
<b>Singleton Terminology</b><br/>
This&#160;section&#160;discusses&#160;the&#160;“Singleton&#160;Pattern,”&#160;a&#160;well-known&#160;design&#160;pattern&#160;in&#160;object-<br/>oriented&#160;&#160;programming.&#160;&#160;In&#160;&#160;Ruby,&#160;&#160;we&#160;&#160;have&#160;&#160;to&#160;&#160;be&#160;&#160;careful&#160;&#160;with&#160;&#160;the&#160;&#160;term&#160;&#160;“singleton”<br/>because&#160;it&#160;is&#160;overloaded.&#160;A&#160;method&#160;added&#160;to&#160;a&#160;single&#160;object&#160;rather&#160;than&#160;to&#160;a&#160;class&#160;of<br/>objects is known as a&#160;<i>singleton method</i><a href="Rubys.html#193">&#160;(see&#160;§6.1.4). The implicit class object to which<br/></a>such&#160;singleton&#160;methods&#160;are&#160;added&#160;is&#160;sometimes&#160;called&#160;a&#160;<i>singleton&#160;class</i>&#160;(though&#160;this<br/>book uses the term&#160;<i>eigenclass</i><a href="Rubys.html#271">&#160;instead; see §7.7).</a><br/>
Properly&#160;implementing&#160;a&#160;singleton&#160;requires&#160;a&#160;number&#160;of&#160;the&#160;tricks&#160;shown&#160;earlier.&#160;The<br/>new&#160;and&#160;allocate&#160;methods&#160;must&#160;be&#160;made&#160;private,&#160;dup&#160;and&#160;clone&#160;must&#160;be&#160;prevented&#160;from<br/>making&#160;copies,&#160;and&#160;so&#160;on.&#160;Fortunately,&#160;the&#160;Singleton&#160;module&#160;in&#160;the&#160;standard&#160;library<br/>does&#160;this&#160;work&#160;for&#160;us;&#160;just&#160;require 'singleton'&#160;and&#160;then&#160;include&#160;Singleton&#160;into&#160;your<br/>
<b>246&#160;|&#160;Chapter 7:</b> <b>Classes and Modules</b><br/>
<hr/>
<a name=261></a>class.&#160;&#160;This&#160;&#160;defines&#160;&#160;a&#160;&#160;class&#160;&#160;method&#160;&#160;named&#160;&#160;instance,&#160;&#160;which&#160;&#160;takes&#160;&#160;no&#160;&#160;arguments&#160;&#160;and<br/>returns the single instance of the class. Define an&#160;initialize&#160;method&#160;to perform initi-<br/>alization&#160;of&#160;the&#160;single&#160;instance&#160;of&#160;the&#160;class.&#160;Note,&#160;however,&#160;that&#160;no&#160;arguments&#160;will&#160;be<br/>passed to this method.<br/>As&#160;an&#160;example,&#160;let’s&#160;return&#160;to&#160;the&#160;Point&#160;class&#160;with&#160;which&#160;we&#160;started&#160;this&#160;chapter&#160;and<br/>revisit&#160;the&#160;problem&#160;of&#160;collecting&#160;point&#160;creation&#160;statistics.&#160;Instead&#160;of&#160;storing&#160;those&#160;sta-<br/>tistics&#160;&#160;in&#160;&#160;class&#160;&#160;variables&#160;&#160;of&#160;&#160;the&#160;&#160;Point&#160;&#160;class&#160;&#160;itself,&#160;&#160;we’ll&#160;&#160;use&#160;&#160;a&#160;&#160;singleton&#160;&#160;instance&#160;&#160;of&#160;&#160;a<br/>PointStats&#160;class:<br/>
require 'singleton' &#160; &#160; &#160; &#160; &#160; # Singleton module is not built-in<br/>
class PointStats &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Define a class<br/>&#160; include Singleton &#160; &#160; &#160; &#160; &#160; # Make it a singleton<br/>
&#160; def initialize &#160; &#160; &#160; &#160; &#160; &#160; &#160;# A normal initialization method<br/>&#160; &#160; @n, @totalX, @totalY = 0, 0.0, 0.0<br/>&#160; end<br/>
&#160; def record(point) &#160; &#160; &#160; &#160; &#160; # Record a new point<br/>&#160; &#160; @n += 1<br/>&#160; &#160; @totalX += point.x<br/>&#160; &#160; @totalY += point.y<br/>&#160; end<br/>
&#160; def report &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Report point statistics<br/>&#160; &#160; puts &#34;Number of points created: #@n&#34;<br/>&#160; &#160; puts &#34;Average X coordinate: #{@totalX/@n}&#34;<br/>&#160; &#160; puts &#34;Average Y coordinate: #{@totalY/@n}&#34;<br/>&#160; end<br/>end<br/>
With&#160;a&#160;class&#160;like&#160;this&#160;in&#160;place,&#160;we&#160;might&#160;write&#160;the&#160;initialize&#160;method&#160;for&#160;our&#160;Point&#160;class<br/>like this:<br/>
def initialize(x,y)<br/>&#160; @x,@y = x,y<br/>&#160; PointStats.instance.record(self)<br/>end<br/>
The&#160;Singleton&#160;module&#160;automatically&#160;creates&#160;the&#160;instance&#160;class&#160;method&#160;for&#160;us,&#160;and&#160;we<br/>invoke&#160;the&#160;regular&#160;instance&#160;method&#160;record&#160;on&#160;that&#160;singleton&#160;instance.&#160;Similarly,&#160;when<br/>we want to query the point statistics, we write:<br/>
PointStats.instance.report<br/>
<b>7.5 &#160;Modules<br/></b>Like&#160;a&#160;class,&#160;a&#160;<i>module</i>&#160;is&#160;a&#160;named&#160;group&#160;of&#160;methods,&#160;constants,&#160;and&#160;class&#160;variables.<br/>Modules&#160;are&#160;defined&#160;much&#160;like&#160;classes&#160;are,&#160;but&#160;the&#160;module&#160;keyword&#160;is&#160;used&#160;in&#160;place&#160;of<br/>the&#160;class&#160;keyword.&#160;Unlike&#160;a&#160;class,&#160;however,&#160;a&#160;module&#160;cannot&#160;be&#160;instantiated,&#160;and&#160;it<br/>
<b>7.5 &#160;Modules&#160;|&#160;247</b><br/>
<hr/>
<a name=262></a>cannot&#160;&#160;be&#160;&#160;subclassed.&#160;&#160;Modules&#160;&#160;stand&#160;&#160;alone;&#160;&#160;there&#160;&#160;is&#160;&#160;no&#160;&#160;“module&#160;&#160;hierarchy”&#160;&#160;of<br/>inheritance.<br/>Modules&#160;are&#160;used&#160;as&#160;namespaces&#160;and&#160;as&#160;mixins.&#160;The&#160;subsections&#160;that&#160;follow&#160;explain<br/>these two uses.<br/>Just&#160;as&#160;a&#160;class&#160;object&#160;is&#160;an&#160;instance&#160;of&#160;the&#160;Class&#160;class,&#160;a&#160;module&#160;object&#160;is&#160;an&#160;instance&#160;of<br/>the&#160;Module&#160;class.&#160;Class&#160;is&#160;a&#160;subclass&#160;of&#160;Module.&#160;This&#160;means&#160;that&#160;all&#160;classes&#160;are&#160;modules,<br/>but&#160;not&#160;all&#160;modules&#160;are&#160;classes.&#160;Classes&#160;can&#160;be&#160;used&#160;as&#160;namespaces,&#160;just&#160;as&#160;modules<br/>can. Classes cannot, however, be used as mixins.<br/>
<b>7.5.1 &#160;Modules as Namespaces<br/></b>Modules&#160;are&#160;a&#160;good&#160;way&#160;to&#160;group&#160;related&#160;methods&#160;when&#160;object-oriented&#160;programming<br/>is&#160;not&#160;necessary.&#160;Suppose,&#160;for&#160;example,&#160;you&#160;were&#160;writing&#160;methods&#160;to&#160;encode&#160;and&#160;decode<br/>binary&#160;data&#160;to&#160;and&#160;from&#160;text&#160;using&#160;the&#160;Base64&#160;encoding.&#160;There&#160;is&#160;no&#160;need&#160;for&#160;special<br/>encoder&#160;and&#160;decoder&#160;objects,&#160;so&#160;there&#160;is&#160;no&#160;reason&#160;to&#160;define&#160;a&#160;class&#160;here.&#160;All&#160;we&#160;need<br/>are&#160;two&#160;methods:&#160;one&#160;to&#160;encode&#160;and&#160;one&#160;to&#160;decode.&#160;We&#160;could&#160;define&#160;just&#160;two&#160;global<br/>methods:<br/>
def base64_encode<br/>end<br/>
def base64_decode<br/>end<br/>
To&#160;prevent&#160;namespace&#160;collisions&#160;with&#160;other&#160;encoding&#160;and&#160;decoding&#160;methods,&#160;we’ve<br/>given&#160;our&#160;method&#160;names&#160;the&#160;base64&#160;prefix.&#160;This&#160;solution&#160;works,&#160;but&#160;most&#160;programmers<br/>prefer&#160;to&#160;avoid&#160;adding&#160;methods&#160;to&#160;the&#160;global&#160;namespace&#160;when&#160;possible.&#160;A&#160;better&#160;sol-<br/>ution, therefore, is to define the two methods within a&#160;Base64&#160;module:<br/>
module Base64<br/>&#160; def self.encode<br/>&#160; end<br/>
&#160; def self.decode<br/>&#160; end<br/>end<br/>
Note that we define our methods with&#160;a&#160;self.&#160;prefix, which makes them “class meth-<br/>ods”&#160;of&#160;the&#160;module.&#160;We&#160;could&#160;also&#160;explicitly&#160;reuse&#160;the&#160;module&#160;name&#160;and&#160;define&#160;the<br/>methods like this:<br/>
module Base64<br/>&#160; def Base64.encode<br/>&#160; end<br/>
&#160; def Base64.decode<br/>&#160; end<br/>end<br/>
<b>248&#160;|&#160;Chapter 7:</b> <b>Classes and Modules</b><br/>
<hr/>
<a name=263></a>Defining&#160;&#160;the&#160;&#160;methods&#160;&#160;this&#160;&#160;way&#160;&#160;is&#160;&#160;more&#160;&#160;repetitive,&#160;&#160;but&#160;&#160;it&#160;&#160;more&#160;&#160;closely&#160;&#160;mirrors&#160;&#160;the<br/>invocation syntax of these methods:<br/>
# This is how we invoke the methods of the Base64 module<br/>text = Base64.encode(data)<br/>data = Base64.decode(text)<br/>
Note&#160;&#160;that&#160;&#160;module&#160;&#160;names&#160;&#160;must&#160;&#160;begin&#160;&#160;with&#160;&#160;a&#160;&#160;capital&#160;&#160;letter,&#160;&#160;just&#160;&#160;as&#160;&#160;class&#160;&#160;names&#160;&#160;do.<br/>Defining&#160;a&#160;module&#160;creates&#160;a&#160;constant&#160;with&#160;the&#160;same&#160;name&#160;as&#160;the&#160;module.&#160;The&#160;value&#160;of<br/>this constant is the&#160;Module&#160;object that represents the module.<br/>Modules&#160;may&#160;also&#160;contain&#160;constants.&#160;Our&#160;Base64&#160;implementation&#160;would&#160;likely&#160;use&#160;a<br/>constant to hold a string of the 64 characters used as digits in Base64:<br/>
module Base64<br/>&#160; DIGITS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' \<br/>&#160; &#160; &#160; &#160; &#160; &#160;'abcdefghijklmnopqrstuvwxyz' \<br/>&#160; &#160; &#160; &#160; &#160; &#160;'0123456789+/'<br/>end<br/>
Outside the&#160;Base64&#160;module,&#160;this&#160;constant&#160;can&#160;be&#160;referred&#160;to&#160;as&#160;Base64::DIGITS. Inside<br/>the module, our&#160;encode&#160;and&#160;decode&#160;methods&#160;can&#160;refer&#160;to&#160;it&#160;by&#160;its&#160;simple&#160;name&#160;DIGITS.<br/>If&#160;the&#160;two&#160;methods&#160;had&#160;some&#160;need&#160;to&#160;share&#160;nonconstant&#160;data,&#160;they&#160;could&#160;use&#160;a&#160;class<br/>variable (with a&#160;@@&#160;prefix), just as they could if they were defined in a class.<br/>
<b>7.5.1.1 &#160;Nested namespaces<br/></b>Modules,&#160;including&#160;classes,&#160;may&#160;be&#160;nested.&#160;This&#160;creates&#160;nested&#160;namespaces&#160;but&#160;has&#160;no<br/>other&#160;effect:&#160;a&#160;class&#160;or&#160;module&#160;nested&#160;within&#160;another&#160;has&#160;no&#160;special&#160;access&#160;to&#160;the&#160;class<br/>or&#160;module&#160;it&#160;is&#160;nested&#160;within.&#160;To&#160;continue&#160;with&#160;our&#160;Base64&#160;example,&#160;let’s&#160;suppose&#160;that<br/>we&#160;wanted&#160;to&#160;define&#160;special&#160;classes&#160;for&#160;encoding&#160;and&#160;decoding.&#160;Because&#160;the&#160;Encoder<br/>and&#160;Decoder&#160;classes are still related to each other, we’ll nest them within a module:<br/>
&#160;<br/>
module Base64<br/>&#160; DIGITS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'<br/>
&#160; class Encoder<br/>&#160; &#160; def encode<br/>&#160; &#160; end<br/>&#160; end<br/>
&#160; class Decoder<br/>&#160; &#160; def decode<br/>&#160; &#160; end<br/>&#160; end<br/>
&#160; # A utility function for use by both classes<br/>&#160; def Base64.helper<br/>&#160; end<br/>end<br/>
By&#160;structuring&#160;our&#160;code&#160;this&#160;way,&#160;we’ve&#160;defined&#160;two&#160;new&#160;classes,&#160;Base64::Encoder&#160;and<br/>Base64::Decoder.&#160;Inside&#160;the&#160;Base64&#160;module,&#160;the&#160;two&#160;classes&#160;can&#160;refer&#160;to&#160;each&#160;other&#160;by<br/>
<b>7.5 &#160;Modules&#160;|&#160;249</b><br/>
<hr/>
<a name=264></a>their&#160;unqualified&#160;names,&#160;without&#160;the&#160;Base64&#160;prefix.&#160;And&#160;each&#160;of&#160;the&#160;classes&#160;can&#160;use&#160;the<br/>DIGITS&#160;constant without a prefix.<br/>
On&#160;the&#160;other&#160;hand,&#160;consider&#160;the&#160;Base64.helper&#160;utility&#160;function.&#160;The&#160;nested&#160;Encoder&#160;and<br/>Decoder&#160;classes&#160;have&#160;no&#160;special&#160;access&#160;to&#160;the&#160;methods&#160;of&#160;the&#160;containing&#160;module,&#160;and<br/>they must refer to this helper method by its fully qualified name:&#160;Base64.helper.<br/>Because&#160;classes&#160;are&#160;modules,&#160;they&#160;too&#160;can&#160;be&#160;nested.&#160;Nesting&#160;one&#160;class&#160;within&#160;another<br/>only&#160;affects&#160;the&#160;namespace&#160;of&#160;the&#160;inner&#160;class;&#160;it&#160;does&#160;not&#160;give&#160;that&#160;class&#160;any&#160;special<br/>access&#160;to&#160;the&#160;methods&#160;or&#160;variables&#160;of&#160;the&#160;outer&#160;class.&#160;If&#160;your&#160;implementation&#160;of&#160;a&#160;class<br/>requires&#160;a&#160;helper&#160;class,&#160;a&#160;proxy&#160;class,&#160;or&#160;some&#160;other&#160;class&#160;that&#160;is&#160;not&#160;part&#160;of&#160;a&#160;public<br/>API,&#160;you&#160;may&#160;want&#160;to&#160;consider&#160;nesting&#160;that&#160;internal&#160;class&#160;within&#160;the&#160;class&#160;that&#160;uses&#160;it.<br/>This&#160;keeps&#160;the&#160;namespace&#160;tidy&#160;but&#160;does&#160;not&#160;actually&#160;make&#160;the&#160;nested&#160;class&#160;private&#160;in<br/>any way.<br/>See&#160;<a href="Rubys.html#275">§7.9&#160;</a>for&#160;an&#160;explanation&#160;of&#160;how&#160;constant&#160;names&#160;are&#160;resolved&#160;when&#160;modules&#160;are<br/>nested.<br/>
<b>7.5.2 &#160;Modules As Mixins<br/></b>The&#160;second&#160;use&#160;of&#160;modules&#160;is&#160;more&#160;powerful&#160;than&#160;the&#160;first.&#160;If&#160;a&#160;module&#160;defines&#160;instance<br/>methods&#160;instead&#160;of&#160;the&#160;class&#160;methods,&#160;those&#160;instance&#160;methods&#160;can&#160;be&#160;mixed&#160;in&#160;to&#160;other<br/>classes.&#160;&#160;Enumerable&#160;&#160;and&#160;&#160;Comparable&#160;&#160;are&#160;&#160;well-known&#160;&#160;examples&#160;&#160;of&#160;&#160;mixin&#160;&#160;modules.<br/>Enumerable&#160;defines&#160;useful&#160;iterators&#160;that&#160;are&#160;implemented&#160;in&#160;terms&#160;of&#160;an&#160;each&#160;iterator.<br/>Enumerable&#160;doesn’t&#160;define&#160;the&#160;each&#160;method&#160;itself,&#160;but&#160;any&#160;class&#160;that&#160;defines&#160;it&#160;can&#160;mix<br/>in the&#160;Enumerable&#160;module&#160;to&#160;instantly&#160;add&#160;many&#160;useful&#160;iterators.&#160;Comparable&#160;is similar;<br/>it&#160;defines&#160;comparison&#160;operators&#160;in&#160;terms&#160;of&#160;the&#160;general-purpose&#160;comparator&#160;&lt;=&gt;.&#160;If&#160;your<br/>class&#160;defines&#160;&lt;=&gt;,&#160;you&#160;can&#160;mix&#160;in&#160;Comparable&#160;to&#160;get&#160;&lt;,&#160;&lt;=,&#160;==&#160;&gt;,&#160;&gt;=,&#160;and&#160;between?&#160;for&#160;free.<br/>To&#160;mix&#160;a&#160;module&#160;into&#160;a&#160;class,&#160;use&#160;include.&#160;include&#160;is&#160;usually&#160;used&#160;as&#160;if&#160;it&#160;were&#160;a&#160;language<br/>keyword:<br/>
class Point<br/>&#160; include Comparable<br/>end<br/>
In&#160;fact,&#160;it&#160;is&#160;a&#160;private&#160;instance&#160;method&#160;of&#160;Module,&#160;implicitly&#160;invoked&#160;on&#160;self—the class<br/>into which the module is being included. In method form, this code would be:<br/>
class Point<br/>&#160; include(Comparable)<br/>end<br/>
Because&#160;include&#160;is&#160;a&#160;private&#160;method,&#160;it&#160;must&#160;be&#160;invoked&#160;as&#160;a&#160;function,&#160;and&#160;we&#160;cannot<br/>write&#160;self.include(Comparable).&#160;The&#160;include&#160;method&#160;accepts&#160;any&#160;number&#160;of&#160;Module<br/>objects to mix in, so a class that defines&#160;each&#160;and&#160;&lt;=&gt;&#160;might include the line:<br/>
include Enumerable, Comparable<br/>
<b>250&#160;|&#160;Chapter 7:</b> <b>Classes and Modules</b><br/>
<hr/>
<a name=265></a>The&#160;&#160;inclusion&#160;&#160;of&#160;&#160;a&#160;&#160;module&#160;&#160;affects&#160;&#160;the&#160;&#160;type-checking&#160;&#160;method&#160;&#160;is_a?&#160;&#160;and&#160;&#160;the&#160;&#160;switch-<br/>equality&#160;operator&#160;===.&#160;For&#160;example,&#160;String&#160;mixes&#160;in&#160;the&#160;Comparable&#160;module&#160;and,&#160;in<br/>Ruby 1.8, also mixes in the&#160;Enumerable&#160;module:<br/>
&#34;text&#34;.is_a? Comparable &#160; &#160; &#160; &#160; # =&gt; true<br/>Enumerable === &#34;text&#34; &#160; &#160; &#160; &#160; &#160; # =&gt; true in Ruby 1.8, false in 1.9<br/>
Note&#160;that&#160;instance_of?&#160;only&#160;checks&#160;the&#160;class&#160;of&#160;its&#160;receiver,&#160;not&#160;superclasses&#160;or&#160;mod-<br/>ules, so the following is false:<br/>
&#34;text&#34;.instance_of? Comparable &#160;# =&gt; false<br/>
Although&#160;every&#160;class&#160;is&#160;a&#160;module,&#160;the&#160;include&#160;method&#160;does&#160;not&#160;allow&#160;a&#160;class&#160;to&#160;be<br/>included&#160;within&#160;another&#160;class.&#160;The&#160;arguments&#160;to&#160;include&#160;must&#160;be&#160;modules&#160;declared<br/>with&#160;module, not classes.<br/>It&#160;is&#160;legal,&#160;however,&#160;to&#160;include&#160;one&#160;module&#160;into&#160;another.&#160;Doing&#160;this&#160;simply&#160;makes&#160;the<br/>instance&#160;&#160;methods&#160;&#160;of&#160;&#160;the&#160;&#160;included&#160;&#160;modules&#160;&#160;into&#160;&#160;instance&#160;&#160;methods&#160;&#160;of&#160;&#160;the&#160;&#160;including<br/><a href="Rubys.html#131">module. As an example, consider this code from Chapter 5:</a><br/>
module Iterable &#160; &#160; &#160; # Classes that define next can include this module<br/>&#160; include Enumerable &#160; &#160; &#160; &#160; &#160;# Define iterators on top of each<br/>&#160; def each &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# And define each on top of next<br/>&#160; &#160; loop { yield self.next }<br/>&#160; end<br/>end<br/>
The normal way to mix in a module is with the&#160;Module.include&#160;method. Another way<br/>is&#160;with&#160;Object.extend.&#160;This&#160;method&#160;makes&#160;the&#160;instance&#160;methods&#160;of&#160;the&#160;specified&#160;mod-<br/>ule&#160;or&#160;modules&#160;into&#160;singleton&#160;methods&#160;of&#160;the&#160;receiver&#160;object.&#160;(And&#160;if&#160;the&#160;receiver&#160;object<br/>is&#160;a&#160;Class&#160;instance,&#160;then&#160;the&#160;methods&#160;of&#160;the&#160;receiver&#160;become&#160;class&#160;methods&#160;of&#160;that&#160;class.)<br/>Here is an example:<br/>
countdown = Object.new &#160; &#160; &#160; # A plain old object<br/>def countdown.each &#160; &#160; &#160; &#160; &#160; # The each iterator as a singleton method<br/>&#160; yield 3<br/>&#160; yield 2<br/>&#160; yield 1<br/>end<br/>countdown.extend(Enumerable) # Now the object has all Enumerable methods &#160;<br/>print countdown.sort &#160; &#160; &#160; &#160; # Prints &#34;[1, 2, 3]&#34;<br/>
<b>7.5.3 &#160;Includable Namespace Modules<br/></b>It&#160;is&#160;possible&#160;to&#160;define&#160;modules&#160;that&#160;define&#160;a&#160;namespace&#160;but&#160;still&#160;allow&#160;their&#160;methods<br/>to be mixed in. The&#160;Math&#160;module works like this:<br/>
Math.sin(0) &#160; &#160;# =&gt; 0.0: Math is a namespace&#160;<br/>include Math &#160; # The Math namespace can be included<br/>sin(0) &#160; &#160; &#160; &#160; # =&gt; 0.0: Now we have easy access to the functions<br/>
The&#160;&#160;Kernel&#160;&#160;module&#160;&#160;also&#160;&#160;works&#160;&#160;like&#160;&#160;this:&#160;&#160;we&#160;&#160;can&#160;&#160;invoke&#160;&#160;its&#160;&#160;methods&#160;&#160;through&#160;&#160;the<br/>Kernel&#160;namespace, or as private methods of&#160;Object, into which it is included.<br/>
<b>7.5 &#160;Modules&#160;|&#160;251</b><br/>
<hr/>
<a name=266></a>If&#160;you&#160;want&#160;to&#160;create&#160;a&#160;module&#160;like&#160;Math&#160;or&#160;Kernel,&#160;define&#160;your&#160;methods&#160;as&#160;instance<br/>methods&#160;&#160;of&#160;&#160;the&#160;&#160;module.&#160;&#160;Then&#160;&#160;use&#160;&#160;module_function&#160;&#160;to&#160;&#160;convert&#160;&#160;those&#160;&#160;methods&#160;&#160;to<br/>“module&#160;functions.”&#160;module_function&#160;is&#160;a&#160;private&#160;instance&#160;method&#160;of&#160;Module,&#160;much&#160;like<br/>the&#160;public,&#160;protected, and&#160;private&#160;methods. It accepts any number of method names<br/>(as&#160;symbols&#160;or&#160;strings)&#160;as&#160;arguments.&#160;The&#160;primary&#160;effect&#160;of&#160;calling&#160;module_function&#160;is<br/>that&#160;it&#160;makes&#160;class&#160;method&#160;copies&#160;of&#160;the&#160;specified&#160;methods.&#160;A&#160;secondary&#160;effect&#160;is&#160;that<br/>it makes the instance methods private (we’ll have more to say about this shortly).<br/>Like&#160;the&#160;public,&#160;protected,&#160;and&#160;private&#160;methods,&#160;the&#160;module_function&#160;method&#160;can&#160;also<br/>be&#160;invoked&#160;with&#160;no&#160;arguments.&#160;When&#160;invoked&#160;in&#160;this&#160;way,&#160;any&#160;instance&#160;methods&#160;sub-<br/>sequently&#160;defined&#160;in&#160;the&#160;module&#160;will&#160;be&#160;module&#160;functions:&#160;they&#160;will&#160;become&#160;public<br/>class&#160;&#160;methods&#160;&#160;and&#160;&#160;private&#160;&#160;instance&#160;&#160;methods.&#160;&#160;Once&#160;&#160;you&#160;&#160;have&#160;&#160;invoked<br/>module_function&#160;&#160;with&#160;&#160;no&#160;&#160;arguments,&#160;&#160;it&#160;&#160;remains&#160;&#160;in&#160;&#160;effect&#160;&#160;for&#160;&#160;the&#160;&#160;rest&#160;&#160;of&#160;&#160;the&#160;&#160;module<br/>definition—so&#160;if&#160;you&#160;want&#160;to&#160;define&#160;methods&#160;that&#160;are&#160;not&#160;module&#160;functions,&#160;define<br/>those first.<br/>It&#160;may&#160;seem&#160;surprising&#160;at&#160;first&#160;that&#160;module_function&#160;makes&#160;the&#160;instance&#160;methods&#160;of&#160;a<br/>module&#160;private.&#160;The&#160;reason&#160;to&#160;do&#160;this&#160;is&#160;not&#160;really&#160;for&#160;access&#160;control,&#160;as&#160;obviously&#160;the<br/>methods&#160;&#160;are&#160;&#160;also&#160;&#160;available&#160;&#160;publicly&#160;&#160;through&#160;&#160;the&#160;&#160;module’s&#160;&#160;namespace.&#160;&#160;Instead,&#160;&#160;the<br/>methods&#160;&#160;are&#160;&#160;made&#160;&#160;private&#160;&#160;to&#160;&#160;restrict&#160;&#160;them&#160;&#160;to&#160;&#160;function-style&#160;&#160;invocation&#160;&#160;without&#160;&#160;an<br/>explicit&#160;receiver.&#160;(The&#160;reason&#160;that&#160;these&#160;are&#160;called&#160;module&#160;<i>functions</i>&#160;instead&#160;of&#160;module<br/>methods&#160;is&#160;that&#160;they&#160;must&#160;be&#160;invoked&#160;in&#160;functional&#160;style.)&#160;Forcing&#160;included&#160;module<br/>functions&#160;to&#160;be&#160;invoked&#160;without&#160;a&#160;receiver&#160;makes&#160;it&#160;less&#160;likely&#160;that&#160;they’ll&#160;be&#160;mistaken<br/>for&#160;true&#160;instance&#160;methods.&#160;Suppose&#160;we’re&#160;defining&#160;a&#160;class&#160;whose&#160;methods&#160;perform&#160;a<br/>lot&#160;of&#160;trigonometry.&#160;For&#160;our&#160;own&#160;convenience,&#160;we&#160;include&#160;the&#160;Math&#160;module.&#160;Then&#160;we<br/>can&#160;invoke&#160;the&#160;sin&#160;method&#160;as&#160;a&#160;function&#160;instead&#160;of&#160;calling&#160;Math.sin.&#160;The&#160;sin&#160;method<br/>is implicitly invoked on&#160;self, but we don’t actually expect it to do anything to&#160;self.<br/>When&#160;defining&#160;a&#160;module&#160;function,&#160;you&#160;should&#160;avoid&#160;using&#160;self,&#160;because&#160;the&#160;value&#160;of<br/>self&#160;will&#160;depend&#160;on&#160;how&#160;it&#160;is&#160;invoked.&#160;It&#160;is&#160;certainly&#160;possible&#160;to&#160;define&#160;a&#160;module&#160;function<br/>that&#160;behaves&#160;differently&#160;depending&#160;on&#160;how&#160;it&#160;is&#160;invoked.&#160;But&#160;if&#160;you&#160;are&#160;going&#160;to&#160;do&#160;that,<br/>then&#160;it&#160;makes&#160;more&#160;sense&#160;to&#160;simply&#160;define&#160;one&#160;class&#160;method&#160;and&#160;one&#160;instance&#160;method.<br/>
<b>7.6 &#160;Loading and Requiring Modules<br/></b>Ruby&#160;programs&#160;may&#160;be&#160;broken&#160;up&#160;into&#160;multiple&#160;files,&#160;and&#160;the&#160;most&#160;natural&#160;way&#160;to<br/>partition&#160;a&#160;program&#160;is&#160;to&#160;place&#160;each&#160;nontrivial&#160;class&#160;or&#160;module&#160;into&#160;a&#160;separate&#160;file.&#160;These<br/>separate&#160;files&#160;can&#160;then&#160;be&#160;reassembled&#160;into&#160;a&#160;single&#160;program&#160;(and,&#160;if&#160;well-designed,&#160;can<br/>be&#160;reused&#160;by&#160;other&#160;programs)&#160;using&#160;require&#160;or&#160;load.&#160;These&#160;are&#160;global&#160;functions&#160;defined<br/>in&#160;Kernel,&#160;but&#160;are&#160;used&#160;like&#160;language&#160;keywords.&#160;The&#160;same&#160;require&#160;method&#160;is&#160;also&#160;used<br/>for loading files from the standard library.<br/>
load&#160;and&#160;require&#160;serve&#160;similar&#160;purposes,&#160;though&#160;require&#160;is&#160;much&#160;more&#160;commonly&#160;used<br/>than&#160;load.&#160;Both&#160;functions&#160;can&#160;load&#160;and&#160;execute&#160;a&#160;specified&#160;file&#160;of&#160;Ruby&#160;source&#160;code.&#160;If<br/>the&#160;file&#160;to&#160;load&#160;is&#160;specified&#160;with&#160;an&#160;absolute&#160;path,&#160;or&#160;is&#160;relative&#160;to&#160;~&#160;(the&#160;user’s&#160;home<br/>
<b>252&#160;|&#160;Chapter 7:</b> <b>Classes and Modules</b><br/>
<hr/>
<a name=267></a>directory),&#160;then&#160;that&#160;specific&#160;file&#160;is&#160;loaded.&#160;Usually,&#160;however,&#160;the&#160;file&#160;is&#160;specified&#160;as&#160;a<br/>relative&#160;path,&#160;and&#160;load&#160;and&#160;require&#160;search&#160;for&#160;it&#160;relative&#160;to&#160;the&#160;directories&#160;of&#160;Ruby’s<br/>load path (details on the load path appear below).<br/>Ruby&#160;1.9&#160;also&#160;defines&#160;a&#160;require_relative&#160;&#160;method.&#160;It&#160;works&#160;like&#160;require,&#160;except&#160;that&#160;it<br/>ignores&#160;the&#160;load&#160;path&#160;and&#160;searches&#160;for&#160;the&#160;named&#160;file&#160;relative&#160;to&#160;the&#160;directory&#160;from<br/>which the invoking code was loaded.<br/>Despite&#160;&#160;their&#160;&#160;overall&#160;&#160;similarities,&#160;&#160;there&#160;&#160;are&#160;&#160;important&#160;&#160;differences&#160;&#160;between&#160;&#160;load&#160;&#160;and<br/>require:<br/>
•&#160;In&#160;&#160;addition&#160;&#160;to&#160;&#160;loading&#160;&#160;source&#160;&#160;code,&#160;&#160;require&#160;&#160;can&#160;&#160;also&#160;&#160;load&#160;&#160;binary&#160;&#160;extensions&#160;&#160;to<br/>
Ruby.&#160;Binary&#160;extensions&#160;are,&#160;of&#160;course,&#160;implementation-dependent,&#160;but&#160;in&#160;C-based<br/>implementations,&#160;they&#160;typically&#160;take&#160;the&#160;form&#160;of&#160;shared&#160;library&#160;files&#160;with&#160;exten-<br/>sions like&#160;<i>.so</i>&#160;or&#160;<i>.dll</i>.<br/>
•&#160;load&#160;expects&#160;a&#160;complete&#160;filename&#160;including&#160;an&#160;extension.&#160;require&#160;is&#160;usually&#160;passed<br/>
a&#160;library&#160;name,&#160;with&#160;no&#160;extension,&#160;rather&#160;than&#160;a&#160;filename.&#160;In&#160;that&#160;case,&#160;it&#160;searches<br/>for&#160;a&#160;file&#160;that&#160;has&#160;the&#160;library&#160;name&#160;as&#160;its&#160;base&#160;name&#160;and&#160;an&#160;appropriate&#160;source&#160;or<br/>native&#160;library&#160;extension.&#160;If&#160;a&#160;directory&#160;contains&#160;both&#160;an&#160;<i>.rb</i>&#160;source&#160;file&#160;and&#160;a&#160;binary<br/>extension file,&#160;require&#160;will load the source file instead of the binary file.<br/>
•&#160;load&#160;can load the same file multiple times.&#160;require&#160;tries to prevent multiple loads<br/>
of&#160;the&#160;same&#160;file.&#160;(require&#160;can&#160;be&#160;fooled,&#160;however,&#160;if&#160;you&#160;use&#160;two&#160;different,&#160;but<br/>equivalent,&#160;paths&#160;to&#160;the&#160;same&#160;library&#160;file.&#160;In&#160;Ruby&#160;1.9,&#160;require&#160;expands&#160;relative<br/>paths&#160;to&#160;absolute&#160;paths,&#160;which&#160;makes&#160;it&#160;somewhat&#160;harder&#160;to&#160;fool.)&#160;require&#160;keeps<br/>track&#160;of&#160;the&#160;files&#160;that&#160;have&#160;been&#160;loaded&#160;by&#160;appending&#160;them&#160;to&#160;the&#160;global&#160;array<br/>$&#34;&#160;(also known as&#160;$LOADED_FEATURES).&#160;load&#160;does not do this.<br/>
•&#160;load&#160;loads&#160;the&#160;specified&#160;file&#160;at&#160;the&#160;current&#160;$SAFE&#160;level.&#160;require&#160;loads&#160;the&#160;specified<br/>
library&#160;with&#160;$SAFE&#160;set&#160;to&#160;0,&#160;even&#160;if&#160;the&#160;code&#160;that&#160;called&#160;require&#160;has&#160;a&#160;higher&#160;value<br/>for&#160;that&#160;variable.&#160;See&#160;<a href="Rubys.html#423">§10.5&#160;</a>for&#160;more&#160;on&#160;$SAFE&#160;and&#160;Ruby’s&#160;security&#160;system.&#160;(Note<br/>that&#160;if&#160;$SAFE&#160;is&#160;set&#160;to&#160;a&#160;value&#160;higher&#160;than&#160;0,&#160;require&#160;will&#160;refuse&#160;to&#160;load&#160;any&#160;file&#160;with<br/>a&#160;tainted&#160;filename&#160;or&#160;from&#160;a&#160;world-writable&#160;directory.&#160;In&#160;theory,&#160;therefore,&#160;it&#160;should<br/>be safe for&#160;require&#160;to load files with a reduced&#160;$SAFE&#160;level.)<br/>
The&#160;&#160;subsections&#160;&#160;that&#160;&#160;follow&#160;&#160;provide&#160;&#160;further&#160;&#160;details&#160;&#160;about&#160;&#160;the&#160;&#160;behavior&#160;&#160;of&#160;&#160;load&#160;&#160;and<br/>require.<br/>
<b>7.6.1 &#160;The Load Path<br/></b>Ruby’s&#160;load&#160;path&#160;is&#160;an&#160;array&#160;that&#160;you&#160;can&#160;access&#160;using&#160;either&#160;of&#160;the&#160;global&#160;variables<br/>$LOAD_PATH&#160;or&#160;$:.&#160;(The&#160;mnemonic&#160;for&#160;this&#160;global&#160;is&#160;that&#160;colons&#160;are&#160;used&#160;as&#160;path&#160;separator<br/>characters&#160;on&#160;Unix-like&#160;operating&#160;systems.)&#160;Each&#160;element&#160;of&#160;the&#160;array&#160;is&#160;the&#160;name&#160;of&#160;a<br/>directory&#160;that&#160;Ruby&#160;will&#160;search&#160;for&#160;files&#160;to&#160;load.&#160;Directories&#160;at&#160;the&#160;start&#160;of&#160;the&#160;array&#160;are<br/>searched&#160;before&#160;directories&#160;at&#160;the&#160;end&#160;of&#160;the&#160;array.&#160;The&#160;elements&#160;of&#160;$LOAD_PATH&#160;must&#160;be<br/>strings&#160;&#160;in&#160;&#160;Ruby&#160;&#160;1.8,&#160;&#160;but&#160;&#160;in&#160;&#160;Ruby&#160;&#160;1.9,&#160;&#160;they&#160;&#160;may&#160;&#160;be&#160;&#160;strings&#160;&#160;or&#160;&#160;any&#160;&#160;object&#160;&#160;that&#160;&#160;has&#160;&#160;a<br/>to_path&#160;method that returns a string.<br/>
<b>7.6 &#160;Loading and Requiring Modules&#160;|&#160;253</b><br/>
<hr/>
<a name=268></a>The default value of&#160;$LOAD_PATH&#160;depends&#160;on&#160;your&#160;implementation&#160;of&#160;Ruby,&#160;on&#160;the&#160;op-<br/>erating&#160;system&#160;it&#160;is&#160;running&#160;on,&#160;and&#160;even&#160;on&#160;where&#160;in&#160;your&#160;filesystem&#160;you&#160;installed&#160;it.<br/>Here is a typical value for Ruby 1.8, obtained with&#160;ruby -e 'puts $:':<br/>
/usr/lib/site_ruby/1.8<br/>/usr/lib/site_ruby/1.8/i386-linux<br/>/usr/lib/site_ruby<br/>/usr/lib/ruby/1.8<br/>/usr/lib/ruby/1.8/i386-linux<br/>.<br/>
The&#160;&#160;<i>/usr/lib/ruby/1.8/</i>&#160;&#160;directory&#160;&#160;is&#160;&#160;where&#160;&#160;the&#160;&#160;Ruby&#160;&#160;standard&#160;&#160;library&#160;&#160;is&#160;&#160;installed.<br/>The&#160;<i>/usr/lib/ruby/1.8/i386-linux/</i>&#160;directory&#160;holds&#160;Linux&#160;binary&#160;extensions&#160;for&#160;the&#160;stand-<br/>ard&#160;library.&#160;The&#160;<i>site_ruby</i>&#160;directories&#160;in&#160;the&#160;path&#160;are&#160;for&#160;site-specific&#160;libraries&#160;that&#160;you<br/>have&#160;installed.&#160;Note&#160;that&#160;site-specific&#160;directories&#160;are&#160;searched&#160;first,&#160;which&#160;means&#160;that<br/>you&#160;can&#160;override&#160;the&#160;standard&#160;library&#160;with&#160;files&#160;installed&#160;here.&#160;The&#160;current&#160;working<br/>directory&#160;“.”&#160;is&#160;at&#160;the&#160;end&#160;of&#160;the&#160;search&#160;path.&#160;This&#160;is&#160;the&#160;directory&#160;from&#160;which&#160;a&#160;user<br/>invokes&#160;your&#160;Ruby&#160;program;&#160;it&#160;is&#160;not&#160;the&#160;same&#160;as&#160;the&#160;directory&#160;in&#160;which&#160;your&#160;Ruby<br/>program is installed.<br/>In Ruby 1.9, the default load path is more complicated. Here is a typical value:<br/>
/usr/local/lib/ruby/gems/1.9/gems/rake-0.7.3/lib<br/>/usr/local/lib/ruby/gems/1.9/gems/rake-0.7.3/bin<br/>/usr/local/lib/ruby/site_ruby/1.9<br/>/usr/local/lib/ruby/site_ruby/1.9/i686-linux<br/>/usr/local/lib/ruby/site_ruby<br/>/usr/local/lib/ruby/vendor_ruby/1.9<br/>/usr/local/lib/ruby/vendor_ruby/1.9/i686-linux<br/>/usr/local/lib/ruby/vendor_ruby<br/>/usr/local/lib/ruby/1.9<br/>/usr/local/lib/ruby/1.9/i686-linux<br/>.<br/>
One&#160;minor&#160;load&#160;path&#160;change&#160;in&#160;Ruby&#160;1.9&#160;is&#160;the&#160;inclusion&#160;of&#160;<i>vendor_ruby</i>&#160;directories<br/>that&#160;are&#160;searched&#160;after&#160;<i>site_ruby</i>&#160;and&#160;before&#160;the&#160;standard&#160;library.&#160;These&#160;are&#160;intended&#160;for<br/>customizations provided by operating system vendors.<br/>The&#160;more&#160;significant&#160;load&#160;path&#160;change&#160;in&#160;Ruby&#160;1.9&#160;is&#160;the&#160;inclusion&#160;of&#160;RubyGems&#160;in-<br/>stallation&#160;directories.&#160;In&#160;the&#160;path&#160;shown&#160;here,&#160;the&#160;first&#160;two&#160;directories&#160;searched&#160;are&#160;for<br/>the&#160;<i>rake</i>&#160;package&#160;installed&#160;with&#160;the&#160;<i>gem</i>&#160;command&#160;of&#160;the&#160;RubyGems&#160;package&#160;manage-<br/>ment&#160;system.&#160;There&#160;is&#160;only&#160;one&#160;gem&#160;installed&#160;in&#160;this&#160;example,&#160;but&#160;if&#160;you&#160;have&#160;many<br/>gems&#160;on&#160;your&#160;system,&#160;your&#160;default&#160;load&#160;path&#160;may&#160;become&#160;quite&#160;long.&#160;(When&#160;running<br/>programs&#160;that&#160;do&#160;not&#160;use&#160;gems,&#160;you&#160;may&#160;get&#160;a&#160;minor&#160;speed&#160;boost&#160;by&#160;invoking&#160;Ruby<br/>with the&#160;--disable-gems&#160;command-line option, which prevents these directories from<br/>being&#160;added&#160;to&#160;the&#160;load&#160;path.)&#160;If&#160;more&#160;than&#160;one&#160;version&#160;of&#160;a&#160;gem&#160;is&#160;installed,&#160;the&#160;version<br/>with&#160;&#160;the&#160;&#160;highest&#160;&#160;version&#160;&#160;number&#160;&#160;is&#160;&#160;included&#160;&#160;in&#160;&#160;the&#160;&#160;default&#160;&#160;load&#160;&#160;path.&#160;&#160;Use&#160;&#160;the<br/>Kernel.gem&#160;method to alter this default.<br/>
RubyGems&#160;is&#160;built&#160;into&#160;Ruby&#160;1.9:&#160;the&#160;<i>gem</i>&#160;command&#160;is&#160;distributed&#160;with&#160;Ruby&#160;and&#160;can<br/>be&#160;used&#160;to&#160;install&#160;new&#160;packages&#160;whose&#160;installation&#160;directories&#160;are&#160;automatically&#160;added<br/>
<b>254&#160;|&#160;Chapter 7:</b> <b>Classes and Modules</b><br/>
<hr/>
<a name=269></a>to&#160;the&#160;default&#160;load&#160;path.&#160;In&#160;Ruby&#160;1.8,&#160;RubyGems&#160;must&#160;be&#160;installed&#160;separately&#160;(though<br/>some distributions of Ruby 1.8 may automatically bundle it), and gem installation di-<br/>rectories&#160;are&#160;never&#160;added&#160;to&#160;the&#160;load&#160;path.&#160;Instead,&#160;Ruby&#160;1.8&#160;programs&#160;require&#160;the<br/>rubygems&#160;module.&#160;Doing&#160;this&#160;replaces&#160;the&#160;default&#160;require&#160;method&#160;with&#160;a&#160;new&#160;version<br/><a href="Rubys.html#28">that knows where to look for installed gems. See §1.2.5 for more on RubyGems.<br/></a>You&#160;can&#160;add&#160;new&#160;directories&#160;to&#160;the&#160;start&#160;of&#160;Ruby’s&#160;search&#160;path&#160;with&#160;the&#160;–I&#160;command-<br/>line&#160;&#160;option&#160;&#160;to&#160;&#160;the&#160;&#160;Ruby&#160;&#160;interpreter.&#160;&#160;Use&#160;&#160;multiple&#160;&#160;–I&#160;&#160;options&#160;&#160;to&#160;&#160;specify&#160;&#160;multiple<br/>directories,&#160;or&#160;use&#160;a&#160;single&#160;–I&#160;and&#160;separate&#160;multiple&#160;directories&#160;from&#160;each&#160;other&#160;with<br/>colons (or semicolons on Windows).<br/>Ruby&#160;programs&#160;can&#160;also&#160;modify&#160;their&#160;own&#160;load&#160;path&#160;by&#160;altering&#160;the&#160;contents&#160;of&#160;the<br/>$LOAD_PATH&#160;array. Here are some examples:<br/>
# Remove the current directory from the load path<br/>$:.pop if $:.last == '.' &#160;<br/>
# Add the installation directory for the current program to&#160;<br/># the beginning of the load path instead of using require_relative.<br/>$LOAD_PATH.unshift File.expand_path($PROGRAM_NAME)<br/>
# Add the value of an environment variable to the end of the path<br/>$LOAD_PATH &lt;&lt; ENV['MY_LIBRARY_DIRECTORY']<br/>
Finally,&#160;keep&#160;in&#160;mind&#160;that&#160;you&#160;can&#160;bypass&#160;the&#160;load&#160;path&#160;entirely&#160;by&#160;passing&#160;absolute<br/>filenames (that begin with&#160;<i>/</i>&#160;or&#160;<i>~</i>) to&#160;load&#160;or&#160;require.<br/>
<b>7.6.2 &#160;Executing Loaded Code<br/></b>loadandrequireexecute&#160;the&#160;code&#160;in&#160;the&#160;specified&#160;file&#160;immediately.&#160;Calling&#160;these&#160;meth-<br/>ods&#160;is&#160;not,&#160;however,&#160;equivalent&#160;to&#160;simply&#160;replacing&#160;the&#160;call&#160;to&#160;load&#160;or&#160;require&#160;with&#160;the<br/>code contained by the file.*<br/>Files&#160;loaded&#160;with&#160;load&#160;or&#160;require&#160;are&#160;executed&#160;in&#160;a&#160;new&#160;top-level&#160;scope&#160;that&#160;is&#160;different<br/>from&#160;the&#160;one&#160;in&#160;which&#160;load&#160;or&#160;require&#160;was&#160;invoked.&#160;The&#160;loaded&#160;file&#160;can&#160;see&#160;all&#160;global<br/>variables&#160;and&#160;constants&#160;that&#160;have&#160;been&#160;defined&#160;at&#160;the&#160;time&#160;it&#160;is&#160;loaded,&#160;but&#160;it&#160;does&#160;not<br/>have&#160;access&#160;to&#160;the&#160;local&#160;scope&#160;from&#160;which&#160;the&#160;load&#160;was&#160;initiated.&#160;The&#160;implications&#160;of<br/>this include the following:<br/>
•&#160;The&#160;local&#160;variables&#160;defined&#160;in&#160;the&#160;scope&#160;from&#160;which&#160;load&#160;or&#160;require&#160;is&#160;invoked&#160;are<br/>
not visible to the loaded file.<br/>
•&#160;Any&#160;&#160;local&#160;&#160;variables&#160;&#160;created&#160;&#160;by&#160;&#160;the&#160;&#160;loaded&#160;&#160;file&#160;&#160;are&#160;&#160;discarded&#160;&#160;once&#160;&#160;the&#160;&#160;load&#160;&#160;is<br/>
complete; they are never visible outside the file in which they are defined.<br/>
*&#160;To&#160;put&#160;this&#160;another&#160;way&#160;for&#160;C&#160;programmers:&#160;load&#160;and&#160;require&#160;are&#160;different&#160;from&#160;C’s&#160;#include&#160;directive.<br/>
Passing&#160;&#160;a&#160;&#160;file&#160;&#160;of&#160;&#160;loaded&#160;&#160;code&#160;&#160;to&#160;&#160;the&#160;&#160;global&#160;&#160;eval&#160;&#160;function&#160;&#160;is&#160;&#160;closer&#160;&#160;to&#160;&#160;including&#160;&#160;it&#160;&#160;directly&#160;&#160;in&#160;&#160;a&#160;&#160;file:<br/>eval(File.read(filename)). But even this is not the same, as&#160;eval&#160;does not set local variables.<br/>
<b>7.6 &#160;Loading and Requiring Modules&#160;|&#160;255</b><br/>
<hr/>
<a name=270></a>•&#160;At&#160;the&#160;start&#160;of&#160;the&#160;loaded&#160;file,&#160;the&#160;value&#160;of&#160;self&#160;is&#160;always&#160;the&#160;main&#160;object,&#160;just&#160;as&#160;it<br/>
is&#160;&#160;when&#160;&#160;the&#160;&#160;Ruby&#160;&#160;interpreter&#160;&#160;starts&#160;&#160;running.&#160;&#160;That&#160;&#160;is,&#160;&#160;invoking&#160;&#160;load&#160;&#160;or&#160;&#160;require<br/>within&#160;a&#160;method&#160;invocation&#160;does&#160;not&#160;propagate&#160;the&#160;receiver&#160;object&#160;to&#160;the&#160;loaded<br/>file.<br/>
•&#160;The&#160;current&#160;module&#160;nesting&#160;is&#160;ignored&#160;within&#160;the&#160;loaded&#160;file.&#160;You&#160;cannot,&#160;for&#160;ex-<br/>
ample,&#160;open&#160;a&#160;class&#160;and&#160;then&#160;load&#160;a&#160;file&#160;of&#160;method&#160;definitions.&#160;The&#160;file&#160;will&#160;be<br/>processed in a top-level scope, not inside any class or module.<br/>
<b>7.6.2.1 &#160;Wrapped loads<br/></b>The&#160;load&#160;method&#160;has&#160;an&#160;infrequently&#160;used&#160;feature&#160;that&#160;we&#160;did&#160;not&#160;describe&#160;earlier.&#160;If<br/>called&#160;with&#160;a&#160;second&#160;argument&#160;that&#160;is&#160;anything&#160;other&#160;than&#160;nil&#160;or&#160;false,&#160;then&#160;it&#160;“wraps”<br/>the&#160;specified&#160;file&#160;and&#160;loads&#160;it&#160;into&#160;an&#160;anonymous&#160;module.&#160;This&#160;means&#160;that&#160;the&#160;loaded<br/>file&#160;cannot&#160;affect&#160;the&#160;global&#160;namespace;&#160;any&#160;constants&#160;(including&#160;classes&#160;and&#160;modules)<br/>it&#160;defines&#160;are&#160;trapped&#160;within&#160;the&#160;anonymous&#160;module.&#160;You&#160;can&#160;use&#160;wrapped&#160;loads&#160;as&#160;a<br/>security&#160;precaution&#160;(or&#160;as&#160;a&#160;way&#160;to&#160;minimize&#160;bugs&#160;caused&#160;by&#160;namespace&#160;collisions).<br/>We’ll&#160;see&#160;<a href="Rubys.html#423">in&#160;§10.5&#160;</a>that&#160;when&#160;Ruby&#160;is&#160;running&#160;untrusted&#160;code&#160;in&#160;a&#160;“sandbox,”&#160;that&#160;code<br/>is not allowed to call&#160;require&#160;and can use&#160;load&#160;only for wrapped loads.<br/>When&#160;a&#160;file&#160;is&#160;loaded&#160;into&#160;an&#160;anonymous&#160;module,&#160;it&#160;can&#160;still&#160;set&#160;global&#160;variables,&#160;and<br/>the&#160;variables&#160;it&#160;sets&#160;will&#160;be&#160;visible&#160;to&#160;the&#160;code&#160;that&#160;loaded&#160;it.&#160;Suppose&#160;you&#160;write&#160;a&#160;file<br/><i>util.rb</i>&#160;that&#160;defines&#160;a&#160;Util&#160;module&#160;of&#160;useful&#160;utility&#160;methods.&#160;If&#160;you&#160;want&#160;those&#160;methods<br/>to&#160;be&#160;accessible&#160;even&#160;if&#160;your&#160;file&#160;is&#160;loaded&#160;wrapped,&#160;you&#160;might&#160;add&#160;the&#160;following&#160;line<br/>to the end of the file:<br/>
$Util = Util &#160; # Store a reference to this module in a global variable<br/>
Now,&#160;the&#160;code&#160;that&#160;loads&#160;<i>util.rb</i>&#160;into&#160;an&#160;anonymous&#160;namespace&#160;can&#160;access&#160;the&#160;utility<br/>functions through the global&#160;$Util&#160;instead of the constant&#160;Util.<br/>In&#160;Ruby&#160;1.8,&#160;it&#160;is&#160;even&#160;possible&#160;to&#160;pass&#160;the&#160;anonymous&#160;module&#160;itself&#160;back&#160;to&#160;the&#160;loading<br/>code:<br/>
if Module.nesting.size &gt; 0 &#160; &#160; &#160; # If we're loaded into a wrapper module<br/>&#160; $wrapper = Module.nesting[0] &#160; # Pass the module back to the loading code<br/>end<br/>
<a href="Rubys.html#281">See §8.1.1 for more on&#160;</a>Module.nesting.<br/>
<b>7.6.3 &#160;Autoloading Modules<br/></b>The&#160;autoload&#160;methods&#160;of&#160;Kernel&#160;and&#160;Module&#160;allow&#160;lazy&#160;loading&#160;of&#160;files&#160;on&#160;an&#160;as-needed<br/>basis.&#160;The&#160;global&#160;autoload&#160;function&#160;allows&#160;you&#160;to&#160;register&#160;the&#160;name&#160;of&#160;an&#160;undefined<br/>constant&#160;(typically&#160;a&#160;class&#160;or&#160;module&#160;name)&#160;and&#160;a&#160;name&#160;of&#160;the&#160;library&#160;that&#160;defines&#160;it.<br/>When&#160;that&#160;constant&#160;is&#160;first&#160;referenced,&#160;the&#160;named&#160;library&#160;is&#160;loaded&#160;using&#160;require. For<br/>example:<br/>
# Require 'socket' if and when the TCPSocket is first used<br/>autoload :TCPSocket, &#34;socket&#34;<br/>
<b>256&#160;|&#160;Chapter 7:</b> <b>Classes and Modules</b><br/>
<hr/>
<a name=271></a>The&#160;Module&#160;class&#160;defines&#160;its&#160;own&#160;version&#160;of&#160;autoload&#160;to&#160;work&#160;with&#160;constants&#160;nested<br/>within another module.<br/>Use&#160;autoload?&#160;or&#160;Module.autoload?&#160;to&#160;test&#160;whether&#160;a&#160;reference&#160;to&#160;a&#160;constant&#160;will&#160;cause<br/>a&#160;file&#160;to&#160;be&#160;loaded.&#160;This&#160;method&#160;expects&#160;a&#160;symbol&#160;argument.&#160;If&#160;a&#160;file&#160;will&#160;be&#160;loaded<br/>when&#160;the&#160;constant&#160;named&#160;by&#160;the&#160;symbol&#160;is&#160;referenced,&#160;then&#160;autoload?&#160;returns&#160;the&#160;name<br/>of&#160;the&#160;file.&#160;Otherwise&#160;(if&#160;no&#160;autoload&#160;was&#160;requested,&#160;or&#160;if&#160;the&#160;file&#160;has&#160;already&#160;been<br/>loaded),&#160;autoload?&#160;returns&#160;nil.<br/>
<b>7.7 &#160;Singleton Methods and the Eigenclass<br/></b>We&#160;learned&#160;<a href="Rubys.html#189">in&#160;Chapter&#160;6&#160;</a>that&#160;it&#160;is&#160;possible&#160;to&#160;define&#160;singleton&#160;methods—methods&#160;that<br/>are&#160;defined&#160;for&#160;only&#160;a&#160;single&#160;object&#160;rather&#160;than&#160;a&#160;class&#160;of&#160;objects.&#160;To&#160;define&#160;a&#160;singleton<br/>method&#160;sum&#160;on an object&#160;Point, we’d write:<br/>
def Point.sum<br/>&#160; # Method body goes here<br/>end<br/>
As&#160;noted&#160;earlier&#160;in&#160;this&#160;chapter,&#160;the&#160;class&#160;methods&#160;of&#160;a&#160;class&#160;are&#160;nothing&#160;more&#160;than<br/>singleton methods on the&#160;Class&#160;instance that represents that class.<br/>The&#160;singleton&#160;methods&#160;of&#160;an&#160;object&#160;are&#160;not&#160;defined&#160;by&#160;the&#160;class&#160;of&#160;that&#160;object.&#160;But&#160;they<br/>are&#160;&#160;methods&#160;&#160;and&#160;&#160;they&#160;&#160;must&#160;&#160;be&#160;&#160;associated&#160;&#160;with&#160;&#160;a&#160;&#160;class&#160;&#160;of&#160;&#160;some&#160;&#160;sort.&#160;&#160;The&#160;&#160;singleton<br/>methods&#160;of&#160;an&#160;object&#160;are&#160;instance&#160;methods&#160;of&#160;the&#160;anonymous&#160;<i>eigenclass</i>&#160;associated&#160;with<br/>that&#160;object.&#160;“Eigen”&#160;is&#160;a&#160;German&#160;word&#160;meaning&#160;(roughly)&#160;“self,”&#160;“own,”&#160;“particular<br/>to,”&#160;or&#160;“characteristic&#160;of.”&#160;The&#160;eigenclass&#160;is&#160;also&#160;called&#160;the&#160;<i>singleton class</i>&#160;or&#160;(less&#160;com-<br/>monly)&#160;the&#160;<i>metaclass</i>.&#160;The&#160;term&#160;“eigenclass”&#160;is&#160;not&#160;uniformly&#160;accepted&#160;within&#160;the&#160;Ruby<br/>community, but it is the term we’ll use in this book.<br/>Ruby&#160;defines&#160;a&#160;syntax&#160;for&#160;opening&#160;the&#160;eigenclass&#160;of&#160;an&#160;object&#160;and&#160;adding&#160;methods&#160;to<br/>it.&#160;This&#160;provides&#160;an&#160;alternative&#160;to&#160;defining&#160;singleton&#160;methods&#160;one&#160;by&#160;one;&#160;we&#160;can&#160;instead<br/>define&#160;any&#160;number&#160;of&#160;instance&#160;methods&#160;of&#160;the&#160;eigenclass.&#160;To&#160;open&#160;the&#160;eigenclass&#160;of&#160;the<br/>object&#160;o, use&#160;class &lt;&lt; o. For example, we can define class methods of&#160;Point&#160;like this:<br/>
class &lt;&lt; Point<br/>&#160; def class_method1 &#160; &#160; &#160;# This is an instance method of the eigenclass.<br/>&#160; end &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# It is also a class method of Point.<br/>
&#160; def class_method2<br/>&#160; end<br/>end<br/>
If&#160;you&#160;open&#160;the&#160;eigenclass&#160;of&#160;a&#160;class&#160;object&#160;within&#160;the&#160;definition&#160;of&#160;a&#160;class&#160;itself,&#160;then<br/>you&#160;can&#160;use&#160;self&#160;instead&#160;of&#160;repeating&#160;the&#160;name&#160;of&#160;the&#160;class.&#160;To&#160;repeat&#160;an&#160;example&#160;from<br/>earlier in this chapter:<br/>
class Point<br/>&#160; # instance methods go here<br/>
&#160; class &lt;&lt; self<br/>
<b>7.7 &#160;Singleton Methods and the Eigenclass&#160;|&#160;257</b><br/>
<hr/>
<a name=272></a>&#160; &#160; # class methods go here as instance methods of the eigenclass<br/>&#160; end<br/>end<br/>
Be&#160;careful&#160;with&#160;your&#160;syntax.&#160;Note&#160;that&#160;there&#160;is&#160;considerable&#160;difference&#160;between&#160;the<br/>following three lines:<br/>
class Point &#160; &#160; &#160; &#160; &#160; &#160;# Create or open the class Point<br/>class Point3D &lt; Point &#160;# Create a subclass of Point<br/>class &lt;&lt; Point &#160; &#160; &#160; &#160; # Open the eigenclass of the object Point<br/>
In&#160;general,&#160;it&#160;is&#160;clearer&#160;to&#160;define&#160;class&#160;methods&#160;as&#160;individual&#160;singleton&#160;methods&#160;without<br/>explicitly opening the eigenclass.<br/>When&#160;you&#160;open&#160;the&#160;eigenclass&#160;of&#160;an&#160;object,&#160;self&#160;refers&#160;to&#160;the&#160;eigenclass&#160;object.&#160;The<br/>idiom for obtaining the eigenclass of an object&#160;o&#160;is therefore:<br/>
eigenclass = class &lt;&lt; o; self; end<br/>
We&#160;can&#160;formalize&#160;this&#160;into&#160;a&#160;method&#160;of&#160;Object,&#160;so&#160;that&#160;we&#160;can&#160;ask&#160;for&#160;the&#160;eigenclass&#160;of<br/>any object:<br/>
class Object<br/>&#160; def eigenclass<br/>&#160; &#160; class &lt;&lt; self; self; end<br/>&#160; end<br/>end<br/>
Unless&#160;you&#160;are&#160;doing&#160;sophisticated&#160;metaprogramming&#160;with&#160;Ruby,&#160;you&#160;are&#160;unlikely&#160;to<br/>really&#160;need&#160;an&#160;eigenclass&#160;utility&#160;function&#160;like&#160;the&#160;one&#160;shown&#160;here.&#160;It&#160;is&#160;worth&#160;under-<br/>standing&#160;eigenclasses,&#160;however,&#160;because&#160;you’ll&#160;occasionally&#160;see&#160;them&#160;used&#160;in&#160;existing<br/>code,&#160;&#160;and&#160;&#160;because&#160;&#160;they’re&#160;&#160;an&#160;&#160;important&#160;&#160;part&#160;&#160;of&#160;&#160;Ruby’s&#160;&#160;method&#160;&#160;name&#160;&#160;resolution<br/>algorithm, which we describe next.<br/>
<b>7.8 &#160;Method Lookup<br/></b>When&#160;Ruby&#160;evaluates&#160;a&#160;method&#160;invocation&#160;expression,&#160;it&#160;must&#160;first&#160;figure&#160;out&#160;which<br/>method&#160;is&#160;to&#160;be&#160;invoked.&#160;The&#160;process&#160;for&#160;doing&#160;this&#160;is&#160;called&#160;<i>method lookup</i>&#160;or&#160;<i>method<br/>name&#160;&#160;resolution</i>.&#160;&#160;For&#160;&#160;the&#160;&#160;method&#160;&#160;invocation&#160;&#160;expression&#160;&#160;o.m,&#160;&#160;Ruby&#160;&#160;performs&#160;&#160;name<br/>resolution with the following steps:<br/>
1.&#160;First, it checks the eigenclass of&#160;o&#160;for singleton methods named&#160;m.<br/>2.&#160;If&#160;no&#160;method&#160;m&#160;is&#160;found&#160;in&#160;the&#160;eigenclass,&#160;Ruby&#160;searches&#160;the&#160;class&#160;of&#160;o&#160;for&#160;an&#160;instance<br/>
method named&#160;m.<br/>
3.&#160;If&#160;no&#160;method&#160;m&#160;is&#160;found&#160;in&#160;the&#160;class,&#160;Ruby&#160;searches&#160;the&#160;instance&#160;methods&#160;of&#160;any<br/>
modules&#160;included&#160;by&#160;the&#160;class&#160;of&#160;o.&#160;If&#160;that&#160;class&#160;includes&#160;more&#160;than&#160;one&#160;module,<br/>then&#160;they&#160;are&#160;searched&#160;in&#160;the&#160;reverse&#160;of&#160;the&#160;order&#160;in&#160;which&#160;they&#160;were&#160;included.&#160;That<br/>is, the most recently included module is searched first.<br/>
4.&#160;If&#160;no&#160;instance&#160;method&#160;m&#160;is&#160;found&#160;in&#160;the&#160;class&#160;of&#160;o&#160;or&#160;in&#160;its&#160;modules,&#160;then&#160;the&#160;search<br/>
moves&#160;up&#160;the&#160;inheritance&#160;hierarchy&#160;to&#160;the&#160;superclass.&#160;Steps&#160;2&#160;and&#160;3&#160;are&#160;repeated<br/>
<b>258&#160;|&#160;Chapter 7:</b> <b>Classes and Modules</b><br/>
<hr/>
<a name=273></a>for&#160;each&#160;class&#160;in&#160;the&#160;inheritance&#160;hierarchy&#160;until&#160;each&#160;ancestor&#160;class&#160;and&#160;its&#160;included<br/>modules have been searched.<br/>
5.&#160;If&#160;no&#160;method&#160;named&#160;m&#160;is&#160;found&#160;after&#160;completing&#160;the&#160;search,&#160;then&#160;a&#160;method&#160;named<br/>
method_missing&#160;is&#160;invoked&#160;instead.&#160;In&#160;order&#160;to&#160;find&#160;an&#160;appropriate&#160;definition&#160;of&#160;this<br/>method,&#160;the&#160;name&#160;resolution&#160;algorithm&#160;starts&#160;over&#160;at&#160;step&#160;1.&#160;The&#160;Kernel&#160;module<br/>provides&#160;a&#160;default&#160;implementation&#160;of&#160;method_missing,&#160;so&#160;this&#160;second&#160;pass&#160;of&#160;name<br/>resolution&#160;is&#160;guaranteed&#160;to&#160;succeed.&#160;The&#160;method_missing&#160;method&#160;is&#160;covered&#160;in&#160;more<br/><a href="Rubys.html#290">detail in §8.4.5.</a><br/>
Let’s&#160;consider&#160;a&#160;concrete&#160;example&#160;of&#160;this&#160;algorithm.&#160;Suppose&#160;we&#160;have&#160;the&#160;following<br/>code:<br/>
message = &#34;hello&#34;<br/>message.world<br/>
We&#160;&#160;want&#160;&#160;to&#160;&#160;invoke&#160;&#160;a&#160;&#160;method&#160;&#160;named&#160;&#160;world&#160;&#160;on&#160;&#160;the&#160;&#160;String&#160;&#160;instance&#160;&#160;&#34;hello&#34;.&#160;&#160;Name<br/>resolution proceeds as follows:<br/>
1.&#160;Check the eigenclass for singleton methods. There aren’t any in this case.<br/>2.&#160;Check the&#160;String&#160;class. There is no instance method named&#160;world.<br/>3.&#160;Check the&#160;Comparable&#160;and&#160;Enumerable&#160;modules&#160;of&#160;the&#160;String&#160;class&#160;for&#160;an&#160;instance<br/>
method named&#160;world. Neither module defines such a method.<br/>
4.&#160;Check the superclass of&#160;String, which is&#160;Object. The&#160;Object&#160;class does not define<br/>
a method named&#160;world, either.<br/>
5.&#160;Check&#160;the&#160;Kernel&#160;module&#160;included&#160;by&#160;Object.&#160;The&#160;world&#160;method&#160;is&#160;not&#160;found&#160;here<br/>
either, so we now switch to looking for a method named&#160;method_missing.<br/>
6.&#160;Look&#160;for&#160;method_missing&#160;in&#160;each&#160;of&#160;the&#160;spots&#160;above&#160;(the&#160;eigenclass&#160;of&#160;the&#160;String<br/>
object, the&#160;String&#160;class, the&#160;Comparable&#160;and&#160;Enumerable&#160;modules, the&#160;Object&#160;class,<br/>and&#160;the&#160;Kernel&#160;module).&#160;The&#160;first&#160;definition&#160;of&#160;method_missing&#160;we&#160;find&#160;is&#160;in&#160;the<br/>Kernel&#160;module,&#160;so&#160;this&#160;is&#160;the&#160;method&#160;we&#160;invoke.&#160;What&#160;it&#160;does&#160;is&#160;raise&#160;an&#160;exception:<br/>
NoMethodError: undefined method `world' for &#34;hello&#34;:String<br/>
This&#160;&#160;may&#160;&#160;seem&#160;&#160;like&#160;&#160;it&#160;&#160;requires&#160;&#160;Ruby&#160;&#160;to&#160;&#160;perform&#160;&#160;an&#160;&#160;exhaustive&#160;&#160;search&#160;&#160;every&#160;&#160;time&#160;&#160;it<br/>invokes&#160;a&#160;method.&#160;In&#160;typical&#160;implementations,&#160;however,&#160;successful&#160;method&#160;lookups<br/>will&#160;&#160;be&#160;&#160;cached&#160;&#160;so&#160;&#160;that&#160;&#160;subsequent&#160;&#160;lookups&#160;&#160;of&#160;&#160;the&#160;&#160;same&#160;&#160;name&#160;&#160;(with&#160;&#160;no&#160;&#160;intervening<br/>method definitions) will be very quick.<br/>
<b>7.8.1 &#160;Class Method Lookup<br/></b>The&#160;name&#160;resolution&#160;algorithm&#160;for&#160;class&#160;methods&#160;is&#160;exactly&#160;the&#160;same&#160;as&#160;it&#160;is&#160;for&#160;instance<br/>methods,&#160;but&#160;there&#160;is&#160;a&#160;twist.&#160;Let’s&#160;start&#160;with&#160;a&#160;simple&#160;case,&#160;without&#160;the&#160;twist.&#160;Here&#160;is<br/>a class&#160;C&#160;that defines no class methods of its own:<br/>
class C<br/>end<br/>
<b>7.8 &#160;Method Lookup&#160;|&#160;259</b><br/>
<hr/>
<a name=274></a>Remember&#160;that&#160;after&#160;we&#160;define&#160;a&#160;class&#160;like&#160;this,&#160;the&#160;constant&#160;C&#160;refers&#160;to&#160;an&#160;object&#160;that<br/>is&#160;an&#160;instance&#160;of&#160;Class.&#160;Any&#160;class&#160;methods&#160;we&#160;define&#160;are&#160;simply&#160;singleton&#160;methods&#160;of<br/>the object&#160;C.<br/>Once we have defined a class&#160;C, we are likely to write a method invocation expression<br/>involving the class method&#160;new:<br/>
c = C.new<br/>
To resolve the method&#160;new, Ruby first looks for singleton methods in the&#160;eigenclass of<br/>the&#160;object&#160;C.&#160;Our&#160;class&#160;does&#160;not&#160;have&#160;any&#160;class&#160;methods,&#160;so&#160;nothing&#160;is&#160;found&#160;there.&#160;After<br/>searching&#160;the&#160;eigenclass,&#160;the&#160;name&#160;resolution&#160;algorithm&#160;searches&#160;the&#160;class&#160;object&#160;of&#160;C.<br/>The&#160;class&#160;of&#160;C&#160;is&#160;Class,&#160;so&#160;Ruby&#160;next&#160;looks&#160;for&#160;methods&#160;in&#160;Class,&#160;and&#160;it&#160;finds&#160;an&#160;instance<br/>method named&#160;new&#160;there.<br/>You&#160;&#160;read&#160;&#160;that&#160;&#160;right.&#160;&#160;The&#160;&#160;method&#160;&#160;name&#160;&#160;resolution&#160;&#160;algorithm&#160;&#160;for&#160;&#160;the&#160;&#160;<i>class</i>&#160;&#160;method<br/>C.new&#160;ends&#160;up&#160;locating&#160;the&#160;<i>instance</i>&#160;method&#160;Class.new.&#160;The&#160;distinction&#160;between&#160;instance<br/>methods&#160;and&#160;class&#160;methods&#160;is&#160;a&#160;useful&#160;one&#160;to&#160;draw&#160;in&#160;the&#160;object-oriented&#160;programming<br/>paradigm,&#160;but&#160;the&#160;truth&#160;is&#160;that&#160;in&#160;Ruby—where&#160;classes&#160;are&#160;represented&#160;by&#160;objects—<br/>the&#160;&#160;distinction&#160;&#160;is&#160;&#160;somewhat&#160;&#160;artificial.&#160;&#160;Every&#160;&#160;method&#160;&#160;invocation,&#160;&#160;whether&#160;&#160;instance<br/>method&#160;or&#160;class&#160;method,&#160;has&#160;a&#160;receiver&#160;object&#160;and&#160;a&#160;method&#160;name.&#160;The&#160;name&#160;resolution<br/>algorithm&#160;finds&#160;the&#160;appropriate&#160;method&#160;definition&#160;for&#160;that&#160;object.&#160;Our&#160;object&#160;C&#160;is&#160;an<br/>instance&#160;&#160;of&#160;&#160;class&#160;&#160;Class,&#160;&#160;so&#160;&#160;we&#160;&#160;can&#160;&#160;of&#160;&#160;course&#160;&#160;invoke&#160;&#160;the&#160;&#160;instance&#160;&#160;methods&#160;&#160;of&#160;&#160;Class<br/>through&#160;C.&#160;Furthermore,&#160;Class&#160;inherits&#160;the&#160;instance&#160;methods&#160;of&#160;Module,&#160;Object,&#160;and<br/>Kernel,&#160;so&#160;those&#160;inherited&#160;methods&#160;are&#160;also&#160;available&#160;as&#160;methods&#160;of&#160;C.&#160;The&#160;only&#160;reason<br/>we call these “class methods” is that our object&#160;C&#160;happens to be a class.<br/>Our&#160;class&#160;method&#160;C.new&#160;is&#160;found&#160;as&#160;an&#160;instance&#160;method&#160;of&#160;Class.&#160;If&#160;it&#160;had&#160;not&#160;been<br/>found&#160;there,&#160;however,&#160;the&#160;name&#160;resolution&#160;algorithm&#160;would&#160;have&#160;continued&#160;just&#160;as&#160;it<br/>would&#160;have&#160;for&#160;an&#160;instance&#160;method.&#160;After&#160;searching&#160;Class&#160;unsuccessfully,&#160;we&#160;would<br/>have&#160;&#160;looked&#160;&#160;at&#160;&#160;modules&#160;&#160;(Class&#160;&#160;doesn’t&#160;&#160;include&#160;&#160;any)&#160;&#160;and&#160;&#160;then&#160;&#160;at&#160;&#160;the&#160;&#160;superclass<br/>Module.&#160;Next,&#160;we&#160;would&#160;search&#160;the&#160;modules&#160;of&#160;Module&#160;(there&#160;aren’t&#160;any),&#160;and&#160;finally&#160;the<br/>superclass of&#160;Module,&#160;Object, and its module&#160;Kernel.<br/>The&#160;twist&#160;mentioned&#160;at&#160;the&#160;beginning&#160;of&#160;this&#160;section&#160;has&#160;to&#160;do&#160;with&#160;the&#160;fact&#160;that&#160;class<br/>methods&#160;&#160;are&#160;&#160;inherited&#160;&#160;just&#160;&#160;like&#160;&#160;instance&#160;&#160;methods&#160;&#160;are.&#160;&#160;Let’s&#160;&#160;define&#160;&#160;a&#160;&#160;class&#160;&#160;method<br/>Integer.parse&#160;to use as an example:<br/>
def Integer.parse(text)<br/>&#160; text.to_i<br/>end<br/>
Because&#160;Fixnum&#160;is&#160;a&#160;subclass&#160;of&#160;Integer,&#160;we&#160;can&#160;invoke&#160;this&#160;method&#160;with&#160;an&#160;expression<br/>like this:<br/>
n = Fixnum.parse(&#34;1&#34;)<br/>
From&#160;the&#160;description&#160;of&#160;the&#160;method&#160;name&#160;resolution&#160;algorithm&#160;that&#160;we’ve&#160;seen&#160;previ-<br/>ously,&#160;we&#160;know&#160;that&#160;Ruby&#160;would&#160;first&#160;search&#160;the&#160;eigenclass&#160;of&#160;&#160;Fixnum&#160;for&#160;singleton<br/>methods.&#160;Next,&#160;it&#160;would&#160;search&#160;for&#160;instance&#160;methods&#160;of&#160;Class,&#160;Module,&#160;Object,&#160;and<br/>
<b>260&#160;|&#160;Chapter 7:</b> <b>Classes and Modules</b><br/>
<hr/>
<a name=275></a>Kernel.&#160;So&#160;where&#160;does&#160;it&#160;find&#160;the&#160;parse&#160;method?&#160;A&#160;class&#160;method&#160;of&#160;Integer&#160;is&#160;just&#160;a<br/>singleton&#160;method&#160;of&#160;the&#160;Integer&#160;object,&#160;which&#160;means&#160;that&#160;it&#160;is&#160;defined&#160;by&#160;the&#160;eigenclass<br/>of&#160;Integer.&#160;So&#160;how&#160;does&#160;this&#160;eigenclass&#160;of&#160;Integer&#160;get&#160;involved&#160;in&#160;the&#160;name&#160;resolution<br/>algorithm?<br/>Class&#160;objects&#160;are&#160;special:&#160;they&#160;have&#160;superclasses.&#160;The&#160;eigenclasses&#160;of&#160;class&#160;objects&#160;are<br/>also&#160;special:&#160;they&#160;have&#160;superclasses,&#160;too.&#160;The&#160;eigenclass&#160;of&#160;an&#160;ordinary&#160;object&#160;stands<br/>alone&#160;and&#160;has&#160;no&#160;superclass.&#160;Let’s&#160;use&#160;the&#160;names&#160;Fixnum'&#160;and&#160;Integer'&#160;to&#160;refer&#160;to&#160;the<br/>eigenclasses of&#160;Fixnum&#160;and&#160;Integer. The superclass of&#160;Fixnum'&#160;is&#160;Integer'.<br/>With&#160;that&#160;twist&#160;in&#160;mind,&#160;we&#160;can&#160;now&#160;more&#160;fully&#160;explain&#160;the&#160;method&#160;name&#160;resolution<br/>algorithm&#160;and&#160;say&#160;that&#160;when&#160;Ruby&#160;searches&#160;for&#160;singleton&#160;methods&#160;in&#160;the&#160;eigenclass&#160;of<br/>an&#160;object,&#160;it&#160;also&#160;searches&#160;the&#160;superclass&#160;(and&#160;all&#160;ancestors)&#160;of&#160;the&#160;eigenclass&#160;as&#160;well.&#160;So<br/>when&#160;looking&#160;for&#160;a&#160;class&#160;method&#160;of&#160;Fixnum,&#160;Ruby&#160;first&#160;checks&#160;the&#160;singleton&#160;methods&#160;of<br/>Fixnum,&#160;Integer,&#160;Numeric, and&#160;Object,&#160;and&#160;then&#160;checks&#160;the&#160;instance&#160;methods&#160;of&#160;Class,<br/>Module,&#160;Object, and&#160;Kernel.<br/>
<b>7.9 &#160;Constant Lookup<br/></b>When&#160;a&#160;constant&#160;is&#160;referenced&#160;without&#160;any&#160;qualifying&#160;namespace,&#160;the&#160;Ruby&#160;interpreter<br/>must&#160;find&#160;the&#160;appropriate&#160;definition&#160;of&#160;the&#160;constant.&#160;To&#160;do&#160;so,&#160;it&#160;uses&#160;a&#160;name&#160;resolution<br/>algorithm,&#160;just&#160;as&#160;it&#160;does&#160;to&#160;find&#160;method&#160;definitions.&#160;However,&#160;constants&#160;are&#160;resolved<br/>much differently than methods.<br/>Ruby&#160;first&#160;attempts&#160;to&#160;resolve&#160;a&#160;constant&#160;reference&#160;in&#160;the&#160;lexical&#160;scope&#160;of&#160;the&#160;reference.<br/>This&#160;means&#160;that&#160;it&#160;first&#160;checks&#160;the&#160;class&#160;or&#160;module&#160;that&#160;encloses&#160;the&#160;constant&#160;reference<br/>to&#160;see&#160;if&#160;that&#160;class&#160;or&#160;module&#160;defines&#160;the&#160;constant.&#160;If&#160;not,&#160;it&#160;checks&#160;the&#160;next&#160;enclosing<br/>class&#160;or&#160;module.&#160;This&#160;continues&#160;until&#160;there&#160;are&#160;no&#160;more&#160;enclosing&#160;classes&#160;or&#160;modules.<br/>Note&#160;that&#160;top-level&#160;or&#160;“global”&#160;constants&#160;are&#160;not&#160;considered&#160;part&#160;of&#160;the&#160;lexical&#160;scope<br/>and&#160;&#160;are&#160;&#160;not&#160;&#160;considered&#160;&#160;during&#160;&#160;this&#160;&#160;part&#160;&#160;of&#160;&#160;constant&#160;&#160;lookup.&#160;&#160;The&#160;&#160;class&#160;&#160;method<br/>Module.nesting&#160;returns&#160;the&#160;list&#160;of&#160;classes&#160;and&#160;modules&#160;that&#160;are&#160;searched&#160;in&#160;this&#160;step,&#160;in<br/>the order they are searched.<br/>If&#160;no&#160;constant&#160;definition&#160;is&#160;found&#160;in&#160;the&#160;lexically&#160;enclosing&#160;scope,&#160;Ruby&#160;next&#160;tries&#160;to<br/>resolve&#160;the&#160;constant&#160;in&#160;the&#160;inheritance&#160;hierarchy&#160;by&#160;checking&#160;the&#160;ancestors&#160;of&#160;the&#160;class<br/>or&#160;module&#160;that&#160;referred&#160;to&#160;the&#160;constant.&#160;The&#160;ancestors&#160;method&#160;of&#160;the&#160;containing&#160;class<br/>or module returns the list of classes and modules searched in this step.<br/>If no constant definition is found in the inheritance hierarchy, then top-level constant<br/>definitions are checked.<br/>If&#160;no&#160;definition&#160;can&#160;be&#160;found&#160;for&#160;the&#160;desired&#160;constant,&#160;then&#160;the&#160;const_missing&#160;method<br/>—if&#160;there&#160;is&#160;one—of&#160;the&#160;containing&#160;class&#160;or&#160;module&#160;is&#160;called&#160;and&#160;given&#160;the&#160;opportunity<br/>to&#160;provide&#160;a&#160;value&#160;for&#160;the&#160;constant.&#160;This&#160;const_missing&#160;hook&#160;is&#160;covered&#160;<a href="Rubys.html#279">in&#160;Chapter 8,<br/></a><a href="Rubys.html#298">and Example 8-3 illustrates its use.</a><br/>
<b>7.9 &#160;Constant Lookup&#160;|&#160;261</b><br/>
<hr/>
<a name=276></a>There&#160;are&#160;a&#160;few&#160;points&#160;about&#160;this&#160;constant&#160;lookup&#160;algorithm&#160;that&#160;are&#160;worth&#160;noting&#160;in<br/>more detail:<br/>
•&#160;Constants&#160;&#160;defined&#160;&#160;in&#160;&#160;enclosing&#160;&#160;modules&#160;&#160;are&#160;&#160;found&#160;&#160;in&#160;&#160;preference&#160;&#160;to&#160;&#160;constants<br/>
defined in included modules.<br/>
•&#160;The modules included by a class are searched before the superclass of the class.<br/>•&#160;The&#160;Object&#160;class&#160;is&#160;part&#160;of&#160;the&#160;inheritance&#160;hierarchy&#160;of&#160;all&#160;classes.&#160;Top-level&#160;con-<br/>
stants,&#160;defined&#160;outside&#160;of&#160;any&#160;class&#160;or&#160;module,&#160;are&#160;like&#160;top-level&#160;methods:&#160;they&#160;are<br/>implicitly&#160;defined&#160;in&#160;Object.&#160;When&#160;a&#160;top-level&#160;constant&#160;is&#160;referenced&#160;from&#160;within<br/>a&#160;class,&#160;therefore,&#160;it&#160;is&#160;resolved&#160;during&#160;the&#160;search&#160;of&#160;the&#160;inheritance&#160;hierarchy.&#160;If<br/>the&#160;constant&#160;is&#160;referenced&#160;within&#160;a&#160;module&#160;definition,&#160;however,&#160;an&#160;explicit&#160;check<br/>of&#160;Object&#160;is needed after searching the ancestors of the module.<br/>
•&#160;The&#160;Kernel&#160;module&#160;is&#160;an&#160;ancestor&#160;of&#160;Object.&#160;This&#160;means&#160;that&#160;constants&#160;defined&#160;in<br/>
Kernel&#160;&#160;behave&#160;&#160;like&#160;&#160;top-level&#160;&#160;constants&#160;&#160;but&#160;&#160;can&#160;&#160;be&#160;&#160;overridden&#160;&#160;by&#160;&#160;true&#160;&#160;top-level<br/>constants, that are defined in&#160;Object.<br/>
<a href="Rubys.html#276">Example&#160;7-1&#160;</a>defines&#160;and&#160;resolves&#160;constants&#160;in&#160;six&#160;different&#160;scopes&#160;and&#160;demonstrates<br/>the constant name lookup algorithm described previously.<br/>
<i>Example 7-1. Constant name resolution</i><br/>
module Kernel<br/>&#160; # Constants defined in Kernel<br/>&#160; A = B = C = D = E = F = &#34;defined in kernel&#34;<br/>end<br/>
# Top-level or &#34;global&#34; constants defined in Object<br/>A = B = C = D = E = &#34;defined at toplevel&#34;<br/>
class Super<br/>&#160; # Constants defined in a superclass<br/>&#160; A = B = C = D = &#34;defined in superclass&#34;<br/>end<br/>
module Included<br/>&#160; # Constants defined in an included module<br/>&#160; A = B = C = &#34;defined in included module&#34;<br/>end<br/>
module Enclosing<br/>&#160; # Constants defined in an enclosing module<br/>&#160; A = B = &#34;defined in enclosing module&#34;<br/>
&#160; class Local &lt; Super<br/>&#160; &#160; include Included<br/>
&#160; &#160; # Locally defined constant<br/>&#160; &#160; A = &#34;defined locally&#34;<br/>
&#160; &#160; # The list of modules searched, in the order searched<br/>&#160; &#160; # [Enclosing::Local, Enclosing, Included, Super, Object, Kernel]<br/>
<b>262&#160;|&#160;Chapter 7:</b> <b>Classes and Modules</b><br/>
<hr/>
<a name=277></a>&#160; &#160; search = (Module.nesting + self.ancestors + Object.ancestors).uniq<br/>
&#160; &#160; puts A &#160;# Prints &#34;defined locally&#34;<br/>&#160; &#160; puts B &#160;# Prints &#34;defined in enclosing module&#34;<br/>&#160; &#160; puts C &#160;# Prints &#34;defined in included module&#34;<br/>&#160; &#160; puts D &#160;# Prints &#34;defined in superclass&#34;<br/>&#160; &#160; puts E &#160;# Prints &#34;defined at toplevel&#34;<br/>&#160; &#160; puts F &#160;# Prints &#34;defined in kernel&#34;<br/>&#160; end<br/>end<br/>
<b>7.9 &#160;Constant Lookup&#160;|&#160;263</b><br/>
<hr/>
<a name=278></a><hr/>
<a name=279></a><img src="Ruby-279_1.jpg"/><br/>
<b>CHAPTER&#160;8</b><br/>
<b>Reflection and Metaprogramming</b><br/>
<b>265</b><br/>
<hr/>
<a name=280></a>We’ve&#160;seen&#160;that&#160;Ruby&#160;is&#160;a&#160;very&#160;dynamic&#160;language;&#160;you&#160;can&#160;insert&#160;new&#160;methods&#160;into<br/>classes&#160;at&#160;runtime,&#160;create&#160;aliases&#160;for&#160;existing&#160;methods,&#160;and&#160;even&#160;define&#160;methods&#160;on<br/>individual&#160;objects.&#160;In&#160;addition,&#160;it&#160;has&#160;a&#160;rich&#160;API&#160;for&#160;<i>reflection</i>.&#160;Reflection,&#160;also&#160;called<br/><i>introspection</i>,&#160;simply&#160;means&#160;that&#160;a&#160;program&#160;can&#160;examine&#160;its&#160;state&#160;and&#160;its&#160;structure.&#160;A<br/>Ruby&#160;program&#160;can,&#160;for&#160;example,&#160;obtain&#160;the&#160;list&#160;of&#160;methods&#160;defined&#160;by&#160;the&#160;Hash&#160;class,<br/>query&#160;the&#160;value&#160;of&#160;a&#160;named&#160;instance&#160;variable&#160;within&#160;a&#160;specified&#160;object,&#160;or&#160;iterate&#160;through<br/>all&#160;Regexp&#160;objects&#160;currently&#160;defined&#160;by&#160;the&#160;interpreter.&#160;The&#160;reflection&#160;API&#160;actually&#160;goes<br/>further&#160;&#160;and&#160;&#160;allows&#160;&#160;a&#160;&#160;program&#160;&#160;to&#160;&#160;alter&#160;&#160;its&#160;&#160;state&#160;&#160;and&#160;&#160;structure.&#160;&#160;A&#160;&#160;Ruby&#160;&#160;program&#160;&#160;can<br/>dynamically&#160;set&#160;named&#160;variables,&#160;invoke&#160;named&#160;methods,&#160;and&#160;even&#160;define&#160;new&#160;classes<br/>and new methods.<br/>Ruby’s&#160;&#160;reflection&#160;&#160;API—along&#160;&#160;with&#160;&#160;its&#160;&#160;generally&#160;&#160;dynamic&#160;&#160;nature,&#160;&#160;its&#160;&#160;blocks-and-<br/>iterators&#160;&#160;control&#160;&#160;structures,&#160;&#160;and&#160;&#160;its&#160;&#160;parentheses-optional&#160;&#160;syntax—makes&#160;&#160;it&#160;&#160;an&#160;&#160;ideal<br/>language&#160;&#160;for&#160;&#160;<i>metaprogramming</i>.&#160;&#160;Loosely&#160;&#160;defined,&#160;&#160;metaprogramming&#160;&#160;is&#160;&#160;writing&#160;&#160;pro-<br/>grams&#160;(or&#160;frameworks)&#160;that&#160;help&#160;you&#160;write&#160;programs.&#160;To&#160;put&#160;it&#160;another&#160;way,&#160;meta-<br/>programming&#160;is&#160;a&#160;set&#160;of&#160;techniques&#160;for&#160;extending&#160;Ruby’s&#160;syntax&#160;in&#160;ways&#160;that&#160;make<br/>programming&#160;easier.&#160;Metaprogramming&#160;is&#160;closely&#160;tied&#160;to&#160;the&#160;idea&#160;of&#160;writing&#160;<i>domain-<br/>specific&#160;languages</i>,&#160;or&#160;DSLs.&#160;DSLs&#160;in&#160;Ruby&#160;typically&#160;use&#160;method&#160;invocations&#160;and&#160;blocks<br/>as if they were keywords in a task-specific extension to the language.<br/>This&#160;chapter&#160;starts&#160;with&#160;several&#160;sections&#160;that&#160;introduce&#160;Ruby’s&#160;reflection&#160;API.&#160;This&#160;API<br/>is&#160;surprisingly&#160;rich&#160;and&#160;consists&#160;of&#160;quite&#160;a&#160;few&#160;methods.&#160;These&#160;methods&#160;are&#160;defined,<br/>for the most part, by&#160;Kernel,&#160;Object, and&#160;Module.<br/>As&#160;you&#160;read&#160;these&#160;introductory&#160;sections,&#160;keep&#160;in&#160;mind&#160;that&#160;reflection&#160;is&#160;not,&#160;by&#160;itself,<br/>metaprogramming.&#160;Metaprogramming&#160;typically&#160;extends&#160;the&#160;syntax&#160;or&#160;the&#160;behavior&#160;of<br/>Ruby&#160;in&#160;some&#160;way,&#160;and&#160;often&#160;involves&#160;more&#160;than&#160;one&#160;kind&#160;of&#160;reflection.&#160;After&#160;intro-<br/>ducing&#160;Ruby’s&#160;core&#160;reflection&#160;API,&#160;this&#160;chapter&#160;moves&#160;on&#160;to&#160;demonstrate,&#160;by&#160;example,<br/>common metaprogramming techniques that use that API.<br/>Note&#160;that&#160;this&#160;chapter&#160;covers&#160;advanced&#160;topics.&#160;You&#160;can&#160;be&#160;a&#160;productive&#160;Ruby&#160;pro-<br/>grammer&#160;&#160;without&#160;&#160;ever&#160;&#160;reading&#160;&#160;this&#160;&#160;chapter.&#160;&#160;You&#160;&#160;may&#160;&#160;find&#160;&#160;it&#160;&#160;helpful&#160;&#160;to&#160;&#160;read&#160;&#160;the<br/>remaining&#160;chapters&#160;of&#160;this&#160;book&#160;first,&#160;and&#160;then&#160;return&#160;to&#160;this&#160;chapter.&#160;Consider&#160;this<br/>chapter&#160;a&#160;kind&#160;of&#160;final&#160;exam:&#160;if&#160;you&#160;understand&#160;the&#160;examples&#160;(particularly&#160;the&#160;longer<br/>ones at the end), then you have mastered Ruby!<br/>
<b>8.1 &#160;Types, Classes, and Modules<br/></b>The most commonly&#160;used&#160;reflective&#160;methods&#160;are&#160;those&#160;for&#160;determining&#160;the&#160;type&#160;of&#160;an<br/>object—what&#160;class&#160;it&#160;is&#160;an&#160;instance&#160;of&#160;and&#160;what&#160;methods&#160;it&#160;responds&#160;to.&#160;We&#160;introduced<br/><a href="Rubys.html#88">most of these important methods early in this book in §3.8.4. To review:</a><br/>
o.class<br/>
Returns the class of an object&#160;o.<br/>
c.superclass<br/>
Returns the superclass of a class&#160;c.<br/>
<b>266&#160;|&#160;Chapter 8:</b> <b>Reflection and Metaprogramming</b><br/>
<hr/>
<a name=281></a>o.instance_of? c<br/>
Determines whether the object&#160;o.class == c.<br/>
o.is_a? c<br/>
Determines&#160;whether&#160;o&#160;is&#160;an&#160;instance&#160;of&#160;c,&#160;or&#160;of&#160;any&#160;of&#160;its&#160;subclasses.&#160;If&#160;c&#160;is&#160;a&#160;module,<br/>this method tests whether&#160;o.class&#160;(or any of its ancestors) includes the module.<br/>
o.kind_of? c<br/>
kind_of?&#160;is a synonym for&#160;is_a?.<br/>
c === o<br/>
For any class or module&#160;c, determines if&#160;o.is_a?(c).<br/>
o.respond_to? name<br/>
Determines&#160;whether&#160;the&#160;object&#160;o&#160;has&#160;a&#160;public&#160;or&#160;protected&#160;method&#160;with&#160;the&#160;speci-<br/>fied name. Pass&#160;true&#160;as the second argument to check private methods as well.<br/>
<b>8.1.1 &#160;Ancestry and Modules<br/></b>In addition&#160;to&#160;these&#160;methods&#160;that&#160;you’ve&#160;already&#160;seen,&#160;there&#160;are&#160;a&#160;few&#160;related&#160;reflective<br/>methods&#160;for&#160;determining&#160;the&#160;ancestors&#160;of&#160;a&#160;class&#160;or&#160;module&#160;and&#160;for&#160;determining&#160;which<br/>modules&#160;are&#160;included&#160;by&#160;a&#160;class&#160;or&#160;module.&#160;These&#160;methods&#160;are&#160;easy&#160;to&#160;understand&#160;when<br/>demonstrated:<br/>
module A; end &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Empty module<br/>module B; include A; end; &#160; &#160;# Module B includes A<br/>class C; include B; end; &#160; &#160; # Class C includes module B<br/>
C &lt; B &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; true: C includes B<br/>B &lt; A &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; true: B includes A<br/>C &lt; A &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; true<br/>Fixnum &lt; Integer &#160; &#160; # =&gt; true: all fixnums are integers<br/>Integer &lt; Comparable # =&gt; true: integers are comparable<br/>Integer &lt; Fixnum &#160; &#160; # =&gt; false: not all integers are fixnums<br/>String &lt; Numeric &#160; &#160; # =&gt; nil: strings are not numbers<br/>
A.ancestors &#160; &#160; &#160; &#160; &#160;# =&gt; [A]<br/>B.ancestors &#160; &#160; &#160; &#160; &#160;# =&gt; [B, A]<br/>C.ancestors &#160; &#160; &#160; &#160; &#160;# =&gt; [C, B, A, Object, Kernel]<br/>String.ancestors &#160; &#160; # =&gt; [String, Enumerable, Comparable, Object, Kernel]<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Note: in Ruby 1.9 String is no longer Enumerable<br/>
C.include?(B) &#160; &#160; &#160; &#160;# =&gt; true<br/>C.include?(A) &#160; &#160; &#160; &#160;# =&gt; true<br/>B.include?(A) &#160; &#160; &#160; &#160;# =&gt; true<br/>A.include?(A) &#160; &#160; &#160; &#160;# =&gt; false&#160;<br/>A.include?(B) &#160; &#160; &#160; &#160;# =&gt; false<br/>
A.included_modules &#160; # =&gt; []<br/>B.included_modules &#160; # =&gt; [A]<br/>C.included_modules &#160; # =&gt; [B, A, Kernel]<br/>
<b>8.1 &#160;Types, Classes, and Modules&#160;|&#160;267</b><br/>
<hr/>
<a name=282></a>This&#160;code&#160;demonstrates&#160;include?,&#160;which&#160;is&#160;a&#160;public&#160;instance&#160;method&#160;defined&#160;by&#160;the<br/>Module&#160;class.&#160;But&#160;it&#160;also&#160;features&#160;two&#160;invocations&#160;of&#160;the&#160;include&#160;method&#160;(without&#160;the<br/>question&#160;mark),&#160;which&#160;is&#160;a&#160;private&#160;instance&#160;method&#160;of&#160;Module.&#160;As&#160;a&#160;private&#160;method,&#160;it<br/>can&#160;only&#160;be&#160;invoked&#160;implicitly&#160;on&#160;self,&#160;which&#160;restricts&#160;its&#160;usage&#160;to&#160;the&#160;body&#160;of&#160;a&#160;class&#160;or<br/>module&#160;definition.&#160;This&#160;use&#160;of&#160;the&#160;method&#160;include&#160;as&#160;if&#160;it&#160;were&#160;a&#160;keyword&#160;is&#160;a&#160;meta-<br/>programming example in Ruby’s core syntax.<br/>A&#160;&#160;method&#160;&#160;related&#160;&#160;to&#160;&#160;the&#160;&#160;private&#160;&#160;include&#160;&#160;method&#160;&#160;is&#160;&#160;the&#160;&#160;public&#160;&#160;Object.extend.&#160;&#160;This<br/>method&#160;extends&#160;an&#160;object&#160;by&#160;making&#160;the&#160;instance&#160;methods&#160;of&#160;each&#160;of&#160;the&#160;specified<br/>modules into singleton methods of the object:<br/>
module Greeter; def hi; &#34;hello&#34;; end; end # A silly module<br/>s = &#34;string object&#34;<br/>s.extend(Greeter) &#160; &#160; &#160; # Add hi as a singleton method to s<br/>s.hi &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; &#34;hello&#34;<br/>String.extend(Greeter) &#160;# Add hi as a class method of String<br/>String.hi &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; &#34;hello&#34;<br/>
The&#160;class&#160;method&#160;Module.nesting&#160;is&#160;not&#160;related&#160;to&#160;module&#160;inclusion&#160;or&#160;ancestry;&#160;in-<br/>stead,&#160;it&#160;returns&#160;an&#160;array&#160;that&#160;specifies&#160;the&#160;nesting&#160;of&#160;modules&#160;at&#160;the&#160;current&#160;location.<br/>Module.nesting[0]&#160;is&#160;the&#160;current&#160;class&#160;or&#160;module,&#160;Module.nesting[1]&#160;is the containing<br/>class or module, and so on:<br/>
module M<br/>&#160; class C<br/>&#160; &#160; Module.nesting &#160; # =&gt; [M::C, M]<br/>&#160; end<br/>end<br/>
<b>8.1.2 &#160;Defining Classes and Modules<br/></b>Classes&#160;and&#160;modules&#160;are&#160;instances&#160;of&#160;the&#160;Class&#160;and&#160;Module&#160;classes.&#160;As&#160;such,&#160;you&#160;can<br/>create them dynamically:<br/>
M = Module.new &#160; &#160; &#160;# Define a new module M<br/>C = Class.new &#160; &#160; &#160; # Define a new class C<br/>D = Class.new(C) { &#160;# Define a subclass of C<br/>&#160; include M &#160; &#160; &#160; &#160; # that includes module M<br/>}<br/>D.to_s &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; &#34;D&#34;: class gets constant name by magic<br/>
One&#160;nice&#160;feature&#160;of&#160;Ruby&#160;is&#160;that&#160;when&#160;a&#160;dynamically&#160;created&#160;anonymous&#160;module&#160;or<br/>class&#160;is&#160;assigned&#160;to&#160;a&#160;constant,&#160;the&#160;name&#160;of&#160;that&#160;constant&#160;is&#160;used&#160;as&#160;the&#160;name&#160;of&#160;the<br/>module or class (and is returned by its&#160;name&#160;and&#160;to_s&#160;methods).<br/>
<b>8.2 &#160;Evaluating Strings and Blocks<br/></b>One&#160;of&#160;the&#160;most&#160;powerful&#160;and&#160;straightforward&#160;reflective&#160;features&#160;of&#160;Ruby&#160;is&#160;its&#160;eval<br/>method.&#160;&#160;If&#160;&#160;your&#160;&#160;Ruby&#160;&#160;program&#160;&#160;can&#160;&#160;generate&#160;&#160;a&#160;&#160;string&#160;&#160;of&#160;&#160;valid&#160;&#160;Ruby&#160;&#160;code,&#160;&#160;the<br/>Kernel.eval&#160;method can evaluate that code:<br/>
<b>268&#160;|&#160;Chapter 8:</b> <b>Reflection and Metaprogramming</b><br/>
<hr/>
<a name=283></a>x = 1<br/>eval &#34;x + 1&#34; &#160;# =&gt; 2<br/>
eval&#160;is&#160;a&#160;very&#160;powerful&#160;function,&#160;but&#160;unless&#160;you&#160;are&#160;actually&#160;writing&#160;a&#160;shell&#160;program<br/>(like&#160;<i>irb</i>)&#160;that&#160;executes&#160;lines&#160;of&#160;Ruby&#160;code&#160;entered&#160;by&#160;a&#160;user&#160;you&#160;are&#160;unlikely&#160;to&#160;really<br/>need&#160;it.&#160;(And&#160;in&#160;a&#160;networked&#160;context,&#160;it&#160;is&#160;almost&#160;never&#160;safe&#160;to&#160;call&#160;eval&#160;on&#160;text&#160;received<br/>from&#160;a&#160;user,&#160;as&#160;it&#160;could&#160;contain&#160;malicious&#160;code.)&#160;Inexperienced&#160;programmers&#160;some-<br/>times&#160;end&#160;up&#160;using&#160;eval&#160;as&#160;a&#160;crutch.&#160;If&#160;you&#160;find&#160;yourself&#160;using&#160;it&#160;in&#160;your&#160;code,&#160;see&#160;if<br/>there&#160;isn’t&#160;a&#160;way&#160;to&#160;avoid&#160;it.&#160;Having&#160;said&#160;that,&#160;there&#160;are&#160;some&#160;more&#160;useful&#160;ways&#160;to&#160;use<br/>eval&#160;and&#160;eval-like methods.<br/>
<b>8.2.1 &#160;Bindings and eval<br/></b>A&#160;Binding&#160;object&#160;represents&#160;the&#160;state&#160;of&#160;Ruby’s&#160;variable&#160;bindings&#160;at&#160;some&#160;moment.&#160;The<br/>Kernel.binding&#160;object&#160;returns&#160;the&#160;bindings&#160;in&#160;effect&#160;at&#160;the&#160;location&#160;of&#160;the&#160;call.&#160;You&#160;may<br/>pass&#160;a&#160;Binding&#160;object&#160;as&#160;the&#160;second&#160;argument&#160;to&#160;eval,&#160;and&#160;the&#160;string&#160;you&#160;specify&#160;will<br/>be&#160;evaluated&#160;in&#160;the&#160;context&#160;of&#160;those&#160;bindings.&#160;If,&#160;for&#160;example,&#160;we&#160;define&#160;an&#160;instance<br/>method&#160;that&#160;returns&#160;a&#160;Binding&#160;object&#160;that&#160;represents&#160;the&#160;variable&#160;bindings&#160;inside&#160;an<br/>object,&#160;then&#160;we&#160;can&#160;use&#160;those&#160;bindings&#160;to&#160;query&#160;and&#160;set&#160;the&#160;instance&#160;variables&#160;of&#160;that<br/>object. We might accomplish this as follows:<br/>
class Object &#160; &#160; # Open Object to add a new method<br/>&#160; def bindings &#160; # Note plural on this method<br/>&#160; &#160; binding &#160; &#160; &#160;# This is the predefined Kernel method<br/>&#160; end<br/>end<br/>
class Test &#160; &#160; &#160; # A simple class with an instance variable<br/>&#160; def initialize(x); @x = x; end<br/>end<br/>
t = Test.new(10) &#160; &#160; &#160; # Create a test object<br/>eval(&#34;@x&#34;, t.bindings) # =&gt; 10: We've peeked inside t<br/>
Note that it is not actually necessary to define an&#160;Object.bindings&#160;method of this sort<br/>to&#160;peek&#160;at&#160;the&#160;instance&#160;variables&#160;of&#160;an&#160;object.&#160;Several&#160;other&#160;methods&#160;described&#160;shortly<br/>offer easier ways to query (and set) the value of the instance variables of an object.<br/><a href="Rubys.html#216">As described in §6.6.2, the&#160;</a>Proc&#160;object defines a public&#160;binding&#160;method that returns a<br/>Binding&#160;object&#160;representing&#160;the&#160;variable&#160;bindings&#160;in&#160;effect&#160;for&#160;the&#160;body&#160;of&#160;that&#160;Proc.<br/>Furthermore,&#160;the&#160;eval&#160;method&#160;allows&#160;you&#160;to&#160;pass&#160;a&#160;Proc&#160;object&#160;instead&#160;of&#160;a&#160;Binding<br/>object as the second argument.<br/>Ruby&#160;1.9&#160;defines&#160;an&#160;eval&#160;method&#160;on&#160;Binding&#160;objects,&#160;so&#160;instead&#160;of&#160;passing&#160;a&#160;Binding&#160;as<br/>the second argument to the global&#160;eval, you can instead invoke the&#160;eval&#160;method on a<br/>Binding.&#160;&#160;Which&#160;&#160;one&#160;&#160;you&#160;&#160;choose&#160;&#160;is&#160;&#160;purely&#160;&#160;a&#160;&#160;stylistic&#160;&#160;matter;&#160;&#160;the&#160;&#160;two&#160;&#160;techniques&#160;&#160;are<br/>equivalent.<br/>
<b>8.2 &#160;Evaluating Strings and Blocks&#160;|&#160;269</b><br/>
<hr/>
<a name=284></a><b>8.2.2 &#160;instance_eval and class_eval<br/></b>The&#160;Object&#160;class defines&#160;a method named&#160;instance_eval, and the&#160;Module&#160;class defines<br/>a&#160;method&#160;named&#160;class_eval. (module_eval&#160;is&#160;a&#160;synonym&#160;for&#160;class_eval.)&#160;Both&#160;of&#160;these<br/>methods&#160;evaluate&#160;Ruby&#160;code,&#160;like&#160;eval&#160;does,&#160;but&#160;there&#160;are&#160;two&#160;important&#160;differences.<br/>The first difference is that they evaluate the code in the context of the specified object<br/>or&#160;in&#160;the&#160;context&#160;of&#160;the&#160;specified&#160;module—the&#160;object&#160;or&#160;module&#160;is&#160;the&#160;value&#160;of&#160;self<br/>while the code is being evaluated. Here are some examples:<br/>
o.instance_eval(&#34;@x&#34;) &#160;# Return the value of o's instance variable @x<br/>
# Define an instance method len of String to return string length<br/>String.class_eval(&#34;def len; size; end&#34;)<br/>
# Here's another way to do that<br/># The quoted code behaves just as if it was inside &#34;class String&#34; and &#34;end&#34;<br/>String.class_eval(&#34;alias len size&#34;)<br/>
# Use instance_eval to define class method String.empty<br/># Note that quotes within quotes get a little tricky...<br/>String.instance_eval(&#34;def empty; ''; end&#34;)<br/>
Note&#160;the&#160;subtle&#160;but&#160;crucial&#160;difference&#160;between&#160;instance_eval&#160;and&#160;class_eval&#160;when&#160;the<br/>code&#160;being&#160;evaluated&#160;contains&#160;a&#160;method&#160;definition.&#160;instance_eval&#160;defines&#160;singleton<br/>methods&#160;of&#160;the&#160;object&#160;(and&#160;this&#160;results&#160;in&#160;class&#160;methods&#160;when&#160;it&#160;is&#160;called&#160;on&#160;a&#160;class<br/>object).&#160;class_eval&#160;defines regular instance methods.<br/>The&#160;second&#160;important&#160;difference&#160;between&#160;these&#160;two&#160;methods&#160;and&#160;the&#160;global&#160;eval&#160;is<br/>that&#160;instance_eval&#160;and&#160;class_eval&#160;can&#160;accept&#160;a&#160;block&#160;of&#160;code&#160;to&#160;evaluate.&#160;When&#160;passed<br/>a&#160;block&#160;instead&#160;of&#160;a&#160;string,&#160;the&#160;code&#160;in&#160;the&#160;block&#160;is&#160;executed&#160;in&#160;the&#160;appropriate&#160;context.<br/>Here, therefore, are alternatives to the previously shown invocations:<br/>
o.instance_eval { @x }<br/>String.class_eval {<br/>&#160; def len<br/>&#160; &#160; size<br/>&#160; end<br/>}<br/>String.class_eval { alias len size }<br/>String.instance_eval { def empty; &#34;&#34;; end }<br/>
<b>8.2.3 &#160;instance_exec and class_exec<br/></b>Ruby&#160;1.9&#160;defines&#160;two&#160;more&#160;evaluation&#160;methods:&#160;instance_exec&#160;and&#160;class_exec&#160;(and&#160;its<br/>alias,&#160;module_exec).&#160;These&#160;methods&#160;evaluate&#160;a&#160;block&#160;(but&#160;not&#160;a&#160;string)&#160;of&#160;code&#160;in&#160;the<br/>context&#160;of&#160;the&#160;receiver&#160;object,&#160;as&#160;instance_eval&#160;and&#160;class_eval&#160;do.&#160;The&#160;difference&#160;is<br/>that&#160;the&#160;exec&#160;methods&#160;accept&#160;arguments&#160;and&#160;pass&#160;them&#160;to&#160;the&#160;block.&#160;Thus,&#160;the&#160;block<br/>of&#160;code&#160;is&#160;evaluated&#160;in&#160;the&#160;context&#160;of&#160;the&#160;specified&#160;object,&#160;with&#160;parameters&#160;whose&#160;values<br/>come from outside the object.<br/>
<b>270&#160;|&#160;Chapter 8:</b> <b>Reflection and Metaprogramming</b><br/>
<hr/>
<a name=285></a><b>8.3 &#160;Variables and Constants<br/></b>Kernel,&#160;Object,&#160;and&#160;Moduledefine&#160;reflective&#160;methods&#160;for&#160;listing&#160;the&#160;names&#160;(as&#160;strings)&#160;of<br/>all&#160;defined&#160;global&#160;variables,&#160;currently&#160;defined&#160;local&#160;variables,&#160;all&#160;instance&#160;variables&#160;of<br/>an&#160;object,&#160;all&#160;class&#160;variables&#160;of&#160;a&#160;class&#160;or&#160;module,&#160;and&#160;all&#160;constants&#160;of&#160;a&#160;class&#160;or&#160;module:<br/>
global_variables &#160; # =&gt; [&#34;$DEBUG&#34;, &#34;$SAFE&#34;, ...]<br/>x = 1 &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Define a local variable<br/>local_variables &#160; &#160;# =&gt; [&#34;x&#34;]<br/>
# Define a simple class<br/>class Point<br/>&#160; def initialize(x,y); @x,@y = x,y; end # Define instance variables<br/>&#160; @@classvar = 1 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Define a class variable<br/>&#160; ORIGIN = Point.new(0,0) &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Define a constant<br/>end<br/>
Point::ORIGIN.instance_variables # =&gt; [&#34;@y&#34;, &#34;@x&#34;]<br/>Point.class_variables &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; [&#34;@@classvar&#34;]<br/>Point.constants &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; [&#34;ORIGIN&#34;]<br/>
The&#160;&#160;global_variables,&#160;&#160;local_variables,&#160;&#160;instance_variables,&#160;&#160;class_variables,&#160;&#160;and<br/>constants&#160;methods&#160;return&#160;arrays&#160;of&#160;strings&#160;in&#160;Ruby&#160;1.8&#160;and&#160;arrays&#160;of&#160;symbols&#160;in&#160;Ruby<br/>1.9.<br/>
<b>8.3.1 &#160;Querying, Setting, and Testing Variables<br/></b>In&#160;addition&#160;to&#160;listing&#160;defined&#160;variables&#160;and&#160;constants,&#160;Ruby&#160;&#160;Object&#160;and&#160;Module&#160;also<br/>define&#160;reflective&#160;methods&#160;for&#160;querying,&#160;setting,&#160;and&#160;removing&#160;instance variables, class<br/>variables,&#160;and&#160;constants.&#160;There&#160;are&#160;no&#160;special&#160;purpose&#160;methods&#160;for&#160;querying&#160;or&#160;setting<br/>local variables or global variables, but you can use the&#160;eval&#160;method for this purpose:<br/>
x = 1<br/>varname = &#34;x&#34;<br/>eval(varname) &#160; &#160; &#160; &#160; &#160; # =&gt; 1<br/>eval(&#34;varname = '$g'&#34;) &#160;# Set varname to &#34;$g&#34;<br/>eval(&#34;#{varname} = x&#34;) &#160;# Set $g to 1<br/>eval(varname) &#160; &#160; &#160; &#160; &#160; # =&gt; 1<br/>
Note&#160;that&#160;eval&#160;evaluates&#160;its&#160;code&#160;in&#160;a&#160;temporary&#160;scope.&#160;eval&#160;can&#160;alter&#160;the&#160;value&#160;of&#160;local<br/>variables that already exist. But any new local variables defined by the evaluated code<br/>are&#160;local&#160;to&#160;the&#160;invocation&#160;of&#160;eval&#160;and&#160;cease&#160;to&#160;exist&#160;when&#160;it&#160;returns.&#160;(It&#160;is&#160;as&#160;if&#160;the<br/>evaluated&#160;code&#160;is&#160;run&#160;in&#160;the&#160;body&#160;of&#160;a&#160;block—variables&#160;local&#160;to&#160;a&#160;block&#160;do&#160;not&#160;exist<br/>outside the block.)<br/>You&#160;can&#160;query,&#160;set,&#160;and&#160;test&#160;the&#160;existence&#160;of&#160;instance&#160;variables&#160;on&#160;any&#160;object&#160;and&#160;of<br/>class variables and constants on any class or module:<br/>
o = Object.new<br/>o.instance_variable_set(:@x, 0) &#160; # Note required @ prefix<br/>o.instance_variable_get(:@x) &#160; &#160; &#160;# =&gt; 0<br/>o.instance_variable_defined?(:@x) # =&gt; true<br/>
<b>8.3 &#160;Variables and Constants&#160;|&#160;271</b><br/>
<hr/>
<a name=286></a>Object.class_variable_set(:@@x, 1) &#160; # Private in Ruby 1.8<br/>Object.class_variable_get(:@@x) &#160; &#160; &#160;# Private in Ruby 1.8<br/>Object.class_variable_defined?(:@@x) # =&gt; true; Ruby 1.9 and later<br/>
Math.const_set(:EPI, Math::E*Math::PI)<br/>Math.const_get(:EPI) &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; 8.53973422267357<br/>Math.const_defined? :EPI &#160; &#160; &#160; &#160; # =&gt; true&#160;<br/>
In&#160;&#160;Ruby&#160;&#160;1.9,&#160;&#160;you&#160;&#160;can&#160;&#160;pass&#160;&#160;false&#160;&#160;as&#160;&#160;the&#160;&#160;second&#160;&#160;argument&#160;&#160;to&#160;&#160;const_get&#160;&#160;and<br/>const_defined?&#160;to&#160;specify&#160;that&#160;these&#160;methods&#160;should&#160;only&#160;look&#160;at&#160;the&#160;current&#160;class&#160;or<br/>module and should not consider inherited constants.<br/>The&#160;methods&#160;for&#160;querying&#160;and&#160;setting&#160;class&#160;variables&#160;are&#160;private&#160;in&#160;Ruby&#160;1.8.&#160;In&#160;that<br/>version, you can invoke them with&#160;class_eval:<br/>
String.class_eval { class_variable_set(:@@x, 1) } &#160;# Set @@x in String<br/>String.class_eval { class_variable_get(:@@x) } &#160; &#160; # =&gt; 1<br/>
Object&#160;and&#160;Module&#160;define&#160;private&#160;methods&#160;for&#160;undefining&#160;instance&#160;variables,&#160;class&#160;var-<br/>iables,&#160;and&#160;constants.&#160;They&#160;all&#160;return&#160;the&#160;value&#160;of&#160;the&#160;removed&#160;variable&#160;or&#160;constant.<br/>Because&#160;these&#160;methods&#160;are&#160;private,&#160;you&#160;can’t&#160;invoke&#160;them&#160;directly&#160;on&#160;an&#160;object,&#160;class,<br/>or&#160;module,&#160;and&#160;you&#160;must&#160;use&#160;an&#160;eval&#160;method&#160;or&#160;the&#160;send&#160;method&#160;(described&#160;later&#160;in<br/>this chapter):<br/>
o.instance_eval { remove_instance_variable :@x }<br/>String.class_eval { remove_class_variable(:@@x) }<br/>Math.send :remove_const, :EPI &#160;# Use send to invoke private method<br/>
The&#160;const_missing&#160;method of a module is invoked, if there is one, when a reference is<br/>made to an undefined constant. You can define this method to return the value of the<br/>named&#160;constant.&#160;(This&#160;feature&#160;can&#160;be&#160;used,&#160;for&#160;example,&#160;to&#160;implement&#160;an&#160;autoload<br/>facility&#160;in&#160;which&#160;classes&#160;or&#160;modules&#160;are&#160;loaded&#160;on&#160;demand.)&#160;Here&#160;is&#160;a&#160;simpler&#160;example:<br/>
&#160;<br/>
def Symbol.const_missing(name)<br/>&#160; name # Return the constant name as a symbol<br/>end<br/>Symbol::Test &#160; # =&gt; :Test: undefined constant evaluates to a Symbol<br/>
<b>8.4 &#160;Methods<br/></b>The&#160;&#160;Object&#160;&#160;and&#160;&#160;Module&#160;&#160;classes&#160;&#160;define&#160;&#160;a&#160;&#160;number&#160;&#160;of&#160;&#160;methods&#160;&#160;for&#160;&#160;listing,&#160;&#160;querying,<br/>invoking, and defining methods. We’ll consider each category in turn.<br/>
<b>8.4.1 &#160;Listing and Testing For Methods<br/></b>Object&#160;defines methods for listing the names of methods defined on the object. These<br/>methods&#160;return&#160;arrays&#160;of&#160;methods&#160;names.&#160;Those&#160;name&#160;are&#160;strings&#160;in&#160;Ruby&#160;1.8&#160;and<br/>symbols in Ruby 1.9:<br/>
o = &#34;a string&#34;<br/>o.methods &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; [ names of all public methods ]<br/>
<b>272&#160;|&#160;Chapter 8:</b> <b>Reflection and Metaprogramming</b><br/>
<hr/>
<a name=287></a>o.public_methods &#160; &#160; &#160; &#160; # =&gt; the same thing<br/>o.public_methods(false) &#160;# Exclude inherited methods<br/>o.protected_methods &#160; &#160; &#160;# =&gt; []: there aren't any<br/>o.private_methods &#160; &#160; &#160; &#160;# =&gt; array of all private methods<br/>o.private_methods(false) # Exclude inherited private methods<br/>def o.single; 1; end &#160; &#160; # Define a singleton method<br/>o.singleton_methods &#160; &#160; &#160;# =&gt; [&#34;single&#34;] (or [:single] in 1.9)<br/>
It&#160;is&#160;also&#160;possible&#160;to&#160;query&#160;a&#160;class&#160;for&#160;the&#160;methods&#160;it&#160;defines&#160;rather&#160;than&#160;querying&#160;an<br/>instance&#160;of&#160;the&#160;class.&#160;The&#160;following&#160;methods&#160;are&#160;defined&#160;by&#160;Module.&#160;Like&#160;the&#160;Object<br/>methods, they return arrays of strings in Ruby 1.8 and arrays of symbols in 1.9:<br/>
String.instance_methods == &#34;s&#34;.public_methods &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; true<br/>String.instance_methods(false) == &#34;s&#34;.public_methods(false) &#160;# =&gt; true<br/>String.public_instance_methods == String.instance_methods &#160; &#160;# =&gt; true<br/>String.protected_instance_methods &#160; &#160; &#160; # =&gt; []<br/>String.private_instance_methods(false) &#160;# =&gt; [&#34;initialize_copy&#34;,<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # &#160; &#160; &#34;initialize&#34;]<br/>
Recall&#160;that&#160;the&#160;class&#160;methods&#160;of&#160;a&#160;class&#160;or&#160;module&#160;are&#160;singleton&#160;methods&#160;of&#160;the&#160;Class<br/>or&#160;Module&#160;object. So to list class methods, use&#160;Object.singleton_methods:<br/>
Math.singleton_methods &#160;# =&gt; [&#34;acos&#34;, &#34;log10&#34;, &#34;atan2&#34;, ... ]<br/>
In&#160;addition&#160;to&#160;these&#160;listing&#160;methods,&#160;the&#160;Module&#160;class&#160;defines&#160;some&#160;predicates&#160;for&#160;testing<br/>whether a specified class or module defines a named instance method:<br/>
String.public_method_defined? :reverse &#160; &#160; # =&gt; true<br/>String.protected_method_defined? :reverse &#160;# =&gt; false<br/>String.private_method_defined? :initialize # =&gt; true<br/>String.method_defined? :upcase! &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; true<br/>
Module.method_defined?&#160;checks&#160;whether&#160;the&#160;named&#160;method&#160;is&#160;defined&#160;as&#160;a&#160;public&#160;or<br/>protected&#160;&#160;method.&#160;&#160;It&#160;&#160;serves&#160;&#160;essentially&#160;&#160;the&#160;&#160;same&#160;&#160;purpose&#160;&#160;as&#160;&#160;Object.respond_to?.&#160;&#160;In<br/>Ruby&#160;1.9,&#160;you&#160;can&#160;pass&#160;false&#160;as&#160;the&#160;second&#160;argument&#160;to&#160;specify&#160;that&#160;inherited&#160;methods<br/>should not be considered.<br/>
<b>8.4.2 &#160;Obtaining Method Objects<br/></b>To&#160;query&#160;a&#160;specific&#160;named&#160;method,&#160;call&#160;method&#160;on&#160;any&#160;object&#160;or&#160;instance_method&#160;on<br/>any&#160;module.&#160;The&#160;former&#160;returns&#160;a&#160;callable&#160;Method&#160;object&#160;bound&#160;to&#160;the&#160;receiver,&#160;and&#160;the<br/>latter&#160;returns&#160;an&#160;UnboundMethod.&#160;In&#160;Ruby&#160;1.9,&#160;you&#160;can&#160;limit&#160;your&#160;search&#160;to&#160;public&#160;meth-<br/>ods&#160;by&#160;calling&#160;public_method&#160;and&#160;public_instance_method.&#160;We&#160;covered&#160;these&#160;methods<br/><a href="Rubys.html#217">and the objects they return in §6.7:</a><br/>
&#34;s&#34;.method(:reverse) &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; Method object&#160;<br/>String.instance_method(:reverse) # =&gt; UnboundMethod object<br/>
<b>8.4 &#160;Methods&#160;|&#160;273</b><br/>
<hr/>
<a name=288></a><b>8.4.3 &#160;Invoking Methods<br/></b>As noted earlier,<a href="Rubys.html#217">&#160;and in&#160;§6.7, you can use&#160;</a>the&#160;method&#160;method&#160;of&#160;any&#160;object&#160;to&#160;obtain&#160;a<br/>Method&#160;object&#160;that&#160;represents&#160;a&#160;named&#160;method&#160;of&#160;that&#160;object.&#160;Method&#160;objects&#160;have&#160;a<br/>call&#160;method just like&#160;Proc&#160;objects do; you can use it to invoke the method.<br/>
Usually, it is simpler to invoke a named method of a specified object with&#160;send:<br/>
&#34;hello&#34;.send :upcase &#160; &#160; &#160; &#160;# =&gt; &#34;HELLO&#34;: invoke an instance method<br/>Math.send(:sin, Math::PI/2) # =&gt; 1.0: invoke a class method<br/>
send&#160;&#160;invokes&#160;&#160;on&#160;&#160;its&#160;&#160;receiver&#160;&#160;the&#160;&#160;method&#160;&#160;named&#160;&#160;by&#160;&#160;its&#160;&#160;first&#160;&#160;argument,&#160;&#160;passing&#160;&#160;any<br/>remaining&#160;&#160;arguments&#160;&#160;to&#160;&#160;that&#160;&#160;method.&#160;&#160;The&#160;&#160;name&#160;&#160;“send”&#160;&#160;derives&#160;&#160;from&#160;&#160;the&#160;&#160;object-<br/>oriented&#160;idiom&#160;in&#160;which&#160;invoking&#160;a&#160;method&#160;is&#160;called&#160;“sending&#160;a&#160;message”&#160;to&#160;an&#160;object.<br/>
send&#160;can&#160;invoke&#160;any&#160;named&#160;method&#160;of&#160;an&#160;object,&#160;including&#160;private&#160;and&#160;protected&#160;meth-<br/>ods.&#160;We&#160;saw&#160;send&#160;used&#160;earlier&#160;to&#160;invoke&#160;the&#160;private&#160;method&#160;remove_const&#160;of&#160;a&#160;Module<br/>object.&#160;&#160;Because&#160;&#160;global&#160;&#160;functions&#160;&#160;are&#160;&#160;really&#160;&#160;private&#160;&#160;methods&#160;&#160;of&#160;&#160;Object,&#160;&#160;we&#160;&#160;can&#160;&#160;use<br/>send&#160;to&#160;invoke&#160;these&#160;methods&#160;on&#160;any&#160;object&#160;(though&#160;this&#160;is&#160;not&#160;anything&#160;that&#160;we’d&#160;ever<br/>actually want to do):<br/>
&#34;hello&#34;.send :puts, &#34;world&#34; &#160; &#160; &#160; &#160; # prints &#34;world&#34;<br/>
Ruby&#160;1.9&#160;defines&#160;public_send&#160;as&#160;an&#160;alternative&#160;to&#160;send.&#160;This&#160;method&#160;works&#160;like&#160;send,<br/>but will only invoke public methods, not private or protected methods:<br/>
&#34;hello&#34;.public_send :puts, &#34;world&#34; &#160;# raises NoMethodError<br/>
send&#160;is&#160;a&#160;very&#160;fundamental&#160;method&#160;of&#160;Object,&#160;but&#160;it&#160;has&#160;a&#160;common&#160;name&#160;that&#160;might&#160;be<br/>overridden&#160;in&#160;subclasses.&#160;Therefore,&#160;Ruby&#160;defines&#160;__send__&#160;as&#160;a&#160;synonym,&#160;and&#160;issues&#160;a<br/>warning if you attempt to delete or redefine&#160;__send__.<br/>
<b>8.4.4 &#160;Defining, Undefining, and Aliasing Methods<br/></b>If you want&#160;to&#160;define&#160;a&#160;new&#160;instance&#160;method&#160;of&#160;a&#160;class&#160;or&#160;module,&#160;use&#160;define_method.&#160;<br/>This instance method of&#160;Module&#160;takes&#160;the&#160;name&#160;of&#160;the&#160;new&#160;method&#160;(as&#160;a&#160;Symbol) as its<br/>first&#160;argument.&#160;The&#160;body&#160;of&#160;the&#160;method&#160;is&#160;provided&#160;either&#160;by&#160;a&#160;Method&#160;object&#160;passed&#160;as<br/>the&#160;second&#160;argument&#160;or&#160;by&#160;a&#160;block.&#160;It&#160;is&#160;important&#160;to&#160;understand&#160;that&#160;define_method&#160;is<br/>private.&#160;You&#160;must&#160;be&#160;inside&#160;the&#160;class&#160;or&#160;module&#160;you&#160;want&#160;to&#160;use&#160;it&#160;on&#160;in&#160;order&#160;to&#160;call&#160;it:<br/>
# Add an instance method named m to class c with body b&#160;<br/>def add_method(c, m, &amp;b)<br/>&#160; c.class_eval {<br/>&#160; &#160; define_method(m, &amp;b)<br/>&#160; }<br/>end<br/>
add_method(String, :greet) { &#34;Hello, &#34; + self }<br/>
&#34;world&#34;.greet &#160; # =&gt; &#34;Hello, world&#34;<br/>
<b>274&#160;|&#160;Chapter 8:</b> <b>Reflection and Metaprogramming</b><br/>
<hr/>
<a name=289></a><b>Defining Attribute Accessor Methods</b><br/>
The&#160;attr_reader&#160;and&#160;attr_accessor&#160;methods&#160;(see&#160;<a href="Rubys.html#231">§7.1.5)&#160;</a>also&#160;define&#160;new&#160;methods&#160;for<br/>a&#160;class.&#160;Like&#160;define_method,&#160;these&#160;are&#160;private&#160;methods&#160;of&#160;Module&#160;and&#160;can&#160;easily&#160;be&#160;im-<br/>plemented&#160;in&#160;terms&#160;of&#160;define_method.&#160;These&#160;method-creation&#160;methods&#160;are&#160;an&#160;excellent<br/>example&#160;of&#160;how&#160;define_method&#160;is&#160;useful.&#160;Notice&#160;that&#160;because&#160;these&#160;methods&#160;are&#160;inten-<br/>ded&#160;&#160;to&#160;&#160;be&#160;&#160;used&#160;&#160;inside&#160;&#160;a&#160;&#160;class&#160;&#160;definition,&#160;&#160;they&#160;&#160;are&#160;&#160;not&#160;&#160;hampered&#160;&#160;by&#160;&#160;the&#160;&#160;fact&#160;&#160;that<br/>define_method&#160;is private.<br/>
To&#160;define&#160;a&#160;class&#160;method&#160;(or&#160;any&#160;singleton&#160;method)&#160;with&#160;define_method,&#160;invoke&#160;it&#160;on<br/>the eigenclass:<br/>
def add_class_method(c, m, &amp;b)<br/>&#160; eigenclass = class &lt;&lt; c; self; end<br/>&#160; eigenclass.class_eval {<br/>&#160; &#160; define_method(m, &amp;b)<br/>&#160; }<br/>end<br/>
add_class_method(String, :greet) {|name| &#34;Hello, &#34; + name }<br/>
String.greet(&#34;world&#34;) &#160;# =&gt; &#34;Hello, world&#34;<br/>
In&#160;Ruby&#160;1.9,&#160;you&#160;can&#160;more&#160;easily&#160;use&#160;define_singleton_method,&#160;which&#160;is&#160;a&#160;method&#160;of<br/>Object:<br/>
String.define_singleton_method(:greet) {|name| &#34;Hello, &#34; + name }<br/>
One&#160;shortcoming&#160;of&#160;define_method&#160;is&#160;that&#160;it&#160;does&#160;not&#160;allow&#160;you&#160;to&#160;specify&#160;a&#160;method<br/>body&#160;that&#160;expects&#160;a&#160;block.&#160;If&#160;you&#160;need&#160;to&#160;dynamically&#160;create&#160;a&#160;method&#160;that&#160;accepts&#160;a<br/>block, you will need to use the&#160;def&#160;statement with&#160;class_eval. And if the method you<br/>are&#160;&#160;creating&#160;&#160;is&#160;&#160;sufficiently&#160;&#160;dynamic,&#160;&#160;you&#160;&#160;may&#160;&#160;not&#160;&#160;be&#160;&#160;able&#160;&#160;to&#160;&#160;pass&#160;&#160;a&#160;&#160;block&#160;&#160;to<br/>class_eval&#160;&#160;and&#160;&#160;will&#160;&#160;instead&#160;&#160;have&#160;&#160;to&#160;&#160;specify&#160;&#160;the&#160;&#160;method&#160;&#160;definition&#160;&#160;as&#160;&#160;a&#160;&#160;string&#160;&#160;to&#160;&#160;be<br/>evaluated. We’ll see examples of this later in the chapter.<br/>To&#160;create&#160;a&#160;synonym&#160;or&#160;an&#160;alias&#160;for&#160;an&#160;existing&#160;method,&#160;you&#160;can&#160;normally&#160;use&#160;the<br/>alias&#160;statement:<br/>
alias plus + &#160; &#160; &#160; &#160; # Make &#34;plus&#34; a synonym for the + operator<br/>
When&#160;programming&#160;dynamically,&#160;however,&#160;you&#160;sometimes&#160;need&#160;to&#160;use&#160;alias_method<br/>instead.&#160;Like&#160;define_method,&#160;alias_method&#160;is&#160;a&#160;private&#160;method&#160;of&#160;Module.&#160;As&#160;a&#160;method,<br/>it&#160;&#160;can&#160;&#160;accept&#160;&#160;two&#160;&#160;arbitrary&#160;&#160;expressions&#160;&#160;as&#160;&#160;its&#160;&#160;arguments,&#160;&#160;rather&#160;&#160;than&#160;&#160;requiring&#160;&#160;two<br/>identifiers&#160;to&#160;be&#160;hardcoded&#160;in&#160;your&#160;source&#160;code.&#160;(As&#160;a&#160;method,&#160;it&#160;also&#160;requires&#160;a&#160;comma<br/>between&#160;&#160;its&#160;&#160;arguments.)&#160;&#160;alias_method&#160;&#160;is&#160;&#160;often&#160;&#160;used&#160;&#160;for&#160;&#160;<i>alias&#160;&#160;chaining</i>&#160;&#160;existing<br/>methods. Here is a simple example; we’ll see more later in the chapter:<br/>
# Create an alias for the method m in the class (or module) c<br/>def backup(c, m, prefix=&#34;original&#34;)<br/>&#160; n = :&#34;#{prefix}_#{m}&#34; &#160; &#160;# Compute the alias<br/>&#160; c.class_eval { &#160; &#160; &#160; &#160; &#160; # Because alias_method is private<br/>
<b>8.4 &#160;Methods&#160;|&#160;275</b><br/>
<hr/>
<a name=290></a>&#160; &#160; alias_method n, m &#160; &#160; &#160;# Make n an alias for m<br/>&#160; }<br/>end<br/>
backup(String, :reverse)<br/>&#34;test&#34;.original_reverse # =&gt; &#34;tset&#34;<br/>
As&#160;we&#160;learned&#160;<a href="Rubys.html#193">in&#160;§6.1.5,&#160;</a>you&#160;can&#160;use&#160;the&#160;undef&#160;statement&#160;to&#160;undefine&#160;a&#160;method.&#160;This<br/>works&#160;only&#160;if&#160;you&#160;can&#160;express&#160;the&#160;name&#160;of&#160;a&#160;method&#160;as&#160;a&#160;hardcoded&#160;identifier&#160;in&#160;your<br/>program.&#160;If&#160;you&#160;need&#160;to&#160;dynamically&#160;delete&#160;a&#160;method&#160;whose&#160;name&#160;has&#160;been&#160;computed<br/>by&#160;your&#160;program,&#160;you&#160;have&#160;two&#160;choices:&#160;remove_method&#160;or&#160;undef_method. Both are pri-<br/>vate methods of&#160;Module.&#160;remove_method&#160;removes the definition of the method from the<br/>current&#160;class.&#160;If&#160;there&#160;is&#160;a&#160;version&#160;defined&#160;by&#160;a&#160;superclass,&#160;that&#160;version&#160;will&#160;now&#160;be<br/>inherited.&#160;&#160;undef_method&#160;&#160;is&#160;&#160;more&#160;&#160;severe;&#160;&#160;it&#160;&#160;prevents&#160;&#160;any&#160;&#160;invocation&#160;&#160;of&#160;&#160;the&#160;&#160;specified<br/>method&#160;through&#160;an&#160;instance&#160;of&#160;the&#160;class,&#160;even&#160;if&#160;there&#160;is&#160;an&#160;inherited&#160;version&#160;of&#160;that<br/>method.<br/>If&#160;you&#160;define&#160;a&#160;class&#160;and&#160;want&#160;to&#160;prevent&#160;any&#160;dynamic&#160;alterations&#160;to&#160;it,&#160;simply&#160;invoke<br/>the&#160;freeze&#160;method of the class. Once frozen, a class cannot be altered.<br/>
<b>8.4.5 &#160;Handling Undefined Methods<br/></b>When&#160;the&#160;method&#160;name&#160;resolution&#160;algorithm&#160;<a href="Rubys.html#272">(see&#160;§7.8)&#160;</a>fails&#160;to&#160;find&#160;a&#160;method,&#160;it&#160;looks<br/>up&#160;a&#160;method&#160;named&#160;method_missing&#160;instead.&#160;When&#160;this&#160;method&#160;is&#160;invoked,&#160;the&#160;first<br/>argument&#160;is&#160;a&#160;symbol&#160;that&#160;names&#160;the&#160;method&#160;that&#160;could&#160;not&#160;be&#160;found.&#160;This&#160;symbol&#160;is<br/>followed&#160;by&#160;all&#160;the&#160;arguments&#160;that&#160;were&#160;to&#160;be&#160;passed&#160;to&#160;the&#160;original&#160;method.&#160;If&#160;there&#160;is<br/>a&#160;&#160;block&#160;&#160;associated&#160;&#160;with&#160;&#160;the&#160;&#160;method&#160;&#160;invocation,&#160;&#160;that&#160;&#160;block&#160;&#160;is&#160;&#160;passed&#160;&#160;to<br/>method_missing&#160;as well.<br/>
The&#160;default&#160;implementation&#160;of&#160;method_missing,&#160;in&#160;the&#160;Kernel&#160;module,&#160;simply&#160;raises a<br/>NoMethodError.&#160;This&#160;exception,&#160;if&#160;uncaught,&#160;causes&#160;the&#160;program&#160;to&#160;exit&#160;with&#160;an&#160;error<br/>message,&#160;which&#160;is&#160;what&#160;you&#160;would&#160;normally&#160;expect&#160;to&#160;happen&#160;when&#160;you&#160;try&#160;to&#160;invoke<br/>a method that does not exist.<br/>Defining&#160;your&#160;own&#160;method_missing&#160;method&#160;for&#160;a&#160;class&#160;allows&#160;you&#160;an&#160;opportunity&#160;to<br/>handle&#160;any&#160;kind&#160;of&#160;invocation&#160;on&#160;instances&#160;of&#160;the&#160;class.&#160;The&#160;method_missing&#160;hook&#160;is<br/>one&#160;of&#160;the&#160;most&#160;powerful&#160;of&#160;Ruby’s&#160;dynamic&#160;capabilities,&#160;and&#160;one&#160;of&#160;the&#160;most&#160;com-<br/>monly&#160;used&#160;metaprogramming&#160;techniques.&#160;We’ll&#160;see&#160;examples&#160;of&#160;its&#160;use&#160;later&#160;in&#160;this<br/>chapter.&#160;For&#160;now,&#160;the&#160;following&#160;example&#160;code&#160;adds&#160;a&#160;method_missing&#160;method&#160;to&#160;the<br/>Hash&#160;class.&#160;It&#160;allows&#160;us&#160;to&#160;query&#160;or&#160;set&#160;the&#160;value&#160;of&#160;any&#160;named&#160;key&#160;as&#160;if&#160;the&#160;key&#160;were&#160;the<br/>name of a method:<br/>
class Hash<br/>&#160; # Allow hash values to be queried and set as if they were attributes.<br/>&#160; # We simulate attribute getters and setters for any key.<br/>&#160; def method_missing(key, *args)<br/>&#160; &#160; text = key.to_s<br/>
&#160; &#160; if text[-1,1] == &#34;=&#34; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # If key ends with = set a value<br/>
<b>276&#160;|&#160;Chapter 8:</b> <b>Reflection and Metaprogramming</b><br/>
<hr/>
<a name=291></a>&#160; &#160; &#160; self[text.chop.to_sym] = args[0] # Strip = from key<br/>&#160; &#160; else &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Otherwise...<br/>&#160; &#160; &#160; self[key] &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# ...just return the key value<br/>&#160; &#160; end<br/>&#160; end<br/>end<br/>
h = {} &#160; &#160; &#160; &#160; # Create an empty hash object<br/>h.one = 1 &#160; &#160; &#160;# Same as h[:one] = 1<br/>puts h.one &#160; &#160; # Prints 1. Same as puts h[:one]<br/>
<b>8.4.6 &#160;Setting Method Visibility<br/></b><a href="Rubys.html#246">§7.2&#160;</a>introducedpublic,&#160;protected,&#160;and&#160;private.&#160;These&#160;look&#160;like&#160;language&#160;keywords&#160;but<br/>are&#160;actually&#160;private&#160;instance&#160;methods&#160;defined&#160;by&#160;Module.&#160;These&#160;methods&#160;are&#160;usually<br/>used&#160;as&#160;a&#160;static&#160;part&#160;of&#160;a&#160;class&#160;definition.&#160;But,&#160;with&#160;class_eval,&#160;they&#160;can&#160;also&#160;be&#160;used<br/>dynamically:<br/>
String.class_eval { private :reverse }<br/>&#34;hello&#34;.reverse &#160;# NoMethodError: private method 'reverse'<br/>
private_class_method&#160;and&#160;public_class_method&#160;are&#160;similar,&#160;except&#160;that&#160;they&#160;operate<br/>on class methods and are themselves public:<br/>
# Make all Math methods private<br/># Now we have to include Math in order to invoke its methods<br/>Math.private_class_method *Math.singleton_methods<br/>
<b>8.5 &#160;Hooks<br/></b>Module,&#160;Class, and&#160;Objectimplement several callback&#160;methods, or&#160;<i>hooks</i>. These meth-<br/>ods&#160;are&#160;not&#160;defined&#160;by&#160;default,&#160;but&#160;if&#160;you&#160;define&#160;them&#160;for&#160;a&#160;module,&#160;class,&#160;or&#160;object,<br/>then&#160;they&#160;will&#160;be&#160;invoked&#160;when&#160;certain&#160;events&#160;occur.&#160;This&#160;gives&#160;you&#160;an&#160;opportunity&#160;to<br/>extend&#160;Ruby’s&#160;behavior&#160;when&#160;classes&#160;are&#160;subclassed,&#160;when&#160;modules&#160;are&#160;included,&#160;or<br/>when&#160;&#160;methods&#160;&#160;are&#160;&#160;defined.&#160;&#160;Hook&#160;&#160;methods&#160;&#160;(except&#160;&#160;for&#160;&#160;some&#160;&#160;deprecated&#160;&#160;ones&#160;&#160;not<br/>described here) have names that end in “ed.”<br/>When&#160;a&#160;new&#160;class&#160;is&#160;defined,&#160;Ruby&#160;invokes&#160;the&#160;class&#160;method&#160;inherited&#160;on&#160;the&#160;superclass<br/>of&#160;the&#160;new&#160;class,&#160;passing&#160;the&#160;new&#160;class&#160;object&#160;as&#160;the&#160;argument.&#160;This&#160;allows&#160;classes&#160;to<br/>add&#160;behavior&#160;to&#160;or&#160;enforce&#160;constraints&#160;on&#160;their&#160;descendants.&#160;Recall&#160;that&#160;class&#160;methods<br/>are&#160;inherited,&#160;so&#160;that&#160;the&#160;an&#160;inherited&#160;method&#160;will&#160;be&#160;invoked&#160;if&#160;it&#160;is&#160;defined&#160;by&#160;any&#160;of<br/>the&#160;ancestors&#160;of&#160;the&#160;new&#160;class.&#160;Define&#160;Object.inherited&#160;to&#160;receive&#160;notification&#160;of&#160;all<br/>new classes that are defined:<br/>
def Object.inherited(c)<br/>&#160; puts &#34;class #{c} &lt; #{self}&#34;<br/>end<br/>
When&#160;a&#160;module&#160;is&#160;included&#160;into&#160;a&#160;class&#160;or&#160;into&#160;another&#160;module,&#160;the&#160;included&#160;class<br/>method&#160;of&#160;the&#160;included&#160;module&#160;is&#160;invoked&#160;with&#160;the&#160;class&#160;or&#160;module&#160;object&#160;into&#160;which<br/>
<b>8.5 &#160;Hooks&#160;|&#160;277</b><br/>
<hr/>
<a name=292></a>it&#160;was&#160;included&#160;as&#160;an&#160;argument.&#160;This&#160;gives&#160;the&#160;included&#160;module&#160;an&#160;opportunity&#160;to<br/>augment&#160;or&#160;alter&#160;the&#160;class&#160;in&#160;whatever&#160;way&#160;it&#160;wants—it&#160;effectively&#160;allows&#160;a&#160;module&#160;to<br/>define&#160;its&#160;own&#160;meaning&#160;for&#160;include.&#160;In&#160;addition&#160;to&#160;adding&#160;methods&#160;to&#160;the&#160;class&#160;into<br/>which&#160;it&#160;is&#160;included,&#160;a&#160;module&#160;with&#160;an&#160;included&#160;method&#160;might&#160;also&#160;alter&#160;the&#160;existing<br/>methods of that class, for example:<br/>
module Final &#160; &#160; &#160; &#160; &#160; &#160; # A class that includes Final can't be subclassed<br/>&#160; def self.included(c) &#160; # When included in class c<br/>&#160; &#160; c.instance_eval do &#160; # Define a class method of c<br/>&#160; &#160; &#160; def inherited(sub) # To detect subclasses<br/>&#160; &#160; &#160; &#160; raise Exception, # And abort with an exception<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#34;Attempt to create subclass #{sub} of Final class #{self}&#34;<br/>&#160; &#160; &#160; end<br/>&#160; &#160; end<br/>&#160; end<br/>end<br/>
Similarly,&#160;if&#160;a&#160;module&#160;defines&#160;a&#160;class&#160;method&#160;named&#160;extended,&#160;that&#160;method&#160;will&#160;be<br/>invoked&#160;any&#160;time&#160;the&#160;module&#160;is&#160;used&#160;to&#160;extend&#160;an&#160;object&#160;(with&#160;Object.extend).&#160;The<br/>argument to the&#160;extended&#160;method&#160;will&#160;be&#160;the&#160;object&#160;that&#160;was&#160;extended,&#160;of&#160;course,&#160;and<br/>the&#160;extended&#160;method can take whatever actions it wants on that object.<br/>In&#160;addition&#160;to&#160;hooks&#160;for&#160;tracking&#160;classes&#160;and&#160;the&#160;modules&#160;they&#160;include,&#160;there&#160;are&#160;also<br/>hooks&#160;for&#160;tracking&#160;the&#160;methods&#160;of&#160;classes&#160;and&#160;modules&#160;and&#160;the&#160;singleton&#160;methods&#160;of<br/>arbitrary&#160;objects.&#160;Define&#160;a&#160;class&#160;method&#160;named&#160;method_added&#160;for&#160;any&#160;class&#160;or&#160;module<br/>and it will be invoked when an instance method is defined for that class or module:<br/>
def String.method_added(name)&#160;<br/>&#160; puts &#34;New instance method #{name} added to String&#34;<br/>end<br/>
Note&#160;that&#160;the&#160;method_added&#160;class&#160;method&#160;is&#160;inherited&#160;by&#160;subclasses&#160;of&#160;the&#160;class&#160;on&#160;which<br/>it&#160;is&#160;defined.&#160;But&#160;no&#160;class&#160;argument&#160;is&#160;passed&#160;to&#160;the&#160;hook,&#160;so&#160;there&#160;is&#160;no&#160;way&#160;to&#160;tell<br/>whether&#160;the&#160;named&#160;method&#160;was&#160;added&#160;to&#160;the&#160;class&#160;that&#160;defines&#160;method_added&#160;or&#160;whether<br/>it&#160;was&#160;added&#160;to&#160;a&#160;subclass&#160;of&#160;that&#160;class.&#160;A&#160;workaround&#160;for&#160;this&#160;problem&#160;is&#160;to&#160;define&#160;an<br/>inherited&#160;hook&#160;on&#160;any&#160;class&#160;that&#160;defines&#160;a&#160;method_added&#160;hook. The&#160;inherited&#160;method<br/>can then define a&#160;method_added&#160;method for each subclass.<br/>When&#160;&#160;a&#160;&#160;singleton&#160;&#160;method&#160;&#160;is&#160;&#160;defined&#160;&#160;for&#160;&#160;any&#160;&#160;object,&#160;&#160;the&#160;&#160;method<br/>singleton_method_added&#160;is&#160;invoked&#160;on&#160;that&#160;object,&#160;passing&#160;the&#160;name&#160;of&#160;the&#160;new&#160;method.<br/>Remember that for classes, singleton methods are class methods:<br/>
def String.singleton_method_added(name)<br/>&#160; puts &#34;New class method #{name} added to String&#34;<br/>end<br/>
Interestingly,&#160;Ruby&#160;invokes&#160;this&#160;singleton_method_added&#160;hook&#160;when&#160;the&#160;hook&#160;method<br/>itself&#160;&#160;is&#160;&#160;first&#160;&#160;defined.&#160;&#160;Here&#160;&#160;is&#160;&#160;another&#160;&#160;use&#160;&#160;of&#160;&#160;the&#160;&#160;hook.&#160;&#160;In&#160;&#160;this&#160;&#160;case,<br/>singleton_method_added&#160;is&#160;defined&#160;as&#160;an&#160;instance&#160;method&#160;of&#160;any&#160;class&#160;that&#160;includes&#160;a<br/>module. It is notified of any singleton methods added to instances of that class:<br/>
<b>278&#160;|&#160;Chapter 8:</b> <b>Reflection and Metaprogramming</b><br/>
<hr/>
<a name=293></a># Including this module in a class prevents instances of that class<br/># from having singleton methods added to them. Any singleton methods added<br/># are immediately removed again.<br/>module Strict<br/>&#160; def singleton_method_added(name)<br/>&#160; &#160; STDERR.puts &#34;Warning: singleton #{name} added to a Strict object&#34;<br/>&#160; &#160; eigenclass = class &lt;&lt; self; self; end<br/>&#160; &#160; eigenclass.class_eval { remove_method name }<br/>&#160; end<br/>end<br/>
In addition to&#160;method_added&#160;and&#160;singleton_method_added, there are hooks for tracking<br/>when&#160;instance&#160;methods&#160;and&#160;singleton&#160;methods&#160;are&#160;removed&#160;or&#160;undefined.&#160;When&#160;an<br/>instance&#160;&#160;method&#160;&#160;is&#160;&#160;removed&#160;&#160;or&#160;&#160;undefined&#160;&#160;on&#160;&#160;a&#160;&#160;class&#160;&#160;or&#160;&#160;module,&#160;&#160;the&#160;&#160;class&#160;&#160;methods<br/>method_removed&#160;and&#160;method_undefined&#160;are&#160;invoked&#160;on&#160;that&#160;module.&#160;When&#160;a&#160;singleton<br/>method&#160;<br/>
is&#160;<br/>
removed&#160;<br/>
or&#160;<br/>
undefined&#160;<br/>
on&#160;<br/>
an&#160;<br/>
object,&#160;<br/>
the&#160;<br/>
methods<br/>
singleton_method_removed&#160;and&#160;singleton_method_undefined&#160;are&#160;invoked&#160;on&#160;that&#160;object.<br/>
Finally,&#160;&#160;note&#160;&#160;that&#160;&#160;the&#160;&#160;method_missing&#160;&#160;and&#160;&#160;const_missing&#160;&#160;methods&#160;&#160;documented<br/>elsewhere in this chapter also behave like hook methods.<br/>
<b>8.6 &#160;Tracing<br/></b>Ruby&#160;defines&#160;a&#160;number&#160;of&#160;features&#160;for&#160;tracing&#160;the&#160;execution&#160;of&#160;a&#160;program.&#160;These&#160;are<br/>mainly&#160;useful&#160;for&#160;debugging&#160;code&#160;and&#160;printing&#160;informative&#160;error&#160;messages.&#160;Two&#160;of&#160;the<br/>simplest&#160;features&#160;are&#160;actual&#160;language&#160;keywords:&#160;__FILE__&#160;and&#160;__LINE__.&#160;These&#160;keyword<br/>expressions&#160;always&#160;evaluate&#160;to&#160;the&#160;name&#160;of&#160;the&#160;file&#160;and&#160;the&#160;line&#160;number&#160;within&#160;that&#160;file<br/>on&#160;which&#160;they&#160;appear,&#160;and&#160;they&#160;allow&#160;an&#160;error&#160;message&#160;to&#160;specify&#160;the&#160;exact&#160;location&#160;at<br/>which it was generated:<br/>
STDERR.puts &#34;#{__FILE__}:#{__LINE__): invalid data&#34;<br/>
As&#160;&#160;an&#160;&#160;aside,&#160;&#160;note&#160;&#160;that&#160;&#160;the&#160;&#160;methods&#160;&#160;Kernel.eval,&#160;&#160;Object.instance_eval,&#160;&#160;and<br/>Module.class_eval&#160;all&#160;accept&#160;a&#160;filename&#160;(or&#160;other&#160;string)&#160;and&#160;a&#160;line&#160;number&#160;as&#160;their&#160;final<br/>two&#160;arguments.&#160;If&#160;you&#160;are&#160;evaluating&#160;code&#160;that&#160;you&#160;have&#160;extracted&#160;from&#160;a&#160;file&#160;of&#160;some<br/>sort,&#160;you&#160;can&#160;use&#160;these&#160;arguments&#160;to&#160;specify&#160;the&#160;values&#160;of&#160;__FILE__&#160;and&#160;__LINE__&#160;for<br/>the evaluation.<br/>You&#160;have&#160;undoubtedly&#160;noticed&#160;that&#160;when&#160;an&#160;exception&#160;is&#160;raised&#160;and&#160;not&#160;handled,&#160;the<br/>error&#160;message&#160;printed&#160;to&#160;the&#160;console&#160;contains&#160;filename&#160;and&#160;line&#160;number&#160;information.<br/>This&#160;information&#160;is&#160;based&#160;on&#160;__FILE__&#160;and&#160;__LINE__,&#160;of&#160;course.&#160;Every&#160;Exception&#160;object<br/>has&#160;a&#160;<i>backtrace</i>&#160;associated&#160;with&#160;it&#160;that&#160;shows&#160;exactly&#160;where&#160;it&#160;was&#160;raised,&#160;where&#160;the<br/>method&#160;that&#160;raised&#160;the&#160;exception&#160;was&#160;invoked,&#160;where&#160;that&#160;method&#160;was&#160;invoked,&#160;and<br/>so&#160;&#160;on.&#160;&#160;The&#160;&#160;Exception.backtrace&#160;&#160;method&#160;&#160;returns&#160;&#160;an&#160;&#160;array&#160;&#160;of&#160;&#160;strings&#160;&#160;containing&#160;&#160;this<br/>information.&#160;&#160;The&#160;&#160;first&#160;&#160;element&#160;&#160;of&#160;&#160;this&#160;&#160;array&#160;&#160;is&#160;&#160;the&#160;&#160;location&#160;&#160;at&#160;&#160;which&#160;&#160;the&#160;&#160;exception<br/>occurred, and each subsequent element is one stack frame higher.<br/>You&#160;&#160;needn’t&#160;&#160;raise&#160;&#160;an&#160;&#160;exception&#160;&#160;to&#160;&#160;obtain&#160;&#160;a&#160;&#160;current&#160;&#160;stack&#160;&#160;trace,&#160;&#160;however.&#160;&#160;The<br/>Kernel.caller&#160;method&#160;returns&#160;the&#160;current&#160;state&#160;of&#160;the&#160;call&#160;stack&#160;in&#160;the&#160;same&#160;form&#160;as<br/>
<b>8.6 &#160;Tracing&#160;|&#160;279</b><br/>
<hr/>
<a name=294></a>Exception.backtrace.&#160;With&#160;no&#160;argument,&#160;caller&#160;returns&#160;a&#160;stack&#160;trace&#160;whose&#160;first&#160;ele-<br/>ment&#160;&#160;is&#160;&#160;the&#160;&#160;method&#160;&#160;that&#160;&#160;invoked&#160;&#160;the&#160;&#160;method&#160;&#160;that&#160;&#160;calls&#160;&#160;caller.&#160;&#160;That&#160;&#160;is,&#160;&#160;caller[0]<br/>specifies&#160;the&#160;location&#160;from&#160;which&#160;the&#160;current&#160;method&#160;was&#160;invoked.&#160;You&#160;can&#160;also&#160;invoke<br/>caller&#160;with&#160;an&#160;argument&#160;that&#160;specifies&#160;how&#160;many&#160;stack&#160;frames&#160;to&#160;drop&#160;from&#160;the&#160;start<br/>of&#160;the&#160;backtrace.&#160;The&#160;default&#160;is&#160;1,&#160;and&#160;caller(0)[0]&#160;specifies&#160;the&#160;location&#160;at&#160;which&#160;the<br/>caller&#160;method&#160;is&#160;invoked.&#160;This&#160;means,&#160;for&#160;example,&#160;that&#160;caller[0]&#160;is&#160;the&#160;same&#160;thing<br/>as&#160;caller(0)[1]&#160;and that&#160;caller(2)&#160;is the same as&#160;caller[1..-1].<br/>Stack traces returned by&#160;Exception.backtrace&#160;and&#160;Kernel.caller&#160;also include method<br/>names.&#160;Prior&#160;to&#160;Ruby&#160;1.9,&#160;you&#160;must&#160;parse&#160;the&#160;stack&#160;trace&#160;strings&#160;to&#160;extract&#160;method<br/>names. In&#160;Ruby&#160;1.9,&#160;however,&#160;you&#160;can&#160;obtain&#160;the&#160;name&#160;(as&#160;a&#160;symbol)&#160;of&#160;the&#160;currently<br/>executing&#160;&#160;method&#160;&#160;with&#160;&#160;Kernel.__method__&#160;&#160;or&#160;&#160;its&#160;&#160;synonym,&#160;&#160;Kernel.__callee__.<br/>__method__&#160;is useful in conjunction with&#160;__FILE__&#160;and&#160;__LINE__:<br/>
raise &#34;Assertion failed in #{__method__} at #{__FILE__}:#{__LINE__}&#34;<br/>
Note&#160;that&#160;__method__&#160;returns&#160;the&#160;name&#160;by&#160;which&#160;a&#160;method&#160;was&#160;originally&#160;defined,&#160;even<br/>if the method was invoked through an alias.<br/>Instead&#160;of&#160;simply&#160;printing&#160;the&#160;filename&#160;and&#160;number&#160;at&#160;which&#160;an&#160;error&#160;occurs,&#160;you&#160;can<br/>take&#160;it&#160;one&#160;step&#160;further&#160;and&#160;display&#160;the&#160;actual&#160;line&#160;of&#160;code.&#160;If&#160;your&#160;program&#160;defines&#160;a<br/>global&#160;constant&#160;named&#160;SCRIPT_LINES__&#160;and&#160;sets&#160;it&#160;equal&#160;to&#160;a&#160;hash,&#160;then&#160;the&#160;require&#160;and<br/>load&#160;methods&#160;add&#160;an&#160;entry&#160;to&#160;this&#160;hash&#160;for&#160;each&#160;file&#160;they&#160;load.&#160;The&#160;hash&#160;keys&#160;are&#160;file-<br/>names&#160;and&#160;the&#160;values&#160;associated&#160;with&#160;those&#160;keys&#160;are&#160;arrays&#160;that&#160;contain&#160;the&#160;lines&#160;of<br/>those&#160;files.&#160;If&#160;you&#160;want&#160;to&#160;include&#160;the&#160;main&#160;file&#160;(rather&#160;than&#160;just&#160;the&#160;files&#160;it&#160;requires)&#160;in<br/>the hash, initialize it like this:<br/>
SCRIPT_LINES__ = {__FILE__ =&gt; File.readlines(__FILE__)}<br/>
If&#160;you&#160;do&#160;this,&#160;then&#160;you&#160;can&#160;obtain&#160;the&#160;current&#160;line&#160;of&#160;source&#160;code&#160;anywhere&#160;in&#160;your<br/>program with this expression:<br/>
SCRIPT_LINES__[__FILE__][__LINE__-1]<br/>
Ruby&#160;allows&#160;you&#160;to&#160;trace&#160;assignments&#160;to&#160;global&#160;variables&#160;with&#160;Kernel.trace_var. Pass&#160;<br/>this&#160;method&#160;a&#160;symbol&#160;that&#160;names&#160;a&#160;global&#160;variable&#160;and&#160;a&#160;string&#160;or&#160;block&#160;of&#160;code.&#160;When<br/>the&#160;value&#160;of&#160;the&#160;named&#160;variable&#160;changes,&#160;the&#160;string&#160;will&#160;be&#160;evaluated&#160;or&#160;the&#160;block&#160;will<br/>be&#160;invoked.&#160;When&#160;a&#160;block&#160;is&#160;specified,&#160;the&#160;new&#160;value&#160;of&#160;the&#160;variable&#160;is&#160;passed&#160;as&#160;an<br/>argument.&#160;&#160;To&#160;&#160;stop&#160;&#160;tracing&#160;&#160;the&#160;&#160;variable,&#160;&#160;call&#160;&#160;Kernel.untrace_var.&#160;&#160;In&#160;&#160;the&#160;&#160;following<br/>example,&#160;note&#160;the&#160;use&#160;of&#160;caller[1]&#160;to&#160;determine&#160;the&#160;program&#160;location&#160;at&#160;which&#160;the<br/>variable tracing block was invoked:<br/>
# Print a message every time $SAFE changes<br/>trace_var(:$SAFE) {|v|<br/>&#160; puts &#34;$SAFE set to #{v} at #{caller[1]}&#34;<br/>}<br/>
The&#160;final&#160;tracing&#160;method&#160;is&#160;Kernel.set_trace_func,&#160;which&#160;registers&#160;a&#160;Proc&#160;to&#160;be&#160;invoked<br/>after&#160;every&#160;line&#160;of&#160;a&#160;Ruby&#160;program.&#160;&#160;set_trace_func&#160;is&#160;useful&#160;if&#160;you&#160;want&#160;to&#160;write&#160;a<br/>
<b>280&#160;|&#160;Chapter 8:</b> <b>Reflection and Metaprogramming</b><br/>
<hr/>
<a name=295></a>debugger&#160;module&#160;that&#160;allows&#160;line-by-line&#160;stepping&#160;through&#160;a&#160;program,&#160;but&#160;we&#160;won’t<br/>cover it in any detail here.<br/>
<b>8.7 &#160;ObjectSpace and GC<br/></b>The&#160;ObjectSpace&#160;module&#160;defines&#160;a&#160;handful&#160;of&#160;low-level&#160;methods&#160;that&#160;can&#160;be&#160;occasion-<br/>ally&#160;&#160;useful&#160;&#160;for&#160;&#160;debugging&#160;&#160;or&#160;&#160;metaprogramming.&#160;&#160;The&#160;&#160;most&#160;&#160;notable&#160;&#160;method&#160;&#160;is<br/>each_object,&#160;an&#160;iterator&#160;that&#160;can&#160;yield&#160;every&#160;object&#160;(or&#160;every&#160;instance&#160;of&#160;a&#160;specified&#160;class)<br/>that the interpreter knows about:<br/>
# Print out a list of all known classes<br/>ObjectSpace.each_object(Class) {|c| puts c }<br/>
ObjectSpace._id2ref&#160;&#160;is&#160;&#160;the&#160;&#160;inverse&#160;&#160;of&#160;&#160;Object.object_id:&#160;&#160;it&#160;&#160;takes&#160;&#160;an&#160;&#160;object&#160;&#160;ID&#160;&#160;as&#160;&#160;its<br/>argument&#160;and&#160;returns&#160;the&#160;corresponding&#160;object,&#160;or&#160;raises&#160;a&#160;RangeError&#160;if&#160;there&#160;is&#160;no<br/>object with that ID.<br/>
ObjectSpace.define_finalizer&#160;allows&#160;the&#160;registration&#160;of&#160;a&#160;Proc&#160;or&#160;a&#160;block&#160;of&#160;code&#160;to&#160;be<br/>invoked&#160;when&#160;a&#160;specified&#160;object&#160;is&#160;garbage&#160;collected.&#160;You&#160;must&#160;be&#160;careful&#160;when&#160;regis-<br/>tering&#160;such&#160;a&#160;finalizer,&#160;however,&#160;as&#160;the&#160;finalizer&#160;block&#160;is&#160;not&#160;allowed&#160;to&#160;use&#160;the&#160;garbage<br/>collected&#160;object.&#160;Any&#160;values&#160;required&#160;to&#160;finalize&#160;the&#160;object&#160;must&#160;be&#160;captured&#160;in&#160;the&#160;scope<br/>of&#160;the&#160;finalizer&#160;block,&#160;so&#160;that&#160;they&#160;are&#160;available&#160;without&#160;dereferencing&#160;the&#160;object.&#160;Use<br/>ObjectSpace.undefine_finalizer&#160;to delete all finalizer blocks registered for an object.<br/>
The&#160;final&#160;ObjectSpace&#160;method&#160;is&#160;ObjectSpace.garbage_collect,&#160;which&#160;forces&#160;Ruby’s<br/>garbage&#160;collector&#160;to&#160;run.&#160;Garbage&#160;collection&#160;functionality&#160;is&#160;also&#160;available&#160;through&#160;the<br/>GC&#160;module.&#160;GC.start&#160;is&#160;a&#160;synonym&#160;for&#160;ObjectSpace.garbage_collect.&#160;Garbage&#160;collection<br/>can&#160;&#160;be&#160;&#160;temporarily&#160;&#160;disabled&#160;&#160;with&#160;&#160;GC.disable,&#160;&#160;and&#160;&#160;it&#160;&#160;can&#160;&#160;be&#160;&#160;enabled&#160;&#160;again&#160;&#160;with<br/>GC.enable.<br/>
The combination of the&#160;_id2ref&#160;and&#160;define_finalizer&#160;methods allows the definition&#160;<br/>of&#160;“weak&#160;reference”&#160;objects,&#160;which&#160;hold&#160;a&#160;reference&#160;to&#160;a&#160;value&#160;without&#160;preventing&#160;the<br/>value&#160;&#160;from&#160;&#160;being&#160;&#160;garbage&#160;&#160;collected&#160;&#160;if&#160;&#160;they&#160;&#160;become&#160;&#160;otherwise&#160;&#160;unreachable.&#160;&#160;See&#160;&#160;the<br/>WeakRef&#160;class in the standard library (in&#160;<i>lib/weakref.rb</i>) for an example.<br/>
<b>8.8 &#160;Custom Control Structures<br/></b>Ruby’s use&#160;of&#160;blocks,&#160;coupled&#160;with&#160;its&#160;parentheses-optional&#160;syntax,&#160;make&#160;it&#160;very&#160;easy<br/>to&#160;define&#160;iterator&#160;methods&#160;that&#160;look&#160;like&#160;and&#160;behave&#160;like&#160;control&#160;structures.&#160;The&#160;loop<br/>method&#160;of&#160;Kernel&#160;is&#160;a&#160;simple&#160;example.&#160;In&#160;this&#160;section&#160;we&#160;develop&#160;three&#160;more&#160;examples.<br/>The&#160;examples&#160;here&#160;use&#160;Ruby’s&#160;threading&#160;API;&#160;you&#160;may&#160;need&#160;to&#160;<a href="Rubys.html#387">read&#160;§9.9&#160;</a>to&#160;understand<br/>all the details.<br/>
<b>8.7 &#160;ObjectSpace and GC&#160;|&#160;281</b><br/>
<hr/>
<a name=296></a><b>8.8.1 &#160;Delaying and Repeating Execution: after and every<br/></b><a href="Rubys.html#296">Example&#160;8-1&#160;</a>defines&#160;global&#160;methods&#160;named&#160;after&#160;and&#160;every.&#160;Each&#160;takes&#160;a&#160;numeric<br/>argument&#160;that&#160;represents&#160;a&#160;number&#160;of&#160;seconds&#160;and&#160;should&#160;have&#160;a&#160;block&#160;associated&#160;with<br/>it.&#160;after&#160;creates&#160;a&#160;new&#160;thread&#160;and&#160;returns&#160;the&#160;Thread&#160;object&#160;immediately.&#160;The&#160;newly<br/>created&#160;&#160;thread&#160;&#160;sleeps&#160;&#160;for&#160;&#160;the&#160;&#160;specified&#160;&#160;number&#160;&#160;of&#160;&#160;seconds&#160;&#160;and&#160;&#160;then&#160;&#160;calls&#160;&#160;(with&#160;&#160;no<br/>arguments)&#160;the&#160;block&#160;you&#160;provided.&#160;every&#160;is&#160;similar,&#160;but&#160;it&#160;calls&#160;the&#160;block&#160;repeatedly,<br/>sleeping&#160;&#160;the&#160;&#160;specified&#160;&#160;number&#160;&#160;of&#160;&#160;seconds&#160;&#160;between&#160;&#160;calls.&#160;&#160;The&#160;&#160;second&#160;&#160;argument&#160;&#160;to<br/>every&#160;is&#160;a&#160;value&#160;to&#160;pass&#160;to&#160;the&#160;first&#160;invocation&#160;of&#160;the&#160;block.&#160;The&#160;return&#160;value&#160;of&#160;each<br/>invocation&#160;becomes&#160;the&#160;value&#160;passed&#160;for&#160;the&#160;next&#160;invocation.&#160;The&#160;block&#160;associated&#160;with<br/>every&#160;can use&#160;break&#160;to prevent any future invocations.<br/>
Here is some example code that uses&#160;after&#160;and&#160;every:<br/>
require 'afterevery'<br/>
1.upto(5) {|i| after i { puts i} } &#160;# Slowly print the numbers 1 to 5<br/>sleep(5) &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Wait five seconds<br/>every 1, 6 do |count| &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Now slowly print 6 to 10<br/>&#160; puts count<br/>&#160; break if count == 10<br/>&#160; count + 1 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # The next value of count<br/>end<br/>sleep(6) &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Give the above time to run<br/>
The&#160;sleep&#160;call&#160;at&#160;the&#160;end&#160;of&#160;this&#160;code&#160;prevents&#160;the&#160;example&#160;program&#160;from&#160;exiting&#160;before<br/>the&#160;thread&#160;created&#160;by&#160;every&#160;can&#160;complete&#160;its&#160;count.&#160;With&#160;that&#160;example&#160;of&#160;how&#160;after<br/>and&#160;every&#160;are&#160;used,&#160;we&#160;are&#160;now&#160;ready&#160;to&#160;present&#160;their&#160;implementation.&#160;Remember&#160;to<br/><a href="Rubys.html#387">consult §9.9 if you don’t understand&#160;</a>Thread.new.<br/>
<i>Example 8-1. The after and every methods</i><br/>
#<br/># Define Kernel methods after and every for deferring blocks of code.<br/># Examples:<br/>#<br/># &#160; after 1 { puts &#34;done&#34; }<br/># &#160; every 60 { redraw_clock }<br/>#<br/># Both methods return Thread objects. Call kill on the returned objects<br/># to cancel the execution of the code.<br/>#<br/># Note that this is a very naive implementation. A more robust<br/># implementation would use a single global timer thread for all tasks,<br/># would allow a way to retrieve the value of a deferred block, and would<br/># provide a way to wait for all pending tasks to complete.<br/>#<br/>
# Execute block after sleeping the specified number of seconds.<br/>def after(seconds, &amp;block) &#160;<br/>&#160; Thread.new do &#160; &#160; # In a new thread...<br/>&#160; &#160; sleep(seconds) &#160;# First sleep&#160;<br/>&#160; &#160; block.call &#160; &#160; &#160;# Then call the block<br/>
<b>282&#160;|&#160;Chapter 8:</b> <b>Reflection and Metaprogramming</b><br/>
<hr/>
<a name=297></a>&#160; end &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Return the Thread object right away<br/>end<br/>
# Repeatedly sleep and then execute the block.<br/># Pass value to the block on the first invocation. &#160;<br/># On subsequent invocations, pass the value of the previous invocation.<br/>def every(seconds, value=nil, &amp;block)<br/>&#160; Thread.new do &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # In a new thread...<br/>&#160; &#160; loop do &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Loop forever (or until break in block)<br/>&#160; &#160; &#160; sleep(seconds) &#160; &#160; &#160; &#160; &#160; &#160;# Sleep<br/>&#160; &#160; &#160; value = block.call(value) # And invoke block<br/>&#160; &#160; end &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Then repeat..<br/>&#160; end &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # every returns the Thread<br/>end<br/>
<b>8.8.2 &#160;Thread Safety with Synchronized Blocks<br/></b>When writing programs&#160;that use multiple threads, it is important that two threads do<br/>not&#160;attempt&#160;to&#160;modify&#160;the&#160;same&#160;object&#160;at&#160;the&#160;same&#160;time.&#160;One&#160;way&#160;to&#160;do&#160;this&#160;is&#160;to&#160;place<br/>the&#160;&#160;code&#160;&#160;that&#160;&#160;must&#160;&#160;be&#160;&#160;made&#160;&#160;thread-safe&#160;&#160;in&#160;&#160;a&#160;&#160;block&#160;&#160;associated&#160;&#160;with&#160;&#160;a&#160;&#160;call&#160;&#160;to&#160;&#160;the<br/>synchronize&#160;&#160;method&#160;&#160;of&#160;&#160;a&#160;&#160;Mutex&#160;&#160;object.&#160;&#160;Again,&#160;&#160;this&#160;&#160;is&#160;&#160;discussed&#160;&#160;in&#160;&#160;detail&#160;&#160;in&#160;&#160;<a href="Rubys.html#387">§9.9.&#160;&#160;</a>In<br/><a href="Rubys.html#297">Example&#160;8-2&#160;</a>we&#160;take&#160;this&#160;a&#160;step&#160;further,&#160;and&#160;emulate&#160;Java’s&#160;synchronized&#160;keyword&#160;with<br/>a&#160;global&#160;method&#160;named&#160;synchronized.&#160;This&#160;synchronized&#160;method&#160;expects&#160;a&#160;single&#160;object<br/>argument&#160;&#160;and&#160;&#160;a&#160;&#160;block.&#160;&#160;It&#160;&#160;obtains&#160;&#160;a&#160;&#160;Mutex&#160;&#160;associated&#160;&#160;with&#160;&#160;the&#160;&#160;object,&#160;&#160;and&#160;&#160;uses<br/>Mutex.synchronize&#160;to&#160;invoke&#160;the&#160;block.&#160;The&#160;tricky&#160;part&#160;is&#160;that&#160;Ruby’s&#160;object,&#160;unlike<br/>Java’s objects, do not have a&#160;Mutex<a href="Rubys.html#297">&#160;associated with them. So&#160;Example 8-2</a>&#160;also defines<br/>an&#160;instance&#160;method&#160;named&#160;mutex&#160;in&#160;Object.&#160;Interestingly,&#160;the&#160;implementation&#160;of&#160;this<br/>mutex&#160;method uses&#160;synchronized&#160;in its new keyword-style form!<br/>
<i>Example 8-2. Simple synchronized blocks</i><br/>
require 'thread' &#160;# Ruby 1.8 keeps Mutex in this library<br/>
# Obtain the Mutex associated with the object o, and then evaluate<br/># the block under the protection of that Mutex.<br/># This works like the synchronized keyword of Java.<br/>def synchronized(o)<br/>&#160; o.mutex.synchronize { yield }<br/>end<br/>
# Object.mutex does not actually exist. We've got to define it.<br/># This method returns a unique Mutex for every object, and<br/># always returns the same Mutex for any particular object.<br/># It creates Mutexes lazily, which requires synchronization for<br/># thread safety.<br/>class Object<br/>&#160; # Return the Mutex for this object, creating it if necessary.<br/>&#160; # The tricky part is making sure that two threads don't call<br/>&#160; # this at the same time and end up creating two different mutexes.<br/>&#160; def mutex<br/>&#160; &#160; # If this object already has a mutex, just return it<br/>&#160; &#160; return @__mutex if @__mutex<br/>
<b>8.8 &#160;Custom Control Structures&#160;|&#160;283</b><br/>
<hr/>
<a name=298></a>&#160; &#160;&#160;<br/>&#160; &#160; # Otherwise, we've got to create a mutex for the object.<br/>&#160; &#160; # To do this safely we've got to synchronize on our class object.<br/>&#160; &#160; synchronized(self.class) {<br/>&#160; &#160; &#160; # Check again: by the time we enter this synchronized block,<br/>&#160; &#160; &#160; # some other thread might have already created the mutex.<br/>&#160; &#160; &#160; @__mutex = @__mutex || Mutex.new<br/>&#160; &#160; }<br/>&#160; &#160; # The return value is @__mutex<br/>&#160; end<br/>end<br/>
# The Object.mutex method defined above needs to lock the class&#160;<br/># if the object doesn't have a Mutex yet. If the class doesn't have<br/># its own Mutex yet, then the class of the class (the Class object)<br/># will be locked. In order to prevent infinite recursion, we must<br/># ensure that the Class object has a mutex.<br/>Class.instance_eval { @__mutex = Mutex.new }<br/>
<b>8.9 &#160;Missing Methods and Missing Constants<br/></b>The&#160;&#160;method_missing&#160;&#160;method&#160;&#160;is&#160;&#160;a&#160;&#160;key&#160;&#160;part&#160;&#160;of&#160;&#160;Ruby’s&#160;&#160;method&#160;&#160;lookup&#160;&#160;algorithm&#160;&#160;(see<br/><a href="Rubys.html#272">§7.8)&#160;</a>and&#160;provides&#160;a&#160;powerful&#160;way&#160;to&#160;catch&#160;and&#160;handle&#160;arbitrary&#160;invocations&#160;on&#160;an<br/>object.&#160;The&#160;const_missing&#160;method&#160;of&#160;Module&#160;performs&#160;a&#160;similar&#160;function&#160;for&#160;the&#160;con-<br/>stant&#160;lookup&#160;algorithm&#160;and&#160;allows&#160;us&#160;to&#160;compute&#160;or&#160;lazily&#160;initialize&#160;constants&#160;on&#160;the<br/>fly. The examples that follow demonstrate both of these methods.<br/>
<b>8.9.1 &#160;Unicode Codepoint Constants with const_missing<br/></b><a href="Rubys.html#298">Example&#160;&#160;8-3&#160;&#160;</a>defines&#160;&#160;a&#160;&#160;Unicode&#160;&#160;module&#160;&#160;that&#160;&#160;appears&#160;&#160;to&#160;&#160;define&#160;&#160;a&#160;&#160;constant&#160;&#160;(a&#160;&#160;UTF-8<br/>encoded&#160;string)&#160;for&#160;every&#160;Unicode&#160;codepoint&#160;from&#160;U+0000&#160;to&#160;U+10FFFF. The only prac-<br/>tical&#160;way&#160;to&#160;support&#160;this&#160;many&#160;constants&#160;is&#160;to&#160;use&#160;the&#160;const_missing&#160;method.&#160;The&#160;code<br/>makes&#160;the&#160;assumption&#160;that&#160;if&#160;a&#160;constant&#160;is&#160;referenced&#160;once,&#160;it&#160;is&#160;likely&#160;to&#160;be&#160;used&#160;again,<br/>so&#160;the&#160;const_missing&#160;method&#160;calls&#160;Module.const_set&#160;to&#160;define&#160;a&#160;real&#160;constant&#160;to&#160;refer<br/>to each value it computes.<br/>
<i>Example 8-3. Unicode codepoint constants with const_missing</i><br/>
# This module provides constants that define the UTF-8 strings for<br/># all Unicode codepoints. It uses const_missing to define them lazily.<br/># Examples:<br/># &#160; copyright = Unicode::U00A9<br/># &#160; euro = Unicode::U20AC<br/># &#160; infinity = Unicode::U221E<br/>module Unicode<br/>&#160; # This method allows us to define Unicode codepoint constants lazily.<br/>&#160; def self.const_missing(name) &#160;# Undefined constant passed as a symbol<br/>&#160; &#160; # Check that the constant name is of the right form.<br/>&#160; &#160; # Capital U followed by a hex number between 0000 and 10FFFF.<br/>&#160; &#160; if name.to_s =~ /^U([0-9a-fA-F]{4,5}|10[0-9a-fA-F]{4})$/<br/>&#160; &#160; &#160; # $1 is the matched hexadecimal number. Convert to an integer.<br/>
<b>284&#160;|&#160;Chapter 8:</b> <b>Reflection and Metaprogramming</b><br/>
<hr/>
<a name=299></a>&#160; &#160; &#160; codepoint = $1.to_i(16)<br/>&#160; &#160; &#160; # Convert the number to a UTF-8 string with the magic of Array.pack.<br/>&#160; &#160; &#160; utf8 = [codepoint].pack(&#34;U&#34;)<br/>&#160; &#160; &#160; # Make the UTF-8 string immutable.<br/>&#160; &#160; &#160; utf8.freeze<br/>&#160; &#160; &#160; # Define a real constant for faster lookup next time, and return<br/>&#160; &#160; &#160; # the UTF-8 text for this time.<br/>&#160; &#160; &#160; const_set(name, utf8)<br/>&#160; &#160; else&#160;<br/>&#160; &#160; &#160; # Raise an error for constants of the wrong form.<br/>&#160; &#160; &#160; raise NameError, &#34;Uninitialized constant: Unicode::#{name}&#34;<br/>&#160; &#160; end<br/>&#160; end<br/>end<br/>
<b>8.9.2 &#160;Tracing Method Invocations with method_missing<br/></b>Earlier&#160;&#160;in&#160;&#160;this&#160;&#160;chapter,&#160;&#160;we&#160;&#160;demonstrated&#160;&#160;an&#160;&#160;extension&#160;&#160;to&#160;&#160;the&#160;&#160;Hash&#160;&#160;class&#160;&#160;using<br/>method_missing.&#160;Now,&#160;in&#160;<a href="Rubys.html#299">Example&#160;8-4,&#160;</a>we&#160;demonstrate&#160;the&#160;use&#160;of&#160;method_missing&#160;to<br/>delegate&#160;arbitrary&#160;calls&#160;on&#160;one&#160;object&#160;to&#160;another&#160;object.&#160;In&#160;this&#160;example,&#160;we&#160;do&#160;this&#160;in<br/>order to output tracing messages for the object.<br/><a href="Rubys.html#299">Example&#160;8-4&#160;</a>defines&#160;an&#160;Object.trace&#160;instance&#160;method&#160;and&#160;a&#160;TracedObject&#160;class.&#160;The<br/>trace&#160;method&#160;returns&#160;an&#160;instance&#160;of&#160;TracedObject&#160;that&#160;uses&#160;method_missingto&#160;catch<br/>invocations,&#160;trace&#160;them,&#160;and&#160;delegate&#160;them&#160;to&#160;the&#160;object&#160;being&#160;traced.&#160;You&#160;might&#160;use<br/>it like this:<br/>
a = [1,2,3].trace(&#34;a&#34;)<br/>a.reverse<br/>puts a[2]<br/>puts a.fetch(3)<br/>
This produces the following tracing output:<br/>
Invoking: a.reverse() at trace1.rb:66<br/>Returning: [3, 2, 1] from a.reverse to trace1.rb:66<br/>Invoking: a.fetch(3) at trace1.rb:67<br/>Raising: IndexError:index 3 out of array from a.fetch<br/>
Notice&#160;that&#160;in&#160;addition&#160;to&#160;demonstrating&#160;method_missing,&#160;<a href="Rubys.html#299">Example&#160;8-4&#160;</a>also&#160;demon-<br/>strates&#160;Module.instance_methods,&#160;Module.undef_method, and&#160;Kernel.caller.<br/>
<i>Example 8-4. Tracing method invocations with method_missing</i><br/>
# Call the trace method of any object to obtain a new object that<br/># behaves just like the original, but which traces all method calls<br/># on that object. If tracing more than one object, specify a name to<br/># appear in the output. By default, messages will be sent to STDERR,&#160;<br/># but you can specify any stream (or any object that accepts strings<br/># as arguments to &lt;&lt;).<br/>class Object<br/>&#160; def trace(name=&#34;&#34;, stream=STDERR)<br/>&#160; &#160; # Return a TracedObject that traces and delegates everything else to us.<br/>&#160; &#160; TracedObject.new(self, name, stream)<br/>
<b>8.9 &#160;Missing Methods and Missing Constants&#160;|&#160;285</b><br/>
<hr/>
<a name=300></a>&#160; end<br/>end<br/>
# This class uses method_missing to trace method invocations and<br/># then delegate them to some other object. It deletes most of its own<br/># instance methods so that they don't get in the way of method_missing.<br/># Note that only methods invoked through the TracedObject will be traced.<br/># If the delegate object calls methods on itself, those invocations<br/># will not be traced.<br/>class TracedObject<br/>&#160; # Undefine all of our noncritical public instance methods.<br/>&#160; # Note the use of Module.instance_methods and Module.undef_method.<br/>&#160; instance_methods.each do |m|<br/>&#160; &#160; m = m.to_sym &#160;# Ruby 1.8 returns strings, instead of symbols<br/>&#160; &#160; next if m == :object_id || m == :__id__ || m == :__send__<br/>&#160; &#160; undef_method m<br/>&#160; end<br/>
&#160; # Initialize this TracedObject instance.<br/>&#160; def initialize(o, name, stream)<br/>&#160; &#160; @o = o &#160; &#160; &#160; &#160; &#160; &#160;# The object we delegate to<br/>&#160; &#160; @n = name &#160; &#160; &#160; &#160; # The object name to appear in tracing messages<br/>&#160; &#160; @trace = stream &#160; # Where those tracing messages are sent<br/>&#160; end<br/>
&#160; # This is the key method of TracedObject. It is invoked for just<br/>&#160; # about any method invocation on a TracedObject.<br/>&#160; def method_missing(*args, &amp;block)<br/>&#160; &#160; m = args.shift &#160; &#160; &#160; &#160; # First arg is the name of the method<br/>&#160; &#160; begin<br/>&#160; &#160; &#160; # Trace the invocation of the method.<br/>&#160; &#160; &#160; arglist = args.map {|a| a.inspect}.join(', ')<br/>&#160; &#160; &#160; @trace &lt;&lt; &#34;Invoking: #{@n}.#{m}(#{arglist}) at #{caller[0]}\n&#34;<br/>&#160; &#160; &#160; # Invoke the method on our delegate object and get the return value.<br/>&#160; &#160; &#160; r = @o.send m, *args, &amp;block<br/>&#160; &#160; &#160; # Trace a normal return of the method.<br/>&#160; &#160; &#160; @trace &lt;&lt; &#34;Returning: #{r.inspect} from #{@n}.#{m} to #{caller[0]}\n&#34;<br/>&#160; &#160; &#160; # Return whatever value the delegate object returned.<br/>&#160; &#160; &#160; r<br/>&#160; &#160; rescue Exception =&gt; e<br/>&#160; &#160; &#160; # Trace an abnormal return from the method.<br/>&#160; &#160; &#160; @trace &lt;&lt; &#34;Raising: #{e.class}:#{e} from #{@n}.#{m}\n&#34;<br/>&#160; &#160; &#160; # And re-raise whatever exception the delegate object raised.<br/>&#160; &#160; &#160; raise<br/>&#160; &#160; end<br/>&#160; end<br/>
&#160; # Return the object we delegate to.<br/>&#160; def __delegate<br/>&#160; &#160; @o<br/>&#160; end<br/>end<br/>
<b>286&#160;|&#160;Chapter 8:</b> <b>Reflection and Metaprogramming</b><br/>
<hr/>
<a name=301></a><b>8.9.3 &#160;Synchronized Objects by Delegation<br/></b>In&#160;<a href="Rubys.html#297">Example&#160;8-2,&#160;</a>we&#160;saw&#160;a&#160;global&#160;method&#160;synchronized,&#160;which&#160;accepts&#160;an&#160;object&#160;and<br/>executes&#160;a&#160;block&#160;under&#160;the&#160;protection&#160;of&#160;the&#160;Mutex&#160;associated&#160;with&#160;that&#160;object.&#160;Most&#160;of<br/>the&#160;&#160;example&#160;&#160;consisted&#160;&#160;of&#160;&#160;the&#160;&#160;implementation&#160;&#160;of&#160;&#160;the&#160;&#160;Object.mutex&#160;&#160;method.&#160;&#160;The<br/>synchronized&#160;method was trivial:<br/>
def synchronized(o)<br/>&#160; o.mutex.synchronize { yield }<br/>end<br/>
<a href="Rubys.html#301">Example 8-5&#160;</a>modifies&#160;this&#160;method&#160;so&#160;that,&#160;when&#160;invoked&#160;without&#160;a&#160;block,&#160;it&#160;returns&#160;a<br/>SynchronizedObject&#160;&#160;wrapper&#160;&#160;around&#160;&#160;the&#160;&#160;object.&#160;&#160;SynchronizedObject&#160;&#160;is&#160;&#160;a&#160;&#160;delegating<br/>wrapper&#160;class&#160;based&#160;on&#160;method_missing.&#160;It&#160;is&#160;much&#160;like&#160;the&#160;TracedObject&#160;class&#160;of&#160;<a href="Rubys.html#299">Ex-<br/>ample 8-4,&#160;</a>but&#160;it&#160;is&#160;written&#160;as&#160;a&#160;subclass&#160;of&#160;Ruby&#160;1.9’s&#160;BasicObject,&#160;so&#160;there&#160;is&#160;no&#160;need<br/>to&#160;explicitly&#160;delete&#160;the&#160;instance&#160;methods&#160;of&#160;Object.&#160;Note&#160;that&#160;the&#160;code&#160;in&#160;this&#160;example<br/>does not stand alone; it requires the&#160;Object.mutex&#160;method defined earlier.<br/>
<i>Example 8-5. Synchronizing methods with method_missing</i><br/>
def synchronized(o)<br/>&#160; if block_given?<br/>&#160; &#160; o.mutex.synchronize { yield }<br/>&#160; else<br/>&#160; &#160; SynchronizedObject.new(o)<br/>&#160; end<br/>end<br/>
# A delegating wrapper class using method_missing for thread safety<br/># Instead of extending Object and deleting our methods we just extend<br/># BasicObject, which is defined in Ruby 1.9. BasicObject does not&#160;<br/># inherit from Object or Kernel, so the methods of a BasicObject cannot<br/># invoke any top-level methods: they are just not there.<br/>class SynchronizedObject &#160;&lt; BasicObject<br/>&#160; def initialize(o); @delegate = o; &#160;end<br/>&#160; def __delegate; @delegate; end<br/>
&#160; def method_missing(*args, &amp;block)<br/>&#160; &#160; @delegate.mutex.synchronize {<br/>&#160; &#160; &#160; @delegate.send *args, &amp;block<br/>&#160; &#160; }<br/>&#160; end<br/>end<br/>
<b>8.10 &#160;Dynamically Creating Methods<br/></b>One&#160;important&#160;metaprogramming&#160;technique&#160;is&#160;the&#160;use&#160;of&#160;methods&#160;that&#160;create&#160;methods.<br/>The&#160;attr_reader&#160;and&#160;attr_accessor<a href="Rubys.html#231">&#160;methods (see&#160;§7.1.5)&#160;</a>are&#160;examples.&#160;These&#160;private<br/>instance&#160;methods&#160;of&#160;Module&#160;are&#160;used&#160;like&#160;keywords&#160;within&#160;class&#160;definitions.&#160;They&#160;accept<br/>attribute&#160;names&#160;as&#160;their&#160;arguments,&#160;and&#160;dynamically&#160;create&#160;methods&#160;with&#160;those&#160;names.<br/>
<b>8.10 &#160;Dynamically Creating Methods&#160;|&#160;287</b><br/>
<hr/>
<a name=302></a>The&#160;examples&#160;that&#160;follow&#160;are&#160;variants&#160;on&#160;these&#160;attribute&#160;accessor&#160;creation&#160;methods&#160;and<br/>demonstrate two different ways to dynamically create methods like this.<br/>
<b>8.10.1 &#160;Defining Methods with class_eval<br/></b><a href="Rubys.html#302">Example&#160;&#160;8-6defines&#160;&#160;</a>private&#160;&#160;instance&#160;&#160;methods&#160;&#160;of&#160;&#160;Module&#160;&#160;named&#160;&#160;readonly&#160;&#160;and<br/>readwrite.&#160;These&#160;methods&#160;work&#160;like&#160;attr_reader&#160;and&#160;attr_accessor&#160;do,&#160;and&#160;they&#160;are<br/>here&#160;to&#160;demonstrate&#160;how&#160;those&#160;methods&#160;are&#160;implemented.&#160;The&#160;implementation&#160;is&#160;ac-<br/>tually&#160;quite&#160;simple:&#160;readonly&#160;and&#160;readwrite&#160;first&#160;build&#160;a&#160;string&#160;of&#160;Ruby&#160;code&#160;containing<br/>the&#160;def&#160;statements&#160;required&#160;to&#160;define&#160;appropriate&#160;accessor&#160;methods.&#160;Next,&#160;they&#160;evaluate<br/>that&#160;&#160;string&#160;&#160;of&#160;&#160;code&#160;&#160;using&#160;&#160;class_eval&#160;&#160;(described&#160;&#160;earlier&#160;&#160;in&#160;&#160;the&#160;&#160;chapter).&#160;&#160;Using<br/>class_eval&#160;like&#160;this&#160;incurs&#160;the&#160;slight&#160;overhead&#160;of&#160;parsing&#160;the&#160;string&#160;of&#160;code.&#160;The&#160;benefit,<br/>however,&#160;is&#160;that&#160;the&#160;methods&#160;we&#160;define&#160;need&#160;not&#160;use&#160;any&#160;reflective&#160;APIs&#160;themselves;<br/>they can query or set the value of an instance variable directly.<br/>
<i>Example 8-6. Attribute methods with class_eval</i><br/>
class Module<br/>&#160; private &#160; &#160; # The methods that follow are both private<br/>
&#160; # This method works like attr_reader, but has a shorter name<br/>&#160; def readonly(*syms)<br/>&#160; &#160; return if syms.size == 0 &#160;# If no arguments, do nothing<br/>&#160; &#160; code = &#34;&#34; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Start with an empty string of code<br/>&#160; &#160; # Generate a string of Ruby code to define attribute reader methods.<br/>&#160; &#160; # Notice how the symbol is interpolated into the string of code.<br/>&#160; &#160; syms.each do |s| &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # For each symbol<br/>&#160; &#160; &#160; code &lt;&lt; &#34;def #{s}; @#{s}; end\n&#34; &#160; # The method definition<br/>&#160; &#160; end<br/>&#160; &#160; # Finally, class_eval the generated code to create instance methods.<br/>&#160; &#160; class_eval code<br/>&#160; end<br/>
&#160; # This method works like attr_accessor, but has a shorter name.<br/>&#160; def readwrite(*syms)<br/>&#160; &#160; return if syms.size == 0<br/>&#160; &#160; code = &#34;&#34;<br/>&#160; &#160; syms.each do |s|<br/>&#160; &#160; &#160; code &lt;&lt; &#34;def #{s}; @#{s} end\n&#34;<br/>&#160; &#160; &#160; code &lt;&lt; &#34;def #{s}=(value); @#{s} = value; end\n&#34;<br/>&#160; &#160; end<br/>&#160; &#160; class_eval code<br/>&#160; end<br/>end<br/>
<b>8.10.2 &#160;Defining Methods with define_method<br/></b><a href="Rubys.html#303">Example&#160;8-7&#160;</a>is&#160;a&#160;different&#160;take&#160;on&#160;attribute&#160;accessors.&#160;The&#160;attributes&#160;method&#160;is&#160;some-<br/>thing&#160;like&#160;the&#160;readwrite&#160;method&#160;defined&#160;<a href="Rubys.html#302">in&#160;Example&#160;8-6.&#160;</a>Instead&#160;of&#160;taking&#160;any&#160;number<br/>of&#160;attribute&#160;names&#160;as&#160;arguments,&#160;it&#160;expects&#160;a&#160;single&#160;hash&#160;object.&#160;This&#160;hash&#160;should&#160;have<br/>
<b>288&#160;|&#160;Chapter 8:</b> <b>Reflection and Metaprogramming</b><br/>
<hr/>
<a name=303></a>attribute&#160;names&#160;as&#160;its&#160;keys,&#160;and&#160;should&#160;map&#160;those&#160;attribute&#160;names&#160;to&#160;the&#160;default&#160;values<br/>for&#160;the&#160;attributes.&#160;The&#160;class_attrs&#160;method&#160;works&#160;like&#160;attributes,&#160;but&#160;defines&#160;class<br/>attributes rather than instance attributes.<br/>Remember that Ruby allows the curly braces to be omitted around hash literals when<br/>they&#160;are&#160;the&#160;final&#160;argument&#160;in&#160;a&#160;method&#160;invocation.&#160;So&#160;the&#160;attributes&#160;method&#160;might<br/>be invoked with code like this:<br/>
class Point<br/>&#160; attributes :x =&gt; 0, :y =&gt; 0<br/>end<br/>
In Ruby 1.9, we can use the more succinct hash syntax:<br/>
class Point<br/>&#160; attributes x:0, y:0<br/>end<br/>
This&#160;is&#160;another&#160;example&#160;that&#160;leverages&#160;Ruby’s&#160;flexible&#160;syntax&#160;to&#160;create&#160;methods&#160;that<br/>behave like language keywords.<br/>The&#160;implementation&#160;of&#160;the&#160;attributes&#160;method&#160;in&#160;<a href="Rubys.html#303">Example 8-7&#160;</a>is&#160;quite&#160;a&#160;bit&#160;different<br/>than&#160;that&#160;of&#160;the&#160;readwrite&#160;method&#160;<a href="Rubys.html#302">in&#160;Example 8-6.&#160;</a>Instead&#160;of&#160;defining&#160;a&#160;string&#160;of&#160;Ruby<br/>code&#160;and&#160;evaluating&#160;it&#160;with&#160;class_eval,&#160;the&#160;attributes&#160;method&#160;defines&#160;the&#160;body&#160;of&#160;the<br/>attribute&#160;accessors&#160;in&#160;a&#160;block&#160;and&#160;defines&#160;the&#160;methods&#160;using&#160;define_method.&#160;Because<br/>this&#160;method&#160;definition&#160;technique&#160;does&#160;not&#160;allow&#160;us&#160;to&#160;interpolate&#160;identifiers&#160;directly<br/>into&#160;&#160;the&#160;&#160;method&#160;&#160;body,&#160;&#160;we&#160;&#160;must&#160;&#160;rely&#160;&#160;on&#160;&#160;reflective&#160;&#160;methods&#160;&#160;such&#160;&#160;as<br/>instance_variable_get.&#160;Because&#160;of&#160;this,&#160;the&#160;accessors&#160;defined&#160;with&#160;attributes&#160;are&#160;likely<br/>to be less efficient than those defined with&#160;readwrite.<br/>An&#160;interesting&#160;point&#160;about&#160;the&#160;attributes&#160;method&#160;is&#160;that&#160;it&#160;does&#160;not&#160;explicitly&#160;store&#160;the<br/>default&#160;values&#160;for&#160;the&#160;attributes&#160;in&#160;a&#160;class&#160;variable&#160;of&#160;any&#160;kind.&#160;Instead,&#160;the&#160;default&#160;value<br/>for&#160;each&#160;attribute&#160;is&#160;captured&#160;by&#160;the&#160;scope&#160;of&#160;the&#160;block&#160;used&#160;to&#160;define&#160;the&#160;method.&#160;(See<br/><a href="Rubys.html#214">§6.6 for more about closures like this.)<br/></a>The&#160;class_attrs&#160;method&#160;defines&#160;class&#160;attributes&#160;very&#160;simply:&#160;it&#160;invokes&#160;attributes&#160;on<br/>the&#160;eigenclass&#160;of&#160;the&#160;class.&#160;This&#160;means&#160;that&#160;the&#160;resulting&#160;methods&#160;use&#160;class&#160;instance<br/><a href="Rubys.html#245">variables (see §7.1.16) instead of regular class variables.</a><br/>
<i>Example 8-7. Attribute methods with define_method</i><br/>
class Module<br/>&#160; # This method defines attribute reader and writer methods for named<br/>&#160; # attributes, but expects a hash argument mapping attribute names to<br/>&#160; # default values. The generated attribute reader methods return the<br/>&#160; # default value if the instance variable has not yet been defined.<br/>&#160; def attributes(hash)<br/>&#160; &#160; hash.each_pair do |symbol, default| &#160; # For each attribute/default pair<br/>&#160; &#160; &#160; getter = symbol &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Name of the getter method<br/>&#160; &#160; &#160; setter = :&#34;#{symbol}=&#34; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Name of the setter method<br/>&#160; &#160; &#160; variable = :&#34;@#{symbol}&#34; &#160; &#160; &#160; &#160; &#160; &#160;# Name of the instance variable<br/>&#160; &#160; &#160; define_method getter do &#160; &#160; &#160; &#160; &#160; &#160; # Define the getter method<br/>&#160; &#160; &#160; &#160; if instance_variable_defined? variable<br/>
<b>8.10 &#160;Dynamically Creating Methods&#160;|&#160;289</b><br/>
<hr/>
<a name=304></a>&#160; &#160; &#160; &#160; &#160; instance_variable_get variable &#160;# Return variable, if defined<br/>&#160; &#160; &#160; &#160; else<br/>&#160; &#160; &#160; &#160; &#160; default &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Otherwise return default<br/>&#160; &#160; &#160; &#160; end<br/>&#160; &#160; &#160; end<br/>
&#160; &#160; &#160; define_method setter do |value| &#160; &#160; # Define setter method<br/>&#160; &#160; &#160; &#160; instance_variable_set variable, &#160; # Set the instance variable<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; value &#160; &#160; &#160; # To the argument value<br/>&#160; &#160; &#160; end<br/>&#160; &#160; end<br/>&#160; end<br/>
&#160; # This method works like attributes, but defines class methods instead<br/>&#160; # by invoking attributes on the eigenclass instead of on self.<br/>&#160; # Note that the defined methods use class instance variables<br/>&#160; # instead of regular class variables. &#160;<br/>&#160; def class_attrs(hash)<br/>&#160; &#160; eigenclass = class &lt;&lt; self; self; end<br/>&#160; &#160; eigenclass.class_eval { attributes(hash) }<br/>&#160; end<br/>
&#160; # Both methods are private<br/>&#160; private :attributes, :class_attrs<br/>end<br/>
<b>8.11 &#160;Alias Chaining<br/></b>As&#160;we’ve&#160;seen,&#160;metaprogramming&#160;in&#160;Ruby&#160;often&#160;involves&#160;the&#160;dynamic&#160;definition&#160;of<br/>methods.&#160;Just&#160;as&#160;common&#160;is&#160;the&#160;dynamic&#160;<i>modification</i>&#160;of&#160;methods.&#160;Methods&#160;are&#160;modi-<br/>fied with a technique we’ll call&#160;<i>alias chaining</i>.*&#160;&#160;It works like this:<br/>
•&#160;First,&#160;create&#160;an&#160;alias&#160;for&#160;the&#160;method&#160;to&#160;be&#160;modified.&#160;This&#160;alias&#160;provides&#160;a&#160;name&#160;for<br/>
the unmodified version of the method.<br/>
•&#160;Next,&#160;&#160;define&#160;&#160;a&#160;&#160;new&#160;&#160;version&#160;&#160;of&#160;&#160;the&#160;&#160;method.&#160;&#160;This&#160;&#160;new&#160;&#160;version&#160;&#160;should&#160;&#160;call&#160;&#160;the<br/>
unmodified&#160;&#160;version&#160;&#160;through&#160;&#160;the&#160;&#160;alias,&#160;&#160;but&#160;&#160;it&#160;&#160;can&#160;&#160;add&#160;&#160;whatever&#160;&#160;functionality&#160;&#160;is<br/>needed before and after it does that.<br/>
Note&#160;that&#160;these&#160;steps&#160;can&#160;be&#160;applied&#160;repeatedly&#160;(as&#160;long&#160;as&#160;a&#160;different&#160;alias&#160;is&#160;used&#160;each<br/>time), creating a chain of methods and aliases.<br/>This&#160;section&#160;includes&#160;three&#160;alias&#160;chaining&#160;examples.&#160;The&#160;first&#160;performs&#160;the&#160;alias&#160;chain-<br/>ing&#160;&#160;statically;&#160;&#160;i.e.,&#160;&#160;using&#160;&#160;regular&#160;&#160;alias&#160;&#160;and&#160;&#160;def&#160;&#160;statements.&#160;&#160;The&#160;&#160;second&#160;&#160;and&#160;&#160;third<br/>examples&#160;&#160;are&#160;&#160;more&#160;&#160;dynamic;&#160;&#160;they&#160;&#160;alias&#160;&#160;chain&#160;&#160;arbitrarily&#160;&#160;named&#160;&#160;methods&#160;&#160;using<br/>alias_method,&#160;define_method, and&#160;class_eval.<br/>
*&#160;It&#160;has&#160;also&#160;been&#160;called&#160;<i>monkey&#160;patching</i>,&#160;but&#160;since&#160;that&#160;term&#160;was&#160;originally&#160;used&#160;with&#160;derision,&#160;we&#160;avoid&#160;it<br/>
here. The term&#160;<i>duck punching</i>&#160;is sometimes used as a humorous alternative.<br/>
<b>290&#160;|&#160;Chapter 8:</b> <b>Reflection and Metaprogramming</b><br/>
<hr/>
<a name=305></a><b>8.11.1 &#160;Tracing Files Loaded and Classes Defined<br/></b><a href="Rubys.html#305">Example&#160;8-8&#160;</a>is&#160;code&#160;that&#160;keeps&#160;track&#160;of&#160;all&#160;files&#160;loaded&#160;and&#160;all&#160;classes&#160;defined&#160;in&#160;a<br/>program.&#160;When&#160;the&#160;program&#160;exits,&#160;it&#160;prints&#160;a&#160;report.&#160;You&#160;can&#160;use&#160;this&#160;code&#160;to&#160;“instru-<br/>ment”&#160;an&#160;existing&#160;program&#160;so&#160;that&#160;you&#160;better&#160;understand&#160;what&#160;it&#160;is&#160;doing.&#160;One&#160;way&#160;to<br/>use this code is to insert this line at the beginning of the program:<br/>
require 'classtrace'<br/>
An easier solution, however, is to use the&#160;-r&#160;option to your Ruby interpreter:<br/>
ruby -rclasstrace my_program.rb &#160;--traceout /tmp/trace<br/>
The&#160;&#160;-r&#160;&#160;option&#160;&#160;loads&#160;&#160;the&#160;&#160;specified&#160;&#160;library&#160;&#160;before&#160;&#160;it&#160;&#160;starts&#160;&#160;running&#160;&#160;the&#160;&#160;program.&#160;&#160;See<br/><a href="Rubys.html#404">§10.1 for more on the Ruby interpreter’s command-line arguments.<br/></a><a href="Rubys.html#305">Example&#160;8-8&#160;</a>uses&#160;static&#160;alias&#160;chaining&#160;to&#160;trace&#160;all&#160;invocations&#160;of&#160;the&#160;Kernel.require&#160;and<br/>Kernel.load&#160;methods. It defines an&#160;Object.inherited&#160;hook&#160;to&#160;track&#160;definitions&#160;of&#160;new<br/>classes.&#160;And&#160;it&#160;uses&#160;Kernel.at_exit&#160;to&#160;execute&#160;a&#160;block&#160;of&#160;code&#160;when&#160;the&#160;program&#160;ter-<br/>minates. (The&#160;END<a href="Rubys.html#179">&#160;statement described in&#160;§5.7&#160;</a>would&#160;work&#160;here&#160;as&#160;well.)&#160;Besides&#160;alias<br/>chaining&#160;require&#160;and&#160;load&#160;and&#160;defining&#160;Object.inherited,&#160;the&#160;only&#160;modification&#160;to&#160;the<br/>global&#160;namespace&#160;made&#160;by&#160;this&#160;code&#160;is&#160;the&#160;definition&#160;of&#160;a&#160;module&#160;named&#160;ClassTrace.<br/>All&#160;state&#160;required&#160;for&#160;tracing&#160;is&#160;stored&#160;in&#160;constants&#160;within&#160;this&#160;module,&#160;so&#160;that&#160;we&#160;don’t<br/>pollute the namespace with global variables.<br/>
<i>Example 8-8. Tracing files loaded and classes defined</i><br/>
# We define this module to hold the global state we require, so that<br/># we don't alter the global namespace any more than necessary.<br/>module ClassTrace<br/>&#160; # This array holds our list of files loaded and classes defined.<br/>&#160; # Each element is a subarray holding the class defined or the<br/>&#160; # file loaded and the stack frame where it was defined or loaded.<br/>&#160; T = [] &#160;# Array to hold the files loaded<br/>
&#160; # Now define the constant OUT to specify where tracing output goes.<br/>&#160; # This defaults to STDERR, but can also come from command-line arguments<br/>&#160; if x = ARGV.index(&#34;--traceout&#34;) &#160; &#160;# If argument exists<br/>&#160; &#160; OUT = File.open(ARGV[x+1], &#34;w&#34;) &#160;# Open the specified file<br/>&#160; &#160; ARGV[x,2] = nil &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# And remove the arguments<br/>&#160; else<br/>&#160; &#160; OUT = STDERR &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Otherwise default to STDERR<br/>&#160; end<br/>end<br/>
# Alias chaining step 1: define aliases for the original methods<br/>alias original_require require<br/>alias original_load load<br/>
# Alias chaining step 2: define new versions of the methods&#160;<br/>def require(file)<br/>&#160; ClassTrace::T &lt;&lt; [file,caller[0]] &#160; &#160; # Remember what was loaded where<br/>&#160; original_require(file) &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Invoke the original method<br/>end<br/>
<b>8.11 &#160;Alias Chaining&#160;|&#160;291</b><br/>
<hr/>
<a name=306></a>def load(*args)<br/>&#160; ClassTrace::T &lt;&lt; [args[0],caller[0]] &#160;# Remember what was loaded where<br/>&#160; original_load(*args) &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Invoke the original method<br/>end<br/>
# This hook method is invoked each time a new class is defined<br/>def Object.inherited(c)<br/>&#160; ClassTrace::T &lt;&lt; [c,caller[0]] &#160; &#160; &#160; &#160;# Remember what was defined where<br/>end<br/>
# Kernel.at_exit registers a block to be run when the program exits<br/># We use it to report the file and class data we collected<br/>at_exit {<br/>&#160; o = ClassTrace::OUT<br/>&#160; o.puts &#34;=&#34;*60<br/>&#160; o.puts &#34;Files Loaded and Classes Defined:&#34;<br/>&#160; o.puts &#34;=&#34;*60<br/>&#160; ClassTrace::T.each do |what,where|<br/>&#160; &#160; if what.is_a? Class &#160;# Report class (with hierarchy) defined<br/>&#160; &#160; &#160; o.puts &#34;Defined: #{what.ancestors.join('&lt;-')} at #{where}&#34;<br/>&#160; &#160; else &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Report file loaded<br/>&#160; &#160; &#160; o.puts &#34;Loaded: #{what} at #{where}&#34;<br/>&#160; &#160; end<br/>&#160; end<br/>}<br/>
<b>8.11.2 &#160;Chaining Methods for Thread Safety<br/></b>Two&#160;earlier&#160;examples&#160;in&#160;this&#160;chapter&#160;have&#160;involved&#160;thread&#160;<a href="Rubys.html#297">safety.&#160;Example 8-2</a>&#160;defined<br/>a&#160;synchronized&#160;method&#160;(based&#160;on&#160;an&#160;Object.mutex&#160;method)&#160;that&#160;executed&#160;a&#160;block&#160;under<br/>the&#160;protection&#160;of&#160;a&#160;Mutex&#160;object.&#160;<a href="Rubys.html#301">Then,&#160;Example&#160;8-5&#160;</a>redefined&#160;the&#160;synchronized&#160;method<br/>so&#160;that&#160;when&#160;it&#160;was&#160;invoked&#160;without&#160;a&#160;block,&#160;it&#160;would&#160;return&#160;a&#160;SynchronizedObject<br/>wrapper&#160;&#160;around&#160;&#160;an&#160;&#160;object,&#160;&#160;protecting&#160;&#160;access&#160;&#160;to&#160;&#160;any&#160;&#160;methods&#160;&#160;invoked&#160;&#160;through&#160;&#160;that<br/>wrapper&#160;object.&#160;Now,&#160;<a href="Rubys.html#307">in&#160;Example 8-9,&#160;</a>we&#160;augment&#160;the&#160;synchronized&#160;method&#160;again&#160;so<br/>that&#160;when&#160;it&#160;is&#160;invoked&#160;within&#160;a&#160;class&#160;or&#160;module&#160;definition,&#160;it&#160;alias&#160;chains&#160;the&#160;named<br/>methods to add synchronization.<br/>The&#160;alias&#160;chaining&#160;is&#160;done&#160;by&#160;our&#160;method&#160;Module.synchronize_method,&#160;which&#160;in&#160;turn<br/>uses&#160;a&#160;helper&#160;method&#160;Module.create_alias&#160;to&#160;define&#160;an&#160;appropriate&#160;alias&#160;for&#160;any&#160;given<br/>method (including operator methods like&#160;+).<br/>After&#160;&#160;defining&#160;&#160;these&#160;&#160;new&#160;&#160;Module&#160;&#160;methods,&#160;&#160;<a href="Rubys.html#307">Example&#160;&#160;8-9&#160;&#160;</a>redefines&#160;&#160;the&#160;&#160;synchronized<br/>method&#160;&#160;again.&#160;&#160;When&#160;&#160;the&#160;&#160;method&#160;&#160;is&#160;&#160;invoked&#160;&#160;within&#160;&#160;a&#160;&#160;class&#160;&#160;or&#160;&#160;a&#160;&#160;module,&#160;&#160;it&#160;&#160;calls<br/>synchronize_method&#160;on&#160;each&#160;of&#160;the&#160;symbols&#160;it&#160;is&#160;passed.&#160;Interestingly,&#160;however,&#160;it&#160;can<br/>also&#160;&#160;be&#160;&#160;called&#160;&#160;with&#160;&#160;no&#160;&#160;arguments;&#160;&#160;when&#160;&#160;used&#160;&#160;this&#160;&#160;way,&#160;&#160;it&#160;&#160;adds&#160;&#160;synchronization&#160;&#160;to<br/>whatever&#160;instance&#160;method&#160;is&#160;defined&#160;next.&#160;(It&#160;uses&#160;the&#160;method_added&#160;hook&#160;to&#160;receive<br/>notifications&#160;when&#160;a&#160;new&#160;method&#160;is&#160;added.)&#160;Note&#160;that&#160;the&#160;code&#160;in&#160;this&#160;example&#160;depends<br/>on&#160;the&#160;Object.mutex&#160;method&#160;of&#160;<a href="Rubys.html#297">Example&#160;8-2&#160;</a>and&#160;the&#160;SynchronizedObject&#160;class&#160;of&#160;<a href="Rubys.html#301">Ex-<br/>ample 8-5.</a><br/>
<b>292&#160;|&#160;Chapter 8:</b> <b>Reflection and Metaprogramming</b><br/>
<hr/>
<a name=307></a><i>Example 8-9. Alias chaining for thread safety</i><br/>
# Define a Module.synchronize_method that alias chains instance methods<br/># so they synchronize on the instance before running.<br/>class Module<br/>&#160; # This is a helper function for alias chaining.<br/>&#160; # Given a method name (as a string or symbol) and a prefix, create<br/>&#160; # a unique alias for the method, and return the name of the alias<br/>&#160; # as a symbol. Any punctuation characters in the original method name<br/>&#160; # will be converted to numbers so that operators can be aliased.<br/>&#160; def create_alias(original, prefix=&#34;alias&#34;)<br/>&#160; &#160; # Stick the prefix on the original name and convert punctuation<br/>&#160; &#160; aka = &#34;#{prefix}_#{original}&#34;<br/>&#160; &#160; aka.gsub!(/([\=\|\&amp;\+\-\*\/\^\!\?\~\%\&lt;\&gt;\[\]])/) {<br/>&#160; &#160; &#160; num = $1[0] &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Ruby 1.8 character -&gt; ordinal<br/>&#160; &#160; &#160; num = num.ord if num.is_a? String # Ruby 1.9 character -&gt; ordinal<br/>&#160; &#160; &#160; '_' + num.to_s<br/>&#160; &#160; }<br/>&#160; &#160;&#160;<br/>&#160; &#160; # Keep appending underscores until we get a name that is not in use<br/>&#160; &#160; aka += &#34;_&#34; while method_defined? aka or private_method_defined? aka<br/>
&#160; &#160; aka = aka.to_sym &#160; &#160; &#160; &#160; &#160; &#160;# Convert the alias name to a symbol<br/>&#160; &#160; alias_method aka, original &#160;# Actually create the alias<br/>&#160; &#160; aka &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Return the alias name<br/>&#160; end<br/>
&#160; # Alias chain the named method to add synchronization<br/>&#160; def synchronize_method(m)<br/>&#160; &#160; # First, make an alias for the unsynchronized version of the method.<br/>&#160; &#160; aka = create_alias(m, &#34;unsync&#34;)&#160;<br/>&#160; &#160; # Now redefine the original to invoke the alias in a synchronized block.<br/>&#160; &#160; # We want the defined &#160;method to be able to accept blocks, so we<br/>&#160; &#160; # can't use define_method, and must instead evaluate a string with&#160;<br/>&#160; &#160; # class_eval. Note that everything between %Q{ and the matching }&#160;<br/>&#160; &#160; # is a double-quoted string, not a block.&#160;<br/>&#160; &#160; class_eval %Q{<br/>&#160; &#160; &#160; def #{m}(*args, &amp;block)<br/>&#160; &#160; &#160; &#160; synchronized(self) { #{aka}(*args, &amp;block) }<br/>&#160; &#160; &#160; end<br/>&#160; &#160; }<br/>&#160; end<br/>end<br/>
# This global synchronized method can now be used in three different ways.<br/>def synchronized(*args)<br/>&#160; # Case 1: with one argument and a block, synchronize on the object<br/>&#160; # and execute the block<br/>&#160; if args.size == 1 &amp;&amp; block_given?<br/>&#160; &#160; args[0].mutex.synchronize { yield }<br/>
&#160; # Case two: with one argument that is not a symbol and no block<br/>&#160; # return a SynchronizedObject wrapper<br/>&#160; elsif args.size == 1 and not args[0].is_a? Symbol and not block_given?<br/>&#160; &#160; SynchronizedObject.new(args[0])<br/>
<b>8.11 &#160;Alias Chaining&#160;|&#160;293</b><br/>
<hr/>
<a name=308></a>&#160; # Case three: when invoked on a module with no block, alias chain the<br/>&#160; # named methods to add synchronization. Or, if there are no arguments,&#160;<br/>&#160; # then alias chain the next method defined.<br/>&#160; elsif self.is_a? Module and not block_given?<br/>&#160; &#160; if (args.size &gt; 0) # Synchronize the named methods<br/>&#160; &#160; &#160; args.each {|m| self.synchronize_method(m) }<br/>&#160; &#160; else<br/>&#160; &#160; &#160; # If no methods are specified synchronize the next method defined<br/>&#160; &#160; &#160; eigenclass = class&lt;&lt;self; self; end&#160;<br/>&#160; &#160; &#160; eigenclass.class_eval do # Use eigenclass to define class methods<br/>&#160; &#160; &#160; &#160; # Define method_added for notification when next method is defined<br/>&#160; &#160; &#160; &#160; define_method :method_added do |name|<br/>&#160; &#160; &#160; &#160; &#160; # First remove this hook method<br/>&#160; &#160; &#160; &#160; &#160; eigenclass.class_eval { remove_method :method_added }<br/>&#160; &#160; &#160; &#160; &#160; # Next, synchronize the method that was just added<br/>&#160; &#160; &#160; &#160; &#160; self.synchronize_method name<br/>&#160; &#160; &#160; &#160; end<br/>&#160; &#160; &#160; end<br/>&#160; &#160; end<br/>
&#160; # Case 4: any other invocation is an error<br/>&#160; else<br/>&#160; &#160; raise ArgumentError, &#34;Invalid arguments to synchronize()&#34;<br/>&#160; end<br/>end<br/>
<b>8.11.3 &#160;Chaining Methods for Tracing<br/></b><a href="Rubys.html#308">Example 8-10&#160;is a variant on&#160;</a><a href="Rubys.html#299">Example 8-4&#160;</a>that&#160;supports&#160;tracing&#160;of&#160;named&#160;methods&#160;of<br/>an&#160;&#160;object.&#160;&#160;<a href="Rubys.html#299">Example&#160;&#160;8-4&#160;&#160;</a>used&#160;&#160;delegation&#160;&#160;and&#160;&#160;method_missing&#160;&#160;to&#160;&#160;define&#160;&#160;an<br/>Object.trace&#160;&#160;method&#160;&#160;that&#160;&#160;would&#160;&#160;return&#160;&#160;a&#160;&#160;traced&#160;&#160;wrapper&#160;&#160;object.&#160;&#160;This&#160;&#160;version&#160;&#160;uses<br/>chaining&#160;to&#160;alter&#160;methods&#160;of&#160;an&#160;object&#160;in&#160;place.&#160;It&#160;defines&#160;trace!&#160;and&#160;untrace!&#160;to&#160;chain<br/>and unchain named methods of an object.<br/>The&#160;interesting&#160;thing&#160;about&#160;this&#160;example&#160;is&#160;that&#160;it&#160;does&#160;its&#160;chaining&#160;in&#160;a&#160;different&#160;way<br/>from&#160;<a href="Rubys.html#307">Example&#160;8-9;&#160;</a>it&#160;simply&#160;defines&#160;singleton&#160;methods&#160;on&#160;the&#160;object&#160;and&#160;uses&#160;super<br/>within&#160;the&#160;singleton&#160;to&#160;chain&#160;to&#160;the&#160;original&#160;instance&#160;method&#160;definition.&#160;No&#160;method<br/>aliases are created.<br/>
<i>Example 8-10. Chaining with singleton methods for tracing</i><br/>
# Define trace! and untrace! instance methods for all objects.<br/># trace! &#34;chains&#34; the named methods by defining singleton methods<br/># that add tracing functionality and then use super to call the original.<br/># untrace! deletes the singleton methods to remove tracing.<br/>class Object<br/>&#160; # Trace the specified methods, sending output to STDERR.<br/>&#160; def trace!(*methods)<br/>&#160; &#160; @_traced = @_traced || [] &#160; &#160;# Remember the set of traced methods<br/>
&#160; &#160; # If no methods were specified, use all public methods defined&#160;<br/>&#160; &#160; # directly (not inherited) by the class of this object&#160;<br/>&#160; &#160; methods = public_methods(false) if methods.size == 0<br/>
<b>294&#160;|&#160;Chapter 8:</b> <b>Reflection and Metaprogramming</b><br/>
<hr/>
<a name=309></a>&#160; &#160; methods.map! {|m| m.to_sym } # Convert any strings to symbols<br/>&#160; &#160; methods -= @_traced &#160; &#160; &#160; &#160; &#160;# Remove methods that are already traced<br/>&#160; &#160; return if methods.empty? &#160; &#160; # Return early if there is nothing to do<br/>&#160; &#160; @_traced |= methods &#160; &#160; &#160; &#160; &#160;# Add methods to set of traced methods<br/>
&#160; &#160; # Trace the fact that we're starting to trace these methods<br/>&#160; &#160; STDERR &lt;&lt; &#34;Tracing #{methods.join(', ')} on #{object_id}\n&#34;<br/>
&#160; &#160; # Singleton methods are defined in the eigenclass<br/>&#160; &#160; eigenclass = class &lt;&lt; self; self; end<br/>
&#160; &#160; methods.each do |m| &#160; &#160; &#160; &#160; # For each method m<br/>&#160; &#160; &#160; # Define a traced singleton version of the method m.<br/>&#160; &#160; &#160; # Output tracing information and use super to invoke the<br/>&#160; &#160; &#160; # instance method that it is tracing.<br/>&#160; &#160; &#160; # We want the defined &#160;methods to be able to accept blocks, so we<br/>&#160; &#160; &#160; # can't use define_method, and must instead evaluate a string.<br/>&#160; &#160; &#160; # Note that everything between %Q{ and the matching } is a&#160;<br/>&#160; &#160; &#160; # double-quoted string, not a block. Also note that there are&#160;<br/>&#160; &#160; &#160; # two levels of string interpolations here. #{} is interpolated<br/>&#160; &#160; &#160; # when the singleton method is defined. And \#{} is interpolated&#160;<br/>&#160; &#160; &#160; # when the singleton method is invoked.<br/>&#160; &#160; &#160; eigenclass.class_eval %Q{<br/>&#160; &#160; &#160; &#160; def #{m}(*args, &amp;block)<br/>&#160; &#160; &#160; &#160; &#160; begin<br/>&#160; &#160; &#160; &#160; &#160; &#160; STDERR &lt;&lt; &#34;Entering: #{m}(\#{args.join(', ')})\n&#34;<br/>&#160; &#160; &#160; &#160; &#160; &#160; result = super<br/>&#160; &#160; &#160; &#160; &#160; &#160; STDERR &lt;&lt; &#34;Exiting: #{m} with \#{result}\n&#34;<br/>&#160; &#160; &#160; &#160; &#160; &#160; result<br/>&#160; &#160; &#160; &#160; &#160; rescue<br/>&#160; &#160; &#160; &#160; &#160; &#160; STDERR &lt;&lt; &#34;Aborting: #{m}: \#{$!.class}: \#{$!.message}&#34;<br/>&#160; &#160; &#160; &#160; &#160; &#160; raise<br/>&#160; &#160; &#160; &#160; &#160; end<br/>
&#160;<br/>
&#160; &#160; &#160; &#160; end<br/>&#160; &#160; &#160; }<br/>&#160; &#160; end<br/>&#160; end<br/>
&#160; # Untrace the specified methods or all traced methods<br/>&#160; def untrace!(*methods)<br/>&#160; &#160; if methods.size == 0 &#160; &#160;# If no methods specified untrace<br/>&#160; &#160; &#160; methods = @_traced &#160; &#160;# all currently traced methods<br/>&#160; &#160; &#160; STDERR &lt;&lt; &#34;Untracing all methods on #{object_id}\n&#34;<br/>&#160; &#160; else &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Otherwise, untrace<br/>&#160; &#160; &#160; methods.map! {|m| m.to_sym } &#160;# Convert string to symbols<br/>&#160; &#160; &#160; methods &amp;= @_traced &#160; # all specified methods that are traced<br/>&#160; &#160; &#160; STDERR &lt;&lt; &#34;Untracing #{methods.join(', ')} on #{object_id}\n&#34;<br/>&#160; &#160; end<br/>
&#160; &#160; @_traced -= methods &#160; &#160; # Remove them from our set of traced methods<br/>
&#160; &#160; # Remove the traced singleton methods from the eigenclass<br/>&#160; &#160; # Note that we class_eval a block here, not a string<br/>&#160; &#160; (class &lt;&lt; self; self; end).class_eval do<br/>
<b>8.11 &#160;Alias Chaining&#160;|&#160;295</b><br/>
<hr/>
<a name=310></a>&#160; &#160; &#160; methods.each do |m|<br/>&#160; &#160; &#160; &#160; remove_method m &#160; &#160; # undef_method would not work correctly<br/>&#160; &#160; &#160; end<br/>&#160; &#160; end<br/>
&#160; &#160; # If no methods are traced anymore, remove our instance var&#160;<br/>&#160; &#160; if @_traced.empty?<br/>&#160; &#160; &#160; remove_instance_variable :@_traced<br/>&#160; &#160; end<br/>&#160; end<br/>end<br/>
<b>8.12 &#160;Domain-Specific Languages<br/></b>The&#160;goal&#160;of&#160;metaprogramming&#160;in&#160;Ruby&#160;is&#160;often&#160;the&#160;creation&#160;of&#160;<i>domain-specific&#160;lan-<br/>guages</i>,&#160;or&#160;DSLs.&#160;A&#160;DSL&#160;is&#160;just&#160;an&#160;extension&#160;of&#160;Ruby’s&#160;syntax&#160;(with&#160;methods&#160;that&#160;look<br/>like&#160;keywords)&#160;or&#160;API&#160;that&#160;allows&#160;you&#160;to&#160;solve&#160;a&#160;problem&#160;or&#160;represent&#160;data&#160;more&#160;nat-<br/>urally&#160;than&#160;you&#160;could&#160;otherwise.&#160;For&#160;our&#160;examples,&#160;we’ll&#160;take&#160;the&#160;problem&#160;domain&#160;to<br/>be&#160;the&#160;output&#160;of&#160;XML&#160;formatted&#160;data,&#160;and&#160;we’ll&#160;define&#160;two&#160;DSLs—one&#160;very&#160;simple&#160;and<br/>one more clever—to tackle this problem.*<br/>
<b>8.12.1 &#160;Simple XML Output with method_missing<br/></b>We&#160;begin&#160;with&#160;a&#160;simple&#160;class&#160;named&#160;XML&#160;for&#160;generating&#160;XML&#160;output.&#160;Here’s&#160;an&#160;example<br/>of how the&#160;XML&#160;can be used:<br/>
pagetitle = &#34;Test Page for XML.generate&#34;<br/>XML.generate(STDOUT) do&#160;<br/>&#160; html do<br/>&#160; &#160; head do<br/>&#160; &#160; &#160; title { pagetitle }<br/>&#160; &#160; &#160; comment &#34;This is a test&#34;<br/>&#160; &#160; end<br/>&#160; &#160; body do<br/>&#160; &#160; &#160; h1(:style =&gt; &#34;font-family:sans-serif&#34;) { pagetitle }<br/>&#160; &#160; &#160; ul :type=&gt;&#34;square&#34; do<br/>&#160; &#160; &#160; &#160; li { Time.now }<br/>&#160; &#160; &#160; &#160; li { RUBY_VERSION }<br/>&#160; &#160; &#160; end<br/>&#160; &#160; end<br/>&#160; end<br/>end<br/>
This&#160;code&#160;doesn’t&#160;look&#160;like&#160;XML,&#160;and&#160;it&#160;only&#160;sort&#160;of&#160;looks&#160;like&#160;Ruby.&#160;Here’s&#160;the&#160;output<br/>it generates (with some line breaks added for legibility):<br/>
&lt;html&gt;&lt;head&gt;<br/>&lt;title&gt;Test Page for XML.generate&lt;/title&gt;<br/>&lt;!-- This is a test --&gt;<br/>
*&#160;For a fully realized solution to this problem, see Jim Weirich’s Builder API at&#160;<a href="http://builder.rubyforge.org"><i>http://builder.rubyforge.org</i></a>.<br/>
<b>296&#160;|&#160;Chapter 8:</b> <b>Reflection and Metaprogramming</b><br/>
<hr/>
<a name=311></a>&lt;/head&gt;&lt;body&gt;<br/>&lt;h1 style='font-family:sans-serif'&gt;Test Page for XML.generate&lt;/h1&gt;<br/>&lt;ul type='square'&gt;<br/>&lt;li&gt;2007-08-19 16:19:58 -0700&lt;/li&gt;<br/>&lt;li&gt;1.9.0&lt;/li&gt;<br/>&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;<br/>
To implement this class and the XML generation syntax it supports, we rely on:<br/>
•&#160;Ruby’s block structure<br/>•&#160;Ruby’s parentheses-optional method invocations<br/>•&#160;Ruby’s syntax for passing hash literals to methods without curly braces<br/>•&#160;The&#160;method_missing&#160;method<br/>
<a href="Rubys.html#311">Example 8-11 shows the implementation for this simple DSL.</a><br/>
<i>Example 8-11. A simple DSL for generating XML output</i><br/>
class XML<br/>&#160; # Create an instance of this class, specifying a stream or object to<br/>&#160; # hold the output. This can be any object that responds to &lt;&lt;(String).<br/>&#160; def initialize(out)<br/>&#160; &#160; @out = out &#160;# Remember where to send our output<br/>&#160; end<br/>
&#160; # Output the specified object as CDATA, return nil.<br/>&#160; def content(text)<br/>&#160; &#160; @out &lt;&lt; text.to_s<br/>&#160; &#160; nil<br/>&#160; end<br/>
&#160; # Output the specified object as a comment, return nil.<br/>&#160; def comment(text)<br/>&#160; &#160; @out &lt;&lt; &#34;&lt;!-- #{text} --&gt;&#34;<br/>&#160; &#160; nil<br/>&#160; end<br/>
&#160; # Output a tag with the specified name and attributes.<br/>&#160; # If there is a block invoke it to output or return content.<br/>&#160; # Return nil.<br/>&#160; def tag(tagname, attributes={})<br/>&#160; &#160; # Output the tag name<br/>&#160; &#160; @out &lt;&lt; &#34;&lt;#{tagname}&#34;<br/>
&#160; &#160; # Output the attributes<br/>&#160; &#160; attributes.each {|attr,value| @out &lt;&lt; &#34; #{attr}='#{value}'&#34; }<br/>&#160; &#160;&#160;<br/>&#160; &#160; if block_given?<br/>&#160; &#160; &#160; # This block has content<br/>&#160; &#160; &#160; @out &lt;&lt; '&gt;' &#160; &#160; &#160; &#160; &#160; &#160; # End the opening tag<br/>&#160; &#160; &#160; content = yield &#160; &#160; &#160; &#160; # Invoke the block to output or return content<br/>&#160; &#160; &#160; if content &#160; &#160; &#160; &#160; &#160; &#160; &#160;# If any content returned<br/>&#160; &#160; &#160; &#160; @out &lt;&lt; content.to_s &#160;# Output it as a string<br/>&#160; &#160; &#160; end<br/>&#160; &#160; &#160; @out &lt;&lt; &#34;&lt;/#{tagname}&gt;&#34; # Close the tag<br/>
<b>8.12 &#160;Domain-Specific Languages&#160;|&#160;297</b><br/>
<hr/>
<a name=312></a>&#160; &#160; else&#160;<br/>&#160; &#160; &#160; # Otherwise, this is an empty tag, so just close it.<br/>&#160; &#160; &#160; @out &lt;&lt; '/&gt;'<br/>&#160; &#160; end<br/>&#160; &#160; nil # Tags output themselves, so they don't return any content<br/>&#160; end<br/>
&#160; # The code below is what changes this from an ordinary class into a DSL.<br/>&#160; # First: any unknown method is treated as the name of a tag.<br/>&#160; alias method_missing tag<br/>
&#160; # Second: run a block in a new instance of the class.<br/>&#160; def self.generate(out, &amp;block)<br/>&#160; &#160; XML.new(out).instance_eval(&amp;block)<br/>&#160; end<br/>end<br/>
<b>8.12.2 &#160;Validated XML Output with Method Generation<br/></b>The&#160;XML&#160;class&#160;of&#160;<a href="Rubys.html#311">Example 8-11&#160;</a>is&#160;helpful&#160;for&#160;generating&#160;well-formed&#160;XML,&#160;but&#160;it&#160;does<br/>no&#160;error&#160;checking&#160;to&#160;ensure&#160;that&#160;the&#160;output&#160;is&#160;valid&#160;according&#160;to&#160;any&#160;particular&#160;XML<br/>grammar.&#160;&#160;In&#160;&#160;the&#160;&#160;next&#160;&#160;example,&#160;&#160;<a href="Rubys.html#313">Example&#160;&#160;8-12,&#160;&#160;</a>we&#160;&#160;add&#160;&#160;some&#160;&#160;simple&#160;&#160;error&#160;&#160;checking<br/>(though&#160;not&#160;nearly&#160;enough&#160;to&#160;ensure&#160;complete&#160;validity—that&#160;would&#160;require&#160;a&#160;much<br/>longer&#160;example).&#160;This&#160;example&#160;is&#160;really&#160;two&#160;DSLs&#160;in&#160;one.&#160;The&#160;first&#160;is&#160;a&#160;DSL&#160;for&#160;defining<br/>an XML grammar: a set of tags and the allowed attributes for each tag. You use it like<br/>this:<br/>
class HTMLForm &lt; XMLGrammar<br/>&#160; element :form, :action =&gt; REQ,<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;:method =&gt; &#34;GET&#34;,<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;:enctype =&gt; &#34;application/x-www-form-urlencoded&#34;,<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;:name =&gt; OPT<br/>&#160; element :input, :type =&gt; &#34;text&#34;, :name =&gt; OPT, :value =&gt; OPT,<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; :maxlength =&gt; OPT, :size =&gt; OPT, :src =&gt; OPT,<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; :checked =&gt; BOOL, :disabled =&gt; BOOL, :readonly =&gt; BOOL<br/>&#160; element :textarea, :rows =&gt; REQ, :cols =&gt; REQ, :name =&gt; OPT,<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;:disabled =&gt; BOOL, :readonly =&gt; BOOL<br/>&#160; element :button, :name =&gt; OPT, :value =&gt; OPT,<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;:type =&gt; &#34;submit&#34;, :disabled =&gt; OPT<br/>end<br/>
This&#160;first&#160;DSL&#160;is&#160;defined&#160;by&#160;the&#160;class&#160;method&#160;XMLGrammar.element.&#160;You&#160;use&#160;it&#160;by&#160;sub-<br/>classing&#160;XMLGrammar&#160;to&#160;create&#160;a&#160;new&#160;class.&#160;The&#160;element&#160;method&#160;expects&#160;the&#160;name&#160;of&#160;a<br/>tag&#160;as&#160;its&#160;first&#160;argument&#160;and&#160;a&#160;hash&#160;of&#160;legal&#160;attributes&#160;as&#160;the&#160;second&#160;argument.&#160;The&#160;keys<br/>of&#160;&#160;the&#160;&#160;hash&#160;&#160;are&#160;&#160;attribute&#160;&#160;names.&#160;&#160;These&#160;&#160;names&#160;&#160;may&#160;&#160;map&#160;&#160;to&#160;&#160;default&#160;&#160;values&#160;&#160;for&#160;&#160;the<br/>attribute,&#160;to&#160;the&#160;constant&#160;REQ&#160;for&#160;required&#160;attributes,&#160;or&#160;to&#160;the&#160;constant&#160;OPT&#160;for&#160;optional<br/>attributes. Calling&#160;element&#160;generates&#160;a&#160;method&#160;with&#160;the&#160;specified&#160;name&#160;in&#160;the&#160;subclass<br/>you are defining.<br/>The&#160;subclass&#160;of&#160;XMLGrammar&#160;you&#160;define&#160;is&#160;the&#160;second&#160;DSL,&#160;and&#160;you&#160;can&#160;use&#160;it&#160;to&#160;generate<br/>XML&#160;output&#160;that&#160;is&#160;valid&#160;according&#160;to&#160;the&#160;rules&#160;you&#160;specified.&#160;The&#160;XMLGrammar&#160;class&#160;does<br/>
<b>298&#160;|&#160;Chapter 8:</b> <b>Reflection and Metaprogramming</b><br/>
<hr/>
<a name=313></a>not&#160;have&#160;a&#160;method_missing&#160;method&#160;so&#160;it&#160;won’t&#160;allow&#160;you&#160;to&#160;use&#160;a&#160;tag&#160;that&#160;is&#160;not&#160;part&#160;of<br/>the&#160;grammar.&#160;And&#160;the&#160;tag&#160;method&#160;for&#160;outputting&#160;tags&#160;performs&#160;error&#160;checking&#160;on&#160;your<br/>attributes. Use the generated grammar subclass like the&#160;XML<a href="Rubys.html#311">&#160;class of Example 8-11:</a><br/>
HTMLForm.generate(STDOUT) do<br/>&#160; comment &#34;This is a simple HTML form&#34;<br/>&#160; form :name =&gt; &#34;registration&#34;,<br/>&#160; &#160; &#160; &#160;:action =&gt; &#34;http://www.example.com/register.cgi&#34; do<br/>&#160; &#160; content &#34;Name:&#34;<br/>&#160; &#160; input :name =&gt; &#34;name&#34;<br/>&#160; &#160; content &#34;Address:&#34;<br/>&#160; &#160; textarea :name =&gt; &#34;address&#34;, :rows=&gt;6, :cols=&gt;40 do<br/>&#160; &#160; &#160; &#34;Please enter your mailing address here&#34;<br/>&#160; &#160; end<br/>&#160; &#160; button { &#34;Submit&#34; }<br/>&#160; end<br/>end<br/>
<a href="Rubys.html#313">Example 8-12 shows the implementation of the&#160;</a>XMLGrammar&#160;class.<br/>
<i>Example 8-12. A DSL for validated XML output</i><br/>
class XMLGrammar<br/>&#160; # Create an instance of this class, specifying a stream or object to<br/>&#160; # hold the output. This can be any object that responds to &lt;&lt;(String).<br/>&#160; def initialize(out)<br/>&#160; &#160; @out = out &#160;# Remember where to send our output<br/>&#160; end<br/>
&#160; # Invoke the block in an instance that outputs to the specified stream.<br/>&#160; def self.generate(out, &amp;block)<br/>&#160; &#160; new(out).instance_eval(&amp;block)<br/>&#160; end<br/>
&#160; # Define an allowed element (or tag) in the grammar.<br/>&#160; # This class method is the grammar-specification DSL<br/>&#160; # and defines the methods that constitute the XML-output DSL.<br/>&#160; def self.element(tagname, attributes={})<br/>&#160; &#160; @allowed_attributes ||= {}<br/>&#160; &#160; @allowed_attributes[tagname] = attributes<br/>
&#160; &#160; class_eval %Q{<br/>&#160; &#160; &#160; def #{tagname}(attributes={}, &amp;block)<br/>&#160; &#160; &#160; &#160; tag(:#{tagname},attributes,&amp;block)<br/>&#160; &#160; &#160; end<br/>&#160; &#160; }<br/>&#160; end<br/>
&#160; # These are constants used when defining attribute values.<br/>&#160; OPT = :opt &#160; &#160; # for optional attributes<br/>&#160; REQ = :req &#160; &#160; # for required attributes<br/>&#160; BOOL = :bool &#160; # for attributes whose value is their own name<br/>
&#160; def self.allowed_attributes<br/>&#160; &#160; @allowed_attributes<br/>&#160; end<br/>
<b>8.12 &#160;Domain-Specific Languages&#160;|&#160;299</b><br/>
<hr/>
<a name=314></a>&#160; # Output the specified object as CDATA, return nil.<br/>&#160; def content(text)<br/>&#160; &#160; @out &lt;&lt; text.to_s<br/>&#160; &#160; nil<br/>&#160; end<br/>
&#160; # Output the specified object as a comment, return nil.<br/>&#160; def comment(text)<br/>&#160; &#160; @out &lt;&lt; &#34;&lt;!-- #{text} --&gt;&#34;<br/>&#160; &#160; nil<br/>&#160; end<br/>
&#160; # Output a tag with the specified name and attribute.<br/>&#160; # If there is a block, invoke it to output or return content.<br/>&#160; # Return nil.<br/>&#160; def tag(tagname, attributes={})<br/>&#160; &#160; # Output the tag name<br/>&#160; &#160; @out &lt;&lt; &#34;&lt;#{tagname}&#34;<br/>
&#160; &#160; # Get the allowed attributes for this tag.<br/>&#160; &#160; allowed = self.class.allowed_attributes[tagname]<br/>
&#160; &#160; # First, make sure that each of the attributes is allowed.<br/>&#160; &#160; # Assuming they are allowed, output all of the specified ones.<br/>&#160; &#160; attributes.each_pair do |key,value|<br/>&#160; &#160; &#160; raise &#34;unknown attribute: #{key}&#34; unless allowed.include?(key)<br/>&#160; &#160; &#160; @out &lt;&lt; &#34; #{key}='#{value}'&#34;<br/>&#160; &#160; end<br/>
&#160; &#160; # Now look through the allowed attributes, checking for&#160;<br/>&#160; &#160; # required attributes that were omitted and for attributes with<br/>&#160; &#160; # default values that we can output.<br/>&#160; &#160; allowed.each_pair do |key,value|<br/>&#160; &#160; &#160; # If this attribute was already output, do nothing.<br/>&#160; &#160; &#160; next if attributes.has_key? key<br/>&#160; &#160; &#160; if (value == REQ)<br/>&#160; &#160; &#160; &#160; raise &#34;required attribute '#{key}' missing in &lt;#{tagname}&gt;&#34;<br/>&#160; &#160; &#160; elsif value.is_a? String<br/>&#160; &#160; &#160; &#160; @out &lt;&lt; &#34; #{key}='#{value}'&#34;<br/>&#160; &#160; &#160; end<br/>&#160; &#160; end<br/>
&#160; &#160; if block_given?<br/>&#160; &#160; &#160; # This block has content<br/>&#160; &#160; &#160; @out &lt;&lt; '&gt;' &#160; &#160; &#160; &#160; &#160; &#160; # End the opening tag<br/>&#160; &#160; &#160; content = yield &#160; &#160; &#160; &#160; # Invoke the block to output or return content<br/>&#160; &#160; &#160; if content &#160; &#160; &#160; &#160; &#160; &#160; &#160;# If any content returned<br/>&#160; &#160; &#160; &#160; @out &lt;&lt; content.to_s &#160;# Output it as a string<br/>&#160; &#160; &#160; end<br/>&#160; &#160; &#160; @out &lt;&lt; &#34;&lt;/#{tagname}&gt;&#34; # Close the tag<br/>&#160; &#160; else&#160;<br/>&#160; &#160; &#160; # Otherwise, this is an empty tag, so just close it.<br/>&#160; &#160; &#160; @out &lt;&lt; '/&gt;'<br/>&#160; &#160; end<br/>
<b>300&#160;|&#160;Chapter 8:</b> <b>Reflection and Metaprogramming</b><br/>
<hr/>
<a name=315></a>&#160; &#160; nil # Tags output themselves, so they don't return any content.<br/>&#160; end<br/>end<br/>
<b>8.12 &#160;Domain-Specific Languages&#160;|&#160;301</b><br/>
<hr/>
<a name=316></a><hr/>
<a name=317></a><img src="Ruby-317_1.jpg"/><br/>
<b>CHAPTER&#160;9</b><br/>
<b>The Ruby Platform</b><br/>
<b>303</b><br/>
<hr/>
<a name=318></a>Ruby’s&#160;&#160;core&#160;library&#160;defines&#160;a&#160;rich&#160;and&#160;powerful&#160;API&#160;that&#160;serves&#160;as&#160;a&#160;platform&#160;on&#160;which<br/>to&#160;create&#160;your&#160;programs.&#160;It&#160;is&#160;well&#160;worth&#160;your&#160;time&#160;to&#160;study&#160;and&#160;master&#160;this&#160;API,&#160;par-<br/>ticularly&#160;the&#160;key&#160;classes&#160;such&#160;as&#160;String,&#160;Array,&#160;Hash,&#160;Enumerable,&#160;and&#160;IO.&#160;If&#160;you&#160;aren’t<br/>familiar&#160;with&#160;the&#160;methods&#160;defined&#160;by&#160;these&#160;classes,&#160;you&#160;may&#160;end&#160;up&#160;spending&#160;time<br/>reinventing functionality that is already provided for you.<br/>This&#160;chapter&#160;documents&#160;those&#160;methods.&#160;It&#160;is&#160;not&#160;a&#160;comprehensive&#160;API&#160;reference,&#160;but<br/>attempts&#160;to&#160;illustrate,&#160;with&#160;short&#160;code&#160;snippets,&#160;the&#160;use&#160;of&#160;the&#160;important&#160;methods&#160;of<br/>all&#160;the&#160;important&#160;core&#160;classes&#160;and&#160;modules,&#160;and&#160;a&#160;few&#160;of&#160;the&#160;most&#160;commonly&#160;used<br/>classes&#160;from&#160;the&#160;standard&#160;library.&#160;The&#160;aim&#160;is&#160;to&#160;familiarize&#160;you&#160;with&#160;the&#160;broad&#160;range&#160;of<br/>existing&#160;methods,&#160;so&#160;that&#160;when&#160;you&#160;need&#160;one&#160;of&#160;them,&#160;you&#160;will&#160;remember&#160;that&#160;it&#160;exists<br/>and will be able to find its documentation with&#160;<i>ri</i>.<br/>This is a long chapter, broken down into sections that cover the following:<br/>
•&#160;Strings and text processing<br/>•&#160;Regular expressions<br/>•&#160;Numbers and math<br/>•&#160;Dates and times<br/>•&#160;The&#160;Enumerable&#160;module and the&#160;Array,&#160;Hash&#160;and&#160;Set&#160;collections<br/>•&#160;Input/output and files<br/>•&#160;Networking<br/>•&#160;Threads and concurrency<br/>
You’ll&#160;find&#160;that&#160;the&#160;code&#160;early&#160;in&#160;the&#160;chapter&#160;takes&#160;the&#160;form&#160;of&#160;one-line&#160;snippets&#160;dem-<br/>onstrating&#160;&#160;individual&#160;&#160;methods.&#160;&#160;Toward&#160;&#160;the&#160;&#160;end,&#160;&#160;however,&#160;&#160;when&#160;&#160;documenting<br/>networking&#160;and&#160;threads,&#160;the&#160;examples&#160;become&#160;longer&#160;and&#160;demonstrate&#160;how&#160;to&#160;accom-<br/>plish&#160;common&#160;tasks&#160;like&#160;creating&#160;a&#160;network&#160;client&#160;or&#160;using&#160;threads&#160;to&#160;concurrently<br/>process the items in a collection.<br/>
<b>9.1 &#160;Strings<br/></b><a href="Rubys.html#55">Chapter&#160;3explained&#160;</a>Ruby’s&#160;string&#160;literal&#160;syntax,&#160;as&#160;well&#160;as&#160;the&#160;&#160;String&#160;operators&#160;for<br/>concatenation&#160;(+),&#160;appends&#160;(&lt;&lt;),&#160;repetition&#160;(*),&#160;and&#160;indexing&#160;([]).&#160;In&#160;this&#160;section&#160;we<br/>expand&#160;on&#160;that&#160;coverage&#160;by&#160;demonstrating&#160;the&#160;named&#160;methods&#160;of&#160;the&#160;String&#160;class.&#160;The<br/>subsections that follow this API overview cover specific areas in more detail.<br/>We&#160;&#160;begin&#160;&#160;with&#160;&#160;methods&#160;&#160;that&#160;&#160;provide&#160;&#160;named&#160;&#160;alternatives&#160;&#160;to&#160;&#160;some&#160;&#160;of&#160;&#160;the&#160;&#160;operators<br/><a href="Rubys.html#55">documented in Chapter 3:</a><br/>
s = &#34;hello&#34;<br/>s.concat(&#34; world&#34;) &#160; &#160;# Synonym for &lt;&lt;. Mutating append to s. Returns new s.<br/>s.insert(5, &#34; there&#34;) # Same as s[5,0] = &#34; there&#34;. Alters s. Returns new s.<br/>s.slice(0,5) &#160; &#160; &#160; &#160; &#160;# Same as s[0,5]. Returns a substring.<br/>s.slice!(5,6) &#160; &#160; &#160; &#160; # Deletion. Same as s[5,6]=&#34;&#34;. Returns deleted substring.<br/>s.eql?(&#34;hello world&#34;) # True. Same as ==.<br/>
<b>304&#160;|&#160;Chapter 9:</b> <b>The Ruby Platform</b><br/>
<hr/>
<a name=319></a>There are several methods for querying the length of a string:<br/>
s.length &#160; &#160; &#160; &#160; # =&gt; 11: counts characters in 1.9, bytes in 1.8<br/>s.size &#160; &#160; &#160; &#160; &#160; # =&gt; 11: size is a synonym<br/>s.bytesize &#160; &#160; &#160; # =&gt; 11: length in bytes; Ruby 1.9 only<br/>s.empty? &#160; &#160; &#160; &#160; # =&gt; false<br/>&#34;&#34;.empty? &#160; &#160; &#160; &#160;# =&gt; true<br/>
String&#160;methods&#160;for&#160;searching&#160;a&#160;string&#160;and&#160;for&#160;replacing&#160;content&#160;include&#160;the&#160;following.<br/>We’ll revisit some of these when we consider regular expressions later in this section:<br/>
s = &#34;hello&#34;<br/># Finding the position of a substring or pattern match<br/>s.index('l') &#160; &#160; &#160; &#160; # =&gt; 2: index of first l in string<br/>s.index(?l) &#160; &#160; &#160; &#160; &#160;# =&gt; 2: works with character codes as well<br/>s.index(/l+/) &#160; &#160; &#160; &#160;# =&gt; 2: works with regular expressions, too<br/>s.index('l',3) &#160; &#160; &#160; # =&gt; 3: index of first l in string at or after position 3<br/>s.index('Ruby') &#160; &#160; &#160;# =&gt; nil: search string not found<br/>s.rindex('l') &#160; &#160; &#160; &#160;# =&gt; 3: index of rightmost l in string<br/>s.rindex('l',2) &#160; &#160; &#160;# =&gt; 2: index of rightmost l in string at or before 2<br/>
# Checking for prefixes and suffixes: Ruby 1.9 and later<br/>s.start_with? &#34;hell&#34; # =&gt; true. Note start_with not starts_with<br/>s.end_with? &#34;bells&#34; &#160;# =&gt; false<br/>
# Testing for presence of substring<br/>s.include?(&#34;ll&#34;) &#160; &#160; # =&gt; true: &#34;hello&#34; includes &#34;ll&#34;<br/>s.include?(?H) &#160; &#160; &#160; # =&gt; false: &#34;hello&#34; does not include character H<br/>
# Pattern matching with regular expressions<br/>s =~ /[aeiou]{2}/ &#160; &#160;# =&gt; nil: no double vowels in &#34;hello&#34;<br/>s.match(/[aeiou]/) {|m| m.to_s} # =&gt; &#34;e&#34;: return first vowel<br/>
# Splitting a string into substrings based on a delimiter string or pattern<br/>&#34;this is it&#34;.split &#160; &#160; # =&gt; [&#34;this&#34;, &#34;is&#34;, &#34;it&#34;]: split on spaces by default<br/>&#34;hello&#34;.split('l') &#160; &#160; # =&gt; [&#34;he&#34;, &#34;&#34;, &#34;o&#34;]<br/>&#34;1, 2,3&#34;.split(/,\s*/) # =&gt; [&#34;1&#34;,&#34;2&#34;,&#34;3&#34;]: comma and optional space delimiter<br/>
# Split a string into two parts plus a delimiter. Ruby 1.9 only.<br/># These methods always return arrays of 3 strings:<br/>&#34;banana&#34;.partition(&#34;an&#34;) &#160;# =&gt; [&#34;b&#34;, &#34;an&#34;, &#34;ana&#34;]&#160;<br/>&#34;banana&#34;.rpartition(&#34;an&#34;) # =&gt; [&#34;ban&#34;, &#34;an&#34;, &#34;a&#34;]: start from right<br/>&#34;a123b&#34;.partition(/\d+/) &#160;# =&gt; [&#34;a&#34;, &#34;123&#34;, &#34;b&#34;]: works with Regexps, too<br/>
# Search and replace the first (sub, sub!) or all (gsub, gsub!)<br/># occurrences of the specified string or pattern.<br/># More about sub and gsub when we cover regular expressions later.<br/>s.sub(&#34;l&#34;, &#34;L&#34;) &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; &#34;heLlo&#34;: Just replace first occurrence<br/>s.gsub(&#34;l&#34;, &#34;L&#34;) &#160; &#160; &#160; &#160; &#160; # =&gt; &#34;heLLo&#34;: Replace all occurrences<br/>s.sub!(/(.)(.)/, '\2\1') &#160; # =&gt; &#34;ehllo&#34;: Match and swap first 2 letters<br/>s.sub!(/(.)(.)/, &#34;\\2\\1&#34;) # =&gt; &#34;hello&#34;: Double backslashes for double quotes<br/># sub and gsub can also compute a replacement string with a block<br/># Match the first letter of each word and capitalize it<br/>&#34;hello world&#34;.gsub(/\b./) {|match| match.upcase } # =&gt; &#34;Hello World&#34;<br/># In Ruby 1.9, you can specify a hash to map matches to replacements<br/>s.gsub(/[aeiou]/,&#34;a&#34;=&gt;0, &#34;e&#34;=&gt;1, &#34;i&#34;=&gt;2) &#160; # =&gt; &#34;h1ll&#34;<br/>
<b>9.1 &#160;Strings&#160;|&#160;305</b><br/>
<hr/>
<a name=320></a>The&#160;last&#160;line&#160;of&#160;this&#160;example&#160;uses&#160;the&#160;upcase&#160;method&#160;to&#160;convert&#160;a&#160;string&#160;to&#160;uppercase.<br/>The&#160;String&#160;class&#160;defines&#160;a&#160;number&#160;of&#160;methods&#160;for&#160;working&#160;with&#160;case&#160;(but&#160;it&#160;does&#160;not<br/>define methods for testing the case or category of a character):<br/>
# Case modification methods<br/>s = &#34;world&#34; &#160; # These methods work with ASCII characters only<br/>s.upcase &#160; &#160; &#160;# =&gt; &#34;WORLD&#34;<br/>s.upcase! &#160; &#160; # =&gt; &#34;WORLD&#34;; alter s in place<br/>s.downcase &#160; &#160;# =&gt; &#34;world&#34;<br/>s.capitalize &#160;# =&gt; &#34;World&#34;: first letter upper, rest lower<br/>s.capitalize! # =&gt; &#34;World&#34;: alter s in place<br/>s.swapcase &#160; &#160;# =&gt; &#34;wORLD&#34;: alter case of each letter<br/>
# Case insensitive comparison. (ASCII text only)<br/># casecmp works like &lt;=&gt; and returns -1 for less, 0 for equal, +1 for greater<br/>&#34;world&#34;.casecmp(&#34;WORLD&#34;) &#160;# =&gt; 0&#160;<br/>&#34;a&#34;.casecmp(&#34;B&#34;) &#160; &#160; &#160; &#160; &#160;# =&gt; -1 (&lt;=&gt; returns 1 in this case)<br/>
String&#160;defines&#160;a&#160;number&#160;of&#160;useful&#160;methods&#160;for&#160;adding&#160;and&#160;removing&#160;whitespace.&#160;Most<br/>exist in mutating (end with&#160;!) and nonmutating versions:<br/>
s = &#34;hello\r\n&#34; &#160; &#160; &#160;# A string with a line terminator<br/>s.chomp! &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; &#34;hello&#34;: remove one line terminator from end<br/>s.chomp &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; &#34;hello&#34;: no line terminator so no change<br/>s.chomp! &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; nil: return of nil indicates no change made<br/>s.chomp(&#34;o&#34;) &#160; &#160; &#160; &#160; # =&gt; &#34;hell&#34;: remove &#34;o&#34; from end<br/>$/ = &#34;;&#34; &#160; &#160; &#160; &#160; &#160; &#160; # Set global record separator $/ to semicolon<br/>&#34;hello;&#34;.chomp &#160; &#160; &#160; # =&gt; &#34;hello&#34;: now chomp removes semicolons and end<br/>
# chop removes trailing character or line terminator (\n, \r, or \r\n)<br/>s = &#34;hello\n&#34;<br/>s.chop! &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; &#34;hello&#34;: line terminator removed. s modified.<br/>s.chop &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; &#34;hell&#34;: last character removed. s not modified.<br/>&#34;&#34;.chop &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; &#34;&#34;: no characters to remove<br/>&#34;&#34;.chop! &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; nil: nothing changed<br/>
# Strip all whitespace (including \t, \r, \n) from left, right, or both<br/># strip!, lstrip! and rstrip! modify the string in place.<br/>s = &#34;\t hello \n&#34; &#160; # Whitespace at beginning and end<br/>s.strip &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; &#34;hello&#34;<br/>s.lstrip &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; &#34;hello \n&#34;<br/>s.rstrip &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; &#34;\t hello&#34;<br/>
# Left-justify, right-justify, or center a string in a field n-characters wide.<br/># There are no mutator versions of these methods. See also printf method.<br/>s = &#34;x&#34;<br/>s.ljust(3) &#160; &#160; &#160; &#160; &#160;# =&gt; &#34;x &#160;&#34;<br/>s.rjust(3) &#160; &#160; &#160; &#160; &#160;# =&gt; &#34; &#160;x&#34;<br/>s.center(3) &#160; &#160; &#160; &#160; # =&gt; &#34; x &#34;<br/>s.center(5, '-') &#160; &#160;# =&gt; &#34;--x--&#34;: padding other than space are allowed<br/>s.center(7, '-=') &#160; # =&gt; &#34;-=-x-=-&#34;: multicharacter padding allowed<br/>
Strings&#160;&#160;may&#160;&#160;be&#160;&#160;enumerated&#160;&#160;byte-by-byte&#160;&#160;or&#160;&#160;line-by-line&#160;&#160;with&#160;&#160;the&#160;&#160;each_byte&#160;&#160;and<br/>each_line&#160;iterators.&#160;In&#160;Ruby&#160;1.8,&#160;the&#160;each&#160;method&#160;is&#160;a&#160;synonym&#160;for&#160;each_line, and the<br/>String&#160;&#160;class&#160;&#160;includes&#160;&#160;Enumerable.&#160;&#160;Avoid&#160;&#160;using&#160;&#160;each&#160;&#160;and&#160;&#160;its&#160;&#160;related&#160;&#160;iterators&#160;&#160;because<br/>
<b>306&#160;|&#160;Chapter 9:</b> <b>The Ruby Platform</b><br/>
<hr/>
<a name=321></a>Ruby 1.9 removes the&#160;each&#160;method&#160;and&#160;no&#160;longer&#160;makes&#160;strings&#160;Enumerable. Ruby 1.9<br/>(and&#160;the&#160;jcode&#160;library&#160;in&#160;Ruby&#160;1.8)&#160;adds&#160;an&#160;each_char&#160;iterator&#160;and&#160;enables&#160;character-<br/>by-character &#160;enumeration of strings:<br/>
s = &#34;A\nB&#34; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Three ASCII characters on two lines<br/>s.each_byte {|b| print b, &#34; &#34; } &#160;# Prints &#34;65 10 66 &#34;<br/>s.each_line {|l| print l.chomp} &#160;# Prints &#34;AB&#34;<br/>
# Sequentially iterate characters as 1-character strings<br/># Works in Ruby 1.9, or in 1.8 with the jcode library:<br/>s.each_char { |c| print c, &#34; &#34; } # Prints &#34;A \n B &#34;<br/>
# Enumerate each character as a 1-character string<br/># This does not work for multibyte strings in 1.8<br/># It works (inefficiently) for multibyte strings in 1.9:<br/>0.upto(s.length-1) {|n| print s[n,1], &#34; &#34;}<br/>
# In Ruby 1.9, bytes, lines, and chars are aliases<br/>s.bytes.to_a &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; [65,10,66]: alias for each_byte<br/>s.lines.to_a &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; [&#34;A\n&#34;,&#34;B&#34;]: alias for each_line<br/>s.chars.to_a &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; [&#34;A&#34;, &#34;\n&#34;, &#34;B&#34;] alias for each_char<br/>
String&#160;&#160;defines&#160;&#160;a&#160;&#160;number&#160;&#160;of&#160;&#160;methods&#160;&#160;for&#160;&#160;parsing&#160;&#160;numbers&#160;&#160;from&#160;&#160;strings,&#160;&#160;and&#160;&#160;for<br/>converting strings to symbols:<br/>
&#34;10&#34;.to_i &#160; &#160; &#160; &#160; &#160;# =&gt; 10: convert string to integer<br/>&#34;10&#34;.to_i(2) &#160; &#160; &#160; # =&gt; 2: argument is radix: between base-2 and base-36<br/>&#34;10x&#34;.to_i &#160; &#160; &#160; &#160; # =&gt; 10: nonnumeric suffix is ignored. Same for oct, hex<br/>&#34; 10&#34;.to_i &#160; &#160; &#160; &#160; # =&gt; 10: leading whitespace ignored<br/>&#34;ten&#34;.to_i &#160; &#160; &#160; &#160; # =&gt; 0: does not raise exception on bad input<br/>&#34;10&#34;.oct &#160; &#160; &#160; &#160; &#160; # =&gt; 8: parse string as base-8 integer<br/>&#34;10&#34;.hex &#160; &#160; &#160; &#160; &#160; # =&gt; 16: parse string as hexadecimal integer<br/>&#34;0xff&#34;.hex &#160; &#160; &#160; &#160; # =&gt; 255: hex numbers may begin with 0x prefix<br/>&#34; 1.1 dozen&#34;.to_f &#160;# =&gt; 1.1: parse leading floating-point number<br/>&#34;6.02e23&#34;.to_f &#160; &#160; # =&gt; 6.02e+23: exponential notation supported<br/>
&#34;one&#34;.to_sym &#160; &#160; &#160; # =&gt; :one -- string to symbol conversion<br/>&#34;two&#34;.intern &#160; &#160; &#160; # =&gt; :two -- intern is a synonym for to_sym<br/>
Finally, here are some miscellaneous&#160;String&#160;methods:<br/>
# Increment a string:<br/>&#34;a&#34;.succ &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; &#34;b&#34;: the successor of &#34;a&#34;. Also, succ!<br/>&#34;aaz&#34;.next &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; &#34;aba&#34;: next is a synonym. Also, next!<br/>&#34;a&#34;.upto(&#34;e&#34;) {|c| print c } &#160;# Prints &#34;abcde&#34;. upto iterator based on succ.<br/>
# Reverse a string:<br/>&#34;hello&#34;.reverse &#160; &#160; # =&gt; &#34;olleh&#34;. Also reverse!<br/>
# Debugging<br/>&#34;hello\n&#34;.dump &#160; &#160; &#160;# =&gt; &#34;\&#34;hello\\n\&#34;&#34;: Escape special characters<br/>&#34;hello\n&#34;.inspect &#160; # Works much like dump<br/>
# Translation from one set of characters to another<br/>&#34;hello&#34;.tr(&#34;aeiou&#34;, &#34;AEIOU&#34;) &#160;# =&gt; &#34;hEllO&#34;: capitalize vowels. Also tr!<br/>&#34;hello&#34;.tr(&#34;aeiou&#34;, &#34; &#34;) &#160; &#160; &#160;# =&gt; &#34;h ll &#34;: convert vowels to spaces<br/>
<b>9.1 &#160;Strings&#160;|&#160;307</b><br/>
<hr/>
<a name=322></a>&#34;bead&#34;.tr_s(&#34;aeiou&#34;, &#34; &#34;) &#160; &#160; # =&gt; &#34;b d&#34;: convert and remove duplicates<br/>
# Checksums<br/>&#34;hello&#34;.sum &#160; &#160; &#160; &#160; &#160;# =&gt; 532: weak 16-bit checksum<br/>&#34;hello&#34;.sum(8) &#160; &#160; &#160; # =&gt; 20: 8 bit checksum instead of 16 bit<br/>&#34;hello&#34;.crypt(&#34;ab&#34;) &#160;# =&gt; &#34;abl0JrMf6tlhw&#34;: one way cryptographic checksum<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Pass two alphanumeric characters as &#34;salt&#34;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# The result may be platform-dependent<br/>
# Counting letters, deleting letters, and removing duplicates<br/>&#34;hello&#34;.count('aeiou') &#160;# =&gt; 2: count lowercase vowels<br/>&#34;hello&#34;.delete('aeiou') # =&gt; &#34;hll&#34;: delete lowercase vowels. Also delete!<br/>&#34;hello&#34;.squeeze('a-z') &#160;# =&gt; &#34;helo&#34;: remove runs of letters. Also squeeze!<br/># When there is more than one argument, take the intersection.<br/># Arguments that begin with ^ are negated.<br/>&#34;hello&#34;.count('a-z', '^aeiou') &#160; # =&gt; 3: count lowercase consonants<br/>&#34;hello&#34;.delete('a-z', '^aeiou') &#160;# =&gt; &#34;eo: delete lowercase consonants<br/>
<b>9.1.1 &#160;Formatting Text<br/></b>As&#160;you&#160;know,&#160;Ruby’s&#160;double-quoted&#160;string&#160;literals&#160;allow&#160;arbitrary&#160;Ruby&#160;expressions&#160;to<br/>be interpolated into strings. For example:<br/>
n, animal = 2, &#34;mice&#34;<br/>&#34;#{n+1} blind #{animal}&#34; &#160;# =&gt; '3 blind mice'<br/>
This&#160;string-literal&#160;interpolation&#160;syntax&#160;was&#160;documented&#160;in&#160;<a href="Rubys.html#55">Chapter 3</a>.&#160;Ruby&#160;also&#160;sup-<br/>ports&#160;another&#160;technique&#160;for&#160;interpolating&#160;values&#160;into&#160;strings:&#160;the&#160;String&#160;class&#160;defines&#160;a<br/>format&#160;operator&#160;%,&#160;and&#160;the&#160;Kernel&#160;module&#160;defines&#160;global&#160;printf&#160;and&#160;sprintf&#160;meth-<br/>ods.&#160;&#160;These&#160;&#160;methods&#160;&#160;and&#160;&#160;the&#160;&#160;%&#160;&#160;operator&#160;&#160;are&#160;&#160;very&#160;&#160;much&#160;&#160;like&#160;&#160;the&#160;&#160;printf&#160;&#160;function<br/>popularized&#160;by&#160;the&#160;C&#160;programming&#160;language.&#160;One&#160;advantage&#160;of&#160;printf-style&#160;formatting<br/>over&#160;regular&#160;string&#160;literal&#160;interpolation&#160;is&#160;that&#160;it&#160;allows&#160;precise&#160;control&#160;over&#160;field&#160;widths,<br/>which&#160;makes&#160;it&#160;useful&#160;for&#160;ASCII&#160;report&#160;generation.&#160;Another&#160;advantage&#160;is&#160;that&#160;it&#160;allows<br/>you&#160;to&#160;specify&#160;the&#160;number&#160;of&#160;significant&#160;digits&#160;to&#160;display&#160;in&#160;floating-point&#160;numbers,<br/>which&#160;is&#160;useful&#160;in&#160;scientific&#160;(and&#160;sometimes&#160;financial)&#160;applications.&#160;Finally,&#160;printf-style<br/>formatting&#160;decouples&#160;the&#160;values&#160;to&#160;be&#160;formatted&#160;from&#160;the&#160;string&#160;into&#160;which&#160;they&#160;are<br/>interpolated.&#160;&#160;This&#160;&#160;can&#160;&#160;be&#160;&#160;helpful&#160;&#160;for&#160;&#160;internationalization&#160;&#160;and&#160;&#160;localization&#160;&#160;of<br/>applications.<br/>Examples&#160;using&#160;the&#160;%&#160;operator&#160;follow.&#160;See&#160;Kernel.sprintf&#160;for&#160;complete&#160;documentation<br/>of the formatting directives used by these methods:<br/>
# Alternatives to the interpolation above<br/>printf('%d blind %s', n+1, animal) &#160;# Prints '3 blind mice', returns nil<br/>sprintf('%d blind %s', n+1, animal) # =&gt; '3 blind mice'<br/>'%d blind %s' % [n+1, animal] &#160;# Use array on right if more than one argument<br/>
# Formatting numbers<br/>'%d' % 10 &#160; &#160; &#160; &#160; # =&gt; '10': %d for decimal integers<br/>'%x' % 10 &#160; &#160; &#160; &#160; # =&gt; 'a': hexadecimal integers<br/>'%X' % 10 &#160; &#160; &#160; &#160; # =&gt; 'A': uppercase hexadecimal integers<br/>'%o' % 10 &#160; &#160; &#160; &#160; # =&gt; '12': octal integers<br/>
<b>308&#160;|&#160;Chapter 9:</b> <b>The Ruby Platform</b><br/>
<hr/>
<a name=323></a>'%f' % 1234.567 &#160; # =&gt; '1234.567000': full-length floating-point numbers<br/>'%e' % 1234.567 &#160; # =&gt; '1.234567e+03': force exponential notation<br/>'%E' % 1234.567 &#160; # =&gt; '1.234567e+03': exponential with uppercase E<br/>'%g' % 1234.567 &#160; # =&gt; '1234.57': six significant digits<br/>'%g' % 1.23456E12 # =&gt; '1.23456e+12': Use %f or %e depending on magnitude<br/>
# Field width<br/>'%5s' % '&lt;&lt;&lt;' &#160; &#160; # ' &#160;&lt;&lt;&lt;': right-justify in field five characters wide<br/>'%-5s' % '&gt;&gt;&gt;' &#160; &#160;# '&gt;&gt;&gt; &#160;': left-justify in field five characters wide<br/>'%5d' % 123 &#160; &#160; &#160; # ' &#160;123': field is five characters wide<br/>'%05d' % 123 &#160; &#160; &#160;# '00123': pad with zeros in field five characters wide<br/>
# Precision<br/>'%.2f' % 123.456 &#160;# '123.46': two digits after decimal place<br/>'%.2e' % 123.456 &#160;# '1.23e+02': two digits after decimal = three significant digits<br/>'%.6e' % 123.456 &#160;# '1.234560e+02': note added zero&#160;<br/>'%.4g' % 123.456 &#160;# '123.5': four significant digits<br/>
# Field and precision combined<br/>'%6.4g' % 123.456 # ' 123.5': four significant digits in field six chars wide<br/>'%3s' % 'ruby' &#160; &#160;# 'ruby': string argument exceeds field width<br/>'%3.3s' % 'ruby' &#160;# 'rub': precision forces truncation of string<br/>
# Multiple arguments to be formatted<br/>args = ['Syntax Error', 'test.rb', 20] &#160;# An array of arguments<br/>&#34;%s: in '%s' line %d&#34; % args &#160; &#160;# =&gt; &#34;Syntax Error: in 'test.rb' line 20&#34;&#160;<br/># Same args, interpolated in different order! &#160;Good for internationalization.<br/>&#34;%2$s:%3$d: %1$s&#34; % args &#160; &#160; &#160; &#160;# =&gt; &#34;test.rb:20: Syntax Error&#34;<br/>
<b>9.1.2 &#160;Packing and Unpacking Binary Strings<br/></b>Ruby’s&#160;&#160;strings&#160;&#160;can&#160;&#160;hold&#160;&#160;binary&#160;&#160;data&#160;&#160;as&#160;&#160;well&#160;&#160;as&#160;&#160;textual&#160;&#160;data.&#160;&#160;A&#160;&#160;pair&#160;&#160;of&#160;&#160;methods,<br/>Array.pack&#160;and&#160;String.unpack,&#160;can&#160;be&#160;helpful&#160;if&#160;you&#160;are&#160;working&#160;with&#160;binary&#160;file&#160;formats<br/>or&#160;binary&#160;network&#160;protocols.&#160;Use&#160;Array.pack&#160;to&#160;encode&#160;the&#160;elements&#160;of&#160;an&#160;array&#160;into&#160;a<br/>binary&#160;string.&#160;And&#160;use&#160;String.unpack&#160;to&#160;decode&#160;a&#160;binary&#160;string,&#160;extracting&#160;values&#160;from<br/>it&#160;and&#160;returning&#160;those&#160;values&#160;in&#160;an&#160;array.&#160;Both&#160;the&#160;encoding&#160;and&#160;decoding&#160;operations<br/>are&#160;under&#160;the&#160;control&#160;of&#160;a&#160;format&#160;string&#160;where&#160;letters&#160;specify&#160;the&#160;datatype&#160;and&#160;encoding<br/>and&#160;numbers&#160;specify&#160;the&#160;number&#160;of&#160;repetitions.&#160;The&#160;creation&#160;of&#160;these&#160;format&#160;strings&#160;is<br/>fairly&#160;arcane,&#160;and&#160;you&#160;can&#160;find&#160;a&#160;complete&#160;list&#160;of&#160;letter&#160;codes&#160;in&#160;the&#160;documentation&#160;for<br/>Array.pack&#160;and&#160;String.unpack. Here are some simple examples:<br/>
a = [1,2,3,4,5,6,7,8,9,10] &#160;# An array of 10 integers<br/>b = a.pack('i10') &#160; &#160; &#160; &#160; &#160; # Pack 10 4-byte integers (i) into binary string b<br/>c = b.unpack('i*') &#160; &#160; &#160; &#160; &#160;# Decode all (*) the 4-byte integers from b<br/>c == a &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; true<br/>
m = 'hello world' &#160; &#160; &#160; &#160; &#160; # A message to encode<br/>data = [m.size, m] &#160; &#160; &#160; &#160; &#160;# Length first, then the bytes<br/>template = 'Sa*' &#160; &#160; &#160; &#160; &#160; &#160;# Unsigned short, any number of ASCII chars<br/>b = data.pack(template) &#160; &#160; # =&gt; &#34;\v\000hello world&#34;<br/>b.unpack(template) &#160; &#160; &#160; &#160; &#160;# =&gt; [11, &#34;hello world&#34;]<br/>
<b>9.1 &#160;Strings&#160;|&#160;309</b><br/>
<hr/>
<a name=324></a><b>9.1.3 &#160;Strings and Encodings<br/></b>The&#160;String&#160;methods&#160;encoding,&#160;encode,&#160;encode!,&#160;and&#160;force_encoding&#160;and&#160;the&#160;Encoding<br/>class&#160;were&#160;described&#160;<a href="Rubys.html#72">in&#160;§3.2.6.&#160;</a>You&#160;may&#160;want&#160;to&#160;reread&#160;that&#160;section&#160;now&#160;if&#160;you&#160;will&#160;be<br/>writing programs using Unicode or other multibyte character encodings.<br/>
<b>9.2 &#160;Regular Expressions<br/></b>A&#160;&#160;<i>regular&#160;&#160;expression</i>&#160;&#160;(also&#160;&#160;known&#160;&#160;as&#160;&#160;a&#160;&#160;regexp&#160;&#160;or&#160;&#160;regex)&#160;&#160;describes&#160;&#160;a&#160;&#160;textual&#160;&#160;pattern.<br/>Ruby’s&#160;Regexp&#160;class*&#160;&#160;implements regular expressions, and both&#160;&#160;Regexp&#160;and&#160;String&#160;de-<br/>fine&#160;pattern&#160;matching&#160;methods&#160;and&#160;operators.&#160;Like&#160;most&#160;languages&#160;that&#160;support&#160;regular<br/>expressions,&#160;Ruby’s&#160;Regexp&#160;syntax&#160;follows&#160;closely&#160;(but&#160;not&#160;precisely)&#160;the&#160;syntax&#160;of&#160;Perl<br/>5.<br/>
<b>9.2.1 &#160;Regexp Literals<br/></b>Regular expression literals are delimited by forward slash characters:<br/>
/Ruby?/ &#160;# Matches the text &#34;Rub&#34; followed by an optional &#34;y&#34;<br/>
The&#160;closing&#160;slash&#160;character&#160;isn’t&#160;a&#160;true&#160;delimiter&#160;because&#160;a&#160;regular&#160;expression&#160;literal<br/>may be followed by one or more optional flag characters that specify additional infor-<br/>mation about the how pattern matching is to be done. For example:<br/>
/ruby?/i &#160;# Case-insensitive: matches &#34;ruby&#34; or &#34;RUB&#34;, etc.<br/>/./mu &#160; &#160; # Matches Unicode characters in Multiline mode<br/>
<a href="Rubys.html#324">The allowed modifier characters are shown in Table 9-1.</a><br/>
<i>Table 9-1. Regular expression modifier characters</i><br/>
&#160;<br/>
<b>Modifier</b><br/>
<b>Description</b><br/>
i&#160;<br/>
Ignore case when matching text.<br/>
m&#160;<br/>
The pattern is to be matched against multiline text, so treat newline as an ordinary character: allow&#160;.&#160;to match<br/>newlines.<br/>
x&#160;<br/>
Extended syntax: allow whitespace and comments in regexp.<br/>
o&#160;<br/>
Perform&#160;#{}&#160;interpolations only once, the first time the regexp literal is evaluated.<br/>
u,e,s,n<br/>
Interpret the regexp as Unicode (UTF-8), EUC, SJIS, or ASCII. If none of these modifiers is specified, the regular<br/>expression is assumed to use the source encoding.<br/>
Like&#160;string&#160;literals&#160;delimited&#160;with&#160;%Q,&#160;Ruby&#160;allows&#160;you&#160;to&#160;begin&#160;your&#160;regular&#160;expres-<br/>sions&#160;with&#160;%r&#160;followed&#160;by&#160;a&#160;delimiter&#160;of&#160;your&#160;choice.&#160;This&#160;is&#160;useful&#160;when&#160;the&#160;pattern<br/>you&#160;are&#160;describing&#160;contains&#160;a&#160;lot&#160;of&#160;forward&#160;slash&#160;characters&#160;that&#160;you&#160;don’t&#160;want&#160;to<br/>escape:<br/>
*&#160;JavaScript&#160;programmers&#160;should&#160;note&#160;that&#160;the&#160;Ruby&#160;class&#160;has&#160;a&#160;lowercase&#160;e,&#160;unlike&#160;the&#160;JavaScript&#160;RegExp&#160;class.<br/>
<b>310&#160;|&#160;Chapter 9:</b> <b>The Ruby Platform</b><br/>
<hr/>
<a name=325></a>%r|/| &#160; &#160; &#160; &#160; # Matches a single slash character, no escape required<br/>%r[&lt;/(.*)&gt;]i &#160;# Flag characters are allowed with this syntax, too<br/>
Regular&#160;expression&#160;syntax&#160;gives&#160;special&#160;meaning&#160;to&#160;the&#160;characters&#160;(),&#160;[],&#160;{},&#160;.,&#160;?,&#160;+,&#160;*,<br/>|,&#160;&#160;^,&#160;&#160;and&#160;&#160;$.&#160;&#160;If&#160;&#160;you&#160;&#160;want&#160;&#160;to&#160;&#160;describe&#160;&#160;a&#160;&#160;pattern&#160;&#160;that&#160;&#160;includes&#160;&#160;one&#160;&#160;of&#160;&#160;these&#160;&#160;characters<br/>literally,&#160;use&#160;a&#160;backslash&#160;to&#160;escape&#160;it.&#160;If&#160;you&#160;want&#160;to&#160;describe&#160;a&#160;pattern&#160;that&#160;includes&#160;a<br/>backslash, double the backslash:<br/>
/\(\)/ &#160; &#160; # Matches open and close parentheses<br/>/\\/ &#160; &#160; &#160; # Matches a single backslash<br/>
Regular&#160;expression&#160;literals&#160;behave&#160;like&#160;double-quoted&#160;string&#160;literals&#160;and&#160;can&#160;include<br/>escape&#160;characters&#160;such&#160;as&#160;\n,&#160;\t,&#160;and&#160;(in&#160;Ruby&#160;1.9)&#160;\u<a href="Rubys.html#63">&#160;(see&#160;Table 3-1</a><a href="Rubys.html#55">&#160;in&#160;Chapter 3&#160;for a<br/></a>complete list of escape sequences):<br/>
money = /[$\u20AC\u{a3}\u{a5}]/ # match dollar,euro,pound, or yen sign<br/>
Also&#160;like&#160;double-quoted&#160;string&#160;literals,&#160;Regexp&#160;literals&#160;allow&#160;the&#160;interpolation&#160;of&#160;arbi-<br/>trary Ruby expressions with the&#160;#{}&#160;syntax:<br/>
prefix = &#34;,&#34;<br/>/#{prefix}\t/ &#160; # Matches a comma followed by an ASCII TAB character<br/>
Note&#160;that&#160;interpolation&#160;is&#160;done&#160;early,&#160;before&#160;the&#160;content&#160;of&#160;the&#160;regular&#160;expression&#160;is<br/>parsed.&#160;This&#160;means&#160;that&#160;any&#160;special&#160;characters&#160;in&#160;the&#160;interpolated&#160;expression&#160;become<br/>part&#160;of&#160;the&#160;regular&#160;expression&#160;syntax.&#160;Interpolation&#160;is&#160;normally&#160;done&#160;anew&#160;each&#160;time&#160;a<br/>regular&#160;expression&#160;literal&#160;is&#160;evaluated.&#160;If&#160;you&#160;use&#160;the&#160;o&#160;modifier,&#160;however,&#160;this&#160;interpo-<br/>lation&#160;is&#160;only&#160;performed&#160;once,&#160;the&#160;first&#160;time&#160;the&#160;code&#160;is&#160;parsed.&#160;The&#160;behavior&#160;of&#160;the&#160;o<br/>modifier is best demonstrated by example:<br/>
[1,2].map{|x| /#{x}/} &#160; # =&gt; [/1/, /2/]<br/>[1,2].map{|x| /#{x}/o} &#160;# =&gt; [/1/, /1/]<br/>
<b>9.2.2 &#160;Regexp Factory Methods<br/></b>As&#160;&#160;an&#160;&#160;alternative&#160;&#160;to&#160;&#160;regexp&#160;&#160;literals,&#160;&#160;you&#160;&#160;can&#160;&#160;also&#160;&#160;create&#160;&#160;regular&#160;&#160;expressions&#160;&#160;with<br/>Regexp.new, or its synonym,&#160;Regexp.compile:<br/>
Regexp.new(&#34;Ruby?&#34;) &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# /Ruby?/<br/>Regexp.new(&#34;ruby?&#34;, Regexp::IGNORECASE) &#160; &#160; &#160;# /ruby?/i<br/>Regexp.compile(&#34;.&#34;, Regexp::MULTILINE, &#34;u&#34;) &#160;# /./mu<br/>
Use&#160;the&#160;Regexp.escape&#160;to&#160;escape&#160;special&#160;regular&#160;expression&#160;characters&#160;in&#160;a&#160;string&#160;before<br/>passing them to the&#160;Regexp&#160;constructor:<br/>
pattern = &#34;[a-z]+&#34; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# One or more letters<br/>suffix = Regexp.escape(&#34;()&#34;) &#160; &#160; &#160;# Treat these characters literally<br/>r = Regexp.new(pattern + suffix) &#160;# /[a-z]+\(\)/<br/>
In&#160;Ruby&#160;1.9&#160;(and&#160;1.8.7),&#160;the&#160;factory&#160;method&#160;Regexp.union&#160;creates&#160;a&#160;pattern&#160;that&#160;is the<br/>“union”&#160;&#160;of&#160;&#160;any&#160;&#160;number&#160;&#160;of&#160;&#160;strings&#160;&#160;or&#160;&#160;Regexp&#160;&#160;objects.&#160;&#160;(That&#160;&#160;is,&#160;&#160;the&#160;&#160;resulting&#160;&#160;pattern<br/>matches&#160;any&#160;of&#160;the&#160;strings&#160;matched&#160;by&#160;its&#160;constituent&#160;patterns.)&#160;Pass&#160;any&#160;number&#160;of<br/>arguments&#160;or&#160;a&#160;single&#160;array&#160;of&#160;strings&#160;and&#160;patterns.&#160;This&#160;factory&#160;method&#160;is&#160;good&#160;for<br/>
<b>9.2 &#160;Regular Expressions&#160;|&#160;311</b><br/>
<hr/>
<a name=326></a>creating&#160;&#160;patterns&#160;&#160;that&#160;&#160;match&#160;&#160;any&#160;&#160;word&#160;&#160;in&#160;&#160;a&#160;&#160;list&#160;&#160;of&#160;&#160;words.&#160;&#160;Strings&#160;&#160;passed&#160;&#160;to<br/>Regexp.union&#160;are automatically escaped, unlike those passed to&#160;new&#160;and&#160;compile:<br/>
# Match any one of five language names.<br/>pattern = Regexp.union(&#34;Ruby&#34;, &#34;Perl&#34;, &#34;Python&#34;, /Java(Script)?/)<br/># Match empty parens, brackets, or braces. Escaping is automatic:<br/>Regexp.union(&#34;()&#34;, &#34;[]&#34;, &#34;{}&#34;) &#160; # =&gt; /\(\)|\[\]|\{\}/<br/>
<b>9.2.3 &#160;Regular Expression Syntax<br/></b>Many&#160;programming&#160;languages&#160;support&#160;regular&#160;expressions,&#160;using&#160;the&#160;syntax&#160;popular-<br/>ized by Perl. This book does not include a complete discussion of that syntax, but the<br/>following&#160;examples&#160;walk&#160;you&#160;through&#160;the&#160;elements&#160;of&#160;regular&#160;expression&#160;grammar.&#160;The<br/>tutorial&#160;is&#160;followed&#160;<a href="Rubys.html#328">by&#160;Table 9-2</a>,&#160;which&#160;summarizes&#160;the&#160;syntax.&#160;The&#160;tutorial’s&#160;focus&#160;is<br/>on&#160;Ruby&#160;1.8&#160;regular&#160;expression&#160;syntax,&#160;but&#160;some&#160;of&#160;the&#160;features&#160;available&#160;only&#160;in&#160;Ruby<br/>1.9&#160;&#160;are&#160;&#160;demonstrated&#160;&#160;as&#160;&#160;well.&#160;&#160;For&#160;&#160;book-length&#160;&#160;coverage&#160;&#160;of&#160;&#160;regular&#160;&#160;expressions,&#160;&#160;see<br/><i>Mastering Regular Expressions</i>&#160;by Jeffrey E. F. Friedl (O’Reilly).<br/>
# Literal characters<br/>/ruby/ &#160; &#160; &#160; &#160; &#160; &#160; # Match &#34;ruby&#34;. Most characters simply match themselves.<br/>/¥/ &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Matches Yen sign. Multibyte characters are suported<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# in Ruby 1.9 and Ruby 1.8.<br/>
# Character classes<br/>/[Rr]uby/ &#160; &#160; &#160; &#160; &#160;# Match &#34;Ruby&#34; or &#34;ruby&#34;<br/>/rub[ye]/ &#160; &#160; &#160; &#160; &#160;# Match &#34;ruby&#34; or &#34;rube&#34;<br/>/[aeiou]/ &#160; &#160; &#160; &#160; &#160;# Match any one lowercase vowel<br/>/[0-9]/ &#160; &#160; &#160; &#160; &#160; &#160;# Match any digit; same as /[0123456789]/<br/>/[a-z]/ &#160; &#160; &#160; &#160; &#160; &#160;# Match any lowercase ASCII letter<br/>/[A-Z]/ &#160; &#160; &#160; &#160; &#160; &#160;# Match any uppercase ASCII letter<br/>/[a-zA-Z0-9]/ &#160; &#160; &#160;# Match any of the above<br/>/[^aeiou]/ &#160; &#160; &#160; &#160; # Match anything other than a lowercase vowel<br/>/[^0-9] &#160; &#160; &#160; &#160; &#160; &#160;# Match anything other than a digit<br/>
# Special character classes<br/>/./ &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Match any character except newline<br/>/./m &#160; &#160; &#160; &#160; &#160; &#160; &#160; # In multiline mode . matches newline, too<br/>/\d/ &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Match a digit /[0-9]/<br/>/\D/ &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Match a nondigit: /[^0-9]/<br/>/\s/ &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Match a whitespace character: /[ \t\r\n\f]/<br/>/\S/ &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Match nonwhitespace: /[^ \t\r\n\f]/<br/>/\w/ &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Match a single word character: /[A-Za-z0-9_]/<br/>/\W/ &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Match a nonword character: /[^A-Za-z0-9_]/<br/>
# Repetition<br/>/ruby?/ &#160; &#160; &#160; &#160; &#160; &#160;# Match &#34;rub&#34; or &#34;ruby&#34;: the y is optional<br/>/ruby*/ &#160; &#160; &#160; &#160; &#160; &#160;# Match &#34;rub&#34; plus 0 or more ys<br/>/ruby+/ &#160; &#160; &#160; &#160; &#160; &#160;# Match &#34;rub&#34; plus 1 or more ys<br/>/\d{3}/ &#160; &#160; &#160; &#160; &#160; &#160;# Match exactly 3 digits<br/>/\d{3,}/ &#160; &#160; &#160; &#160; &#160; # Match 3 or more digits<br/>/\d{3,5}/ &#160; &#160; &#160; &#160; &#160;# Match 3, 4, or 5 digits<br/>
# Nongreedy repetition: match the smallest number of repetitions<br/>
<b>312&#160;|&#160;Chapter 9:</b> <b>The Ruby Platform</b><br/>
<hr/>
<a name=327></a>/&lt;.*&gt;/ &#160; &#160; &#160; &#160; &#160; &#160; # Greedy repetition: matches &#34;&lt;ruby&gt;perl&gt;&#34;<br/>/&lt;.*?&gt;/ &#160; &#160; &#160; &#160; &#160; &#160;# Nongreedy: matches &#34;&lt;ruby&gt;&#34; in &#34;&lt;ruby&gt;perl&gt;&#34;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Also nongreedy: ??, +?, and {n,m}?<br/>
# Grouping with parentheses<br/>/\D\d+/ &#160; &#160; &#160; &#160; &#160; &#160;# No group: + repeats \d<br/>/(\D\d)+/ &#160; &#160; &#160; &#160; &#160;# Grouped: + repeats \D\d pair<br/>/([Rr]uby(, )?)+/ &#160;# Match &#34;Ruby&#34;, &#34;Ruby, ruby, ruby&#34;, etc.<br/>
# Backreferences: matching a previously matched group again<br/>/([Rr])uby&amp;\1ails/ # Match ruby&amp;rails or Ruby&amp;Rails<br/>/(['&#34;])[^\1]*\1/ &#160; # Single or double-quoted string<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# &#160; \1 matches whatever the 1st group matched<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# &#160; \2 matches whatever the 2nd group matched, etc.<br/>
# Named groups and backreferences in Ruby 1.9: match a 4-letter palindrome<br/>/(?&lt;first&gt;\w)(?&lt;second&gt;\w)\k&lt;second&gt;\k&lt;first&gt;/<br/>/(?'first'\w)(?'second'\w)\k'second'\k'first'/ # Alternate syntax<br/>
# Alternatives<br/>/ruby|rube/ &#160; &#160; &#160; &#160;# Match &#34;ruby&#34; or &#34;rube&#34;<br/>/rub(y|le))/ &#160; &#160; &#160; # Match &#34;ruby&#34; or &#34;ruble&#34;<br/>/ruby(!+|\?)/ &#160; &#160; &#160;# &#34;ruby&#34; followed by one or more ! or one ?<br/>
# Anchors: specifying match position<br/>/^Ruby/ &#160; &#160; &#160; &#160; &#160; &#160;# Match &#34;Ruby&#34; at the start of a string or internal line<br/>/Ruby$/ &#160; &#160; &#160; &#160; &#160; &#160;# Match &#34;Ruby&#34; at the end of a string or line<br/>/\ARuby/ &#160; &#160; &#160; &#160; &#160; # Match &#34;Ruby&#34; at the start of a string<br/>/Ruby\Z/ &#160; &#160; &#160; &#160; &#160; # Match &#34;Ruby&#34; at the end of a string<br/>/\bRuby\b/ &#160; &#160; &#160; &#160; # Match &#34;Ruby&#34; at a word boundary<br/>/\brub\B/ &#160; &#160; &#160; &#160; &#160;# \B is nonword boundary:<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# &#160; match &#34;rub&#34; in &#34;rube&#34; and &#34;ruby&#34; but not alone<br/>/Ruby(?=!)/ &#160; &#160; &#160; &#160;# Match &#34;Ruby&#34;, if followed by an exclamation point<br/>/Ruby(?!!)/ &#160; &#160; &#160; &#160;# Match &#34;Ruby&#34;, if not followed by an exclamation point<br/>
# Special syntax with parentheses<br/>/R(?#comment)/ &#160; &#160; # Matches &#34;R&#34;. All the rest is a comment<br/>/R(?i)uby/ &#160; &#160; &#160; &#160; # Case-insensitive while matching &#34;uby&#34;<br/>/R(?i:uby)/ &#160; &#160; &#160; &#160;# Same thing<br/>/rub(?:y|le))/ &#160; &#160; # Group only without creating \1 backreference<br/>
# The x option allows comments and ignores whitespace<br/>/ &#160;# This is not a Ruby comment. It is a literal part<br/>&#160; &#160;# of the regular expression, but is ignored.<br/>&#160; &#160;R &#160; &#160; &#160;# Match a single letter R<br/>&#160; &#160;(uby)+ # Followed by one or more &#34;uby&#34;s<br/>&#160; &#160;\ &#160; &#160; &#160;# Use backslash for a nonignored space<br/>/x &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Closing delimiter. Don't forget the x option!<br/>
<a href="Rubys.html#328">Table 9-2 summarizes the syntax rules demonstrated by this code.</a><br/>
<b>9.2 &#160;Regular Expressions&#160;|&#160;313</b><br/>
<hr/>
<a name=328></a><i>Table 9-2. Regular expression syntax</i><br/>
<b>Syntax</b><br/>
<b>Matches</b><br/>
<b>Character classes</b><br/>
.<br/>
Matches any single character except newline. Using&#160;m&#160;option allows it to match newline as well.<br/>
[...]<br/>
Matches any single character in brackets.<br/>
[^...]<br/>
Matches any single character not in brackets.<br/>
\w<br/>
Matches word characters.<br/>
\W<br/>
Matches nonword characters.<br/>
\s<br/>
Matches whitespace. Equivalent to&#160;[ \t\n\r\f].<br/>
\S<br/>
Matches nonwhitespace.<br/>
\d<br/>
Matches digits. Equivalent to&#160;[0–9].<br/>
\D<br/>
Matches nondigits.<br/>
<b>Sequences, alternatives, groups, and references</b><br/>
<i>ab</i><br/>
Matches expression&#160;<i>a</i>&#160;followed by expression&#160;<i>b</i>.<br/>
<i>a</i>&#160;|&#160;<i>b</i><br/>
Matches either expression&#160;<i>a</i>&#160;or expression&#160;<i>b</i>.<br/>
(&#160;<i>re</i>&#160;)<br/>
Grouping: groups&#160;<i>re</i>&#160;into a single syntactic unit that can be used with&#160;*,&#160;+,&#160;?,&#160;|, and so on. Also “captures”<br/>the text that matches&#160;<i>re</i>&#160;for later use.<br/>
(?:&#160;<i>re</i>&#160;)<br/>
Groups as with&#160;(), but does not capture the matched text.<br/>
(?&lt;&#160;<i>name</i>&#160;&gt;&#160;<i>re</i>&#160;)<br/>
Groups a subexpression and captures the text that matches&#160;<i>re</i>&#160;as with&#160;(), and also labels the<br/>subexpression with&#160;<i>name</i>. Ruby 1.9.<br/>
(?'&#160;<i>name</i>&#160;'&#160;<i>re</i>&#160;)<br/>
A named capture, as above. Single quotes may optionally replace angle brackets around&#160;<i>name</i>. Ruby 1.9.<br/>
\1...\9<br/>
Matches the same text that matched the&#160;<i>n</i>th grouped subexpression.<br/>
\10...<br/>
Matches the same text that matched the&#160;<i>n</i>th grouped subexpression if there are that many previous<br/>subexpressions. Otherwise, matches the character with the specified octal encoding.<br/>
\k&lt;&#160;<i>name</i>&#160;&gt;<br/>
Matches the same text that matched the named capturing group&#160;<i>name</i>.<br/>
\g&lt;&#160;<i>n</i>&#160;&gt;<br/>
Matches group&#160;<i>n</i>&#160;again.&#160;<i>n</i>&#160;can be a group name or a group number. Contrast&#160;\g, which rematches or<br/>reexecutes the specified group, with an ordinary back reference that tries to match the same text that<br/>matched the first time. Ruby 1.9.<br/>
<b>Repetition</b><br/>
<i>By default, repetition is “greedy”—as many occurrences as possible are matched. For “reluctant” matching,<br/>follow a&#160;</i>&#160;*&#160;<i>,&#160;</i>&#160;+&#160;<i>,&#160;</i>&#160;?&#160;<i>, or</i>&#160;{}&#160;<i>quantifier with a&#160;</i>&#160;?&#160;<i>.</i>&#160;<i>This will match as few occurrences as possible while still<br/>allowing the rest of the expression to match. In Ruby 1.9, follow a quantifier with a</i>&#160;+&#160;<i>&#160;for “possessive” (non-<br/>backtracking) behavior.</i><br/>
<i>re</i>&#160;*<br/>
Matches zero or more occurrences of&#160;<i>re</i>.<br/>
<i>re</i>&#160;+<br/>
Matches one or more occurrences of&#160;<i>re</i>.<br/>
<i>re</i>&#160;?<br/>
Optional: matches zero or one occurrence of&#160;<i>re</i>.<br/>
<i>re</i>&#160;{&#160;<i>n</i>&#160;}<br/>
Matches exactly&#160;<i>n</i>&#160;occurrences of&#160;<i>re</i>.<br/>
<i>re</i>&#160;{&#160;<i>n</i>&#160;,}<br/>
Matches&#160;<i>n</i>&#160;or more occurrences of&#160;<i>re</i>.<br/>
<i>re</i>&#160;{&#160;<i>n</i>&#160;,&#160;<i>m</i>&#160;}<br/>
Matches at least&#160;<i>n</i>&#160;and at most&#160;<i>m</i>&#160;occurrences of&#160;<i>re</i>.<br/>
<b>314&#160;|&#160;Chapter 9:</b> <b>The Ruby Platform</b><br/>
<hr/>
<a name=329></a><b>Syntax</b><br/>
<b>Matches</b><br/>
<b>Anchors</b><br/>
<i>Anchors do not match characters but instead match the zero-width positions between characters,<br/>“anchoring” the match to a position at which a specific condition holds.</i><br/>
^<br/>
Matches beginning of line.<br/>
$<br/>
Matches end of line.<br/>
\A<br/>
Matches beginning of string.<br/>
\Z<br/>
Matches end of string. If string ends with a newline, it matches just before newline.<br/>
\z<br/>
Matches end of string.<br/>
\G<br/>
Matches point where last match finished.<br/>
\b<br/>
Matches word boundaries when outside brackets. Matches backspace (0x08) when inside brackets.<br/>
\B<br/>
Matches nonword boundaries.<br/>
(?=&#160;<i>re</i>&#160;)<br/>
Positive lookahead assertion: ensures that the following characters match&#160;<i>re</i>, but doesn’t include those<br/>characters in the matched text.<br/>
(?!&#160;<i>re</i>&#160;)<br/>
Negative lookahead assertion: ensures that the following characters do not match&#160;<i>re</i>.<br/>
(?&lt;=&#160;<i>re</i>&#160;)<br/>
Positive lookbehind assertion: ensures that the preceeding characters match&#160;<i>re</i>, but doesn’t include those<br/>characters in the matched text. Ruby 1.9.<br/>
(?&lt;!&#160;<i>re</i>&#160;)<br/>
Negative lookbehind assertion: ensures that the preceeding characters do not match&#160;<i>re</i>. Ruby 1.9.<br/>
<b>Miscellaneous</b><br/>
(?&#160;<i>onflags</i>&#160;-<br/>
Doesn’t match anything, but turns on the flags specified by&#160;<i>onflags</i>, and turns off the flags specified by<br/>
<i>offflags</i>&#160;)<br/>
<i>offflags</i>. These two strings are combinations in any order of the modifier letters&#160;i,&#160;m, and&#160;x. Flag<br/>settings specified in this way take effect at the point that they appear in the expression and persist until<br/>the end of the expression, or until the end of the parenthesized group of which they are a part, or until<br/>overridden by another flag setting expression.<br/>
(?&#160;<i>onflags</i>&#160;-<br/>
Matches&#160;<i>x</i>, applying the specified flags to this subexpression only. This is a noncapturing group, like<br/>
<i>offflags</i>&#160;:&#160;<i>x</i>&#160;)<br/>
(?:...), with the addition of flags.<br/>
(?#...)<br/>
Comment: all text within parentheses is ignored.<br/>
(?&gt;&#160;<i>re</i>&#160;)<br/>
Matches&#160;<i>re</i>&#160;independently of the rest of the expression, without considering whether the match causes<br/>the rest of the expression to fail to match. Useful to optimize certain complex regular expressions. The<br/>parentheses do not capture the matched text.<br/>
<b>9.2.4 &#160;Pattern Matching with Regular Expressions<br/></b>=~&#160;is&#160;Ruby’s&#160;basic&#160;pattern-matching&#160;operator.&#160;One&#160;operand&#160;must&#160;be&#160;a&#160;regular&#160;expres-<br/>sion&#160;and&#160;one&#160;must&#160;be&#160;a&#160;string.&#160;(It&#160;is&#160;implemented&#160;equivalently&#160;by&#160;both&#160;&#160;Regexp&#160;and<br/>String,&#160;so&#160;it&#160;doesn’t&#160;matter&#160;whether&#160;the&#160;regular&#160;expression&#160;is&#160;on&#160;the&#160;left&#160;or&#160;the&#160;right.)<br/>The&#160;=~&#160;operator&#160;checks&#160;its&#160;string&#160;operand&#160;to&#160;see&#160;if&#160;it,&#160;or&#160;any&#160;substring,&#160;matches&#160;the<br/>pattern&#160;specified&#160;by&#160;the&#160;regular&#160;expression.&#160;If&#160;a&#160;match&#160;is&#160;found,&#160;the&#160;operator&#160;returns<br/>the string index at which the first match begins. Otherwise, it returns&#160;nil:<br/>
pattern = /Ruby?/i &#160; &#160; &#160;# Match &#34;Rub&#34; or &#34;Ruby&#34;, case-insensitive<br/>pattern =~ &#34;backrub&#34; &#160; &#160;# Returns 4.<br/>
<b>9.2 &#160;Regular Expressions&#160;|&#160;315</b><br/>
<hr/>
<a name=330></a>&#34;rub ruby&#34; =~ pattern &#160; # 0<br/>pattern =~ &#34;r&#34; &#160; &#160; &#160; &#160; &#160;# nil<br/>
After&#160;using&#160;the&#160;=~&#160;operator,&#160;we&#160;may&#160;be&#160;interested&#160;in&#160;things&#160;other&#160;than&#160;the&#160;position&#160;at<br/>which&#160;the&#160;matched&#160;text&#160;begins.&#160;After&#160;any&#160;successful&#160;(non-nil)&#160;match,&#160;the&#160;global&#160;vari-<br/>able&#160;$~&#160;holds&#160;a&#160;MatchData&#160;object&#160;which&#160;contains&#160;complete&#160;information&#160;about&#160;the&#160;match:<br/>
&#34;hello&#34; =~ /e\w{2}/ &#160; &#160; # 1: Match an e followed by 2 word characters<br/>$~.string &#160; &#160; &#160; &#160; &#160; &#160; &#160; # &#34;hello&#34;: the complete string<br/>$~.to_s &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # &#34;ell&#34;: the portion that matched<br/>$~.pre_match &#160; &#160; &#160; &#160; &#160; &#160;# &#34;h&#34;: the portion before the match<br/>$~.post_match &#160; &#160; &#160; &#160; &#160; # &#34;o&#34;: the portion after the match<br/>
$~&#160;is&#160;a&#160;special&#160;thread-local&#160;and&#160;method-local&#160;variable.&#160;Two&#160;threads&#160;running&#160;concur-<br/>rently&#160;will&#160;see&#160;distinct&#160;values&#160;of&#160;this&#160;variable.&#160;And&#160;a&#160;method&#160;that&#160;uses&#160;the&#160;=~&#160;operator<br/>does&#160;not&#160;alter&#160;the&#160;value&#160;of&#160;$~&#160;seen&#160;by&#160;the&#160;calling&#160;method.&#160;We’ll&#160;have&#160;more&#160;to&#160;say&#160;about<br/>$~&#160;and&#160;related&#160;global&#160;variables&#160;later.&#160;An&#160;object-oriented&#160;alternative&#160;to&#160;this&#160;magical&#160;and<br/>somewhat&#160;&#160;cryptic&#160;&#160;variable&#160;&#160;is&#160;&#160;Regexp.last_match.&#160;&#160;Invoking&#160;&#160;this&#160;&#160;method&#160;&#160;with&#160;&#160;no<br/>arguments returns the same value as a reference to&#160;$~.<br/>A&#160;MatchData&#160;object&#160;is more powerful when the&#160;Regexp&#160;that was matched contains sub-<br/>expressions&#160;in&#160;parentheses.&#160;In&#160;this&#160;case,&#160;the&#160;MatchData&#160;object&#160;can&#160;tell&#160;us&#160;the&#160;text&#160;(and<br/>the starting and ending offsets of that text) that matched each subexpression:<br/>
# This is a pattern with three subpatterns<br/>pattern = /(Ruby|Perl)(\s+)(rocks|sucks)!/&#160;<br/>text = &#34;Ruby\trocks!&#34; &#160; &#160; # Text that matches the pattern &#160; &#160;<br/>pattern =~ text &#160; &#160; &#160; &#160; &#160; # =&gt; 0: pattern matches at the first character<br/>data = Regexp.last_match &#160;# =&gt; Get match details<br/>data.size &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; 4: MatchData objects behave like arrays<br/>data[0] &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; &#34;Ruby\trocks!&#34;: the complete matched text<br/>data[1] &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; &#34;Ruby&#34;: text matching first subpattern<br/>data[2] &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; &#34;\t&#34;: text matching second subpattern<br/>data[3] &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; &#34;rocks&#34;: text matching third subpattern<br/>data[1,2] &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; [&#34;Ruby&#34;, &#34;\t&#34;]<br/>data[1..3] &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; [&#34;Ruby&#34;, &#34;\t&#34;, &#34;rocks&#34;]<br/>data.values_at(1,3) &#160; &#160; &#160; # =&gt; [&#34;Ruby&#34;, &#34;rocks&#34;]: only selected indexes<br/>data.captures &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; [&#34;Ruby&#34;, &#34;\t&#34;, &#34;rocks&#34;]: only subpatterns<br/>Regexp.last_match(3) &#160; &#160; &#160;# =&gt; &#34;rocks&#34;: same as Regexp.last_match[3]<br/>
# Start and end positions of matches<br/>data.begin(0) &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; 0: start index of entire match<br/>data.begin(2) &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; 4: start index of second subpattern<br/>data.end(2) &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; 5: end index of second subpattern<br/>data.offset(3) &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; [5,10]: start and end of third subpattern<br/>
In&#160;Ruby&#160;1.9,&#160;if&#160;a&#160;pattern&#160;includes&#160;named&#160;captures,&#160;then&#160;a&#160;MatchData&#160;obtained&#160;from&#160;that<br/>pattern&#160;&#160;can&#160;&#160;be&#160;&#160;used&#160;&#160;like&#160;&#160;a&#160;&#160;hash,&#160;&#160;with&#160;&#160;the&#160;&#160;names&#160;&#160;of&#160;&#160;capturing&#160;&#160;groups&#160;&#160;(as&#160;&#160;strings&#160;&#160;or<br/>symbols) as keys. For example:<br/>
# Ruby 1.9 only<br/>pattern = /(?&lt;lang&gt;Ruby|Perl) (?&lt;ver&gt;\d(\.\d)+) (?&lt;review&gt;rocks|sucks)!/&#160;<br/>if (pattern =~ &#34;Ruby 1.9.1 rocks!&#34;)<br/>&#160; $~[:lang] &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; &#34;Ruby&#34;<br/>
<b>316&#160;|&#160;Chapter 9:</b> <b>The Ruby Platform</b><br/>
<hr/>
<a name=331></a>&#160; $~[:ver] &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; &#34;1.9.1&#34;<br/>&#160; $~[&#34;review&#34;] &#160; &#160; &#160; &#160; # =&gt; &#34;rocks&#34;<br/>&#160; $~.offset(:ver) &#160; &#160; &#160;# =&gt; [5,10] start and end offsets of version number<br/>end<br/># Names of capturing groups and a map of group names to group numbers<br/>pattern.names &#160; &#160; &#160; &#160; &#160;# =&gt; [&#34;lang&#34;, &#34;ver&#34;, &#34;review&#34;]<br/>pattern.named_captures # =&gt; {&#34;lang&#34;=&gt;[1],&#34;ver&#34;=&gt;[2],&#34;review&#34;=&gt;[3]}<br/>
<b>Named Captures and Local Variables</b><br/>
In&#160;Ruby&#160;1.9,&#160;if&#160;a&#160;regular&#160;expression&#160;containing&#160;named&#160;captures&#160;appears&#160;literally&#160;on&#160;the<br/>lefthand&#160;side&#160;of&#160;the&#160;=~&#160;operator,&#160;then&#160;the&#160;names&#160;of&#160;the&#160;capturing&#160;groups&#160;are&#160;taken&#160;to<br/>be&#160;local&#160;variables,&#160;and&#160;the&#160;text&#160;that&#160;matches&#160;is&#160;assigned&#160;to&#160;those&#160;variables.&#160;If&#160;the&#160;match<br/>fails, then the variables are assigned&#160;nil. Here is an example:<br/>
# Ruby 1.9 only<br/>if /(?&lt;lang&gt;\w+) (?&lt;ver&gt;\d+\.(\d+)+) (?&lt;review&gt;\w+)/ =~ &#34;Ruby 1.9 rules!&#34;<br/>&#160; lang &#160; &#160; # =&gt; &#34;Ruby&#34;<br/>&#160; ver &#160; &#160; &#160;# =&gt; &#34;1.9&#34;<br/>&#160; review &#160; # =&gt; &#34;rules&#34;<br/>end<br/>
This&#160;is&#160;magical&#160;behavior,&#160;but&#160;it&#160;only&#160;occurs&#160;when&#160;a&#160;regular&#160;expression&#160;appears&#160;literally<br/>in&#160;your&#160;code.&#160;If&#160;a&#160;pattern&#160;is&#160;stored&#160;in&#160;a&#160;variable&#160;or&#160;a&#160;constant&#160;or&#160;is&#160;returned&#160;by&#160;a&#160;method,<br/>or if the pattern appears on the righthand side, then the&#160;=~&#160;operator does not perform<br/>this&#160;special&#160;local&#160;variable&#160;assignment.&#160;If&#160;Ruby&#160;is&#160;invoked&#160;with&#160;the&#160;-w&#160;option,&#160;then&#160;it<br/>issues a warning if the&#160;=~&#160;operator overwrites a variable that is already defined.<br/>
In&#160;addition&#160;to&#160;the&#160;=~&#160;operator,&#160;the&#160;Regexp&#160;and&#160;String&#160;classes&#160;also&#160;define&#160;a&#160;match&#160;method.&#160;<br/>This&#160;method&#160;is&#160;like&#160;the&#160;match&#160;operator,&#160;except&#160;that&#160;instead&#160;of&#160;returning&#160;the&#160;index&#160;at<br/>which&#160;a&#160;match&#160;is&#160;found,&#160;it&#160;returns&#160;the&#160;MatchData&#160;object,&#160;or&#160;nil&#160;if&#160;no&#160;matching&#160;text&#160;is<br/>found. Use it like this:<br/>
if data = pattern.match(text) &#160;# Or: data = text.match(pattern)<br/>&#160; handle_match(data)<br/>end<br/>
In&#160;Ruby&#160;1.9,&#160;you&#160;can&#160;also&#160;associate&#160;a&#160;block&#160;with&#160;a&#160;call&#160;to&#160;match.&#160;If&#160;no&#160;match&#160;is&#160;found,<br/>the&#160;&#160;block&#160;&#160;is&#160;&#160;ignored,&#160;&#160;and&#160;&#160;match&#160;&#160;returns&#160;&#160;nil.&#160;&#160;If&#160;&#160;a&#160;&#160;match&#160;&#160;is&#160;&#160;found,&#160;&#160;however,&#160;&#160;the<br/>MatchData&#160;object&#160;is&#160;passed&#160;to&#160;the&#160;block,&#160;and&#160;the&#160;match&#160;method&#160;returns&#160;whatever&#160;the<br/>block returns. So in Ruby 1.9, this code can be more succinctly written like this:<br/>
pattern.match(text) {|data| handle_match(data) }<br/>
Another&#160;change&#160;in&#160;Ruby&#160;1.9&#160;is&#160;that&#160;the&#160;match&#160;methods&#160;optionally&#160;accept&#160;an&#160;integer&#160;as<br/>the second argument to specify the starting position of the search.<br/>
<b>9.2.4.1 &#160;Global variables for match data<br/></b>Ruby&#160;adopts&#160;Perl’s&#160;regular&#160;expression&#160;syntax&#160;and,&#160;like&#160;Perl,&#160;sets&#160;special&#160;global&#160;variables<br/>after&#160;each&#160;match.&#160;If&#160;you&#160;are&#160;a&#160;Perl&#160;programmer,&#160;you&#160;may&#160;find&#160;these&#160;special&#160;variables<br/>
<b>9.2 &#160;Regular Expressions&#160;|&#160;317</b><br/>
<hr/>
<a name=332></a>useful.&#160;If&#160;you&#160;are&#160;a&#160;not&#160;a&#160;Perl&#160;programmer,&#160;you&#160;may&#160;find&#160;them&#160;unreadable!&#160;<a href="Rubys.html#332">Table 9-3<br/></a>summarizes&#160;these&#160;variables.&#160;The&#160;variables&#160;listed&#160;in&#160;the&#160;second&#160;column&#160;are&#160;aliases&#160;that<br/>are available if you&#160;require 'English'.<br/>
<i>Table 9-3. Special global regular expression variables</i><br/>
<b>Global</b><br/>
<b>English</b><br/>
<b>Alternative</b><br/>
$~<br/>
$LAST_MATCH_INFO<br/>
Regexp.last_match<br/>
$&amp;<br/>
$MATCH<br/>
Regexp.last_match[0]<br/>
$`<br/>
$PREMATCH<br/>
Regexp.last_match.pre_match<br/>
$'<br/>
$POSTMATCH<br/>
Regexp.last_match.post_match<br/>
$1<br/>
none<br/>
Regexp.last_match[1]<br/>
$2, etc.<br/>
none<br/>
Regexp.last_match[2], etc.<br/>
$+<br/>
$LAST_PAREN_MATCH<br/>
Regexp.last_match[-1]<br/>
$~&#160;is the most&#160;important of the variables listed in&#160;<a href="Rubys.html#332">Table 9-3. All the others are derived<br/></a>from&#160;it.&#160;If&#160;you&#160;set&#160;$~&#160;to&#160;a&#160;MatchData&#160;object,&#160;the&#160;values&#160;of&#160;the&#160;other&#160;special&#160;globals&#160;change.<br/>The&#160;&#160;other&#160;&#160;global&#160;&#160;variables&#160;&#160;are&#160;&#160;read-only&#160;&#160;and&#160;&#160;cannot&#160;&#160;be&#160;&#160;set&#160;&#160;directly.&#160;&#160;Finally,&#160;&#160;it&#160;&#160;is<br/>important&#160;to&#160;remember&#160;that&#160;$~&#160;and&#160;the&#160;variables&#160;derived&#160;from&#160;it&#160;are&#160;all&#160;thread-local&#160;and<br/>method-local.&#160;This&#160;means&#160;that&#160;two&#160;Ruby&#160;threads&#160;can&#160;perform&#160;matches&#160;at&#160;the&#160;same&#160;time<br/>without&#160;interfering&#160;with&#160;each&#160;other&#160;and&#160;it&#160;means&#160;that&#160;the&#160;value&#160;of&#160;these&#160;variables,&#160;as<br/>seen&#160;by&#160;your&#160;code,&#160;will&#160;not&#160;change&#160;when&#160;your&#160;code&#160;calls&#160;a&#160;method&#160;that&#160;performs&#160;a<br/>pattern match.<br/>
<b>9.2.4.2 &#160;Pattern matching with strings<br/></b>The&#160;String&#160;class&#160;defines&#160;a&#160;number&#160;of&#160;methods&#160;that&#160;accept&#160;Regexp&#160;arguments.&#160;If&#160;you<br/>index&#160;a&#160;string&#160;with&#160;a&#160;regular&#160;expression,&#160;then&#160;the&#160;portion&#160;of&#160;the&#160;string&#160;that&#160;matches&#160;the<br/>pattern&#160;is&#160;returned.&#160;If&#160;the&#160;Regexp&#160;is&#160;followed&#160;by&#160;an&#160;integer,&#160;then&#160;the&#160;corresponding<br/>element of the&#160;MatchData&#160;is returned:<br/>
&#34;ruby123&#34;[/\d+/] &#160; &#160; &#160; &#160; &#160; &#160; &#160;# &#34;123&#34;<br/>&#34;ruby123&#34;[/([a-z]+)(\d+)/,1] &#160;# &#34;ruby&#34;<br/>&#34;ruby123&#34;[/([a-z]+)(\d+)/,2] &#160;# &#34;123&#34;<br/>
The&#160;slice&#160;method&#160;is&#160;a&#160;synonym&#160;for&#160;the&#160;string&#160;index&#160;operator&#160;[].&#160;The&#160;slice!&#160;variant<br/>returns&#160;the&#160;same&#160;value&#160;as&#160;slice&#160;but&#160;also&#160;has&#160;the&#160;side&#160;effect&#160;of&#160;deleting&#160;the&#160;returned<br/>substring from the string:<br/>
r = &#34;ruby123&#34;<br/>r.slice!(/\d+/) &#160;# Returns &#34;123&#34;, changes r to &#34;ruby&#34;<br/>
The&#160;split&#160;method&#160;splits&#160;a&#160;string&#160;into&#160;an&#160;array&#160;of&#160;substrings,&#160;using&#160;a&#160;string&#160;or&#160;regular<br/>expression as its delimiter:<br/>
s = &#34;one, two, three&#34;<br/>s.split &#160; &#160; &#160; &#160; &#160; &#160;# [&#34;one,&#34;,&#34;two,&#34;,&#34;three&#34;]: whitespace delimiter by default<br/>
<b>318&#160;|&#160;Chapter 9:</b> <b>The Ruby Platform</b><br/>
<hr/>
<a name=333></a>s.split(&#34;, &#34;) &#160; &#160; &#160;# [&#34;one&#34;,&#34;two&#34;,&#34;three&#34;]: hardcoded delimiter<br/>s.split(/\s*,\s*/) # [&#34;one&#34;,&#34;two&#34;,&#34;three&#34;]: space is optional around comma<br/>
The&#160;index&#160;method&#160;searches&#160;a&#160;string&#160;for&#160;a&#160;character,&#160;substring,&#160;or&#160;pattern,&#160;and&#160;returns<br/>the&#160;start&#160;index.&#160;With&#160;a&#160;Regexp&#160;argument,&#160;it&#160;works&#160;much&#160;like&#160;the&#160;=~&#160;operator,&#160;but&#160;it&#160;also<br/>allows&#160;a&#160;second&#160;argument&#160;that&#160;specifies&#160;the&#160;character&#160;position&#160;at&#160;which&#160;to&#160;begin&#160;the<br/>search. This allows you to find matches other than the first:<br/>
text = &#34;hello world&#34;<br/>pattern = /l/<br/>first = text.index(pattern) &#160; &#160; &#160; # 2: first match starts at char 2<br/>n = Regexp.last_match.end(0) &#160; &#160; &#160;# 3: end position of first match<br/>second = text.index(pattern, n) &#160; # 3: search again from there<br/>last = text.rindex(pattern) &#160; &#160; &#160; # 9: rindex searches backward from end<br/>
<b>9.2.4.3 &#160;Search and replace<br/></b>Some&#160;of&#160;the&#160;most&#160;important&#160;String&#160;methods&#160;that&#160;use&#160;regular&#160;expressions&#160;are&#160;sub&#160;(for<br/>substitute)&#160;and&#160;gsub&#160;(for&#160;global&#160;substitute),&#160;and&#160;their&#160;in-place&#160;variants&#160;sub!&#160;and&#160;gsub!.&#160;<br/>All&#160;of&#160;these&#160;methods&#160;perform&#160;a&#160;search-and-replace&#160;operation&#160;using&#160;a&#160;Regexp&#160;pattern.<br/>sub&#160;&#160;and&#160;&#160;sub!&#160;&#160;replace&#160;&#160;the&#160;&#160;first&#160;&#160;occurrence&#160;&#160;of&#160;&#160;the&#160;&#160;pattern.&#160;&#160;gsub&#160;&#160;and&#160;&#160;gsub!&#160;&#160;replace&#160;&#160;all<br/>occurrences.&#160;sub&#160;and&#160;gsub&#160;return&#160;a&#160;new&#160;string,&#160;leaving&#160;the&#160;original&#160;unmodified.&#160;sub!<br/>and&#160;gsub!&#160;modify&#160;the&#160;string&#160;on&#160;which&#160;they&#160;are&#160;called.&#160;If&#160;any&#160;modifications&#160;are&#160;made&#160;to<br/>the&#160;string,&#160;these&#160;mutator&#160;methods&#160;return&#160;the&#160;modified&#160;string.&#160;If&#160;no&#160;modifications&#160;are<br/>made,&#160;they&#160;return&#160;nil&#160;(which&#160;makes&#160;the&#160;methods&#160;suitable&#160;for&#160;use&#160;in&#160;if&#160;statements&#160;and<br/>while&#160;loops):<br/>
phone = gets &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Read a phone number<br/>phone.sub!(/#.*$/, &#34;&#34;) &#160; &#160; # Delete Ruby-style comments<br/>phone.gsub!(/\D/,' '=&gt;'-') # 1.9: remove non-digits but map space to hyphen<br/>
These&#160;search-and-replace&#160;methods&#160;do&#160;not&#160;require&#160;the&#160;use&#160;of&#160;regular&#160;expressions;&#160;you<br/>can also use an ordinary string as the text to be replaced:<br/>
text.gsub!(&#34;rails&#34;, &#34;Rails&#34;) &#160; &#160; # Change &#34;rails&#34; to &#34;Rails&#34; throughout<br/>
However, regular expressions really are more flexible. If you want to capitalize “rails”<br/>without modifying “grails”, for example, use a&#160;Regexp:<br/>
text.gsub!(/\brails\b/, &#34;Rails&#34;) # Capitalize the word &#34;Rails&#34; throughout<br/>
The&#160;reason&#160;that&#160;the&#160;search-and-replace&#160;methods&#160;are&#160;covered&#160;in&#160;this&#160;subsection&#160;on&#160;their<br/>own&#160;is&#160;that&#160;the&#160;replacement&#160;does&#160;not&#160;need&#160;to&#160;be&#160;an&#160;ordinary&#160;string&#160;of&#160;text.&#160;(Replacement<br/>strings&#160;specified&#160;in&#160;a&#160;hash&#160;must&#160;be&#160;ordinary&#160;strings,&#160;however.)&#160;Suppose&#160;you&#160;want&#160;a<br/>replacement&#160;string&#160;that&#160;depends&#160;on&#160;the&#160;details&#160;of&#160;the&#160;match&#160;found.&#160;The&#160;search-and-<br/>replace&#160;methods&#160;process&#160;the&#160;replacement&#160;string&#160;before&#160;performing&#160;replacements.&#160;If&#160;the<br/>string&#160;contains&#160;a&#160;backslash&#160;followed&#160;by&#160;a&#160;single&#160;digit,&#160;then&#160;that&#160;digit&#160;is&#160;used&#160;as&#160;an&#160;index<br/>into&#160;the&#160;$~&#160;object,&#160;and&#160;the&#160;text&#160;from&#160;the&#160;MatchData&#160;object&#160;is&#160;used&#160;in&#160;place&#160;of&#160;the&#160;backslash<br/>and&#160;the&#160;digit.&#160;For&#160;example,&#160;if&#160;the&#160;string&#160;contains&#160;the&#160;escape&#160;sequence&#160;\0,&#160;the&#160;entire<br/>matched&#160;text&#160;is&#160;used.&#160;If&#160;the&#160;replacement&#160;string&#160;contains&#160;\1, then the text that matches<br/>the&#160;first&#160;subexpression&#160;is&#160;used&#160;in&#160;the&#160;replacement.&#160;The&#160;following&#160;code&#160;does&#160;a&#160;case-<br/>
<b>9.2 &#160;Regular Expressions&#160;|&#160;319</b><br/>
<hr/>
<a name=334></a>insensitive&#160;search&#160;for&#160;the&#160;word&#160;“ruby”&#160;and&#160;puts&#160;HTML&#160;bold&#160;tags&#160;around&#160;it,&#160;preserving<br/>the word’s capitalization:<br/>
text.gsub(/\bruby\b/i, '&lt;b&gt;\0&lt;/b&gt;')<br/>
Note&#160;that&#160;if&#160;you&#160;use&#160;a&#160;double-quoted&#160;replacement&#160;string,&#160;you&#160;must&#160;double&#160;the&#160;backslash<br/>character.<br/>You&#160;&#160;might&#160;&#160;be&#160;&#160;tempted&#160;&#160;to&#160;&#160;try&#160;&#160;the&#160;&#160;same&#160;&#160;thing&#160;&#160;using&#160;&#160;normal&#160;&#160;double-quoted&#160;&#160;string<br/>interpolation:<br/>
text.gsub(/\bruby\b/i, &#34;&lt;b&gt;#{$&amp;}&lt;/b&gt;&#34;)<br/>
This&#160;does&#160;not&#160;work,&#160;however,&#160;because&#160;in&#160;this&#160;case&#160;the&#160;interpolation&#160;is&#160;performed&#160;on<br/>the&#160;string&#160;literal&#160;before&#160;it&#160;is&#160;passed&#160;to&#160;gsub.&#160;This&#160;is&#160;before&#160;the&#160;pattern&#160;has&#160;been&#160;matched,<br/>so variables like&#160;$&amp;&#160;are undefined or hold values from a previous match.<br/>In&#160;Ruby&#160;1.9,&#160;you&#160;can&#160;refer&#160;to&#160;named&#160;capturing&#160;groups&#160;using&#160;the&#160;\k&#160;named&#160;backreference<br/>syntax:<br/>
# Strip pairs of quotes from a string<br/>re = /(?&lt;quote&gt;['&#34;])(?&lt;body&gt;[^'&#34;]*)\k&lt;quote&gt;/<br/>puts &#34;These are 'quotes'&#34;.gsub(re, '\k&lt;body&gt;')<br/>
Replacement&#160;strings&#160;can&#160;also&#160;refer&#160;to&#160;text&#160;other&#160;than&#160;that&#160;matched&#160;by&#160;capturing&#160;groups.<br/>Use&#160;\&amp;,&#160;\`,&#160;\', and&#160;\+&#160;to substitute in the value of&#160;$&amp;,&#160;$`,&#160;$', and&#160;$+.<br/>Instead&#160;of&#160;using&#160;a&#160;static&#160;replacement&#160;string,&#160;the&#160;search-and-replace&#160;methods&#160;can&#160;also<br/>be&#160;called&#160;with&#160;a&#160;block&#160;of&#160;code&#160;that&#160;computes&#160;the&#160;replacement&#160;string&#160;dynamically.&#160;The<br/>argument to the block is the text that matched the pattern:<br/>
# Use consistent capitalization for the names of programming languages<br/>text = &#34;RUBY Java perl PyThOn&#34; &#160; &#160; &#160; &#160; # Text to modify<br/>lang = /ruby|java|perl|python/i &#160; &#160; &#160; &#160;# Pattern to match<br/>text.gsub!(lang) {|l| l.capitalize } &#160; # Fix capitalization<br/>
Within the block of code, you can use&#160;$~&#160;and the related global variables listed earlier<br/><a href="Rubys.html#332">in Table 9-3:</a><br/>
pattern = /(['&#34;])([^\1]*)\1/ &#160; # Single- or double-quoted string<br/>text.gsub!(pattern) do<br/>&#160; if ($1 == '&#34;') &#160; # If it was a double-quoted string<br/>&#160; &#160; &#34;'#$2'&#34; &#160; &#160; &#160; &#160;# replace with single-quoted<br/>&#160; else &#160; &#160; &#160; &#160; &#160; &#160; # Otherwise, if single-quoted<br/>&#160; &#160; &#34;\&#34;#$2\&#34;&#34; &#160; &#160; &#160;# replace with double-quoted<br/>&#160; end<br/>end<br/>
<b>9.2.4.4 &#160;Regular expression encoding<br/></b>In&#160;Ruby&#160;1.9,&#160;Regexp&#160;objects&#160;have&#160;an&#160;encoding&#160;method&#160;&#160;just&#160;like&#160;strings&#160;do.&#160;You&#160;can<br/>explicitly&#160;specify&#160;the&#160;encoding&#160;of&#160;a&#160;regular&#160;expression&#160;with&#160;modifiers:&#160;u&#160;for&#160;UTF-8,&#160;s<br/>for SJIS,&#160;e&#160;for&#160;EUC-JP,&#160;and&#160;n&#160;for&#160;none.&#160;You&#160;can&#160;also&#160;explicitly&#160;specify&#160;UTF-8&#160;encoding<br/>by&#160;including&#160;a&#160;\u&#160;escape&#160;in&#160;the&#160;regular&#160;expression.&#160;If&#160;you&#160;don’t&#160;explicitly&#160;specify&#160;an<br/>
<b>320&#160;|&#160;Chapter 9:</b> <b>The Ruby Platform</b><br/>
<hr/>
<a name=335></a>encoding,&#160;then&#160;the&#160;source&#160;encoding&#160;is&#160;used.&#160;But&#160;if&#160;all&#160;the&#160;characters&#160;in&#160;the&#160;regexp&#160;are<br/>ASCII, then ASCII is used, even if the source encoding is some superset of ASCII.<br/>Ruby&#160;1.9&#160;pattern-matching&#160;operations&#160;raise&#160;an&#160;exception&#160;if&#160;you&#160;attempt&#160;to&#160;match&#160;a<br/>pattern&#160;and&#160;a&#160;string&#160;that&#160;have&#160;incompatible&#160;encodings.&#160;The&#160;fixed_encoding?&#160;&#160;method<br/>returns&#160;true&#160;if&#160;a&#160;Regexp&#160;has&#160;an&#160;encoding&#160;other&#160;than&#160;ASCII.&#160;If&#160;fixed_encoding?&#160;returns<br/>false, then it is safe to use that pattern to match against any string whose encoding is<br/>ASCII or a superset of ASCII.<br/>
<b>9.3 &#160;Numbers and Math<br/></b><a href="Rubys.html#55">Chapter&#160;&#160;3&#160;&#160;</a>covered&#160;&#160;the&#160;&#160;various&#160;&#160;Numeric&#160;&#160;subclasses&#160;&#160;in&#160;&#160;Ruby,&#160;&#160;explained&#160;&#160;how&#160;&#160;to&#160;&#160;write<br/>numeric&#160;literals&#160;in&#160;Ruby,&#160;and&#160;documented&#160;Ruby’s&#160;integer&#160;and&#160;floating-point&#160;arithmetic.<br/>Here&#160;we&#160;expand&#160;on&#160;that&#160;chapter&#160;to&#160;cover&#160;numeric&#160;APIs&#160;and&#160;other&#160;math-related&#160;classes.<br/>
<b>9.3.1 &#160;Numeric Methods<br/></b>Numericand&#160;its&#160;subclasses&#160;define&#160;a&#160;number&#160;of&#160;useful&#160;predicates&#160;for&#160;determining&#160;the&#160;class<br/>or&#160;testing&#160;the&#160;value&#160;of&#160;a&#160;number.&#160;Some&#160;of&#160;these&#160;predicates&#160;work&#160;only&#160;for&#160;Float&#160;values,<br/>and some work only for&#160;Integervalues:<br/>
# General Predicates<br/>0.zero? &#160; &#160; &#160; &#160;# =&gt; true (is this number zero?)<br/>1.0.zero? &#160; &#160; &#160;# =&gt; false<br/>0.0.nonzero? &#160; # =&gt; nil (works like false)<br/>1.nonzero? &#160; &#160; # =&gt; 1 (works like true)<br/>1.integer? &#160; &#160; # =&gt; true<br/>1.0.integer? &#160; # =&gt; false<br/>1.scalar? &#160; &#160; &#160;# =&gt; true: not a complex number. Ruby 1.9.<br/>1.0.scalar? &#160; &#160;# =&gt; true: not a complex number. Ruby 1.9.<br/>Complex(1,2).scalar? # =&gt; false: a complex number. require 'complex' in 1.8<br/>
# Integer predicates (Ruby 1.9 and 1.8.7)<br/>0.even? &#160; &#160; &#160; &#160;# =&gt; true<br/>0.odd? &#160; &#160; &#160; &#160; # =&gt; false<br/>
# Float predicates<br/>ZERO, INF, NAN = 0.0, 1.0/0.0, 0.0/0.0 &#160;# Constants for testing<br/>
ZERO.finite? &#160; # =&gt; true: is this number finite?<br/>INF.finite? &#160; &#160;# =&gt; false<br/>NAN.finite? &#160; &#160;# =&gt; false<br/>
ZERO.infinite? # =&gt; nil: is this number infinite? Positive or negative?<br/>INF.infinite? &#160;# =&gt; 1<br/>-INF.infinite? # =&gt; -1<br/>NAN.infinite? &#160;# =&gt; nil<br/>
ZERO.nan? &#160; &#160; &#160;# =&gt; false: is this number not-a-number?<br/>INF.nan? &#160; &#160; &#160; # =&gt; false<br/>NAN.nan? &#160; &#160; &#160; # =&gt; true<br/>
<b>9.3 &#160;Numbers and Math&#160;|&#160;321</b><br/>
<hr/>
<a name=336></a>Numeric and its subclasses define various methods for rounding numbers:<br/>
# Rounding methods<br/>1.1.ceil &#160; &#160; # =&gt; &#160;2: ceiling: smallest integer &gt;= its argument<br/>-1.1.ceil &#160; &#160;# =&gt; -1: ceiling: smallest integer &gt;= its argument<br/>1.9.floor &#160; &#160;# =&gt; &#160;1: floor: largest integer &lt;= its argument<br/>-1.9.floor &#160; # =&gt; -2: floor: largest integer &lt;= its argument<br/>1.1.round &#160; &#160;# =&gt; &#160;1: round to nearest integer<br/>0.5.round &#160; &#160;# =&gt; &#160;1: round toward infinity when halfway between integers&#160;<br/>-0.5.round &#160; # =&gt; -1: or round toward negative infinity<br/>1.1.truncate # =&gt; &#160;1: chop off fractional part: round toward zero<br/>-1.1.to_i &#160; &#160;# =&gt; -1: synonym for truncate<br/>
Here are a few other numeric methods and constants of interest:<br/>
# For any Numeric value n, in Ruby 1.9<br/>[n.abs, n&lt;=&gt;0] &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Absolute value and sign<br/>[n.abs, n.angle] &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Magnitude and angle (or use n.polar)<br/>[n.numerator, n.denominator] &#160;# Numerator and denominator<br/>[n.real, n.imag] &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Real and imaginary parts<br/>
# Floating point constants: may be implementation dependent<br/>[Float::MAX, Float::MIN] &#160; &#160; &#160;# =&gt; [1.79769313486232e+308,2.2250738585072e-308]<br/>Float::EPSILON # =&gt; 2.22044604925031e-16: difference between adjacent floats<br/>
<b>9.3.2 &#160;The Math Module<br/></b>The&#160;&#160;Math&#160;&#160;module&#160;&#160;defines&#160;&#160;constants&#160;&#160;PI&#160;&#160;and&#160;&#160;E,&#160;&#160;and&#160;&#160;methods&#160;&#160;for&#160;&#160;trigonometry&#160;&#160;and<br/>logarithms,&#160;plus&#160;a&#160;few&#160;miscellaneous&#160;methods.&#160;The&#160;methods&#160;of&#160;Math&#160;are&#160;“module&#160;func-<br/>tions”&#160;<a href="Rubys.html#265">(see&#160;§7.5.3),&#160;</a>which&#160;means&#160;that&#160;they&#160;can&#160;be&#160;invoked&#160;through&#160;the&#160;Math&#160;namespace<br/>or included and invoked as if they were global functions. Here are some examples:<br/>
# Constants<br/>Math::PI &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; 3.14159265358979<br/>Math::E &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; 2.71828182845905<br/>
# Roots<br/>Math.sqrt(25.0) &#160; &#160; &#160; &#160;# =&gt; 5.0: square root<br/>Math.cbrt(27.0) &#160; &#160; &#160; &#160;# =&gt; 3.0: cube root; Ruby 1.9 and later<br/>27.0**(1.0/3.0) &#160; &#160; &#160; &#160;# =&gt; 3.0: cube root computed with ** operator<br/>
# Logarithms<br/>Math.log10(100.0) &#160; &#160; &#160;# =&gt; 2.0: base-10 logarithm<br/>Math.log(Math::E**3) &#160; # =&gt; 3.0: natural (base-e) logarithm<br/>Math.log2(8) &#160; &#160; &#160; &#160; &#160; # =&gt; 3.0: base-2 logarithm. Ruby 1.9 and later.<br/>Math.log(16, 4) &#160; &#160; &#160; &#160;# =&gt; 2.0: 2nd arg to log() is the base. Ruby 1.9.<br/>Math.exp(2) &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; 7.38905609893065: same as Math::E**2<br/>
# Trigonometry<br/>include Math &#160; &#160; &#160; &#160; &#160; # Save typing: we can now omit Math prefix.<br/>sin(PI/2) &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; 1.0: sine. Argument is in radians, not degrees.<br/>cos(0) &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; 1.0: cosine.<br/>tan(PI/4) &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; 1.0: tangent.<br/>asin(1.0)/PI &#160; &#160; &#160; &#160; &#160; # =&gt; 0.5: arcsine. See also acos and atan.<br/>sinh(0) &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; 0.0: hyperbolic sine. Also cosh, tanh.<br/>
<b>322&#160;|&#160;Chapter 9:</b> <b>The Ruby Platform</b><br/>
<hr/>
<a name=337></a>asinh(1.0) &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; 0.0: inverse sinh. Also acosh, atanh.<br/>
# Convert cartesian point (x,y) to polar coordinates (theta, r)<br/>theta = atan2(y,x) &#160; &#160; # Angle between X axis and line (0,0)-(x,y)<br/>r = hypot(x,y) &#160; &#160; &#160; &#160; # Hypotenuse: sqrt(x**2 + y**2)<br/>
# Miscellaneous Functions<br/>f,e = frexp(1024.0) &#160; &#160;# =&gt; [0.5, 11]: decompose x into [f,e], x = f*2**e<br/>x = ldexp(f, e) &#160; &#160; &#160; &#160;# =&gt; 1024: compute x = f*2**e<br/>erf(0.0) &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; 0.0: error function<br/>erfc(0.0) &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; 1.0: 1-erf(x): complementary error function<br/>gamma(5) &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; 24.0: floating-point factorial function<br/>lgamma(100) &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; [359.134205369575, 1]: logarithmic gamma<br/>
<b>9.3.3 &#160;Decimal Arithmetic<br/></b>The&#160;BigDecimal&#160;class&#160;from&#160;the&#160;standard&#160;library&#160;is&#160;a&#160;useful&#160;alternative&#160;to&#160;Float, partic-<br/>ularly&#160;for&#160;financial&#160;computations&#160;where&#160;you&#160;want&#160;to&#160;avoid&#160;the&#160;rounding&#160;error&#160;inherent<br/>in&#160;the&#160;use&#160;of&#160;a&#160;binary&#160;floating-point&#160;arithmetic&#160;<a href="Rubys.html#59">(see&#160;§3.1.4).&#160;</a>BigDecimal&#160;objects&#160;can&#160;have<br/>an&#160;unlimited&#160;number&#160;of&#160;significant&#160;digits&#160;and&#160;practically&#160;unlimited&#160;size&#160;(exponents&#160;over<br/>1&#160;&#160;billion&#160;&#160;are&#160;&#160;supported).&#160;&#160;Most&#160;&#160;importantly,&#160;&#160;they&#160;&#160;use&#160;&#160;decimal&#160;&#160;arithmetic&#160;&#160;and&#160;&#160;offer<br/>precise control over rounding modes. Here is example&#160;BigDecimal&#160;code:<br/>
require &#34;bigdecimal&#34; &#160; &#160; &#160;# Load standard library<br/>dime = BigDecimal(&#34;0.1&#34;) &#160;# Pass a string to constructor, not a Float<br/>4*dime-3*dime == dime &#160; &#160; # true with BigDecimal, but false if we use Float<br/>
# Compute monthly interest payments on a mortgage with BigDecimal.<br/># Use &#34;Banker's Rounding&#34; mode, and limit computations to 20 digits<br/>BigDecimal.mode(BigDecimal::ROUND_MODE, BigDecimal::ROUND_HALF_EVEN)<br/>BigDecimal.limit(20)<br/>principal = BigDecimal(&#34;200000&#34;) &#160;# Always pass strings to constructor<br/>
&#160;<br/>
apr = BigDecimal(&#34;6.5&#34;) &#160; &#160; &#160; &#160; &#160; # Annual percentage rate interest<br/>years = 30 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Term of mortgage in years<br/>payments = years*12 &#160; &#160; &#160; &#160; &#160; &#160; &#160; # 12 monthly payments in a year<br/>interest = apr/100/12 &#160; &#160; &#160; &#160; &#160; &#160; # Convert APR to monthly fraction<br/>x = (interest+1)**payments &#160; &#160; &#160; &#160;# Note exponentiation with BigDecimal<br/>monthly = (principal * interest * x)/(x-1) &#160;# Compute monthly payment<br/>monthly = monthly.round(2) &#160; &#160; &#160; &#160;# Round to two decimal places<br/>monthly = monthly.to_s(&#34;f&#34;) &#160; &#160; &#160; # Convert to human-readable string<br/>
Use&#160;<i>ri</i>&#160;for&#160;more&#160;details&#160;on&#160;the&#160;BigDecimal&#160;API,&#160;and&#160;for&#160;complete&#160;documentation&#160;see&#160;the<br/>file&#160;<i>ext/bigdecimal/bigdecimal_en.html</i>&#160;in the Ruby source distribution.<br/>
<b>9.3.4 &#160;Complex Numbers<br/></b>The&#160;Complex&#160;class represents complex numbers. It is a core class in 1.9 and part of the<br/>standard&#160;library&#160;in&#160;1.8.&#160;Requiring&#160;the&#160;“complex”&#160;module&#160;(in&#160;either&#160;1.8&#160;or&#160;1.9)&#160;redefines<br/>the&#160;methods&#160;of&#160;the&#160;Math&#160;module&#160;so&#160;that&#160;they&#160;can&#160;accept&#160;and&#160;return&#160;complex&#160;numbers.<br/>In&#160;Ruby&#160;1.9&#160;you&#160;can&#160;instead&#160;require&#160;“cmath”&#160;to&#160;define&#160;a&#160;CMath&#160;module&#160;that&#160;defines<br/>complex-enabled versions of the&#160;Math&#160;methods. Examples:<br/>
<b>9.3 &#160;Numbers and Math&#160;|&#160;323</b><br/>
<hr/>
<a name=338></a>require &#34;complex&#34; &#160; &#160; &#160; &#160; &#160; # Ruby 1.8 and for complex Math methods in 1.9<br/>c = Complex(0.5,-0.2) &#160; &#160; &#160; # =&gt; .5-.2i. &#160;<br/>Complex.polar(1,Math::PI/2) # =&gt; Complex(0.0,1.0): create with polar coords<br/>i = 1.im &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; Complex(0,1): multiply by i<br/>(2.re - 3.5.im).to_s &#160; &#160; &#160; &#160;# =&gt; &#34;2-3.5i&#34;: re method in Ruby 1.9 only<br/>r,i = c.real, c.imag &#160; &#160; &#160; &#160;# =&gt; [0.5,-0.2]: Real part, imaginary part<br/>m,a = c.polar &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; [magnitude, angle]: Same as [c.abs,c.angle]<br/>d = c.conj &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; .5+.2i: change sign of imaginary part<br/>z = &#34;0+0i&#34;.to_c &#160; &#160; &#160; &#160; &#160; &#160; # String-to-Complex conversion function<br/>10.times { z = z*z + c } &#160; &#160;# Arithmetic operators work on Complex numbers<br/>1.im**2 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; Complex(-1,0): i*i == -1<br/>x = Math.sin(z) &#160; &#160; &#160; &#160; &#160; &#160; # 'complex' module redefines Math functions<br/>require 'cmath' &#160; &#160; &#160; &#160; &#160; &#160; # Ruby 1.9: Define CMath module for complex math<br/>CMath.sqrt(-1)==Complex::I &#160;# =&gt; true<br/>
<b>9.3.5 &#160;Rational Numbers<br/></b>The&#160;&#160;Rational&#160;&#160;class&#160;&#160;represents&#160;&#160;rational&#160;&#160;numbers&#160;&#160;(the&#160;&#160;quotient&#160;&#160;of&#160;&#160;two&#160;&#160;integers).<br/>Rational&#160;is&#160;built-in&#160;to&#160;Ruby&#160;1.9&#160;and&#160;is&#160;part&#160;of&#160;the&#160;standard&#160;library&#160;in&#160;Ruby&#160;1.8.&#160;Division<br/>with&#160;the&#160;quo&#160;method&#160;returns&#160;a&#160;Rational&#160;value&#160;if&#160;both&#160;arguments&#160;are&#160;integers.&#160;Some<br/>examples:<br/>
require &#34;rational&#34; &#160; &#160; &#160; &#160; &#160; # Only necessary in Ruby 1.8<br/>penny = Rational(1, 100) &#160; &#160; # A penny is 1/100th<br/>nickel = &#34;5/100&#34;.to_r &#160; &#160; &#160; &#160;# String-to-Rational conversion: Ruby 1.9 only<br/>dime = 10.quo 100 &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; Rational(1,10)<br/>change = 2*dime + 3*penny &#160; &#160;# =&gt; Rational(23,100)<br/>change.numerator &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; 23: top of the fraction<br/>change.denominator &#160; &#160; &#160; &#160; &#160; # =&gt; 100: bottom of the fraction<br/>change.to_f &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; 0.23: convert to Float<br/>(nickel * dime).to_s &#160; &#160; &#160; &#160; # =&gt; &#34;1/200&#34;: to_s returns fractions<br/>
<b>9.3.6 &#160;Vectors and Matrices<br/></b>The&#160;matrix&#160;library defines&#160;Matrix&#160;and&#160;Vector&#160;classes&#160;to represent matrices and vectors<br/>of numbers as well as operators to perform arithmetic on them. A discussion of linear<br/>algebra&#160;is&#160;well&#160;beyond&#160;the&#160;scope&#160;of&#160;this&#160;book,&#160;but&#160;the&#160;following&#160;example&#160;code&#160;uses&#160;the<br/>Vector&#160;&#160;class&#160;&#160;to&#160;&#160;represent&#160;&#160;a&#160;&#160;two-dimensional&#160;&#160;point,&#160;&#160;and&#160;&#160;uses&#160;&#160;2&#160;×&#160;2&#160;&#160;Matrix&#160;&#160;objects&#160;&#160;to<br/>represent scaling and rotation transformations of the point:<br/>
require &#34;matrix&#34;<br/>
# Represent the point (1,1) as the vector [1,1]<br/>unit = Vector[1,1]<br/>
# The identity transformation matrix<br/>identity = Matrix.identity(2) &#160;# 2x2 matrix<br/>identity*unit == unit &#160; &#160; &#160; &#160; &#160;# true: no transformation<br/>
# This matrix scales a point by sx,sy<br/>sx,sy = 2.0, 3.0;<br/>scale = Matrix[[sx,0], [0, sy]]<br/>
<b>324&#160;|&#160;Chapter 9:</b> <b>The Ruby Platform</b><br/>
<hr/>
<a name=339></a>scale*unit &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; [2.0, 3.0]: scaled point<br/>
# This matrix rotates counterclockwise around the origin<br/>theta = Math::PI/2 &#160; &#160; # 90 degrees<br/>rotate = Matrix[[Math.cos(theta), -Math.sin(theta)],<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; [Math.sin(theta), &#160;Math.cos(theta)]]<br/>rotate*unit &#160; &#160; &#160; &#160; &#160; &#160;# [-1.0, 1.0]: 90 degree rotation<br/>
# Two transformations in one<br/>scale * (rotate*unit) &#160;# [-2.0, 3.0]<br/>
<b>9.3.7 &#160;Random Numbers<br/></b>Random&#160;numbers&#160;are&#160;generated&#160;in&#160;Ruby&#160;with&#160;the&#160;global&#160;Kernel.rand&#160;function.&#160;With<br/>no&#160;arguments,&#160;it&#160;returns&#160;a&#160;pseudorandom&#160;Float&#160;greater&#160;than&#160;or&#160;equal&#160;to&#160;0.0&#160;and&#160;less<br/>than&#160;1.0.&#160;With&#160;an&#160;integer&#160;argument&#160;<i>max</i>,&#160;it&#160;returns&#160;a&#160;pseudorandom&#160;integer&#160;greater&#160;than<br/>or equal to&#160;0&#160;and less than&#160;<i>max</i>. For example:<br/>
rand &#160; &#160; &#160; # =&gt; 0.964395196505186<br/>rand &#160; &#160; &#160; # =&gt; 0.390523655919935<br/>rand(100) &#160;# =&gt; 81<br/>rand(100) &#160;# =&gt; 32<br/>
If&#160;you&#160;need&#160;a&#160;repeatable&#160;sequence&#160;of&#160;pseudorandom&#160;numbers&#160;(for&#160;testing,&#160;perhaps),<br/>seed the random number generator with a known value:<br/>
srand(0) &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Known seed<br/>[rand(100),rand(100)] &#160; # =&gt; [44,47]: pseudorandom sequence<br/>srand(0) &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Reset the seed to repeat the sequence<br/>[rand(100),rand(100)] &#160; # =&gt; [44,47]<br/>
For&#160;cryptographically&#160;secure&#160;random&#160;numbers,&#160;use&#160;the&#160;SecureRandom&#160;module,&#160;which&#160;is<br/>part of the standard library in Ruby 1.9 and 1.8.7.<br/>
<b>9.4 &#160;Dates and Times<br/></b>The&#160;Time&#160;class&#160;represents&#160;dates&#160;and&#160;times.&#160;It&#160;is&#160;a&#160;thin&#160;layer&#160;over&#160;the&#160;system&#160;date&#160;and<br/>time&#160;functionality&#160;provided&#160;by&#160;the&#160;operating&#160;system.&#160;On&#160;some&#160;platforms,&#160;therefore,<br/>this&#160;class&#160;may&#160;be&#160;unable&#160;to&#160;represent&#160;dates&#160;before&#160;1970&#160;or&#160;after&#160;2038.&#160;The&#160;Date&#160;and<br/>DateTime&#160;classes&#160;in&#160;the&#160;standard&#160;date&#160;library&#160;are&#160;not&#160;constrained&#160;in&#160;this&#160;way,&#160;but&#160;are<br/>not demonstrated here:<br/>
# Creating Time objects<br/>Time.now &#160; &#160; &#160; &#160;# Returns a time object that represents the current time<br/>Time.new &#160; &#160; &#160; &#160;# A synonym for Time.now<br/>
Time.local(2007, 7, 8) &#160; &#160; &#160; &#160; &#160;# July 8, 2007<br/>Time.local(2007, 7, 8, 9, 10) &#160; # July 8, 2007, 09:10am, local time<br/>Time.utc(2007, 7, 8, 9, 10) &#160; &#160; # July 8, 2007, 09:10 UTC<br/>Time.gm(2007, 7, 8, 9, 10, 11) &#160;# July 8, 2007, 09:10:11 GMT (same as UTC)<br/>
# One microsecond before the new millennium began in London<br/>
<b>9.4 &#160;Dates and Times&#160;|&#160;325</b><br/>
<hr/>
<a name=340></a># We'll use this Time object in many examples below.<br/>t = Time.utc(2000, 12, 31, 23, 59, 59, 999999)<br/>
# Components of a Time<br/>t.year &#160; &#160;# =&gt; 2000<br/>t.month &#160; # =&gt; 12: December<br/>t.day &#160; &#160; # =&gt; 31<br/>t.wday &#160; &#160;# =&gt; 0: day of week: 0 is Sunday<br/>t.yday &#160; &#160;# =&gt; 366: day of year: 2000 was a leap year<br/>t.hour &#160; &#160;# =&gt; 23: 24-hour clock<br/>t.min &#160; &#160; # =&gt; 59<br/>t.sec &#160; &#160; # =&gt; 59<br/>t.usec &#160; &#160;# =&gt; 999999: microseconds, not milliseconds<br/>t.zone &#160; &#160;# =&gt; &#34;UTC&#34;: timezone name<br/>
# Get all components in an array that holds<br/># [sec,min,hour,day,month,year,wday,yday,isdst,zone]<br/># Note that we lose microseconds<br/>values = t.to_a &#160; &#160;# =&gt; [59, 59, 23, 31, 12, 2000, 0, 366, false, &#34;UTC&#34;]<br/>
# Arrays of this form can be passed to Time.local and Time.utc<br/>values[5] += 1 &#160; &#160; # Increment the year<br/>Time.utc(*values) &#160;# =&gt; Mon Dec 31 23:59:59 UTC 2001<br/>
# Timezones and daylight savings time<br/>t.zone &#160; &#160; &#160; # =&gt; &#34;UTC&#34;: return the timezone<br/>t.utc? &#160; &#160; &#160; # =&gt; true: t is in UTC time zone<br/>t.utc_offset # =&gt; 0: UTC is 0 seconds offset from UTC<br/>t.localtime &#160;# Convert to local timezone. Mutates the Time object!<br/>t.zone &#160; &#160; &#160; # =&gt; &#34;PST&#34; (or whatever your timezone is)<br/>t.utc? &#160; &#160; &#160; # =&gt; false<br/>t.utc_offset # =&gt; -28800: 8 hours before UTC<br/>t.gmtime &#160; &#160; # Convert back to UTC. Another mutator.<br/>t.getlocal &#160; # Return a new Time object in local zone<br/>t.getutc &#160; &#160; # Return a new Time object in UTC<br/>t.isdst &#160; &#160; &#160;# =&gt; false: UTC does not have DST. Note no ?.<br/>t.getlocal.isdst # =&gt; false: no daylight savings time in winter.<br/>
# Weekday predicates: Ruby 1.9<br/>t.sunday? &#160; &#160;# =&gt; true<br/>t.monday? &#160; &#160;# =&gt; false<br/>t.tuesday? &#160; # etc.<br/>
# Formatting Times and Dates<br/>t.to_s &#160; &#160; &#160; # =&gt; &#34;Sun Dec 31 23:59:59 UTC 2000&#34;: Ruby 1.8<br/>t.to_s &#160; &#160; &#160; # =&gt; &#34;2000-12-31 23:59:59 UTC&#34;: Ruby 1.9 uses ISO-8601<br/>t.ctime &#160; &#160; &#160;# =&gt; &#34;Sun Dec 31 23:59:59 2000&#34;: another basic format<br/>
# strftime interpolates date and time components into a template string<br/># Locale-independent formatting<br/>t.strftime(&#34;%Y-%m-%d %H:%M:%S&#34;) # =&gt; &#34;2000-12-31 23:59:59&#34;: ISO-8601 format<br/>t.strftime(&#34;%H:%M&#34;) &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; &#34;23:59&#34;: 24-hour time<br/>t.strftime(&#34;%I:%M %p&#34;) &#160; &#160; &#160; &#160; &#160;# =&gt; &#34;11:59 PM&#34;: 12-hour clock<br/>
# Locale-dependent formats<br/>
<b>326&#160;|&#160;Chapter 9:</b> <b>The Ruby Platform</b><br/>
<hr/>
<a name=341></a>t.strftime(&#34;%A, %B %d&#34;) &#160; &#160; &#160; &#160; # =&gt; &#34;Sunday, December 31&#34;<br/>t.strftime(&#34;%a, %b %d %y&#34;) &#160; &#160; &#160;# =&gt; &#34;Sun, Dec 31 00&#34;: 2-digit year<br/>t.strftime(&#34;%x&#34;) &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; &#34;12/31/00&#34;: locale-dependent format<br/>t.strftime(&#34;%X&#34;) &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; &#34;23:59:59&#34;<br/>t.strftime(&#34;%c&#34;) &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# same as ctime<br/>
# Parsing Times and Dates<br/>require 'parsedate' &#160; &#160;# A versatile date/time parsing library<br/>include ParseDate &#160; &#160; &#160;# Include parsedate() as a global function<br/>datestring = &#34;2001-01-01&#34;<br/>values = parsedate(datestring) &#160;# [2001, 1, 1, nil, nil, nil, nil, nil]<br/>t = Time.local(*values) &#160; &#160; &#160; &#160; # =&gt; Mon Jan 01 00:00:00 -0800 2001<br/>s = t.ctime &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; &#34;Mon Jan &#160;1 00:00:00 2001&#34;<br/>Time.local(*parsedate(s))==t &#160; &#160;# =&gt; true<br/>
s = &#34;2001-01-01 00:00:00-0500&#34; &#160;# midnight in New York<br/>v = parsedate(s) &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; [2001, 1, 1, 0, 0, 0, &#34;-0500&#34;, nil]<br/>t = Time.local(*v) &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Loses time zone information!<br/>
# Time arithmetic<br/>now = Time.now &#160; &#160; &#160; &#160; &#160;# Current time<br/>past = now - 10 &#160; &#160; &#160; &#160; # 10 seconds ago. Time - number =&gt; Time<br/>future = now + 10 &#160; &#160; &#160; # 10 seconds from now Time + number =&gt; Time<br/>future - now &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; 10 &#160;Time - Time =&gt; number of seconds<br/>
# Time comparisons<br/>past &lt;=&gt; future &#160; &#160; &#160; &#160; # =&gt; -1<br/>past &lt; future &#160; &#160; &#160; &#160; &#160; # =&gt; true<br/>now &gt;= future &#160; &#160; &#160; &#160; &#160; # =&gt; false<br/>now == now &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; true<br/>
# Helper methods for working with time units other than seconds<br/>class Numeric<br/>&#160; # Convert time intervals to seconds<br/>&#160; def milliseconds; self/1000.0; end<br/>&#160; def seconds; self; end<br/>&#160; def minutes; self*60; end<br/>&#160; def hours; self*60*60; end<br/>&#160; def days; self*60*60*24; end<br/>&#160; def weeks; self*60*60*24*7; end<br/>
&#160; # Convert seconds to other intervals<br/>&#160; def to_milliseconds; self*1000; end<br/>&#160; def to_seconds; self; end<br/>&#160; def to_minutes; self/60.0; end<br/>&#160; def to_hours; self/(60*60.0); end<br/>&#160; def to_days; self/(60*60*24.0); end<br/>&#160; def to_weeks; self/(60*60*24*7.0); end<br/>end<br/>
expires = now + 10.days &#160; &#160; # 10 days from now<br/>expires - now &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; 864000.0 seconds<br/>(expires - now).to_hours &#160; &#160;# =&gt; 240.0 hours<br/>
# Time represented internally as seconds since the (platform-dependent) epoch<br/>
<b>9.4 &#160;Dates and Times&#160;|&#160;327</b><br/>
<hr/>
<a name=342></a>t = Time.now.to_i &#160; &#160;# =&gt; 1184036194 seconds since epoch<br/>Time.at(t) &#160; &#160; &#160; &#160; &#160; # =&gt; seconds since epoch to Time object<br/>t = Time.now.to_f &#160; &#160;# =&gt; 1184036322.90872: includes 908720 microseconds<br/>Time.at(0) &#160; &#160; &#160; &#160; &#160; # =&gt; Wed Dec 31 16:00:00 -0800 1969: epoch in local time<br/>
<b>9.5 &#160;Collections<br/></b>This&#160;section&#160;documents&#160;Ruby’s&#160;<i>collection</i>&#160;classes.&#160;A&#160;collection&#160;is&#160;any&#160;class&#160;that&#160;repre-<br/>sents a collection of values.&#160;Array&#160;and&#160;Hash&#160;are&#160;the&#160;key&#160;collection&#160;classes&#160;in&#160;Ruby,&#160;and<br/>the&#160;&#160;standard&#160;&#160;library&#160;&#160;adds&#160;&#160;a&#160;&#160;Set&#160;&#160;class.&#160;&#160;Each&#160;&#160;of&#160;&#160;these&#160;&#160;collection&#160;&#160;classes&#160;&#160;mixes&#160;&#160;in&#160;&#160;the<br/>Enumerable&#160;&#160;module,&#160;&#160;which&#160;&#160;means&#160;&#160;that&#160;&#160;Enumerable&#160;&#160;methods&#160;&#160;are&#160;&#160;universal&#160;&#160;collection<br/>methods.<br/>
<b>9.5.1 &#160;Enumerable Objects<br/></b>The&#160;Enumerable&#160;module&#160;is&#160;a&#160;mixin&#160;that&#160;implements&#160;a&#160;number&#160;of&#160;useful&#160;methods&#160;on&#160;top<br/>of&#160;&#160;the&#160;&#160;each&#160;&#160;iterator.&#160;&#160;The&#160;&#160;Array,&#160;&#160;Hash,&#160;&#160;and&#160;&#160;Set&#160;&#160;classes&#160;&#160;described&#160;&#160;below&#160;&#160;all&#160;&#160;include<br/>Enumerable&#160;and&#160;therefore&#160;implement&#160;all&#160;of&#160;the&#160;methods&#160;described&#160;here.&#160;Range&#160;and&#160;IO<br/>are&#160;other&#160;noteworthy&#160;enumerable&#160;classes.&#160;Enumerable&#160;was&#160;covered&#160;briefly&#160;in&#160;<a href="Rubys.html#146">§5.3.2.<br/></a>This section provides more detailed coverage.<br/>Note&#160;that&#160;some&#160;enumerable&#160;classes&#160;have&#160;a&#160;natural&#160;enumeration&#160;order&#160;that&#160;their&#160;each<br/>method&#160;follows.&#160;Arrays,&#160;for&#160;example,&#160;enumerate&#160;their&#160;elements&#160;in&#160;order&#160;of&#160;increasing<br/>array&#160;index.&#160;Range&#160;enumerates&#160;in&#160;ascending&#160;order.&#160;And&#160;IO&#160;objects&#160;enumerate&#160;lines&#160;of<br/>text&#160;in&#160;the&#160;order&#160;in&#160;which&#160;they&#160;are&#160;read&#160;from&#160;the&#160;underlying&#160;file&#160;or&#160;socket.&#160;In&#160;Ruby&#160;1.9,<br/>Hash&#160;and&#160;Set&#160;(which&#160;is&#160;based&#160;on&#160;Hash)&#160;enumerate&#160;their&#160;elements&#160;in&#160;the&#160;order&#160;in&#160;which<br/>they&#160;were&#160;inserted.&#160;Prior&#160;to&#160;Ruby&#160;1.9,&#160;however,&#160;these&#160;classes&#160;enumerate&#160;their&#160;elements<br/>in what is essentially an arbitrary order.<br/>Many&#160;Enumerable&#160;methods&#160;return&#160;a&#160;processed&#160;version&#160;of&#160;the&#160;enumerable&#160;collection&#160;or<br/>a&#160;selected&#160;subcollection&#160;of&#160;its&#160;elements.&#160;Usually,&#160;if&#160;an&#160;Enumerable&#160;method&#160;returns&#160;a<br/>collection&#160;(rather&#160;than&#160;a&#160;single&#160;value&#160;selected&#160;from&#160;a&#160;collection),&#160;the&#160;collection&#160;is&#160;an<br/>Array.&#160;This&#160;is&#160;not&#160;always&#160;the&#160;case,&#160;however.&#160;The&#160;Hash&#160;class&#160;overrides&#160;the&#160;reject&#160;method<br/>so&#160;that&#160;it&#160;returns&#160;a&#160;Hash&#160;object&#160;instead&#160;of&#160;an&#160;array,&#160;for&#160;example.&#160;Whatever&#160;the&#160;precise<br/>return&#160;value,&#160;it&#160;is&#160;certain&#160;that&#160;a&#160;collection&#160;returned&#160;by&#160;an&#160;Enumerable&#160;method&#160;will&#160;itself<br/>be enumerable.<br/>
<b>9.5.1.1 &#160;Iterating and converting collections<br/></b>By definition,&#160;any&#160;Enumerable&#160;object&#160;must&#160;have&#160;an&#160;each&#160;iterator.&#160;Enumerable&#160;provides a<br/>simple&#160;variant&#160;each_with_index,&#160;which&#160;yields&#160;an&#160;element&#160;of&#160;the&#160;collection&#160;and&#160;an&#160;inte-<br/>ger.&#160;For&#160;arrays,&#160;the&#160;integer&#160;is&#160;the&#160;array&#160;index.&#160;For&#160;IO&#160;objects,&#160;the&#160;integer&#160;is&#160;the&#160;line<br/>number (starting at&#160;0). For other objects, the integer is what the array index would be<br/>if the collection was converted to an array:<br/>
(5..7).each {|x| print x } &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Prints &#34;567&#34;<br/>(5..7).each_with_index {|x,i| print x,i } &#160;# Prints &#34;506172&#34;<br/>
<b>328&#160;|&#160;Chapter 9:</b> <b>The Ruby Platform</b><br/>
<hr/>
<a name=343></a>In&#160;Ruby&#160;1.9,&#160;Enumerable&#160;defines&#160;cycle,&#160;which&#160;iterates&#160;repeatedly&#160;through&#160;the&#160;elements<br/>of&#160;the&#160;collection,&#160;looping&#160;forever&#160;until&#160;the&#160;block&#160;you&#160;provide&#160;explicitly&#160;terminates&#160;the<br/>iteration with&#160;break&#160;or&#160;return&#160;or by raising an exception. During its first pass through<br/>the&#160;Enumerable&#160;object,&#160;cycle&#160;saves&#160;the&#160;elements&#160;into&#160;an&#160;array&#160;and&#160;then&#160;subsequently<br/>iterates&#160;&#160;from&#160;&#160;the&#160;&#160;array.&#160;&#160;This&#160;&#160;means&#160;&#160;that&#160;&#160;after&#160;&#160;the&#160;&#160;first&#160;&#160;pass&#160;&#160;through&#160;&#160;the&#160;&#160;collection,<br/>modifications to that collection do not affect the behavior of&#160;cycle.<br/>
each_sliceand&#160;&#160;each_cons&#160;&#160;are&#160;&#160;iterators&#160;&#160;that&#160;&#160;yield&#160;&#160;subarrays&#160;&#160;of&#160;&#160;a&#160;&#160;collection.&#160;&#160;They&#160;&#160;are<br/>available&#160;in&#160;Ruby&#160;1.8&#160;with&#160;require 'enumerator'&#160;and&#160;are&#160;part&#160;of&#160;the&#160;core&#160;library&#160;in&#160;Ruby<br/>1.9 (and 1.8.7).&#160;each_slice(n)&#160;iterates the enumerable values in “slices” of size&#160;n:<br/>
(1..10).each_slice(4) {|x| print x } # Prints &#34;[1,2,3,4][5,6,7,8][9,10]&#34;<br/>
each_cons&#160;is&#160;similar&#160;to&#160;each_slice,&#160;but&#160;it&#160;uses&#160;a&#160;“sliding&#160;window”&#160;on&#160;the&#160;enumerable<br/>collection:<br/>
(1..5).each_cons(3) {|x| print x } &#160; &#160;# Prints &#34;[1,2,3][2,3,4][3,4,5]&#34;<br/>
The&#160;collect&#160;method&#160;applies&#160;a&#160;block&#160;to&#160;each&#160;element&#160;of&#160;a&#160;collection&#160;and&#160;collects&#160;the<br/>return&#160;values&#160;of&#160;the&#160;block&#160;into&#160;a&#160;new&#160;array.&#160;map&#160;is&#160;a&#160;synonym;&#160;it&#160;maps&#160;the&#160;elements&#160;of<br/>a collection to the elements of an array by applying a block to each element:<br/>
data = [1,2,3,4] &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# An enumerable collection<br/>roots = data.collect {|x| Math.sqrt(x)} # Collect roots of our data<br/>words = %w[hello world] &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Another collection<br/>upper = words.map {|x| x.upcase } &#160; &#160; &#160; # Map to uppercase<br/>
The&#160;zip&#160;method&#160;interleaves&#160;the&#160;elements&#160;of&#160;one&#160;enumerable&#160;collection&#160;with&#160;the&#160;ele-<br/>ments&#160;of&#160;zero&#160;or&#160;more&#160;other&#160;collections,&#160;and&#160;yields&#160;an&#160;array&#160;of&#160;elements&#160;(one&#160;from&#160;each<br/>collection)&#160;to&#160;the&#160;associated&#160;block.&#160;If&#160;no&#160;block&#160;is&#160;provided,&#160;the&#160;return&#160;value&#160;is&#160;an&#160;array<br/>of arrays:<br/>
(1..3).zip([4,5,6]) {|x| print x.inspect } # Prints &#34;[1,4][2,5][3,6]&#34;<br/>(1..3).zip([4,5,6],[7,8]) {|x| print x} &#160; &#160;# Prints &#34;14725836&#34;<br/>(1..3).zip('a'..'c') {|x,y| print x,y } &#160; &#160;# Prints &#34;1a2b3c&#34;<br/>p (1..3).zip('a'..'z') &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Prints [[1,&#34;a&#34;],[2,&#34;b&#34;],[3,&#34;c&#34;]]<br/>p (1..3).zip('a'..'b') &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Prints [[1,&#34;a&#34;],[2,&#34;b&#34;],[3,nil]]<br/>
Enumerable&#160;&#160;defines&#160;&#160;a&#160;&#160;to_a&#160;&#160;method&#160;&#160;(and&#160;&#160;a&#160;&#160;synonym&#160;&#160;entries)&#160;&#160;that&#160;&#160;converts&#160;&#160;any&#160;&#160;enu-<br/>merable&#160;collection&#160;into&#160;an&#160;array.&#160;to_a&#160;is&#160;included&#160;in&#160;this&#160;section&#160;because&#160;the&#160;conversion<br/>obviously&#160;involves&#160;iterating&#160;the&#160;collection.&#160;The&#160;elements&#160;of&#160;the&#160;resulting&#160;array&#160;appear<br/>in whatever order the&#160;each&#160;iterator yields them:<br/>
(1..3).to_a &#160; &#160; &#160; # =&gt; [1,2,3]<br/>(1..3).entries &#160; &#160;# =&gt; [1,2,3]<br/>
If you&#160;require 'set', all&#160;Enumerable&#160;objects&#160;gain&#160;a&#160;to_set&#160;conversion&#160;method&#160;as&#160;well.<br/><a href="Rubys.html#360">Sets are described in detail in §9.5.4:</a><br/>
require 'set'<br/>(1..3).to_set &#160; &#160; # =&gt; #&lt;Set: {1, 2, 3}&gt;<br/>
<b>9.5 &#160;Collections&#160;|&#160;329</b><br/>
<hr/>
<a name=344></a><b>9.5.1.2 &#160;Enumerators and external iterators<br/></b>Enumerators&#160;and&#160;their&#160;use&#160;as&#160;external&#160;iterators&#160;are&#160;fully&#160;documented&#160;in&#160;<a href="Rubys.html#149">§5.3.4&#160;</a>and<br/><a href="Rubys.html#151">§5.3.5.&#160;</a>This&#160;section&#160;is&#160;just&#160;a&#160;brief&#160;recap,&#160;with&#160;examples,&#160;of&#160;the&#160;detailed&#160;descriptions&#160;in<br/><a href="Rubys.html#131">Chapter 5.<br/></a>Enumerators&#160;are&#160;of&#160;class&#160;Enumerable::Enumerator,&#160;which&#160;has&#160;a&#160;surprisingly&#160;small&#160;num-<br/>ber&#160;of&#160;methods&#160;for&#160;such&#160;a&#160;powerful&#160;iteration&#160;construct.&#160;Enumerators&#160;are&#160;primarily&#160;a<br/>feature&#160;of&#160;Ruby&#160;1.9&#160;(and&#160;1.8.7)&#160;but&#160;some&#160;enumerator&#160;functionality&#160;is&#160;available&#160;in&#160;Ruby<br/>1.8&#160;by&#160;requiring&#160;the&#160;enumerator&#160;library.&#160;Create&#160;an&#160;Enumerator&#160;with&#160;to_enum&#160;or&#160;its&#160;alias<br/>enum_for, or simply by calling an iterator method without the block it expects:<br/>
e = [1..10].to_enum &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Uses Range.each<br/>e = &#34;test&#34;.enum_for(:each_byte) &#160;# Uses String.each_byte<br/>e = &#34;test&#34;.each_byte &#160; &#160; &#160; &#160; &#160; &#160; # Uses String.each_byte<br/>
Enumerator&#160;objects&#160;are&#160;Enumerable&#160;objects&#160;with&#160;an&#160;each&#160;method&#160;that&#160;is&#160;based&#160;on&#160;some<br/>other&#160;&#160;iterator&#160;&#160;method&#160;&#160;of&#160;&#160;some&#160;&#160;other&#160;&#160;object.&#160;&#160;In&#160;&#160;addition&#160;&#160;to&#160;&#160;being&#160;&#160;Enumerable&#160;&#160;proxy<br/>objects,&#160;an&#160;enumerator&#160;also&#160;behaves&#160;as&#160;an&#160;external&#160;iterator.&#160;To&#160;obtain&#160;the&#160;elements&#160;of<br/>a&#160;&#160;collection&#160;&#160;using&#160;&#160;an&#160;&#160;external&#160;&#160;iterator,&#160;&#160;simply&#160;&#160;call&#160;&#160;next&#160;&#160;repeatedly&#160;&#160;until&#160;&#160;it&#160;&#160;raises<br/>StopIteration.&#160;The&#160;Kernel.loop&#160;iterator&#160;rescues&#160;StopIteration&#160;for&#160;you.&#160;After&#160;next&#160;raises<br/>StopIteration,&#160;a&#160;subsequent&#160;call&#160;will&#160;typically&#160;begin&#160;a&#160;new&#160;iteration,&#160;assuming&#160;the&#160;un-<br/>derlying iterator method allows repeated iterations (iterators reading from a file don’t<br/>allow&#160;that,&#160;for&#160;example).&#160;If&#160;repeated&#160;iterations&#160;are&#160;possible,&#160;you&#160;can&#160;restart&#160;an&#160;external<br/>iterator before&#160;StopIteration&#160;has been raised by calling&#160;rewind:<br/>
&#34;Ruby&#34;.each_char.max &#160; &#160; &#160; # =&gt; &#34;y&#34;; Enumerable method of Enumerator<br/>iter = &#34;Ruby&#34;.each_char &#160; &#160;# Create an Enumerator<br/>loop { print iter.next } &#160; # Prints &#34;Ruby&#34;; use it as external iterator<br/>print iter.next &#160; &#160; &#160; &#160; &#160; &#160;# Prints &#34;R&#34;: iterator restarts automatically<br/>iter.rewind &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Force it to restart now<br/>print iter.next &#160; &#160; &#160; &#160; &#160; &#160;# Prints &#34;R&#34; again<br/>
Given any enumerator&#160;e, you can obtain a new enumerator with&#160;e.with_index. As&#160;the<br/>name&#160;implies,&#160;this&#160;new&#160;enumerator&#160;yields&#160;an&#160;index&#160;(or&#160;iteration&#160;number)&#160;along&#160;with<br/>whatever value the original iterator would yield:<br/>
# Print &#34;0:R\n1:u\n2:b\n3:y\n&#34;<br/>&#34;Ruby&#34;.each_char.with_index.each {|c,i| puts &#34;#{i}:#{c} }<br/>
Finally,&#160;note&#160;that&#160;enumerators,&#160;like&#160;all&#160;Enumerable&#160;objects,&#160;are&#160;<i>splattable</i>:&#160;you&#160;can&#160;prefix<br/>an&#160;enumerator&#160;with&#160;an&#160;asterisk&#160;to&#160;expand&#160;it&#160;into&#160;individual&#160;values&#160;for&#160;method&#160;invoca-<br/>tion or parallel assignment.<br/>
<b>9.5.1.3 &#160;Sorting collections<br/></b>One of the most important methods&#160;of&#160;Enumerable&#160;is&#160;sort. It converts the enumerable<br/>collection&#160;to&#160;an&#160;array&#160;and&#160;sorts&#160;the&#160;elements&#160;of&#160;that&#160;array.&#160;By&#160;default,&#160;the&#160;sort&#160;is&#160;done<br/>according&#160;to&#160;the&#160;&lt;=&gt;&#160;method&#160;of&#160;the&#160;elements.&#160;If&#160;a&#160;block&#160;is&#160;provided,&#160;however,&#160;then&#160;it&#160;is<br/>passed pairs of elements and should return&#160;–1,&#160;0, or&#160;+1&#160;to indicate their relative order:<br/>
<b>330&#160;|&#160;Chapter 9:</b> <b>The Ruby Platform</b><br/>
<hr/>
<a name=345></a>w = Set['apple','Beet','carrot'] &#160;# A set of words to sort<br/>w.sort &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # ['Beet','apple','carrot']: alphabetical<br/>w.sort {|a,b| b&lt;=&gt;a } &#160; &#160; &#160; &#160; &#160;# ['carrot','apple','Beet']: reverse<br/>w.sort {|a,b| a.casecmp(b) } &#160; # ['apple','Beet','carrot']: ignore case<br/>w.sort {|a,b| b.size&lt;=&gt;a.size} # ['carrot','apple','Beet']: reverse length<br/>
If&#160;the&#160;block&#160;you&#160;associate&#160;with&#160;sort&#160;must&#160;do&#160;substantial&#160;computation&#160;in&#160;order&#160;to&#160;per-<br/>form&#160;&#160;its&#160;&#160;comparison,&#160;&#160;then&#160;&#160;it&#160;&#160;is&#160;&#160;more&#160;&#160;efficient&#160;&#160;to&#160;&#160;use&#160;&#160;sort_by&#160;&#160;instead.&#160;&#160;The&#160;&#160;block<br/>associated&#160;&#160;with&#160;&#160;sort_by&#160;&#160;will&#160;&#160;be&#160;&#160;called&#160;&#160;once&#160;&#160;for&#160;&#160;each&#160;&#160;element&#160;&#160;in&#160;&#160;the&#160;&#160;collection,&#160;&#160;and<br/>should&#160;return&#160;a&#160;numeric&#160;“sort&#160;key”&#160;for&#160;that&#160;element.&#160;The&#160;collection&#160;will&#160;then&#160;be&#160;sorted<br/>by&#160;ascending&#160;order&#160;of&#160;the&#160;sort&#160;key.&#160;This&#160;way,&#160;a&#160;sort&#160;key&#160;is&#160;only&#160;computed&#160;once&#160;for&#160;each<br/>element, rather than twice for each comparison:<br/>
# Case-insensitive sort<br/>words = ['carrot', 'Beet', 'apple']<br/>words.sort_by {|x| x.downcase} &#160; &#160; &#160; # =&gt; ['apple', 'Beet', 'carrot']<br/>
<b>9.5.1.4 &#160;Searching collections<br/></b>Enumerable&#160;defines&#160;several&#160;methods&#160;for&#160;searching&#160;for&#160;single&#160;elements&#160;within&#160;a&#160;collection.<br/>include?&#160;&#160;and&#160;&#160;its&#160;&#160;synonym&#160;&#160;member?&#160;&#160;search&#160;&#160;for&#160;&#160;an&#160;&#160;element&#160;&#160;equal&#160;&#160;to&#160;&#160;(using&#160;&#160;==)&#160;&#160;their<br/>argument:<br/>
primes = Set[2, 3, 5, 7]<br/>primes.include? 2 &#160; &#160; &#160; &#160;# =&gt; true<br/>primes.member? 1 &#160; &#160; &#160; &#160; # =&gt; false<br/>
The&#160;find&#160;method,&#160;and&#160;its&#160;synonym&#160;detect,&#160;apply&#160;the&#160;associated&#160;block&#160;to&#160;each&#160;element<br/>of&#160;the&#160;collection&#160;in&#160;turn.&#160;If&#160;the&#160;block&#160;returns&#160;anything&#160;other&#160;than&#160;false&#160;or&#160;nil,&#160;then<br/>find&#160;returns that element and stops iterating. If the block always returns&#160;nil&#160;or&#160;false,<br/>then&#160;find&#160;returns&#160;nil:<br/>
# Find the first subarray that includes the number 1<br/>data = [[1,2], [0,1], [7,8]]<br/>data.find {|x| x.include? 1} &#160; &#160; # =&gt; [1,2]<br/>data.detect {|x| x.include? 3} &#160; # =&gt; nil: no such element<br/>
The&#160;find_index&#160;method&#160;(new&#160;in&#160;Ruby&#160;1.9)&#160;&#160;is&#160;like&#160;the&#160;index&#160;method&#160;of&#160;Array:&#160;it&#160;returns<br/>the index of a specific element or of the first element that matches a block:<br/>
data.find_index [0,1] &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; 1: the second element matches<br/>data.find_index {|x| x.include? 1} # =&gt; 0: the first element matches<br/>data.find_index {|x| x.include? 3} # =&gt; nil: no such element<br/>
Note&#160;that&#160;the&#160;return&#160;value&#160;of&#160;find_index&#160;is&#160;not&#160;terribly&#160;useful&#160;for&#160;collections&#160;like&#160;hashes<br/>and sets that do not use numeric indexes.<br/>
Enumerable&#160;defines other searching methods that return a collection of matches rather<br/>than a single match. We cover these methods in the next section.<br/>
<b>9.5 &#160;Collections&#160;|&#160;331</b><br/>
<hr/>
<a name=346></a><b>9.5.1.5 &#160;Selecting subcollections<br/></b>The&#160;select&#160;method&#160;selects&#160;and&#160;returns&#160;elements&#160;of&#160;a&#160;collection&#160;for&#160;which&#160;a&#160;block&#160;returns<br/>a non-nil, non-false&#160;value.&#160;A&#160;synonym&#160;for&#160;this&#160;method&#160;is&#160;find_all;&#160;it&#160;works&#160;like&#160;the<br/>find&#160;method but returns an array of all matching elements:<br/>
(1..8).select {|x| x%2==0} &#160; &#160;# =&gt; [2,4,6,8]: select even elements<br/>(1..8).find_all {|x| x%2==1} &#160;# =&gt; [1,3,5,7]: find all odd elements<br/>
reject&#160;is&#160;the&#160;opposite&#160;of&#160;select;&#160;the&#160;elements&#160;in&#160;the&#160;returned&#160;array&#160;are&#160;those&#160;for&#160;which<br/>the block returns&#160;false&#160;or&#160;nil.<br/>
primes = [2,3,5,7]<br/>primes.reject {|x| x%2==0} &#160;# =&gt; [3,5,7]: reject the even ones<br/>
If&#160;you&#160;want&#160;both&#160;to&#160;select&#160;and&#160;reject&#160;elements&#160;of&#160;a&#160;collection,&#160;use&#160;partition. It returns<br/>an&#160;array&#160;of&#160;two&#160;arrays.&#160;The&#160;first&#160;subarray&#160;holds&#160;elements&#160;for&#160;which&#160;the&#160;block&#160;is&#160;true,<br/>and the second subarray holds elements for which the block is false:<br/>
(1..8).partition {|x| x%2==0} &#160;# =&gt; [[2, 4, 6, 8], [1, 3, 5, 7]]<br/>
The&#160;group_by&#160;method&#160;of&#160;Ruby&#160;1.9&#160;is&#160;a&#160;generalization&#160;of&#160;partition.&#160;Rather&#160;than&#160;treating<br/>the&#160;block&#160;as&#160;a&#160;predicate&#160;and&#160;returning&#160;two&#160;groups,&#160;group_by&#160;takes&#160;the&#160;return&#160;value&#160;of<br/>the&#160;block&#160;and&#160;uses&#160;it&#160;as&#160;a&#160;hash&#160;key.&#160;It&#160;maps&#160;that&#160;key&#160;to&#160;an&#160;array&#160;of&#160;all&#160;collection&#160;elements<br/>for which the block returned that value. For example:<br/>
# Group programming languages by their first letter<br/>langs = %w[ java perl python ruby ]<br/>groups = langs.group_by {|lang| lang[0] }<br/>groups # =&gt; {&#34;j&#34;=&gt;[&#34;java&#34;], &#34;p&#34;=&gt;[&#34;perl&#34;, &#34;python&#34;], &#34;r&#34;=&gt;[&#34;ruby&#34;]}<br/>
grep&#160;returns&#160;an&#160;array&#160;of&#160;elements&#160;that&#160;match&#160;the&#160;argument&#160;value,&#160;determining&#160;matching<br/>with&#160;&#160;the&#160;&#160;case&#160;&#160;equality&#160;&#160;operator&#160;&#160;(===)&#160;&#160;of&#160;&#160;the&#160;&#160;argument.&#160;&#160;When&#160;&#160;used&#160;&#160;with&#160;&#160;a&#160;&#160;regular<br/>expression argument, this method works like the Unix command-line utility&#160;<i>grep</i>. If a<br/>block&#160;is&#160;associated&#160;with&#160;the&#160;call,&#160;it&#160;is&#160;used&#160;to&#160;process&#160;matching&#160;elements,&#160;as&#160;if&#160;collect<br/>or&#160;map&#160;were called on the results of&#160;grep:<br/>
langs = %w[ java perl python ruby ]<br/>langs.grep(/^p/) &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; [perl, python]: start with 'p'<br/>langs.grep(/^p/) {|x| x.capitalize} # =&gt; [Perl, Python]: fix caps<br/>data = [1, 17, 3.0, 4]<br/>ints = data.grep(Integer) &#160; &#160; &#160; &#160; &#160; # =&gt; [1, 17, 4]: only integers<br/>small = ints.grep(0..9) &#160; &#160; &#160; &#160; &#160; &#160; # [1,4]: only in range<br/>
In&#160;Ruby&#160;1.9,&#160;the&#160;selection&#160;methods&#160;described&#160;previously&#160;are&#160;augmented&#160;by&#160;first,&#160;take,<br/>drop,&#160;take_while, and&#160;drop_while.&#160;first&#160;returns the first element of an&#160;Enumerable&#160;ob-<br/>ject,&#160;or,&#160;given&#160;an&#160;integer&#160;argument&#160;<i>n</i>,&#160;an&#160;array&#160;containing&#160;the&#160;first&#160;<i>n</i>&#160;elements.&#160;take&#160;and<br/>drop&#160;expect&#160;an&#160;integer&#160;argument.&#160;take&#160;behaves&#160;just&#160;like&#160;first;&#160;it&#160;returns&#160;an&#160;array&#160;of&#160;the<br/>first&#160;<i>n</i>&#160;elements of the&#160;Enumerable&#160;receiver object.&#160;drop&#160;does the opposite; it returns an<br/>array of all elements of the&#160;Enumerable&#160;except for the first&#160;<i>n</i>:<br/>
p (1..5).first(2) &#160; &#160; &#160;# =&gt; [1,2]<br/>p (1..5).take(3) &#160; &#160; &#160; # =&gt; [1,2,3]<br/>p (1..5).drop(3) &#160; &#160; &#160; # =&gt; [4,5]<br/>
<b>332&#160;|&#160;Chapter 9:</b> <b>The Ruby Platform</b><br/>
<hr/>
<a name=347></a>take_while&#160;and&#160;drop_while&#160;expect&#160;a&#160;block&#160;instead&#160;of&#160;an&#160;integer&#160;argument.&#160;take_while<br/>passes&#160;elements&#160;of&#160;the&#160;Enumerable&#160;object&#160;to&#160;the&#160;block&#160;in&#160;turn,&#160;until&#160;the&#160;block&#160;returns<br/>false&#160;or&#160;nil&#160;for&#160;the&#160;first&#160;time.&#160;Then&#160;it&#160;returns&#160;an&#160;array&#160;of&#160;the&#160;previous&#160;elements&#160;for<br/>which&#160;the&#160;block&#160;returned&#160;true.&#160;drop&#160;also&#160;passes&#160;elements&#160;to&#160;the&#160;block&#160;in&#160;turn&#160;until&#160;the<br/>block&#160;&#160;returns&#160;&#160;false&#160;&#160;or&#160;&#160;nil&#160;&#160;for&#160;&#160;the&#160;&#160;first&#160;&#160;time.&#160;&#160;Then,&#160;&#160;however,&#160;&#160;it&#160;&#160;returns&#160;&#160;an&#160;&#160;array<br/>containing&#160;the&#160;element&#160;for&#160;which&#160;the&#160;block&#160;returned&#160;false&#160;and&#160;all&#160;subsequent&#160;elements:<br/>
[1,2,3,nil,4].take_while {|x| x } &#160;# =&gt; [1,2,3]: take until nil<br/>[nil, 1, 2].drop_while {|x| !x } &#160; # =&gt; [1,2]: drop leading nils<br/>
The&#160;Array&#160;class&#160;defines&#160;its&#160;own&#160;efficient&#160;versions&#160;of&#160;these&#160;taking&#160;and&#160;dropping&#160;methods<br/>that do not require arrays to be iterated with&#160;each.<br/>
<b>9.5.1.6 &#160;Reducing collections<br/></b>Sometimes we want to&#160;<i>reduce</i>&#160;an&#160;enumerable&#160;collection&#160;to&#160;a&#160;single&#160;value&#160;that&#160;captures<br/>some&#160;property&#160;of&#160;the&#160;collection.&#160;min&#160;and&#160;max&#160;are&#160;&#160;methods&#160;that&#160;perform&#160;a&#160;reduction,<br/>returning&#160;the&#160;smallest&#160;or&#160;largest&#160;element&#160;of&#160;the&#160;collection&#160;(assuming&#160;that&#160;the&#160;elements<br/>are mutually comparable with&#160;&lt;=&gt;):<br/>
[10, 100, 1].min &#160; &#160;# =&gt; 1<br/>['a','c','b'].max &#160; # =&gt; 'c'<br/>[10, 'a', []].min &#160; # =&gt; ArgumentError: elements not comparable<br/>
min&#160;and&#160;max&#160;can&#160;take&#160;a&#160;block&#160;like&#160;sort&#160;can,&#160;to&#160;compare&#160;two&#160;elements.&#160;In&#160;Ruby&#160;1.9,&#160;it&#160;is<br/>easier to use&#160;min_by&#160;and&#160;max_by&#160;instead:<br/>
langs = %w[java perl python ruby] &#160; &#160;# Which has the longest name?<br/>langs.max {|a,b| a.size &lt;=&gt; b.size } # =&gt; &#34;python&#34;: block compares 2<br/>langs.max_by {|word| word.length } &#160; # =&gt; &#34;python&#34;: Ruby 1.9 only<br/>
Ruby&#160;1.9&#160;also&#160;defines&#160;minmax&#160;and&#160;minmax_by,&#160;which&#160;compute&#160;both&#160;the&#160;minimum&#160;and<br/>maximum value of a collection and return them as a two-element array&#160;[min,max]:<br/>
(1..100).minmax &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; [1,100] min, max as numbers<br/>(1..100).minmax_by {|n| n.to_s } &#160;# =&gt; [1,99] &#160;min, max as strings<br/>
any?&#160;andall?&#160;are&#160;predicates&#160;that&#160;also&#160;perform&#160;reductions.&#160;They&#160;apply&#160;a&#160;predicate&#160;block<br/>to&#160;elements&#160;of&#160;the&#160;collection.&#160;all?&#160;returns&#160;true&#160;if&#160;the&#160;predicate&#160;is&#160;true&#160;(that&#160;is,&#160;not&#160;nil<br/>and&#160;not&#160;false)&#160;for&#160;<i>all</i>&#160;elements&#160;of&#160;the&#160;collection.&#160;any?&#160;returns&#160;true&#160;if&#160;the&#160;predicate&#160;is<br/>true&#160;for&#160;any&#160;one&#160;of&#160;the&#160;elements.&#160;In&#160;Ruby&#160;1.9,&#160;none?&#160;returns&#160;true&#160;only&#160;if&#160;the&#160;predicate<br/>never&#160;returns&#160;a&#160;true&#160;value.&#160;Also&#160;in&#160;1.9,&#160;one?&#160;returns&#160;true&#160;only&#160;if&#160;the&#160;predicate&#160;returns&#160;a<br/>true&#160;value&#160;for&#160;one,&#160;and&#160;only&#160;one,&#160;element&#160;of&#160;the&#160;collection.&#160;Invoked&#160;without&#160;blocks,<br/>these methods simply test the elements of the collection themselves:<br/>
c = -2..2<br/>c.all? {|x| x&gt;0} &#160; &#160;# =&gt; false: not all values are &gt; 0<br/>c.any? {|x| x&gt;0} &#160; &#160;# =&gt; true: some values are &gt; 0<br/>c.none? {|x| x&gt;2} &#160; # =&gt; true: no values are &gt; 2<br/>c.one? {|x| x&gt;0} &#160; &#160;# =&gt; false: more than one value is &gt; 0<br/>c.one? {|x| x&gt;2} &#160; &#160;# =&gt; false: no values are &gt; 2<br/>c.one? {|x| x==2} &#160; # =&gt; true: one value == 2<br/>[1, 2, 3].all? &#160; &#160; &#160;# =&gt; true: no values are nil or false<br/>
<b>9.5 &#160;Collections&#160;|&#160;333</b><br/>
<hr/>
<a name=348></a>[nil, false].any? &#160; # =&gt; false: no true values<br/>[].none? &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; true: no non-false, non-nil values &#160; &#160;<br/>
Another&#160;Ruby&#160;1.9&#160;addition&#160;is&#160;the&#160;count&#160;method:&#160;it&#160;returns&#160;the&#160;number&#160;of&#160;elements&#160;in<br/>the&#160;collection&#160;that&#160;equal&#160;a&#160;specified&#160;value,&#160;or&#160;the&#160;number&#160;for&#160;which&#160;an&#160;associated&#160;block<br/>returns&#160;true:<br/>
a = [1,1,2,3,5,8]<br/>a.count(1) &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; 2: two elements equal 1<br/>a.count {|x| x % 2 == 1} &#160;# =&gt; 4: four elements are odd<br/>
Finally,&#160;inject&#160;is&#160;a&#160;general&#160;purpose&#160;method&#160;for&#160;reducing&#160;a&#160;collection.&#160;Ruby&#160;1.9&#160;defines<br/>reduce&#160;as&#160;an&#160;alias&#160;for&#160;inject.&#160;The&#160;block&#160;associated&#160;with&#160;a&#160;call&#160;to&#160;inject&#160;expects&#160;two<br/>arguments.&#160;The&#160;first&#160;is&#160;an&#160;accumulated&#160;value;&#160;the&#160;second&#160;is&#160;an&#160;element&#160;from&#160;the&#160;col-<br/>lection.&#160;&#160;The&#160;&#160;accumulated&#160;&#160;value&#160;&#160;for&#160;&#160;the&#160;&#160;first&#160;&#160;iteration&#160;&#160;is&#160;&#160;the&#160;&#160;argument&#160;&#160;passed&#160;&#160;to<br/>inject.&#160;The&#160;block&#160;return&#160;value&#160;on&#160;one&#160;iteration&#160;becomes&#160;the&#160;accumulated&#160;value&#160;for&#160;the<br/>next&#160;iteration.&#160;The&#160;return&#160;value&#160;after&#160;the&#160;last&#160;iteration&#160;becomes&#160;the&#160;return&#160;value&#160;of<br/>inject. Here are some examples:<br/>
# How many negative numbers?<br/>(-2..10).inject(0) {|num, x| x&lt;0 ? num+1 : num } &#160;# =&gt; 2<br/>
# Sum of word lengths<br/>%w[pea queue are].inject(0) {|total, word| total + word.length } &#160;# =&gt; 11<br/>
If&#160;no&#160;argument&#160;is&#160;passed&#160;to&#160;inject,&#160;then&#160;the&#160;first&#160;time&#160;the&#160;block&#160;is&#160;invoked,&#160;it&#160;is&#160;passed<br/>the&#160;first&#160;two&#160;elements&#160;of&#160;the&#160;collection.&#160;(Or,&#160;if&#160;there&#160;is&#160;only&#160;one&#160;element&#160;in&#160;the&#160;collection,<br/>inject&#160;&#160;simply&#160;&#160;returns&#160;&#160;that&#160;&#160;element.)&#160;&#160;This&#160;&#160;form&#160;&#160;of&#160;&#160;inject&#160;&#160;is&#160;&#160;useful&#160;&#160;for&#160;&#160;a&#160;&#160;number&#160;&#160;of<br/>common operations:<br/>
sum = (1..5).inject {|total,x| total + x} &#160;# =&gt; 15<br/>prod = (1..5).inject {|total,x| total * x} # =&gt; 120<br/>max = [1,3,2].inject {|m,x| m&gt;x ? m : x} &#160; # =&gt; 3<br/>[1].inject {|total,x| total + x} &#160; &#160; &#160; &#160; &#160; # =&gt; 1: block never called<br/>
In&#160;Ruby&#160;1.9,&#160;you&#160;can&#160;pass&#160;a&#160;symbol&#160;that&#160;names&#160;a&#160;method&#160;(or&#160;operator)&#160;to&#160;inject&#160;instead<br/>of&#160;specifying&#160;a&#160;block.&#160;Each&#160;element&#160;in&#160;the&#160;collection&#160;will&#160;be&#160;passed&#160;to&#160;the&#160;named&#160;method<br/>of&#160;the&#160;accumulated&#160;value,&#160;and&#160;its&#160;result&#160;will&#160;become&#160;the&#160;new&#160;accumulated&#160;value.&#160;It&#160;is<br/>common to use the&#160;reduce&#160;synonym&#160;when&#160;invoking&#160;the&#160;method&#160;with&#160;a&#160;symbol&#160;in&#160;this<br/>way:<br/>
sum = (1..5).reduce(:+) &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; 15<br/>prod = (1..5).reduce(:*) &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; 120<br/>letters = ('a'..'e').reduce(&#34;-&#34;, :concat) &#160;# =&gt; &#34;-abcde&#34;<br/>
<b>9.5.2 &#160;Arrays<br/></b>Arrays&#160;are&#160;probably&#160;the&#160;most&#160;fundamental&#160;and&#160;commonly&#160;used&#160;data&#160;structure&#160;in&#160;Ruby<br/>programming.&#160;We&#160;covered&#160;array&#160;literals&#160;and&#160;indexing&#160;operators&#160;in&#160;<a href="Rubys.html#78">§3.3.&#160;</a>This&#160;section<br/>builds&#160;on&#160;that&#160;earlier&#160;one,&#160;demonstrating&#160;the&#160;rich&#160;API&#160;implemented&#160;by&#160;the&#160;Array&#160;class.<br/>
<b>334&#160;|&#160;Chapter 9:</b> <b>The Ruby Platform</b><br/>
<hr/>
<a name=349></a><b>9.5.2.1 &#160;Creating arrays<br/></b>Arrays&#160;can&#160;be&#160;created&#160;with&#160;array&#160;literals,&#160;or&#160;with&#160;the&#160;classmethod&#160;Array.new&#160;or&#160;the&#160;class<br/>operator&#160;Array.[]. Examples:<br/>
[1,2,3] &#160; &#160; &#160; &#160; &#160; &#160; # Basic array literal<br/>[] &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# An empty array<br/>[] &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Arrays are mutable: this empty array is different<br/>%w[a b c] &#160; &#160; &#160; &#160; &#160; # =&gt; ['a', 'b', 'c']: array of words<br/>Array[1,2,3] &#160; &#160; &#160; &#160;# =&gt; [1,2,3]: just like an array literal<br/>
# Creating arrays with the new() method<br/>empty = Array.new &#160; &#160; &#160; &#160; &#160; &#160; # []: returns a new empty array<br/>nils = Array.new(3) &#160; &#160; &#160; &#160; &#160; # [nil, nil, nil]: three nil elements<br/>copy = Array.new(nils) &#160; &#160; &#160; &#160;# Make a new copy of an existing array<br/>zeros = Array.new(4, 0) &#160; &#160; &#160; # [0, 0, 0, 0]: four 0 elements<br/>count = Array.new(3){|i| i+1} # [1,2,3]: three elements computed by block<br/>
# Be careful with repeated objects<br/>a=Array.new(3,'a') &#160;# =&gt; ['a','a','a']: three references to the same string<br/>a[0].upcase! &#160; &#160; &#160; &#160;# Capitalize the first element of the array<br/>a &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; ['A','A','A']: they are all the same string!<br/>a=Array.new(3){'b'} # =&gt; ['b','b','b']: three distinct string objects<br/>a[0].upcase!; &#160; &#160; &#160; # Capitalize the first one<br/>a &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; ['B','b','b']: the others are still lowercase<br/>
In&#160;addition&#160;to&#160;the&#160;Array&#160;factory&#160;methods,&#160;a&#160;number&#160;of&#160;other&#160;classes&#160;define&#160;to_a&#160;methods<br/>that&#160;return&#160;arrays.&#160;In&#160;particular,&#160;any&#160;Enumerable&#160;object,&#160;such&#160;as&#160;a&#160;Range&#160;or&#160;Hash, can be<br/>converted&#160;to&#160;an&#160;array&#160;with&#160;to_a.&#160;Also,&#160;array&#160;operators,&#160;such&#160;as&#160;+,&#160;and&#160;many&#160;array&#160;meth-<br/>ods,&#160;such&#160;as&#160;slice,&#160;create&#160;and&#160;return&#160;new&#160;arrays&#160;rather&#160;than&#160;altering&#160;the&#160;receiving&#160;array<br/>in place.<br/>
<b>9.5.2.2 &#160;Array size and elements<br/></b>The following code&#160;shows&#160;how&#160;to&#160;determine&#160;the&#160;length&#160;of&#160;an&#160;array,&#160;and&#160;demonstrates<br/>a variety of ways to extract elements and subarrays from an array:<br/>
# Array length<br/>[1,2,3].length &#160; &#160; # =&gt; 3<br/>[].size &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; 0: synonym for length<br/>[].empty? &#160; &#160; &#160; &#160; &#160;# =&gt; true<br/>[nil].empty? &#160; &#160; &#160; # =&gt; false<br/>[1,2,nil].nitems &#160; # =&gt; 2: number of non-nil elements (Ruby 1.8 only)<br/>[1,2,nil].count(nil) &#160; &#160;# =&gt; 1: # of nils (Enumerable method in Ruby 1.9)<br/>[1,2,3].count {|x| x&gt;2} # =&gt; 1: # of elts matching block (Ruby 1.9)<br/>
# Indexing single elements<br/>a = %w[a b c d] &#160; &#160;# =&gt; ['a', 'b', 'c', 'd']<br/>a[0] &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; 'a': first element<br/>a[-1] &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; 'd': last element<br/>a[a.size-1] &#160; &#160; &#160; &#160;# =&gt; 'd': last element<br/>a[-a.size] &#160; &#160; &#160; &#160; # =&gt; 'a': first element<br/>a[5] &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; nil: no such element<br/>a[-5] &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; nil: no such element<br/>
<b>9.5 &#160;Collections&#160;|&#160;335</b><br/>
<hr/>
<a name=350></a>a.at(2) &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; 'c': just like [] for single integer argument<br/>a.fetch(1) &#160; &#160; &#160; &#160; # =&gt; 'b': also like [] and at<br/>a.fetch(-1) &#160; &#160; &#160; &#160;# =&gt; 'd': works with negative args<br/>a.fetch(5) &#160; &#160; &#160; &#160; # =&gt; IndexError!: does not allow out-of-bounds<br/>a.fetch(-5) &#160; &#160; &#160; &#160;# =&gt; IndexError!: does not allow out-of-bounds<br/>a.fetch(5, 0) &#160; &#160; &#160;# =&gt; 0: return 2nd arg when out-of-bounds<br/>a.fetch(5){|x|x*x} # =&gt; 25: compute value when out-of-bounds<br/>a.first &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; 'a': the first element<br/>a.last &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; 'd': the last element<br/>a.sample &#160; &#160; &#160; &#160; &#160; # Ruby 1.9: return one element at random<br/>a.sample(n) &#160; &#160; &#160; &#160;# Ruby 1.9: return array of n random elements<br/>
# Indexing subarrays<br/>a[0,2] &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; ['a','b']: two elements, starting at 0<br/>a[0..2] &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; ['a','b','c']: elements with index in range<br/>a[0...2] &#160; &#160; &#160; &#160; &#160; # =&gt; ['a','b']: three dots instead of two<br/>a[1,1] &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; ['b']: single element, as an array<br/>a[-2,2] &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; ['c','d']: last two elements<br/>a[4,2] &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; []: empty array right at the end&#160;<br/>a[5,1] &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; nil: nothing beyond that<br/>a.slice(0..1) &#160; &#160; &#160;# =&gt; ['a','b']: slice is synonym for []<br/>a.first(3) &#160; &#160; &#160; &#160; # =&gt; ['a','b','c']: first three elements<br/>a.last(1) &#160; &#160; &#160; &#160; &#160;# =&gt; ['d']: last element as an array<br/>
# Extracting arbitrary values<br/>a.values_at(0,2) &#160; &#160; &#160; &#160; # =&gt; ['a','c']<br/>a.values_at(4, 3, 2, 1) &#160;# =&gt; [nil, 'd','c','b']<br/>a.values_at(0, 2..3, -1) # =&gt; ['a','c','d','d']<br/>a.values_at(0..2,1..3) &#160; # =&gt; ['a','b','c','b','c','d']<br/>
<b>9.5.2.3 &#160;Altering array elements<br/></b>The&#160;following&#160;code&#160;demonstrates&#160;how&#160;to&#160;change&#160;the&#160;value&#160;of&#160;individual&#160;array&#160;elements,<br/>insert&#160;values&#160;into&#160;an&#160;array,&#160;delete&#160;values&#160;from&#160;an&#160;array,&#160;and&#160;replace&#160;values&#160;with&#160;other<br/>values:<br/>
a = [1,2,3] &#160; &#160; &#160; &#160;# Start with this array<br/># Changing the value of elements<br/>a[0] = 0 &#160; &#160; &#160; &#160; &#160; # Alter an existing element: a is [0,2,3]<br/>a[-1] = 4 &#160; &#160; &#160; &#160; &#160;# Alter the last element: a is [0,2,4]<br/>a[1] = nil &#160; &#160; &#160; &#160; # Set the 2nd element to nil: a is [0,nil,4]<br/>
# Appending to an array<br/>a = [1,2,3] &#160; &#160; &#160; &#160;# Start over with this array<br/>a[3] = 4 &#160; &#160; &#160; &#160; &#160; # Add a fourth element to it: a is [1,2,3,4]<br/>a[5] = 6 &#160; &#160; &#160; &#160; &#160; # We can skip elements: a is [1,2,3,4,nil,6]<br/>a &lt;&lt; 7 &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; [1,2,3,4,nil,6,7]<br/>a &lt;&lt; 8 &lt;&lt; 9 &#160; &#160; &#160; &#160;# =&gt; [1,2,3,4,nil,6,7,8,9] operator is chainable<br/>a = [1,2,3] &#160; &#160; &#160; &#160;# Start over with short array<br/>a + a &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; [1,2,3,1,2,3]: + concatenates into new array<br/>a.concat([4,5]) &#160; &#160;# =&gt; [1,2,3,4,5]: alter a in place: note no !<br/>
# Inserting elements with insert<br/>a = ['a', 'b', 'c']<br/>a.insert(1, 1, 2) &#160;# a now holds ['a',1,2,'b','c']. Like a[1,0] = [1,2]<br/>
<b>336&#160;|&#160;Chapter 9:</b> <b>The Ruby Platform</b><br/>
<hr/>
<a name=351></a># Removing (and returning) individual elements by index<br/>a = [1,2,3,4,5,6]<br/>a.delete_at(4) &#160; &#160; # =&gt; 5: a is now [1,2,3,4,6]<br/>a.delete_at(-1) &#160; &#160;# =&gt; 6: a is now [1,2,3,4]<br/>a.delete_at(4) &#160; &#160; # =&gt; nil: a is unchanged<br/>
# Removing elements by value<br/>a.delete(4) &#160; &#160; &#160; &#160;# =&gt; 4: a is [1,2,3]<br/>a[1] = 1 &#160; &#160; &#160; &#160; &#160; # a is now [1,1,3]<br/>a.delete(1) &#160; &#160; &#160; &#160;# =&gt; 1: a is now [3]: both 1s removed<br/>a = [1,2,3]<br/>a.delete_if {|x| x%2==1} # Remove odd values: a is now [2]<br/>a.reject! {|x| x%2==0} &#160; # Like delete_if: a is now []<br/>&#160;<br/># Removing elements and subarrays with slice!<br/>a = [1,2,3,4,5,6,7,8]<br/>a.slice!(0) &#160; &#160; &#160; &#160;# =&gt; 1: remove element 0: a is [2,3,4,5,6,7,8]<br/>a.slice!(-1,1) &#160; &#160; # =&gt; [8]: remove subarray at end: a is [2,3,4,5,6,7]<br/>a.slice!(2..3) &#160; &#160; # =&gt; [4,5]: works with ranges: a is [2,3,6,7]<br/>a.slice!(4,2) &#160; &#160; &#160;# =&gt; []: empty array just past end: a unchanged<br/>a.slice!(5,2) &#160; &#160; &#160;# =&gt; nil: a now holds [2,3,6,7,nil]!<br/>
# Replacing subarrays with []=<br/># To delete, assign an empty array<br/># To insert, assign to a zero-width slice<br/>a = ('a'..'e').to_a &#160; &#160;# =&gt; ['a','b','c','d','e']<br/>a[0,2] = ['A','B'] &#160; &#160; # a now holds ['A', 'B', 'c', 'd', 'e']<br/>a[2...5]=['C','D','E'] # a now holds ['A', 'B', 'C', 'D', 'E']<br/>a[0,0] = [1,2,3] &#160; &#160; &#160; # Insert elements at the beginning of a<br/>a[0..2] = [] &#160; &#160; &#160; &#160; &#160; # Delete those elements<br/>a[-1,1] = ['Z'] &#160; &#160; &#160; &#160;# Replace last element with another<br/>a[-1,1] = 'Z' &#160; &#160; &#160; &#160; &#160;# For single elements, the array is optional<br/>a[1,4] = nil &#160; &#160; &#160; &#160; &#160; # Ruby 1.9: a now holds ['A',nil]<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Ruby 1.8: a now holds ['A']: nil works like []<br/>
# Other methods<br/>a = [4,5]<br/>a.replace([1,2,3]) &#160; &#160; # a now holds [1,2,3]: a copy of its argument<br/>a.fill(0) &#160; &#160; &#160; &#160; &#160; &#160; &#160;# a now holds [0,0,0]<br/>a.fill(nil,1,3) &#160; &#160; &#160; &#160;# a now holds [0,nil,nil,nil]<br/>a.fill('a',2..4) &#160; &#160; &#160; # a now holds [0,nil,'a','a','a']<br/>a[3].upcase! &#160; &#160; &#160; &#160; &#160; # a now holds [0,nil,'A','A','A']<br/>a.fill(2..4) { 'b' } &#160; # a now holds [0,nil,'b','b','b']<br/>a[3].upcase! &#160; &#160; &#160; &#160; &#160; # a now holds [0,nil,'b','B','b']<br/>a.compact &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; [0,'b','B','b']: copy with nils removed<br/>a.compact! &#160; &#160; &#160; &#160; &#160; &#160; # Remove nils in place: a now holds [0,'b','B','b']<br/>a.clear &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# a now holds []<br/>
<b>9.5.2.4 &#160;Iterating, searching, and sorting arrays<br/></b>Array&#160;mixes&#160;in&#160;the&#160;Enumerable&#160;module,&#160;so&#160;all&#160;of&#160;the&#160;Enumerable&#160;iterators&#160;are&#160;available.<br/>In&#160;addition,&#160;the&#160;Array&#160;class&#160;defines&#160;some&#160;important&#160;iterators&#160;and&#160;related&#160;searching&#160;and<br/>
<b>9.5 &#160;Collections&#160;|&#160;337</b><br/>
<hr/>
<a name=352></a>sorting&#160;methods&#160;of&#160;its&#160;own.&#160;In&#160;Ruby&#160;1.9&#160;and&#160;1.8.7,&#160;array&#160;iterators&#160;return&#160;an&#160;enumerator<br/>when invoked without a block:<br/>
a = ['a','b','c']<br/>a.each {| elt| print elt } &#160; &#160; &#160; &#160; # The basic each iterator prints &#34;abc&#34;<br/>a.reverse_each {|e| print e} &#160; &#160; &#160; # Array-specific: prints &#34;cba&#34;&#160;<br/>a.cycle {|e| print e } &#160; &#160; &#160; &#160; &#160; &#160; # Ruby 1.9, 1.8.7: print &#34;abcabc...&#34; forever<br/>a.each_index {|i| print i} &#160; &#160; &#160; &#160; # Array-specific: prints &#34;012&#34;<br/>a.each_with_index{|e,i| print e,i} # Enumerable: prints &#34;a0b1c2&#34;<br/>a.map {|x| x.upcase} &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Enumerable: returns ['A','B','C']<br/>a.map! {|x| x.upcase} &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Array-specific: alters a in place<br/>a.collect! {|x| x.downcase!} &#160; &#160; &#160; # collect! is synonym for map!<br/>
# Searching methods<br/>a = %w[h e l l o]<br/>a.include?('e') &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; true<br/>a.include?('w') &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; false<br/>a.index('l') &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; 2: index of first match<br/>a.index('L') &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; nil: no match found<br/>a.rindex('l') &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; 3: search backwards<br/>a.index {|c| c =~ /[aeiou]/} &#160; &#160; &#160; # =&gt; 1: index of 1st vowel. 1.9 and 1.8.7<br/>a.rindex {|c| c =~ /[aeiou]/} &#160; &#160; &#160;# =&gt; 4: index of last vowel. 1.9 and 1.8.7<br/>
# Sorting<br/>a.sort &#160; &#160; # =&gt; %w[e h l l o]: copy a and sort the copy<br/>a.sort! &#160; &#160;# Sort in place: a now holds ['e','h','l','l','o']<br/>a = [1,2,3,4,5] &#160; &#160; &#160; &#160; &#160; &#160; &#160; # A new array to sort into evens and odds<br/>a.sort! {|a,b| a%2 &lt;=&gt; b%2} &#160; # Compare elements modulo 2<br/>
# Shuffling arrays: the opposite of sorting; Ruby 1.9 and 1.8.7<br/>a = [1,2,3] &#160; &#160; # Start ordered<br/>puts a.shuffle &#160;# Shuffle randomly. E.g.: [3,1,2]. Also shuffle!<br/>
<b>9.5.2.5 &#160;Array comparison<br/></b>Two&#160;arrays&#160;are&#160;equal&#160;if&#160;and&#160;only&#160;if&#160;they&#160;have&#160;the&#160;same&#160;number&#160;of&#160;elements,&#160;the&#160;elements<br/>have&#160;the&#160;same&#160;values,&#160;and&#160;they&#160;appear&#160;in&#160;the&#160;same&#160;order.&#160;The&#160;&#160;==&#160;method&#160;tests&#160;the<br/>equality of its elements with&#160;==, and the&#160;eql?&#160;method tests the equality of its elements<br/>by calling&#160;eql?&#160;on&#160;them.&#160;In&#160;most&#160;cases,&#160;these&#160;two&#160;equality-testing&#160;methods&#160;return&#160;the<br/>same result.<br/>The&#160;Array&#160;class&#160;is&#160;not&#160;Comparable,&#160;but&#160;it&#160;does&#160;implement&#160;the&#160;&lt;=&gt;&#160;operator and defines<br/>an&#160;&#160;ordering&#160;&#160;for&#160;&#160;arrays.&#160;&#160;This&#160;&#160;ordering&#160;&#160;is&#160;&#160;analogous&#160;&#160;to&#160;&#160;string&#160;&#160;ordering,&#160;&#160;and&#160;&#160;arrays&#160;&#160;of<br/>character&#160;codes&#160;are&#160;sorted&#160;in&#160;the&#160;same&#160;way&#160;that&#160;the&#160;corresponding&#160;String&#160;objects are.<br/>Arrays&#160;are&#160;compared&#160;element-by-element&#160;from&#160;index&#160;0.&#160;If&#160;any&#160;pair&#160;of&#160;elements&#160;is&#160;not<br/>equal, then the array-comparison method returns the same value as the element com-<br/>parison&#160;did.&#160;If&#160;all&#160;pairs&#160;of&#160;elements&#160;are&#160;equal,&#160;and&#160;the&#160;two&#160;arrays&#160;have&#160;the&#160;same&#160;length,<br/>then&#160;the&#160;arrays&#160;are&#160;equal&#160;and&#160;&lt;=&gt;&#160;returns&#160;0.&#160;Otherwise,&#160;one&#160;of&#160;the&#160;arrays&#160;is&#160;a&#160;prefix&#160;of<br/>the&#160;other.&#160;In&#160;this&#160;case,&#160;the&#160;longer&#160;array&#160;is&#160;greater&#160;than&#160;the&#160;shorter&#160;array.&#160;Note&#160;that&#160;the<br/>empty&#160;array&#160;[]&#160;is&#160;a&#160;prefix&#160;of&#160;every&#160;other&#160;array&#160;and&#160;is&#160;always&#160;less&#160;than&#160;any&#160;nonempty<br/>
<b>338&#160;|&#160;Chapter 9:</b> <b>The Ruby Platform</b><br/>
<hr/>
<a name=353></a>array.&#160;Also,&#160;if&#160;a&#160;pair&#160;of&#160;array&#160;elements&#160;is&#160;incomparable&#160;(if&#160;one&#160;is&#160;a&#160;number&#160;and&#160;one&#160;is&#160;a<br/>string, for example), then&#160;&lt;=&gt;&#160;returns&#160;nil&#160;rather than returning&#160;–1,&#160;0, or&#160;+1:<br/>
[1,2] &lt;=&gt; [4,5] &#160; &#160; &#160;# =&gt; -1 because 1 &lt; 4<br/>[1,2] &lt;=&gt; [0,0,0] &#160; &#160;# =&gt; +1 because 1 &gt; 0<br/>[1,2] &lt;=&gt; [1,2,3] &#160; &#160;# =&gt; -1 because first array is shorter<br/>[1,2] &lt;=&gt; [1,2] &#160; &#160; &#160;# =&gt; 0: they are equal<br/>[1,2] &lt;=&gt; [] &#160; &#160; &#160; &#160; # =&gt; +1 [] always less than a nonempty array<br/>
<b>9.5.2.6 &#160;Arrays as stacks and queues<br/></b>The&#160;push&#160;and&#160;pop&#160;add&#160;and&#160;remove&#160;elements&#160;from&#160;the&#160;end&#160;of&#160;an&#160;array.&#160;They&#160;allow&#160;you<br/>to use an array as a last-on-first-off stack:<br/>
a = []<br/>a.push(1) &#160; &#160; # =&gt; [1]: a is now [1]<br/>a.push(2,3) &#160; # =&gt; [1,2,3]: a is now [1,2,3]<br/>a.pop &#160; &#160; &#160; &#160; # =&gt; 3: a is now [1,2]<br/>a.pop &#160; &#160; &#160; &#160; # =&gt; 2: a is now [1]<br/>a.pop &#160; &#160; &#160; &#160; # =&gt; 1: a is now []<br/>a.pop &#160; &#160; &#160; &#160; # =&gt; nil: a is still []<br/>
shift&#160;is like&#160;pop,&#160;but&#160;it&#160;removes&#160;and&#160;returns&#160;the&#160;first&#160;element&#160;of&#160;an&#160;array&#160;instead&#160;of&#160;the<br/>last&#160;element.&#160;unshift&#160;is&#160;like&#160;push,&#160;but&#160;it&#160;adds&#160;elements&#160;at&#160;the&#160;beginning&#160;of&#160;the&#160;array<br/>instead&#160;of&#160;the&#160;end.&#160;You&#160;can&#160;use&#160;push&#160;and&#160;shift&#160;to&#160;implement&#160;a&#160;first-in-first-out&#160;queue:<br/>
a = []<br/>a.push(1) &#160; &#160; # =&gt; [1]: a is [1]<br/>a.push(2) &#160; &#160; # =&gt; [1,2]: a is [1,2]<br/>a.shift &#160; &#160; &#160; # =&gt; 1: a is [2]<br/>a.push(3) &#160; &#160; # =&gt; [2,3]: a is [2,3]<br/>a.shift &#160; &#160; &#160; # =&gt; 2: a is [3]<br/>a.shift &#160; &#160; &#160; # =&gt; 3: a is []<br/>a.shift &#160; &#160; &#160; # =&gt; nil: a is []<br/>
<b>9.5.2.7 &#160;Arrays as sets<br/></b>The&#160;Array&#160;class&#160;implements&#160;the&#160;&amp;,&#160;|,&#160;and&#160;-&#160;operators&#160;to&#160;perform&#160;set-like&#160;intersection,<br/>union,&#160;and&#160;difference&#160;operations.&#160;Furthermore,&#160;it&#160;defines&#160;include?&#160;to&#160;test&#160;for&#160;the&#160;pres-<br/>ence&#160;(membership)&#160;of&#160;a&#160;value&#160;in&#160;an&#160;array.&#160;It&#160;even&#160;defines&#160;uniq&#160;and&#160;uniq!&#160;to&#160;remove<br/>duplicate&#160;values&#160;from&#160;an&#160;array&#160;(sets&#160;don’t&#160;allow&#160;duplicates).&#160;Array&#160;is&#160;not&#160;an&#160;efficient&#160;set<br/>implementation&#160;&#160;(for&#160;&#160;that,&#160;&#160;see&#160;&#160;the&#160;&#160;Set&#160;&#160;class&#160;&#160;in&#160;&#160;the&#160;&#160;standard&#160;&#160;library),&#160;&#160;but&#160;&#160;it&#160;&#160;may&#160;&#160;be<br/>convenient to use it to represent small sets:<br/>
[1,3,5] &amp; [1,2,3] &#160; &#160; &#160; &#160; &#160; # =&gt; [1,3]: set intersection<br/>[1,1,3,5] &amp; [1,2,3] &#160; &#160; &#160; &#160; # =&gt; [1,3]: duplicates removed<br/>[1,3,5] | [2,4,6] &#160; &#160; &#160; &#160; &#160; # =&gt; [1,3,5,2,4,6]: set union<br/>[1,3,5,5] | [2,4,6,6] &#160; &#160; &#160; # =&gt; [1,3,5,2,4,6]: duplicates removed<br/>[1,2,3] - [2,3] &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; [1]: set difference<br/>[1,1,2,2,3,3] - [2, 3] &#160; &#160; &#160;# =&gt; [1,1]: not all duplicates removed<br/>
small = 0..10.to_a &#160; &#160; &#160; &#160; &#160;# A set of small numbers<br/>even = 0..50.map {|x| x*2} &#160;# A set of even numbers<br/>smalleven = small &amp; even &#160; &#160;# Set intersection<br/>
<b>9.5 &#160;Collections&#160;|&#160;339</b><br/>
<hr/>
<a name=354></a>smalleven.include?(8) &#160; &#160; &#160; # =&gt; true: test for set membership<br/>
[1, 1, nil, nil].uniq &#160; &#160; &#160; # =&gt; [1, nil]: remove dups. Also uniq!<br/>
Note&#160;that&#160;the&#160;&amp;&#160;and&#160;|&#160;-&#160;operators&#160;do&#160;not&#160;specify&#160;the&#160;order&#160;of&#160;the&#160;elements&#160;in&#160;the&#160;arrays<br/>they&#160;return.&#160;Only&#160;use&#160;these&#160;operators&#160;if&#160;your&#160;array&#160;truly&#160;represents&#160;an&#160;unordered&#160;set&#160;of<br/>values.<br/>In&#160;&#160;Ruby&#160;&#160;1.9,&#160;&#160;the&#160;&#160;Array&#160;&#160;class&#160;&#160;defines&#160;&#160;set&#160;&#160;combinatorics&#160;&#160;methods&#160;&#160;for&#160;&#160;computing<br/>permutations, combinations, and Cartesian products:<br/>
a = [1,2,3]<br/>
# Iterate all possible 2-element subarrays (order matters)<br/>a.permutation(2) {|x| print x } &#160;# Prints &#34;[1,2][1,3][2,1][2,3][3,1][3,2]&#34;<br/>
# Iterate all possible 2-element subsets (order does not matter)<br/>a.combination(2) {|x| print x } &#160;# Prints &#34;[1, 2][1, 3][2, 3]&#34;<br/>
# Return the Cartesian product of the two sets<br/>a.product(['a','b']) &#160; &#160; &#160; # =&gt; [[1,&#34;a&#34;],[1,&#34;b&#34;],[2,&#34;a&#34;],[2,&#34;b&#34;],[3,&#34;a&#34;],[3,&#34;b&#34;]]<br/>[1,2].product([3,4],[5,6]) # =&gt; [[1,3,5],[1,3,6],[1,4,5],[1,4,6], etc... ]&#160;<br/>
<b>9.5.2.8 &#160;Associative array methods<br/></b>The&#160;assoc&#160;and&#160;rassoc&#160;methods&#160;allow&#160;you&#160;to&#160;treat&#160;an&#160;array&#160;as&#160;an&#160;associative&#160;array&#160;or<br/>hash. For this to work, the array must be an array of arrays, typically like this:<br/>
[[key1, value1], [key2, value2], [key3, value3], ...]<br/>
The&#160;Hash&#160;class&#160;defines&#160;methods&#160;that&#160;convert&#160;a&#160;hash&#160;to&#160;a&#160;nested&#160;array&#160;of&#160;this&#160;form.&#160;The<br/>assoc&#160;&#160;methods&#160;&#160;looks&#160;&#160;for&#160;&#160;a&#160;&#160;nested&#160;&#160;array&#160;&#160;whose&#160;&#160;first&#160;&#160;element&#160;&#160;matches&#160;&#160;the&#160;&#160;supplied<br/>argument.&#160;It&#160;returns&#160;the&#160;first&#160;matching&#160;nested&#160;array.&#160;The&#160;rassoc&#160;method&#160;does&#160;the&#160;same<br/>
&#160;<br/>
thing, but returns the first nested array whose second element matches:<br/>
h = { :a =&gt; 1, :b =&gt; 2} &#160; # Start with a hash<br/>a = h.to_a &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; [[:b,2], [:a,1]]: associative array<br/>a.assoc(:a) &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; [:a,1]: subarray for key :a<br/>a.assoc(:b).last &#160; &#160; &#160; &#160; &#160;# =&gt; 2: value for key :b<br/>a.rassoc(1) &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; [:a,1]: subarray for value 1<br/>a.rassoc(2).first &#160; &#160; &#160; &#160; # =&gt; :b: key for value 2<br/>a.assoc(:c) &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; nil<br/>a.transpose &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; [[:a, :b], [1, 2]]: swap rows and cols<br/>
<b>9.5.2.9 &#160;Miscellaneous array methods<br/></b>Array&#160;&#160;defines&#160;&#160;a&#160;&#160;few&#160;&#160;miscellaneous&#160;&#160;methods&#160;&#160;that&#160;&#160;do&#160;&#160;not&#160;&#160;fit&#160;&#160;in&#160;&#160;any&#160;&#160;of&#160;&#160;the&#160;&#160;previous<br/>categories:<br/>
# Conversion to strings<br/>[1,2,3].join &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; &#34;123&#34;: convert elements to string and join<br/>[1,2,3].join(&#34;, &#34;) &#160; &#160; &#160; &#160;# =&gt; &#34;1, 2, 3&#34;: optional delimiter<br/>[1,2,3].to_s &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; &#34;[1, 2, 3]&#34; in Ruby 1.9<br/>[1,2,3].to_s &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; &#34;123&#34; in Ruby 1.8<br/>[1,2,3].inspect &#160; &#160; &#160; &#160; &#160; # =&gt; &#34;[1, 2, 3]&#34;: better for debugging in 1.8<br/>
<b>340&#160;|&#160;Chapter 9:</b> <b>The Ruby Platform</b><br/>
<hr/>
<a name=355></a># Binary conversion with pack. See also String.unpack.<br/>[1,2,3,4].pack(&#34;CCCC&#34;) &#160; &#160;# =&gt; &#34;\001\002\003\004&#34;<br/>[1,2].pack('s2') &#160; &#160; &#160; &#160; &#160;# =&gt; &#34;\001\000\002\000&#34;<br/>[1234].pack(&#34;i&#34;) &#160; &#160; &#160; &#160; &#160;# =&gt; &#34;\322\004\000\000&#34;<br/>
# Other methods<br/>[0,1]*3 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; [0,1,0,1,0,1]: * operator repeats<br/>[1, [2, [3]]].flatten &#160; &#160; # =&gt; [1,2,3]: recursively flatten; also flatten!<br/>[1, [2, [3]]].flatten(1) &#160;# =&gt; [1,2,[3]]: specify # of levels; Ruby 1.9<br/>[1,2,3].reverse &#160; &#160; &#160; &#160; &#160; # =&gt; [3,2,1]: also reverse!<br/>a=[1,2,3].zip([:a,:b,:c]) # =&gt; [[1,:a],[2,:b],[3,:c]]: Enumerable method<br/>a.transpose &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; [[1,2,3],[:a,:b,:c]]: swap rows/cols<br/>
<b>9.5.3 &#160;Hashes<br/></b>Hashes&#160;were&#160;introduced&#160;in&#160;<a href="Rubys.html#81">§3.4,&#160;</a>which&#160;explained&#160;hash&#160;literal&#160;syntax&#160;and&#160;the&#160;[]&#160;and<br/>[]=&#160;operators&#160;for&#160;retrieving&#160;and&#160;storing&#160;key/value&#160;pairs&#160;in&#160;a&#160;hash.&#160;This&#160;section&#160;covers<br/>the&#160;Hash&#160;API&#160;in&#160;more&#160;detail.&#160;Hashes&#160;use&#160;the&#160;same&#160;square-bracket&#160;operators&#160;as&#160;arrays<br/>do, and you’ll notice that many&#160;Hash&#160;methods are similar to&#160;Array&#160;methods.<br/>
<b>9.5.3.1 &#160;Creating hashes<br/></b>Hashes&#160;can&#160;be&#160;created&#160;with&#160;literals,&#160;the&#160;Hash.new&#160;method,&#160;or&#160;the&#160;[]&#160;operator&#160;of&#160;the<br/>Hash&#160;class itself:<br/>
{ :one =&gt; 1, :two =&gt; 2 } &#160;# Basic hash literal syntax<br/>{ :one, 1, :two, 2 } &#160; &#160; &#160;# Same, with deprecated Ruby 1.8 syntax<br/>{ one: 1, two: 2 } &#160; &#160; &#160; &#160;# Same, Ruby 1.9 syntax. Keys are symbols.<br/>{} &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# A new, empty, Hash object<br/>Hash.new &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; {}: creates empty hash<br/>Hash[:one, 1, :two, 2] &#160; &#160;# =&gt; {one:1, two:2}<br/>
Recall from&#160;<a href="Rubys.html#202">§6.4.4</a>&#160;that&#160;you&#160;can&#160;omit&#160;the&#160;curly&#160;braces&#160;around&#160;a&#160;hash&#160;literal&#160;that&#160;is&#160;the<br/>final argument in a method invocation:<br/>
puts :a=&gt;1, :b=&gt;2 &#160; # Curly braces omitted in invocation<br/>puts a:1, b:2 &#160; &#160; &#160; # Ruby 1.9 syntax works too<br/>
<b>9.5.3.2 &#160;Indexing hashes and testing membership<br/></b>Hashes are very&#160;efficient&#160;at&#160;looking&#160;up&#160;the&#160;value&#160;associated&#160;with&#160;a&#160;given&#160;key.&#160;It&#160;is&#160;also<br/>possible&#160;(though&#160;not&#160;efficient)&#160;to&#160;find&#160;a&#160;key&#160;with&#160;which&#160;a&#160;value&#160;is&#160;associated.&#160;Note,<br/>however,&#160;that&#160;many&#160;keys&#160;can&#160;map&#160;to&#160;the&#160;same&#160;value,&#160;and&#160;in&#160;this&#160;case,&#160;the&#160;key&#160;returned<br/>is arbitrary:<br/>
h = { :one =&gt; 1, :two =&gt; 2 }<br/>h[:one] &#160; &#160; &#160; # =&gt; 1: find value associated with a key<br/>h[:three] &#160; &#160; # =&gt; nil: the key does not exist in the hash<br/>h.assoc :one &#160;# =&gt; [:one, 1]: find key/value pair. Ruby 1.9.<br/>
h.index 1 &#160; &#160; # =&gt; :one: search for key associated with a value<br/>
<b>9.5 &#160;Collections&#160;|&#160;341</b><br/>
<hr/>
<a name=356></a>h.index 4 &#160; &#160; # =&gt; nil: no mapping to this value exists<br/>h.rassoc 2 &#160; &#160;# =&gt; [:two, 2]: key/value pair matching value. Ruby 1.9.<br/>
Hash&#160;defines several synonymous methods for testing membership:<br/>
h = { :a =&gt; 1, :b =&gt; 2 }<br/># Checking for the presence of keys in a hash: fast<br/>h.key?(:a) &#160; &#160; &#160; # true: :a is a key in h<br/>h.has_key?(:b) &#160; # true: has_key? is a synonym for key?<br/>h.include?(:c) &#160; # false: include? is another synonym<br/>h.member?(:d) &#160; &#160;# false: member? is yet another synonym<br/>
# Checking for the presence of values: slow<br/>h.value?(1) &#160; &#160; &#160;# true: 1 is a value in h<br/>h.has_value?(3) &#160;# false: has_value? is a synonym for value?<br/>
The&#160;fetch&#160;method&#160;is&#160;an&#160;alternative&#160;to&#160;[]&#160;when&#160;querying&#160;values&#160;in&#160;a&#160;hash.&#160;It&#160;provides<br/>options for handling the case where a key does not exist in the hash:<br/>
h = { :a =&gt; 1, :b =&gt; 2 }<br/>h.fetch(:a) &#160; &#160; &#160;# =&gt; 1: works like [] for existing keys<br/>h.fetch(:c) &#160; &#160; &#160;# Raises IndexError for nonexistent key<br/>h.fetch(:c, 33) &#160;# =&gt; 33: uses specified value if key is not found<br/>h.fetch(:c) {|k| k.to_s } # =&gt; &#34;c&#34;: calls block if key not found<br/>
If you want to extract more than one value from a hash at once, use&#160;values_at:<br/>
h = { :a =&gt; 1, :b =&gt; 2, :c =&gt; 3 }<br/>h.values_at(:c) &#160; &#160; &#160; &#160; # =&gt; [3]: values returned in an array<br/>h.values_at(:a, :b) &#160; &#160; # =&gt; [1, 2]: pass any # of args<br/>h.values_at(:d, :d, :a) # =&gt; [nil, nil, 1]<br/>
You can extract keys and values selected by a block with the&#160;select&#160;method:<br/>
h = { :a =&gt; 1, :b =&gt; 2, :c =&gt; 3 }<br/>h.select {|k,v| v % 2 == 0 } # =&gt; [:b,2] Ruby 1.8<br/>h.select {|k,v| v % 2 == 0 } # =&gt; {:b=&gt;2} Ruby 1.9<br/>
This&#160;method&#160;overrides&#160;Enumerable.select.&#160;In&#160;Ruby&#160;1.8,&#160;select&#160;returns&#160;an&#160;array&#160;of&#160;key/<br/>value&#160;pairs.&#160;It&#160;has&#160;been&#160;modified&#160;in&#160;Ruby&#160;1.9&#160;so&#160;that&#160;it&#160;returns&#160;a&#160;hash&#160;of&#160;the&#160;selected<br/>keys and values instead.<br/>
<b>9.5.3.3 &#160;Storing keys and values in a hash<br/></b>Associate a&#160;value with a key in a hash with the&#160;[]=&#160;operator&#160;or its synonym, the&#160;store<br/>method:<br/>
h = {} &#160; &#160; &#160; &#160;# Start with an empty hash<br/>h[:a] = 1 &#160; &#160; # Map :a=&gt;1. &#160;h is now {:a=&gt;1}<br/>h.store(:b,2) # More verbose: h is now {:a=&gt;1, :b=&gt;2}<br/>
To&#160;replace&#160;all&#160;the&#160;key/value&#160;pairs&#160;in&#160;a&#160;hash&#160;with&#160;copies&#160;of&#160;the&#160;pairs&#160;from&#160;another&#160;hash,&#160;<br/>use&#160;replace:<br/>
# Replace all of the pairs in h with those from another hash<br/>h.replace({1=&gt;:a, 2=&gt;:b}) # h is now equal to the argument hash<br/>
<b>342&#160;|&#160;Chapter 9:</b> <b>The Ruby Platform</b><br/>
<hr/>
<a name=357></a>The&#160;merge,&#160;merge!,&#160;and&#160;update&#160;methods&#160;allow&#160;you&#160;to&#160;merge&#160;the&#160;mappings&#160;from&#160;two<br/>hashes:<br/>
# Merge hashes h and j into new hash k. &#160;<br/># If h and j share keys, use values from j<br/>k = h.merge(j)<br/>{:a=&gt;1,:b=&gt;2}.merge(:a=&gt;3,:c=&gt;3) &#160;# =&gt; {:a=&gt;3,:b=&gt;2,:c=&gt;3}<br/>h.merge!(j) &#160; # Modifies h in place.<br/>
# If there is a block, use it to decide which value to use<br/>h.merge!(j) {|key,h,j| h } &#160; &#160; &#160;# Use value from h<br/>h.merge(j) {|key,h,j| (h+j)/2 } # Use average of two values<br/>
# update is a synonym for merge!<br/>h = {a:1,b:2} &#160; &#160; # Using Ruby 1.9 syntax and omitting braces<br/>h.update(b:4,c:9) {|key,old,new| old } &#160;# h is now {a:1, b:2, c:9}<br/>h.update(b:4,c:9) # h is now {a:1, b:4, c:9}<br/>
<b>9.5.3.4 &#160;Removing hash entries<br/></b>You&#160;can’t&#160;remove&#160;a&#160;key&#160;from&#160;a&#160;hash&#160;simply&#160;by&#160;mapping&#160;it&#160;to&#160;&#160;nil.&#160;Instead,&#160;use&#160;the<br/>delete&#160;method:<br/>
h = {:a=&gt;1, :b=&gt;2}<br/>h[:a] = nil &#160; &#160; &#160;# h now holds {:a=&gt; nil, :b=&gt;2 }<br/>h.include? :a &#160; &#160;# =&gt; true<br/>h.delete :b &#160; &#160; &#160;# =&gt; 2: returns deleted value: h now holds {:a=&gt;nil}<br/>h.include? :b &#160; &#160;# =&gt; false<br/>h.delete :b &#160; &#160; &#160;# =&gt; nil: key not found<br/># Invoke block if key not found<br/>h.delete(:b) {|k| raise IndexError, k.to_s } # IndexError!<br/>
You&#160;can&#160;delete&#160;multiple&#160;key/value&#160;pairs&#160;from&#160;a&#160;hash&#160;using&#160;the&#160;delete_if&#160;and&#160;reject!<br/>iterators&#160;(and&#160;the&#160;reject&#160;iterator&#160;which&#160;operates&#160;on&#160;a&#160;copy&#160;of&#160;its&#160;receiver).&#160;Note&#160;that<br/>reject&#160;overrides&#160;the&#160;Enumerable&#160;method&#160;by&#160;the&#160;same&#160;name&#160;and&#160;returns&#160;a&#160;hash&#160;rather<br/>than an array:<br/>
h = {:a=&gt;1, :b=&gt;2, :c=&gt;3, :d=&gt;&#34;four&#34;}<br/>h.reject! {|k,v| v.is_a? String } &#160;# =&gt; {:a=&gt;1, :b=&gt;2, :c=&gt;3 }<br/>h.delete_if {|k,v| k.to_s &lt; 'b' } &#160;# =&gt; {:b=&gt;2, :c=&gt;3 }<br/>h.reject! {|k,v| k.to_s &lt; 'b' } &#160; &#160;# =&gt; nil: no change<br/>h.delete_if {|k,v| k.to_s &lt; 'b' } &#160;# =&gt; {:b=&gt;2, :c=&gt;3 }: unchanged hash<br/>h.reject {|k,v| true } &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; {}: h is unchanged<br/>
Finally,&#160;you&#160;can&#160;remove&#160;all&#160;key/value&#160;pairs&#160;from&#160;a&#160;hash&#160;with&#160;the&#160;clear&#160;method.&#160;This<br/>method does not end with an exclamation mark, but it alters its receiver in place:<br/>
h.clear &#160; &#160;# h is now {}<br/>
<b>9.5.3.5 &#160;Arrays from hashes<br/></b>Hash&#160;defines methods for extracting hash data into arrays:<br/>
h = { :a=&gt;1, :b=&gt;2, :c=&gt;3 }<br/># Size of hash: number of key/value pairs<br/>
<b>9.5 &#160;Collections&#160;|&#160;343</b><br/>
<hr/>
<a name=358></a>h.length &#160; &#160; # =&gt; 3<br/>h.size &#160; &#160; &#160; # =&gt; 3: size is a synonym for length<br/>h.empty? &#160; &#160; # =&gt; false<br/>{}.empty? &#160; &#160;# =&gt; true<br/>
h.keys &#160; &#160; &#160; # =&gt; [:b, :c, :a]: array of keys<br/>h.values &#160; &#160; # =&gt; [2,3,1]: array of values<br/>h.to_a &#160; &#160; &#160; # =&gt; [[:b,2],[:c,3],[:a,1]]: array of pairs<br/>h.flatten &#160; &#160;# =&gt; [:b, 2, :c, 3, :a, 1]: flattened array. Ruby 1.9<br/>h.sort &#160; &#160; &#160; # =&gt; [[:a,1],[:b,2],[:c,3]]: sorted array of pairs<br/>h.sort {|a,b| a[1]&lt;=&gt;b[1] } # Sort pairs by value instead of key<br/>
<b>9.5.3.6 &#160;Hash iterators<br/></b>It&#160;is&#160;not&#160;usually&#160;necessary&#160;to&#160;extract&#160;hash&#160;keys,&#160;values,&#160;or&#160;pairs&#160;as&#160;an&#160;array,&#160;because&#160;the<br/>Hash&#160;class&#160;is&#160;Enumerable&#160;and&#160;defines&#160;other&#160;useful&#160;iterators&#160;as&#160;well.&#160;In&#160;Ruby&#160;1.8,&#160;Hash<br/>objects&#160;make&#160;no&#160;guarantees&#160;about&#160;the&#160;order&#160;in&#160;which&#160;their&#160;values&#160;are&#160;iterated.&#160;In&#160;Ruby<br/>1.9, however,&#160;hash&#160;elements&#160;are&#160;iterated&#160;in&#160;their&#160;insertion&#160;order,&#160;and&#160;that&#160;is&#160;the&#160;order<br/>shown in the following examples:<br/>
h = { :a=&gt;1, :b=&gt;2, :c=&gt;3 }<br/>
# The each() iterator iterates [key,value] pairs<br/>h.each {|pair| print pair } &#160; &#160;# Prints &#34;[:a, 1][:b, 2][:c, 3]&#34;<br/>
# It also works with two block arguments<br/>h.each do |key, value| &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;<br/>&#160; print &#34;#{key}:#{value} &#34; &#160; &#160; # Prints &#34;a:1 b:2 c:3&#34;&#160;<br/>end<br/>
# Iterate over keys or values or both<br/>h.each_key {|k| print k } &#160; &#160; &#160;# Prints &#34;abc&#34;<br/>h.each_value {|v| print v } &#160; &#160;# Prints &#34;123&#34;<br/>h.each_pair {|k,v| print k,v } # Prints &#34;a1b2c3&#34;. Like each<br/>
The&#160;each&#160;iterator&#160;yields&#160;an&#160;array&#160;containing&#160;the&#160;key&#160;and&#160;value.&#160;Block&#160;invocation&#160;syntax<br/>allows&#160;this&#160;array&#160;to&#160;be&#160;automatically&#160;expanded&#160;into&#160;separate&#160;key&#160;and&#160;value&#160;parameters.<br/>In&#160;Ruby&#160;1.8,&#160;the&#160;each_pair&#160;iterator&#160;yields&#160;the&#160;key&#160;and&#160;value&#160;as&#160;two&#160;separate&#160;values<br/>(which&#160;may&#160;have&#160;a&#160;slight&#160;performance&#160;advantage).&#160;In&#160;Ruby&#160;1.9,&#160;each_pair&#160;is&#160;simply&#160;a<br/>synonym for&#160;each.<br/>Although&#160;it&#160;is&#160;not&#160;an&#160;iterator,&#160;the&#160;shift&#160;method&#160;can&#160;be&#160;used&#160;to&#160;iterate&#160;through&#160;the&#160;key/<br/>value&#160;pairs&#160;of&#160;a&#160;hash.&#160;Like&#160;the&#160;array&#160;method&#160;of&#160;the&#160;same&#160;name,&#160;it&#160;removes&#160;and&#160;returns<br/>one element (one&#160;[key,value]&#160;array in this case) from the hash:<br/>
h = { :a=&gt; 1, :b=&gt;2 }<br/>print h.shift[1] while not h.empty? &#160; # Prints &#34;12&#34;<br/>
<b>9.5.3.7 &#160;Default values<br/></b>Normally,&#160;if&#160;you&#160;query&#160;the&#160;value&#160;of&#160;a&#160;key&#160;with&#160;which&#160;no&#160;value&#160;has&#160;been&#160;associated,&#160;the<br/>hash returns&#160;nil:<br/>
<b>344&#160;|&#160;Chapter 9:</b> <b>The Ruby Platform</b><br/>
<hr/>
<a name=359></a>empty = {}<br/>empty[&#34;one&#34;] &#160; # nil<br/>
You can alter this behavior, however, by specifying a default value for the hash:<br/>
empty = Hash.new(-1) &#160; # Specify a default value when creating hash<br/>empty[&#34;one&#34;] &#160; &#160; &#160; &#160; &#160; # =&gt; -1<br/>empty.default = -2 &#160; &#160; # Change the default value to something else<br/>empty[&#34;two&#34;] &#160; &#160; &#160; &#160; &#160; # =&gt; -2<br/>empty.default &#160; &#160; &#160; &#160; &#160;# =&gt; -2: return the default value<br/>
Instead&#160;of&#160;providing&#160;a&#160;single&#160;default&#160;value,&#160;you&#160;can&#160;provide&#160;a&#160;block&#160;of&#160;code&#160;to&#160;compute<br/>values for keys that do not have an associated value:<br/>
# If the key is not defined, return the successor of the key.<br/>plus1 = Hash.new {|hash, key| key.succ }<br/>plus1[1] &#160; &#160; &#160;# 2<br/>plus1[&#34;one&#34;] &#160;# &#34;onf&#34;: see String.succ<br/>plus1.default_proc &#160;# Returns the Proc that computes defaults<br/>plus1.default(10) &#160; # =&gt; 11: default returned for key 10<br/>
When&#160;using&#160;a&#160;default&#160;block&#160;like&#160;this,&#160;it&#160;is&#160;common&#160;to&#160;associate&#160;the&#160;computed&#160;value<br/>with&#160;the&#160;key,&#160;so&#160;that&#160;the&#160;computation&#160;does&#160;not&#160;need&#160;to&#160;be&#160;redone&#160;if&#160;the&#160;key&#160;is&#160;queried<br/>again.&#160;This&#160;is&#160;an&#160;easy-to-implement&#160;form&#160;of&#160;lazy&#160;evaluation&#160;(and&#160;it&#160;explains&#160;why&#160;the<br/>default block is passed the hash object itself along with the key):<br/>
# This lazily initialized hash maps integers to their factorials<br/>fact = Hash.new {|h,k| h[k] = if k &gt; 1: k*h[k-1] else 1 end }<br/>fact &#160; &#160; &#160;# {}: it starts off empty<br/>fact[4] &#160; # 24: 4! is 24<br/>fact &#160; &#160; &#160;# {1=&gt;1, 2=&gt;2, 3=&gt;6, 4=&gt;24}: the hash now has entries<br/>
Note&#160;that&#160;setting&#160;the&#160;&#160;default&#160;property&#160;of&#160;a&#160;hash&#160;overrides&#160;any&#160;block&#160;passed&#160;to&#160;the<br/>Hash.new&#160;constructor.<br/>
If&#160;you&#160;are&#160;not&#160;interested&#160;in&#160;default&#160;values&#160;for&#160;a&#160;hash,&#160;or&#160;if&#160;you&#160;want&#160;to&#160;override&#160;them<br/>with&#160;your&#160;own&#160;default,&#160;use&#160;the&#160;fetch&#160;method&#160;to&#160;retrieve&#160;values&#160;instead&#160;of&#160;using&#160;square<br/>brackets.&#160;fetch&#160;was covered earlier:<br/>
fact.fetch(5) &#160; # IndexError: key not found<br/>
<b>9.5.3.8 &#160;Hashcodes, key equality, and mutable keys<br/></b>In&#160;order&#160;for&#160;an&#160;object&#160;to&#160;be&#160;used&#160;as&#160;a&#160;hash&#160;key,&#160;it&#160;must&#160;have&#160;a&#160;hash&#160;method&#160;that&#160;returns<br/>an&#160;integer&#160;“hashcode”&#160;for&#160;the&#160;object.&#160;Classes&#160;that&#160;do&#160;not&#160;define&#160;their&#160;own&#160;eql?&#160;method<br/>can&#160;simply&#160;use&#160;the&#160;hash&#160;method&#160;they&#160;inherit&#160;from&#160;Object.&#160;If&#160;you&#160;define&#160;an&#160;eql?&#160;method<br/>for testing object equality, however, you must define a corresponding&#160;hash&#160;method. If<br/>two&#160;distinct&#160;objects&#160;are&#160;considered&#160;equal,&#160;their&#160;hash&#160;methods&#160;must&#160;return&#160;the&#160;same<br/>value.&#160;Ideally,&#160;two&#160;objects&#160;that&#160;are&#160;not&#160;equal&#160;should&#160;have&#160;different&#160;hashcodes.&#160;This<br/><a href="Rubys.html#82">topic was covered in §3.4.2, and §7.1.9 includes an example&#160;</a>hash&#160;implementation.<br/>As&#160;noted&#160;in&#160;<a href="Rubys.html#82">§3.4.2,&#160;</a>you&#160;must&#160;be&#160;careful&#160;any&#160;time&#160;you&#160;use&#160;a&#160;mutable&#160;object&#160;as&#160;a&#160;hash<br/>key.&#160;(Strings&#160;are&#160;a&#160;special&#160;case:&#160;the&#160;Hash&#160;class&#160;makes&#160;a&#160;private&#160;internal&#160;copy&#160;of&#160;string<br/>
<b>9.5 &#160;Collections&#160;|&#160;345</b><br/>
<hr/>
<a name=360></a>keys.)&#160;If&#160;you&#160;do&#160;use&#160;mutable&#160;keys&#160;and&#160;mutate&#160;one&#160;of&#160;them,&#160;you&#160;must&#160;call&#160;rehash&#160;on&#160;the<br/>Hash&#160;object in order to ensure that it works right:<br/>
key = {:a=&gt;1} &#160; &#160; &#160;# This hash will be a key in another hash!<br/>h = { key =&gt; 2 } &#160; # This hash has a mutable key<br/>h[key] &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; 2: get value associated with key<br/>key.clear &#160; &#160; &#160; &#160; &#160;# Mutate the key<br/>h[key] &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; nil: no value found for mutated key<br/>h.rehash &#160; &#160; &#160; &#160; &#160; # Fix up the hash after mutation<br/>h[key] &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; 2: now the value is found again<br/>
<b>9.5.3.9 &#160;Miscellaneous hash methods<br/></b>The&#160;invert&#160;method does&#160;not&#160;fit&#160;into&#160;any&#160;of&#160;the&#160;previous&#160;categories.&#160;invert&#160;swaps keys<br/>and values in a hash:<br/>
h = {:a=&gt;1, :b=&gt;2}<br/>h.invert &#160; &#160; &#160; &#160;# =&gt; {1=&gt;:a, 2=&gt;:b}: swap keys and values<br/>
As&#160;was&#160;the&#160;case&#160;for&#160;Array,&#160;the&#160;Hash.to_s&#160;method&#160;is&#160;not&#160;very&#160;useful&#160;in&#160;Ruby&#160;1.8,&#160;and&#160;you<br/>may prefer to use&#160;inspect&#160;to&#160;convert&#160;to&#160;a&#160;string&#160;in&#160;hash&#160;literal&#160;form.&#160;In&#160;Ruby&#160;1.9,&#160;to_s<br/>and&#160;inspect&#160;are the same:<br/>
{:a=&gt;1, :b=&gt;2}.to_s &#160; &#160;# =&gt; &#34;a1b2&#34; in Ruby 1.8; &#34;{:a=&gt;1, :b=&gt;2}&#34; in 1.9<br/>{:a=&gt;1, :b=&gt;2}.inspect # =&gt; &#34;{:a=&gt;1, :b=&gt;2}&#34; for both versions<br/>
<b>9.5.4 &#160;Sets<br/></b>A&#160;<i>set</i>&#160;is&#160;simply&#160;a&#160;collection&#160;of&#160;values,&#160;without&#160;duplicates.&#160;Unlike&#160;an&#160;array,&#160;the&#160;elements<br/>of&#160;a&#160;set&#160;have&#160;no&#160;order.&#160;A&#160;hash&#160;can&#160;be&#160;considered&#160;a&#160;set&#160;of&#160;key/value&#160;pairs.&#160;Conversely,<br/>a&#160;set&#160;can&#160;be&#160;implemented&#160;using&#160;a&#160;hash&#160;in&#160;which&#160;set&#160;elements&#160;are&#160;stored&#160;as&#160;keys&#160;and<br/>values&#160;are&#160;ignored.&#160;A&#160;<i>sorted&#160;set</i>&#160;is&#160;a&#160;set&#160;that&#160;imposes&#160;an&#160;ordering&#160;on&#160;its&#160;elements&#160;(but<br/>does&#160;not&#160;allow&#160;random&#160;access&#160;to&#160;them&#160;as&#160;an&#160;array&#160;does).&#160;A&#160;characteristic&#160;feature&#160;of&#160;set<br/>implementations&#160;is&#160;that&#160;they&#160;feature&#160;fast&#160;membership&#160;testing,&#160;insertion,&#160;and&#160;deletion<br/>operations.<br/>Ruby&#160;does&#160;not&#160;offer&#160;a&#160;built-in&#160;set&#160;type,&#160;but&#160;the&#160;standard&#160;library&#160;includes&#160;the&#160;Set&#160;and<br/>SortedSet&#160;classes, which you can use if you first:<br/>
require 'set'<br/>
The&#160;Set&#160;API&#160;is&#160;similar&#160;in&#160;many&#160;ways&#160;to&#160;the&#160;&#160;Array&#160;and&#160;Hash&#160;APIs.&#160;A&#160;number&#160;of&#160;&#160;Set<br/>methods and operators accept any&#160;Enumerable&#160;object as their argument.<br/>
<b>SortedSet</b><br/>
The&#160;SortedSet&#160;class&#160;inherits&#160;from&#160;Set&#160;and&#160;does&#160;not&#160;define&#160;any&#160;new&#160;methods&#160;of&#160;its&#160;own;<br/>it&#160;simply&#160;guarantees&#160;that&#160;the&#160;elements&#160;of&#160;the&#160;set&#160;will&#160;be&#160;iterated&#160;(or&#160;printed&#160;or&#160;converted<br/>to&#160;arrays)&#160;in&#160;sorted&#160;order.&#160;SortedSet&#160;does&#160;not&#160;allow&#160;you&#160;to&#160;provide&#160;a&#160;custom&#160;block&#160;to<br/>compare&#160;&#160;set&#160;&#160;elements,&#160;&#160;and&#160;&#160;requires&#160;&#160;that&#160;&#160;all&#160;&#160;set&#160;&#160;elements&#160;&#160;are&#160;&#160;mutually&#160;&#160;comparable<br/>
<b>346&#160;|&#160;Chapter 9:</b> <b>The Ruby Platform</b><br/>
<hr/>
<a name=361></a>according to their&#160;default&#160;&lt;=&gt;&#160;operator. Because the&#160;SortedSet&#160;API&#160;is&#160;no&#160;different&#160;than<br/>the basic&#160;Set&#160;API, it will not be covered here.<br/>
<b>9.5.4.1 &#160;Creating sets<br/></b>Because&#160;Set&#160;is&#160;not&#160;a&#160;core&#160;Ruby&#160;class,&#160;there&#160;is&#160;no&#160;literal&#160;syntax&#160;for&#160;creating&#160;sets.&#160;The<br/>set&#160;library&#160;adds&#160;a&#160;to_set&#160;method&#160;to&#160;the&#160;Enumerable&#160;module,&#160;and&#160;a&#160;set&#160;can&#160;be&#160;created<br/>from any enumerable object with this method:<br/>
(1..5).to_set &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; #&lt;Set: {5, 1, 2, 3, 4}&gt;<br/>[1,2,3].to_set &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; #&lt;Set: {1, 2, 3}&gt;<br/>
Alternatively,&#160;any&#160;enumerable&#160;object&#160;can&#160;be&#160;passed&#160;to&#160;Set.new.&#160;If&#160;a&#160;block&#160;is&#160;provided,<br/>it is used (as with the&#160;map&#160;iterator) to preprocess the enumerated values before adding<br/>them to the set:<br/>
Set.new(1..5) &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; #&lt;Set: {5, 1, 2, 3, 4}&gt;<br/>Set.new([1,2,3]) &#160; &#160; &#160; &#160; &#160; # =&gt; #&lt;Set: {1, 2, 3}&gt;<br/>Set.new([1,2,3]) {|x| x+1} # =&gt; #&lt;Set: {2, 3, 4}&gt;<br/>
If&#160;you&#160;prefer&#160;to&#160;enumerate&#160;the&#160;members&#160;of&#160;your&#160;set&#160;without&#160;first&#160;placing&#160;them&#160;in&#160;an<br/>array or other enumerable object, use the&#160;[]&#160;operator of the&#160;Set&#160;class:<br/>
Set[&#34;cow&#34;, &#34;pig&#34;, &#34;hen&#34;] &#160; # =&gt; #&lt;Set: {&#34;cow&#34;, &#34;pig&#34;, &#34;hen&#34;}&gt;<br/>
<b>9.5.4.2 &#160;Testing, comparing, and combining Sets<br/></b>The most common operation on sets is usually membership testing:<br/>
s = Set.new(1..3) &#160; # =&gt; #&lt;Set: {1, 2, 3}&gt; &#160;<br/>s.include? 1 &#160; &#160; &#160; &#160;# =&gt; true<br/>s.member? 0 &#160; &#160; &#160; &#160; # =&gt; false: member? is a synonym<br/>
It&#160;is&#160;also&#160;possible&#160;to&#160;test&#160;sets&#160;for&#160;membership&#160;in&#160;other&#160;sets.&#160;A&#160;set&#160;S&#160;is&#160;a&#160;<i>subset</i>&#160;of T if all<br/>the&#160;elements&#160;of&#160;S&#160;are&#160;also&#160;elements&#160;of&#160;T.&#160;We&#160;can&#160;also&#160;say&#160;that&#160;T&#160;is&#160;a&#160;<i>superset</i>&#160;of&#160;S.&#160;If&#160;two<br/>sets&#160;are&#160;equal,&#160;then&#160;they&#160;are&#160;both&#160;subsets&#160;and&#160;supersets&#160;of&#160;each&#160;other.&#160;S&#160;is&#160;a&#160;<i>proper<br/>subset</i>&#160;of&#160;T&#160;if&#160;it&#160;is&#160;a&#160;subset&#160;of&#160;T&#160;but&#160;not&#160;equal&#160;to&#160;T.&#160;In&#160;this&#160;case,&#160;T&#160;is&#160;a&#160;<i>proper superset</i>&#160;of<br/>S:<br/>
s = Set[2, 3, 5]<br/>t = Set[2, 3, 5, 7]<br/>s.subset? t &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; true<br/>t.subset? s &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; false<br/>s.proper_subset? t &#160; &#160; # =&gt; true<br/>t.superset? s &#160; &#160; &#160; &#160; &#160;# =&gt; true<br/>t.proper_superset? s &#160; # =&gt; true<br/>s.subset? s &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; true<br/>s.proper_subset? s &#160; &#160; # =&gt; false<br/>
Set&#160;defines the same size methods as&#160;Array&#160;and&#160;Hash&#160;do:<br/>
s = Set[2, 3, 5]<br/>s.length &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; 3<br/>s.size &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; 3: a synonym for length<br/>
<b>9.5 &#160;Collections&#160;|&#160;347</b><br/>
<hr/>
<a name=362></a>s.empty? &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; false<br/>Set.new.empty? &#160; &#160; &#160; &#160; # =&gt; true<br/>
New&#160;sets&#160;can&#160;be&#160;created&#160;by&#160;combining&#160;two&#160;existing&#160;sets.&#160;There&#160;are&#160;several&#160;ways&#160;this<br/>can&#160;be&#160;done,&#160;and&#160;Set&#160;defines&#160;the&#160;operators&#160;&amp;,&#160;|,&#160;–, and&#160;^&#160;(plus&#160;named&#160;method&#160;aliases)<br/>to represent them:<br/>
# Here are two simple sets<br/>primes = Set[2, 3, 5, 7]<br/>odds = Set[1, 3, 5, 7, 9]<br/>
# The intersection is the set of values that appear in both<br/>primes &amp; odds &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; #&lt;Set: {5, 7, 3}&gt;<br/>primes.intersection(odds) # this is an explicitly named alias<br/>
# The union is the set of values that appear in either<br/>primes | odds &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; #&lt;Set: {5, 1, 7, 2, 3, 9}&gt;<br/>primes.union(odds) &#160; &#160; &#160; &#160;# an explicitly named alias<br/>
# a-b: is the elements of a except for those also in b<br/>primes-odds &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; #&lt;Set: {2}&gt;<br/>odds-primes &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; #&lt;Set: {1, 9}&gt;<br/>primes.difference(odds) &#160; # A named method alias<br/>
# a^b is the set of values that appear in one set but not both: (a|b)-(a&amp;b)<br/>primes ^ odds &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; #&lt;Set: {1, 2, 9}&gt;<br/>
The&#160;Set&#160;class&#160;also&#160;defines&#160;mutating&#160;variants&#160;of&#160;some&#160;of&#160;these&#160;methods;&#160;we’ll&#160;consider<br/>them shortly.<br/>
<b>9.5.4.3 &#160;Adding and deleting set elements<br/></b>This&#160;&#160;section&#160;&#160;describes&#160;&#160;methods&#160;&#160;that&#160;&#160;add&#160;&#160;or&#160;&#160;remove&#160;&#160;elements&#160;&#160;from&#160;&#160;a&#160;&#160;set.&#160;&#160;They&#160;&#160;are<br/>mutator&#160;methods&#160;that&#160;modify&#160;the&#160;receiver&#160;set&#160;in&#160;place&#160;rather&#160;than&#160;returning&#160;a&#160;modified<br/>copy&#160;and&#160;leaving&#160;the&#160;original&#160;unchanged.&#160;Because&#160;these&#160;methods&#160;do&#160;not&#160;exist&#160;in&#160;non-<br/>mutating versions, they do not have an exclamation point suffix.<br/>The&#160;&lt;&lt;&#160;operator adds a single element to a set:<br/>
s = Set[] &#160; &#160; &#160; &#160; &#160; &#160; &#160;# start with an empty set<br/>s &lt;&lt; 1 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; #&lt;Set: {1}&gt;<br/>s.add 2 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; #&lt;Set: {1, 2}&gt;: add is a synonym for &lt;&lt;<br/>s &lt;&lt; 3 &lt;&lt; 4 &lt;&lt; 5 &#160; &#160; &#160; # =&gt; #&lt;Set: {5, 1, 2, 3, 4}&gt;: can be chained<br/>s.add 3 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; #&lt;Set: {5, 1, 2, 3, 4}&gt;: value unchanged<br/>s.add? 6 &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; #&lt;Set: {5, 6, 1, 2, 3, 4}&gt;<br/>s.add? 3 &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; nil: the set was not changed&#160;<br/>
To&#160;add&#160;more&#160;than&#160;one&#160;value&#160;to&#160;a&#160;set,&#160;use&#160;the&#160;merge&#160;method,&#160;which&#160;can&#160;take&#160;any&#160;enu-<br/>merable&#160;&#160;object&#160;&#160;as&#160;&#160;its&#160;&#160;argument.&#160;&#160;merge&#160;&#160;is&#160;&#160;effectively&#160;&#160;a&#160;&#160;mutating&#160;&#160;version&#160;&#160;of&#160;&#160;the&#160;&#160;union<br/>method:<br/>
s = (1..3).to_set &#160; # =&gt; #&lt;Set: {1, 2, 3}&gt;<br/>s.merge(2..5) &#160; &#160; &#160; # =&gt; #&lt;Set: {5, 1, 2, 3, 4}&gt;<br/>
<b>348&#160;|&#160;Chapter 9:</b> <b>The Ruby Platform</b><br/>
<hr/>
<a name=363></a>To&#160;remove&#160;a&#160;single&#160;element&#160;from&#160;a&#160;set,&#160;use&#160;delete&#160;or&#160;delete?, which&#160;are analogous to<br/>add&#160;and&#160;add?&#160;but do not have an operator equivalent:<br/>
s = (1..3).to_set &#160; # =&gt; #&lt;Set: {1, 2, 3}&gt;<br/>s.delete 1 &#160; &#160; &#160; &#160; &#160;# =&gt; #&lt;Set: {2, 3}&gt;<br/>s.delete 1 &#160; &#160; &#160; &#160; &#160;# =&gt; #&lt;Set: {2, 3}&gt;: unchanged<br/>s.delete? 1 &#160; &#160; &#160; &#160; # =&gt; nil: returns nil when no change<br/>s.delete? 2 &#160; &#160; &#160; &#160; # =&gt; #&lt;Set: {3}&gt;: otherwise returns set<br/>
Remove&#160;multiple&#160;values&#160;from&#160;a&#160;set&#160;at&#160;once&#160;with&#160;subtract.&#160;The&#160;argument&#160;to&#160;this&#160;method<br/>can&#160;&#160;be&#160;&#160;any&#160;&#160;enumerable&#160;&#160;object,&#160;&#160;and&#160;&#160;the&#160;&#160;method&#160;&#160;acts&#160;&#160;as&#160;&#160;a&#160;&#160;mutating&#160;&#160;version&#160;&#160;of&#160;&#160;the<br/>difference&#160;method:<br/>
s = (1..3).to_set &#160; # =&gt; #&lt;Set: {1, 2, 3}&gt;<br/>s.subtract(2..10) &#160; # =&gt; #&lt;Set: {1}&gt;<br/>
To&#160;selectively&#160;delete&#160;elements&#160;from&#160;a&#160;set,&#160;use&#160;delete_if&#160;or&#160;reject!.&#160;Just&#160;as&#160;with&#160;the<br/>Array&#160;and&#160;Hash&#160;classes, these two methods are equivalent except for their return value<br/>when the set is unmodified.&#160;delete_if&#160;always returns the receiver set.&#160;reject!&#160;returns<br/>the receiver set if it was modified, or&#160;nil&#160;if no values were removed from it:<br/>
primes = Set[2, 3, 5, 7] &#160; &#160; &#160; # set of prime numbers<br/>primes.delete_if {|x| x%2==1} &#160;# =&gt; #&lt;Set: {2}&gt;: remove odds<br/>primes.delete_if {|x| x%2==1} &#160;# =&gt; #&lt;Set: {2}&gt;: unchanged<br/>primes.reject! {|x| x%2==1} &#160; &#160;# =&gt; nil: unchanged<br/>
# Do an in-place intersection like this:<br/>s = (1..5).to_set<br/>t = (4..8).to_set<br/>s.reject! {|x| not t.include? x} &#160;# =&gt; #&lt;Set: {5, 4}&gt;<br/>
Finally, the&#160;clear&#160;and&#160;replace&#160;methods work just as they do for arrays and hashes:<br/>
s = Set.new(1..3) # Initial set<br/>s.replace(3..4) &#160; # Replace all elements. &#160;Argument is any enumerable<br/>s.clear &#160; &#160; &#160; &#160; &#160; # =&gt; #&lt;Set: {}&gt;<br/>s.empty? &#160; &#160; &#160; &#160; &#160;# =&gt; true<br/>
<b>9.5.4.4 &#160;Set iterators<br/></b>Sets&#160;are&#160;Enumerable,&#160;and&#160;the&#160;Set&#160;class&#160;defines&#160;an&#160;each&#160;iterator&#160;that&#160;yields&#160;each&#160;of&#160;the&#160;set<br/>elements&#160;once.&#160;In&#160;Ruby&#160;1.9,&#160;Set&#160;behaves&#160;like&#160;the&#160;Hash&#160;class&#160;on&#160;which&#160;it&#160;is&#160;implemented<br/>and&#160;iterates&#160;elements&#160;in&#160;the&#160;order&#160;in&#160;which&#160;they&#160;were&#160;inserted.&#160;Prior&#160;to&#160;Ruby&#160;1.9&#160;the<br/>iteration&#160;order&#160;is&#160;arbitrary.&#160;For&#160;SortedSet,&#160;the&#160;elements&#160;are&#160;yielded&#160;in&#160;their&#160;ascending<br/>sorted&#160;order.&#160;In&#160;addition,&#160;the&#160;map!&#160;iterator&#160;transforms&#160;each&#160;element&#160;of&#160;the&#160;set&#160;with&#160;a<br/>block, altering the set in place.&#160;collect!&#160;is a synonym:<br/>
s = Set[1, 2, 3, 4, 5] # =&gt; #&lt;Set: {5, 1, 2, 3, 4}&gt;<br/>s.each {|x| print x } &#160;# prints &#34;51234&#34;: arbitrary order before Ruby 1.9<br/>s.map! {|x| x*x } &#160; &#160; &#160;# =&gt; #&lt;Set: {16, 1, 25, 9, 4}&gt;<br/>s.collect! {|x| x/2 } &#160;# =&gt; #&lt;Set: {0, 12, 2, 8, 4}&gt;<br/>
<b>9.5 &#160;Collections&#160;|&#160;349</b><br/>
<hr/>
<a name=364></a><b>9.5.4.5 &#160;Miscellaneous set methods<br/></b>Set&#160;defines&#160;powerful&#160;methods&#160;for&#160;partitioning&#160;sets&#160;into&#160;subsets&#160;and&#160;for&#160;flattening&#160;sets<br/>of&#160;subsets&#160;into&#160;single&#160;larger&#160;sets.&#160;In&#160;addition,&#160;it&#160;defines&#160;a&#160;few&#160;mundane&#160;methods&#160;that<br/>we will cover first:<br/>
s = (1..3).to_set<br/>s.to_a &#160; &#160; &#160; &#160; &#160;# =&gt; [1, 2, 3]<br/>s.to_s &#160; &#160; &#160; &#160; &#160;# =&gt; &#34;#&lt;Set:0xb7e8f938&gt;&#34;: not useful<br/>s.inspect &#160; &#160; &#160; # =&gt; &#34;#&lt;Set: {1, 2, 3}&gt;&#34;: useful &#160; &#160; &#160;&#160;<br/>s == Set[3,2,1] # =&gt; true: uses eql? to compare set elements<br/>
The&#160;classify&#160;method&#160;expects&#160;a&#160;block&#160;and&#160;yields&#160;each&#160;set&#160;element&#160;to&#160;that&#160;block&#160;in&#160;turn.<br/>The&#160;return&#160;value&#160;is&#160;a&#160;hash&#160;that&#160;maps&#160;block&#160;return&#160;values&#160;to&#160;sets&#160;of&#160;elements&#160;that&#160;returned<br/>that value:<br/>
# Classify set elements as even or odd<br/>s = (0..3).to_set &#160; &#160; # =&gt; #&lt;Set: {0, 1, 2, 3}&gt;<br/>s.classify {|x| x%2} &#160;# =&gt; {0=&gt;#&lt;Set: {0, 2}&gt;, 1=&gt;#&lt;Set: {1, 3}&gt;}<br/>
The&#160;divide&#160;method&#160;is&#160;similar&#160;but&#160;returns&#160;a&#160;set&#160;of&#160;subsets&#160;rather&#160;than&#160;hash&#160;mapping<br/>values to subsets:<br/>
s.divide {|x| x%2} &#160;# =&gt; #&lt;Set: {#&lt;Set: {0, 2}&gt;, #&lt;Set: {1, 3}&gt;}&gt;<br/>
divide&#160;works&#160;completely&#160;differently&#160;if&#160;the&#160;associated&#160;block&#160;expects&#160;two&#160;arguments.&#160;In<br/>this&#160;case,&#160;the&#160;block&#160;should&#160;return&#160;true&#160;if&#160;the&#160;two&#160;values&#160;belong&#160;in&#160;the&#160;same&#160;subset,&#160;and<br/>false&#160;otherwise:<br/>
s = %w[ant ape cow hen hog].to_set # A set of words<br/>s.divide {|x,y| x[0] == y[0]} &#160; &#160; &#160;# Divide into subsets by first letter<br/># =&gt; #&lt;Set:{#&lt;Set:{&#34;hog&#34;, &#34;hen&#34;}&gt;, #&lt;Set:{&#34;cow&#34;}&gt;, #&lt;Set:{&#34;ape&#34;, &#34;ant&#34;}&gt;}&gt;<br/>
If&#160;you&#160;have&#160;a&#160;set&#160;of&#160;sets&#160;(which&#160;may&#160;themselves&#160;include&#160;sets,&#160;recursively),&#160;you&#160;can&#160;flatten<br/>it,&#160;effectively&#160;merging&#160;(by&#160;union)&#160;all&#160;the&#160;contained&#160;sets&#160;with&#160;the&#160;flatten&#160;method,&#160;or&#160;the<br/>flatten!&#160;method, which performs the operation in place:<br/>
s = %w[ant ape cow hen hog].to_set # A set of words<br/>t = s.divide {|x,y| x[0] == y[0]} &#160;# Divide it into subsets<br/>t.flatten! &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Flatten the subsets<br/>t == s &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; true<br/>
<b>9.6 &#160;Files and Directories<br/></b>The&#160;File&#160;class&#160;defines&#160;quite&#160;a&#160;few&#160;class&#160;methods&#160;for&#160;working&#160;with&#160;files&#160;as&#160;entries&#160;in&#160;a<br/>filesystem:&#160;methods&#160;for&#160;testing&#160;the&#160;size&#160;or&#160;existence&#160;of&#160;a&#160;named&#160;file,&#160;for&#160;example,&#160;and<br/>methods&#160;for&#160;separating&#160;a&#160;filename&#160;from&#160;the&#160;directory&#160;name&#160;that&#160;precedes&#160;it.&#160;These&#160;are<br/>class&#160;methods&#160;and&#160;they&#160;do&#160;not&#160;operate&#160;on&#160;File&#160;objects;&#160;instead,&#160;filenames&#160;are&#160;specified<br/>as strings. Similarly, the&#160;Dir&#160;class&#160;defines&#160;class&#160;methods&#160;for&#160;working&#160;with&#160;and&#160;reading<br/>filenames&#160;from&#160;filesystem&#160;directories.&#160;The&#160;subsections&#160;that&#160;follow&#160;demonstrate&#160;how&#160;to:<br/>
•&#160;Work with and manipulate filenames and directory names<br/>
<b>350&#160;|&#160;Chapter 9:</b> <b>The Ruby Platform</b><br/>
<hr/>
<a name=365></a>•&#160;List directories<br/>•&#160;Test files to determine their type, size, modification time, and other attributes<br/>•&#160;Delete, rename, and perform similar operations on files and directories<br/>
Note&#160;that&#160;the&#160;methods&#160;described&#160;here&#160;query&#160;and&#160;manipulate&#160;files,&#160;but&#160;do&#160;not&#160;read&#160;or<br/>write file&#160;<i>content</i><a href="Rubys.html#370">. Reading and writing files is covered in §9.7.</a><br/>
<b>Specifying Filenames in Ruby 1.9</b><br/>
Many&#160;of&#160;the&#160;file&#160;and&#160;directory&#160;methods&#160;described&#160;in&#160;this&#160;section&#160;expect&#160;one&#160;or&#160;more<br/>arguments&#160;&#160;that&#160;&#160;name&#160;&#160;files.&#160;&#160;Normally,&#160;&#160;you&#160;&#160;specify&#160;&#160;filenames&#160;&#160;and&#160;&#160;directory&#160;&#160;paths&#160;&#160;as<br/>strings.&#160;In&#160;Ruby&#160;1.9,&#160;you&#160;can&#160;also&#160;use&#160;nonstring&#160;objects&#160;if&#160;they&#160;have&#160;a&#160;to_path&#160;method&#160;<br/>that returns a string.<br/>
<b>9.6.1 &#160;File and Directory Names<br/></b>The&#160;class&#160;methods&#160;of&#160;the&#160;File&#160;and&#160;Dir&#160;classes&#160;operate&#160;on&#160;files&#160;and&#160;directories&#160;specified<br/>by&#160;name.&#160;Ruby&#160;uses&#160;Unix-style&#160;filenames&#160;with&#160;/&#160;as&#160;the&#160;directory&#160;separator&#160;character.<br/>You&#160;can&#160;use&#160;the&#160;forward&#160;slash&#160;character&#160;in&#160;your&#160;filenames,&#160;even&#160;when&#160;using&#160;Ruby&#160;on<br/>a&#160;Windows&#160;platform.&#160;On&#160;Windows,&#160;Ruby&#160;can&#160;also&#160;handle&#160;filenames&#160;that&#160;use&#160;the&#160;back-<br/>slash&#160;character&#160;and&#160;that&#160;include&#160;drive&#160;letter&#160;prefixes.&#160;The&#160;constant&#160;File::SEPARATOR<br/>should be&#160;'/'&#160;in all implementations.&#160;File::ALT_SEPARATOR&#160;is&#160;'\'&#160;on Windows,&#160;and is<br/>nil&#160;on other platforms.<br/>
The&#160;File&#160;class defines some methods for manipulating filenames:<br/>
full = '/home/matz/bin/ruby.exe'<br/>file=File.basename(full) &#160; &#160; # =&gt; 'ruby.exe': just the local filename<br/>File.basename(full, '.exe') &#160;# =&gt; 'ruby': with extension stripped<br/>dir=File.dirname(full) &#160; &#160; &#160; # =&gt; '/home/matz/bin': no / at end<br/>File.dirname(file) &#160; &#160; &#160; &#160; &#160; # =&gt; '.': current directory<br/>File.split(full) &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; ['/home/matz/bin', 'ruby.exe']<br/>File.extname(full) &#160; &#160; &#160; &#160; &#160; # =&gt; '.exe'<br/>File.extname(file) &#160; &#160; &#160; &#160; &#160; # =&gt; '.exe'<br/>File.extname(dir) &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; ''<br/>File.join('home','matz') &#160; &#160; # =&gt; 'home/matz': relative<br/>File.join('','home','matz') &#160;# =&gt; '/home/matz': absolute<br/>
The&#160;File.expand_path&#160;method&#160;converts&#160;a&#160;relative&#160;path&#160;to&#160;a&#160;fully&#160;qualified&#160;path.&#160;If&#160;the<br/>optional&#160;second&#160;argument&#160;is&#160;supplied,&#160;it&#160;is&#160;first&#160;prepended&#160;as&#160;a&#160;directory&#160;to&#160;the&#160;first<br/>argument.&#160;The&#160;result&#160;is&#160;then&#160;converted&#160;to&#160;an&#160;absolute&#160;path.&#160;If&#160;it&#160;begins&#160;with&#160;a&#160;Unix-<br/>style&#160;~,&#160;the&#160;directory&#160;is&#160;relative&#160;to&#160;the&#160;current&#160;user&#160;or&#160;specified&#160;user’s&#160;home&#160;directory.<br/>Otherwise,&#160;&#160;the&#160;&#160;directory&#160;&#160;is&#160;&#160;resolved&#160;&#160;relative&#160;&#160;to&#160;&#160;the&#160;&#160;current&#160;&#160;working&#160;&#160;directory&#160;&#160;(see<br/>Dir.chdir&#160;below to change the working directory):<br/>
Dir.chdir(&#34;/usr/bin&#34;) &#160; &#160; &#160;# Current working directory is &#34;/usr/bin&#34;<br/>File.expand_path(&#34;ruby&#34;) &#160; &#160; &#160; # =&gt; &#34;/usr/bin/ruby&#34;<br/>File.expand_path(&#34;~/ruby&#34;) &#160; &#160; # =&gt; &#34;/home/david/ruby&#34;<br/>File.expand_path(&#34;~matz/ruby&#34;) # =&gt; &#34;/home/matz/ruby&#34;<br/>
<b>9.6 &#160;Files and Directories&#160;|&#160;351</b><br/>
<hr/>
<a name=366></a>File.expand_path(&#34;ruby&#34;, &#34;/usr/local/bin&#34;) # =&gt; &#34;/usr/local/bin/ruby&#34;<br/>File.expand_path(&#34;ruby&#34;, &#34;../local/bin&#34;) &#160; # =&gt; &#34;/usr/local/bin/ruby&#34;<br/>File.expand_path(&#34;ruby&#34;, &#34;~/bin&#34;) &#160; &#160; &#160; &#160; &#160;# =&gt; &#34;/home/david/bin/ruby&#34;<br/>
The&#160;File.identical?&#160;method&#160;tests&#160;whether&#160;two&#160;filenames&#160;refer&#160;to&#160;the&#160;same&#160;file.&#160;This<br/>might&#160;be&#160;because&#160;the&#160;names&#160;are&#160;the&#160;same,&#160;but&#160;it&#160;is&#160;a&#160;more&#160;useful&#160;method&#160;when&#160;the<br/>names&#160;differ.&#160;Two&#160;different&#160;names&#160;might&#160;refer&#160;to&#160;the&#160;same&#160;file&#160;if&#160;one&#160;is&#160;a&#160;relative&#160;filename<br/>and&#160;the&#160;other&#160;is&#160;absolute,&#160;for&#160;example.&#160;One&#160;might&#160;include&#160;“..”&#160;to&#160;go&#160;up&#160;a&#160;level&#160;and<br/>then&#160;down&#160;again.&#160;Or,&#160;two&#160;different&#160;names&#160;might&#160;refer&#160;to&#160;the&#160;same&#160;file&#160;if&#160;one&#160;name&#160;is&#160;a<br/>symbolic&#160;link&#160;or&#160;shortcut&#160;(or&#160;hard&#160;link&#160;on&#160;platforms&#160;that&#160;support&#160;it)&#160;to&#160;the&#160;other.&#160;Note,<br/>however,&#160;that&#160;File.identical?&#160;only&#160;returns&#160;true&#160;if&#160;the&#160;two&#160;names&#160;refer&#160;to&#160;the&#160;same&#160;file<br/>and&#160;&#160;that&#160;&#160;file&#160;&#160;actually&#160;&#160;exists.&#160;&#160;Also&#160;&#160;note&#160;&#160;that&#160;&#160;File.identical?&#160;&#160;does&#160;&#160;not&#160;&#160;expand&#160;&#160;the&#160;&#160;~<br/>character for home directories the way that&#160;File.expand_path&#160;does:<br/>
File.identical?(&#34;ruby&#34;, &#34;ruby&#34;) &#160; &#160; &#160; &#160; &#160;# =&gt; true if the file exists<br/>File.identical?(&#34;ruby&#34;, &#34;/usr/bin/ruby&#34;) # =&gt; true if CWD is /usr/bin<br/>File.identical?(&#34;ruby&#34;, &#34;../bin/ruby&#34;) &#160; # =&gt; true if CWD is /usr/bin<br/>File.identical?(&#34;ruby&#34;, &#34;ruby1.9&#34;) &#160; &#160; &#160; # =&gt; true if there is a link<br/>
Finally,&#160;File.fnmatch&#160;tests&#160;whether&#160;a&#160;filename&#160;matches&#160;a&#160;specified&#160;pattern.&#160;The&#160;pattern<br/>is&#160;not&#160;a&#160;regular&#160;expression,&#160;but&#160;is&#160;like&#160;the&#160;file-matching&#160;patterns&#160;used&#160;in&#160;shells.&#160;“?”<br/>matches a single character.&#160;“*”&#160;matches&#160;any&#160;number&#160;of&#160;characters.&#160;And&#160;“**” matches<br/>any&#160;number&#160;of&#160;directory&#160;levels.&#160;Characters&#160;in&#160;square&#160;brackets&#160;are&#160;alternatives,&#160;as&#160;in<br/>regular&#160;&#160;expressions.&#160;&#160;fnmatch&#160;&#160;does&#160;&#160;not&#160;&#160;allow&#160;&#160;alternatives&#160;&#160;in&#160;&#160;curly&#160;&#160;braces&#160;&#160;(as&#160;&#160;the<br/>Dir.glob&#160;method&#160;described&#160;below&#160;does).&#160;fnmatch&#160;should&#160;usually&#160;be&#160;invoked&#160;with&#160;a&#160;third<br/>argument&#160;&#160;of&#160;&#160;File::FNM_PATHNAME,&#160;&#160;which&#160;&#160;prevents&#160;&#160;“*”&#160;&#160;from&#160;&#160;matching&#160;&#160;“/”.&#160;&#160;Add<br/>File::FNM_DOTMATCH&#160;if&#160;you&#160;want&#160;“hidden”&#160;files&#160;and&#160;directories&#160;whose&#160;names&#160;begin&#160;with<br/>“.”&#160;to&#160;match.&#160;Only&#160;a&#160;few&#160;examples&#160;of&#160;fnmatch&#160;are&#160;given&#160;here.&#160;Use&#160;ri File.fnmatch&#160;for<br/>complete details. Note that&#160;File.fnmatch?&#160;is a synonym:<br/>
File.fnmatch(&#34;*.rb&#34;, &#34;hello.rb&#34;) &#160; &#160; # =&gt; true<br/>File.fnmatch(&#34;*.[ch]&#34;, &#34;ruby.c&#34;) &#160; &#160; # =&gt; true<br/>File.fnmatch(&#34;*.[ch]&#34;, &#34;ruby.h&#34;) &#160; &#160; # =&gt; true<br/>File.fnmatch(&#34;?.txt&#34;, &#34;ab.txt&#34;) &#160; &#160; &#160;# =&gt; false<br/>flags = File::FNM_PATHNAME | File::FNM_DOTMATCH<br/>File.fnmatch(&#34;lib/*.rb&#34;, &#34;lib/a.rb&#34;, flags) &#160; &#160; &#160;# =&gt; true<br/>File.fnmatch(&#34;lib/*.rb&#34;, &#34;lib/a/b.rb&#34;, flags) &#160; &#160;# =&gt; false<br/>File.fnmatch(&#34;lib/**/*.rb&#34;, &#34;lib/a.rb&#34;, flags) &#160; # =&gt; true<br/>File.fnmatch(&#34;lib/**/*.rb&#34;, &#34;lib/a/b.rb&#34;, flags) # =&gt; true<br/>
<b>9.6.2 &#160;Listing Directories<br/></b>The&#160;easiest&#160;way&#160;to&#160;list&#160;the&#160;contents&#160;of&#160;a&#160;directory&#160;is&#160;with&#160;the&#160;Dir.entries&#160;method&#160;or&#160;the<br/>Dir.foreach&#160;iterator:<br/>
# Get the names of all files in the config/ directory&#160;<br/>filenames = Dir.entries(&#34;config&#34;) &#160; &#160; &#160; &#160;# Get names as an array<br/>Dir.foreach(&#34;config&#34;) {|filename| ... } &#160;# Iterate names<br/>
<b>352&#160;|&#160;Chapter 9:</b> <b>The Ruby Platform</b><br/>
<hr/>
<a name=367></a>The&#160;names&#160;returned&#160;by&#160;these&#160;methods&#160;are&#160;not&#160;guaranteed&#160;to&#160;be&#160;in&#160;any&#160;particular&#160;order,<br/>and&#160;(on&#160;Unix-like&#160;platforms)&#160;include “.”&#160;(the&#160;current&#160;directory)&#160;and&#160;“..”&#160;(the&#160;parent<br/>directory).&#160;To&#160;obtain&#160;a&#160;list&#160;of&#160;files&#160;that&#160;match&#160;a&#160;given&#160;pattern,&#160;use&#160;the&#160;Dir.[]&#160;operator:<br/>
Dir['*.data'] &#160; &#160; &#160; # Files with the &#34;data&#34; extension<br/>Dir['ruby.*'] &#160; &#160; &#160; # Any filename beginning with &#34;ruby.&#34;<br/>Dir['?'] &#160; &#160; &#160; &#160; &#160; &#160;# Any single-character filename<br/>Dir['*.[ch]'] &#160; &#160; &#160; # Any file that ends with .c or .h<br/>Dir['*.{java,rb}'] &#160;# Any file that ends with .java or .rb<br/>Dir['*/*.rb'] &#160; &#160; &#160; # Any Ruby program in any direct sub-directory<br/>Dir['**/*.rb'] &#160; &#160; &#160;# Any Ruby program in any descendant directory<br/>
A&#160;more&#160;powerful&#160;alternative&#160;to&#160;Dir[]&#160;is&#160;Dir.glob.&#160;(The&#160;verb&#160;“glob”&#160;is&#160;an&#160;old&#160;Unix&#160;term<br/>for&#160;filename&#160;matching&#160;in&#160;a&#160;shell.)&#160;By&#160;default,&#160;this&#160;method&#160;works&#160;like&#160;Dir[],&#160;but&#160;if&#160;passed<br/>a&#160;block,&#160;it&#160;yields&#160;the&#160;matching&#160;filenames&#160;one&#160;at&#160;a&#160;time&#160;rather&#160;than&#160;returning&#160;an&#160;array.<br/>Also, the&#160;glob&#160;method&#160;accepts&#160;an&#160;optional&#160;second&#160;argument.&#160;If&#160;you&#160;pass&#160;the&#160;constant<br/>File::FNM_DOTMATCH&#160;(see&#160;File.fnmatch&#160;previously)&#160;as&#160;this&#160;second&#160;argument,&#160;then&#160;the<br/>result&#160;will&#160;include&#160;files&#160;whose&#160;names&#160;begin&#160;with&#160;“.”&#160;(on&#160;Unix&#160;systems,&#160;these&#160;files&#160;are<br/>hidden and are not returned by default):<br/>
Dir.glob('*.rb') {|f| ... } &#160; &#160; &#160;# Iterate all Ruby files<br/>Dir.glob('*') &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Does not include names beginning with '.'<br/>Dir.glob('*',File::FNM_DOTMATCH) # Include . files, just like Dir.entries<br/>
The&#160;directory&#160;listing&#160;methods&#160;shown&#160;here,&#160;and&#160;all&#160;File&#160;and&#160;Dir&#160;methods&#160;that&#160;resolve<br/>relative&#160;pathnames,&#160;do&#160;so&#160;relative&#160;to&#160;the&#160;“current&#160;working&#160;directory,”&#160;which&#160;is&#160;a&#160;value<br/>global&#160;to&#160;the&#160;Ruby&#160;interpreter&#160;process.&#160;Query&#160;and&#160;set&#160;the&#160;CWD&#160;with&#160;the&#160;getwd&#160;and<br/>chdir&#160;methods:<br/>
puts Dir.getwd &#160; &#160; &#160; &#160; &#160;# Print current working directory<br/>Dir.chdir(&#34;..&#34;) &#160; &#160; &#160; &#160; # Change CWD to the parent directory<br/>Dir.chdir(&#34;../sibling&#34;) # Change again to a sibling directory<br/>
&#160;<br/>
Dir.chdir(&#34;/home&#34;) &#160; &#160; &#160;# Change to an absolute directory<br/>Dir.chdir &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Change to user's home directory<br/>home = Dir.pwd &#160; &#160; &#160; &#160; &#160;# pwd is an alias for getwd<br/>
If&#160;you&#160;pass&#160;a&#160;block&#160;to&#160;the&#160;chdir&#160;method,&#160;the&#160;directory&#160;will&#160;be&#160;restored&#160;to&#160;its&#160;original<br/>value&#160;when&#160;the&#160;block&#160;exits.&#160;Note,&#160;however,&#160;that&#160;while&#160;the&#160;directory&#160;change&#160;is&#160;limited<br/>in&#160;duration,&#160;it&#160;is&#160;still&#160;global&#160;in&#160;scope&#160;and&#160;affects&#160;other&#160;threads.&#160;Two&#160;threads&#160;may&#160;not<br/>call&#160;Dir.chdir&#160;with a block at the same time.<br/>
<b>9.6.3 &#160;Testing Files<br/></b>File&#160;defines&#160;a&#160;slew&#160;of&#160;methods&#160;to&#160;obtain&#160;metadata&#160;about&#160;a&#160;named&#160;file&#160;or&#160;directory.<br/>Many&#160;of&#160;the&#160;methods&#160;return&#160;low-level&#160;information&#160;that&#160;is&#160;OS-dependent.&#160;Only&#160;the&#160;most<br/>portable&#160;&#160;and&#160;&#160;broadly&#160;&#160;useful&#160;&#160;are&#160;&#160;demonstrated&#160;&#160;here.&#160;&#160;Use&#160;&#160;<i>ri</i>&#160;&#160;on&#160;&#160;the&#160;&#160;File&#160;&#160;and<br/>File::Statclasses for a complete list of methods.<br/>
The&#160;following&#160;simple&#160;methods&#160;return&#160;basic&#160;information&#160;about&#160;a&#160;file.&#160;Most&#160;are&#160;predicates<br/>that return&#160;true&#160;or&#160;false:<br/>
<b>9.6 &#160;Files and Directories&#160;|&#160;353</b><br/>
<hr/>
<a name=368></a>f = &#34;/usr/bin/ruby&#34; &#160; &#160; &#160;# A filename for the examples below<br/>
# File existence and types.<br/>File.exist?(f) &#160; &#160; &#160; &#160; &#160; # Does the named file exist? Also: File.exists?<br/>File.file?(f) &#160; &#160; &#160; &#160; &#160; &#160;# Is it an existing file?<br/>File.directory?(f) &#160; &#160; &#160; # Or is it an existing directory?<br/>File.symlink?(f) &#160; &#160; &#160; &#160; # Either way, is it a symbolic link?<br/>
# File size methods. Use File.truncate to set file size.<br/>File.size(f) &#160; &#160; &#160; &#160; &#160; &#160; # File size in bytes.<br/>File.size?(f) &#160; &#160; &#160; &#160; &#160; &#160;# Size in bytes or nil if empty file.<br/>File.zero?(f) &#160; &#160; &#160; &#160; &#160; &#160;# True if file is empty.<br/>
# File permissions. Use File.chmod to set permissions (system dependent).<br/>File.readable?(f) &#160; &#160; &#160; &#160;# Can we read the file?<br/>File.writable?(f) &#160; &#160; &#160; &#160;# Can we write the file? No &#34;e&#34; in &#34;writable&#34;<br/>File.executable?(f) &#160; &#160; &#160;# Can we execute the file?<br/>File.world_readable?(f) &#160;# Can everybody read it? Ruby 1.9.<br/>File.world_writable?(f) &#160;# Can everybody write it? Ruby 1.9.<br/>
# File times/dates. Use File.utime to set the times.<br/>File.mtime(f) &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; Last modification time as a Time object<br/>File.atime(f) &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; Last access time as a Time object<br/>
Another&#160;way&#160;to&#160;determine&#160;the&#160;type&#160;(file,&#160;directory,&#160;symbolic&#160;link,&#160;etc.)&#160;of&#160;a&#160;filename&#160;is<br/>with&#160;ftype,&#160;which&#160;returns&#160;a&#160;string&#160;that&#160;names&#160;the&#160;type.&#160;Assume&#160;that&#160;<i>/usr/bin/ruby</i>&#160;is a<br/>symbolic link (or shortcut) to&#160;/usr/bin/ruby1.9:<br/>
File.ftype(&#34;/usr/bin/ruby&#34;) &#160; &#160;# =&gt; &#34;link&#34;<br/>File.ftype(&#34;/usr/bin/ruby1.9&#34;) # =&gt; &#34;file&#34;<br/>File.ftype(&#34;/usr/lib/ruby&#34;) &#160; &#160;# =&gt; &#34;directory&#34;<br/>File.ftype(&#34;/usr/bin/ruby3.0&#34;) # SystemCallError: No such file or directory<br/>
If&#160;you&#160;are&#160;interested&#160;in&#160;multiple&#160;pieces&#160;of&#160;information&#160;about&#160;a&#160;file,&#160;it&#160;may&#160;be&#160;more<br/>efficient&#160;to&#160;call&#160;stat&#160;or&#160;lstat. (stat&#160;follows&#160;symbolic&#160;links;&#160;lstat&#160;returns&#160;information<br/>about&#160;the&#160;link&#160;itself.)&#160;These&#160;methods&#160;return&#160;a&#160;File::Stat&#160;object,&#160;which&#160;has&#160;instance<br/>methods&#160;with&#160;the&#160;same&#160;names&#160;(but&#160;without&#160;arguments)&#160;as&#160;the&#160;class&#160;methods&#160;of&#160;File.<br/>The&#160;efficiency&#160;of&#160;using&#160;stat&#160;is&#160;that&#160;Ruby&#160;only&#160;has&#160;to&#160;make&#160;one&#160;call&#160;to&#160;the&#160;OS&#160;to&#160;obtain<br/>all&#160;&#160;file&#160;&#160;metadata.&#160;&#160;Your&#160;&#160;Ruby&#160;&#160;program&#160;&#160;can&#160;&#160;then&#160;&#160;obtain&#160;&#160;that&#160;&#160;information&#160;&#160;from&#160;&#160;the<br/>File::Stat&#160;object as it needs it:<br/>
s = File.stat(&#34;/usr/bin/ruby&#34;)<br/>s.file? &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; true<br/>s.directory? &#160; &#160; &#160; &#160;# =&gt; false<br/>s.ftype &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; &#34;file&#34;<br/>s.readable? &#160; &#160; &#160; &#160; # =&gt; true<br/>s.writable? &#160; &#160; &#160; &#160; # =&gt; false<br/>s.executable? &#160; &#160; &#160; # =&gt; true<br/>s.size &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; 5492<br/>s.atime &#160; &#160; &#160; &#160; &#160; &#160; # =&gt; Mon Jul 23 13:20:37 -0700 2007<br/>
Use&#160;<i>ri</i>&#160;on&#160;File::Stat&#160;for&#160;a&#160;full&#160;list&#160;of&#160;its&#160;methods.&#160;One&#160;final&#160;general-purpose&#160;file&#160;testing<br/>method&#160;&#160;is&#160;&#160;Kernel.test.&#160;&#160;It&#160;&#160;exists&#160;&#160;for&#160;&#160;historical&#160;&#160;compatibility&#160;&#160;with&#160;&#160;the&#160;&#160;Unix&#160;&#160;shell<br/>
<b>354&#160;|&#160;Chapter 9:</b> <b>The Ruby Platform</b><br/>
<hr/>
<a name=369></a>command&#160;<i>test</i>.&#160;The&#160;test&#160;method&#160;is&#160;largely&#160;obviated&#160;by&#160;the&#160;class&#160;methods&#160;of&#160;the&#160;File<br/>class, but you may see it used in existing Ruby scripts. Use&#160;<i>ri</i>&#160;for complete details:<br/>
# Testing single files<br/>test ?e, &#34;/usr/bin/ruby&#34; &#160; # File.exist?(&#34;/usr/bin/ruby&#34;)<br/>test ?f, &#34;/usr/bin/ruby&#34; &#160; # File.file?(&#34;/usr/bin/ruby&#34;)<br/>test ?d, &#34;/usr/bin/ruby&#34; &#160; # File.directory?(&#34;/usr/bin/ruby&#34;)<br/>test ?r, &#34;/usr/bin/ruby&#34; &#160; # File.readable?(&#34;/usr/bin/ruby&#34;)<br/>test ?w, &#34;/usr/bin/ruby&#34; &#160; # File.writeable?(&#34;/usr/bin/ruby&#34;)<br/>test ?M, &#34;/usr/bin/ruby&#34; &#160; # File.mtime(&#34;/usr/bin/ruby&#34;)<br/>test ?s, &#34;/usr/bin/ruby&#34; &#160; # File.size?(&#34;/usr/bin/ruby&#34;)<br/>
# Comparing two files f and g<br/>test ?-, f, g &#160; &#160; &#160; &#160; &#160; &#160; &#160;# File.identical(f,g)<br/>test ?&lt;, f, g &#160; &#160; &#160; &#160; &#160; &#160; &#160;# File(f).mtime &lt; File(g).mtime<br/>test ?&gt;, f, g &#160; &#160; &#160; &#160; &#160; &#160; &#160;# File(f).mtime &gt; File(g).mtime<br/>test ?=, f, g &#160; &#160; &#160; &#160; &#160; &#160; &#160;# File(f).mtime == File(g).mtime<br/>
<b>9.6.4 &#160;Creating, Deleting, and Renaming Files and Directories<br/></b>The&#160;File&#160;class&#160;does&#160;not&#160;define&#160;any&#160;special&#160;methods&#160;for&#160;creating&#160;a&#160;file.&#160;To&#160;create&#160;one,<br/>simply&#160;open&#160;it&#160;for&#160;writing,&#160;write&#160;zero&#160;or&#160;more&#160;bytes,&#160;and&#160;close&#160;it&#160;again.&#160;If&#160;you&#160;don’t<br/>want to clobber an existing file, open it in append mode:<br/>
# Create (or overwrite) a file named &#34;test&#34;<br/>File.open(&#34;test&#34;, &#34;w&#34;) {}<br/># Create (but do not clobber) a file named &#34;test&#34;<br/>File.open(&#34;test&#34;, &#34;a&#34;) {}<br/>
To&#160;copy&#160;a&#160;file,&#160;use&#160;File.copy_stream,&#160;&#160;specifying&#160;filenames&#160;as&#160;the&#160;source&#160;and&#160;destina-<br/>tion:<br/>
File.copy_stream(&#34;test&#34;, &#34;test.backup&#34;)<br/>
To change the name of a file, use&#160;File.rename:<br/>
File.rename(&#34;test&#34;, &#34;test.old&#34;) &#160; &#160; # Current name, then new name<br/>
To create a symbolic link to a file, use&#160;File.symlink:<br/>
File.symlink(&#34;test.old&#34;, &#34;oldtest&#34;) # Link target, link name<br/>
On systems that support it, you can create a “hard link” with&#160;File.link:<br/>
File.link(&#34;test.old&#34;, &#34;test2&#34;) &#160; # Link target, link name<br/>
Finally, to delete a file or link, use&#160;File.delete, or its synonym&#160;File.unlink:<br/>
File.delete(&#34;test2&#34;) &#160; # May also be called with multiple args<br/>File.unlink(&#34;oldtest&#34;) # to delete multiple named files<br/>
On&#160;systems&#160;that&#160;support&#160;it,&#160;use&#160;File.truncate&#160;to&#160;truncate&#160;a&#160;file&#160;to&#160;a&#160;specified&#160;number<br/>(possibly&#160;zero)&#160;of&#160;bytes.&#160;Use&#160;File.utime&#160;to&#160;set&#160;the&#160;access&#160;and&#160;modification&#160;times&#160;of&#160;a<br/>file.&#160;And&#160;use&#160;the&#160;platform-dependent&#160;method&#160;File.chmod&#160;to&#160;change&#160;the&#160;permissions&#160;of<br/>a file:<br/>
<b>9.6 &#160;Files and Directories&#160;|&#160;355</b><br/>
<hr/>
<a name=370></a>f = &#34;log.messages&#34; &#160; &#160; &#160; &#160; &#160;# Filename<br/>atime = mtime = Time.now &#160; &#160;# New access and modify times<br/>File.truncate(f, 0) &#160; &#160; &#160; &#160; # Erase all existing content<br/>File.utime(atime, mtime, f) # Change times<br/>File.chmod(0600, f) &#160; &#160; &#160; &#160; # Unix permissions -rw-------; note octal arg<br/>
To&#160;create&#160;a&#160;new&#160;directory,&#160;use&#160;Dir.mkdir. To&#160;delete&#160;a&#160;directory,&#160;use&#160;Dir.rmdir&#160;or&#160;one<br/>of its synonyms,&#160;Dir.delete&#160;or&#160;Dir.unlink. The directory must be empty before it can<br/>be deleted:<br/>
Dir.mkdir(&#34;temp&#34;) &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Create a directory<br/>File.open(&#34;temp/f&#34;, &#34;w&#34;) {} &#160; &#160; &#160; # Create a file in it<br/>File.open(&#34;temp/g&#34;, &#34;w&#34;) {} &#160; &#160; &#160; # Create another one<br/>File.delete(*Dir[&#34;temp/*&#34;]) &#160; &#160; &#160; # Delete all files in the directory<br/>Dir.rmdir(&#34;temp&#34;) &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Delete the directory<br/>
<b>9.7 &#160;Input/Output<br/></b>An&#160;IO&#160;object is&#160;a&#160;stream:&#160;a&#160;readable&#160;source&#160;of&#160;bytes&#160;or&#160;characters&#160;or&#160;a&#160;writable&#160;sink&#160;for<br/>bytes&#160;or&#160;characters.&#160;The&#160;File&#160;class&#160;is&#160;a&#160;subclass&#160;of&#160;IO.&#160;IO&#160;objects&#160;also&#160;represent&#160;the<br/>“standard&#160;input”&#160;and&#160;“standard&#160;output”&#160;streams&#160;used&#160;to&#160;read&#160;from&#160;and&#160;write&#160;to&#160;the<br/>console.&#160;&#160;The&#160;&#160;stringio&#160;&#160;module&#160;&#160;in&#160;&#160;the&#160;&#160;standard&#160;&#160;library&#160;&#160;allows&#160;&#160;us&#160;&#160;to&#160;&#160;create&#160;&#160;a&#160;&#160;stream<br/>wrapper&#160;&#160;around&#160;&#160;a&#160;&#160;string&#160;&#160;object.&#160;&#160;Finally,&#160;&#160;the&#160;&#160;socket&#160;&#160;objects&#160;&#160;used&#160;&#160;in&#160;&#160;networking<br/>(described later in this chapter) are also&#160;IO&#160;objects.<br/>
<b>9.7.1 &#160;Opening Streams<br/></b>Before&#160;we&#160;can&#160;perform&#160;input&#160;or&#160;output,&#160;we&#160;must&#160;have&#160;an&#160;IO&#160;object&#160;to&#160;read&#160;from&#160;or&#160;write<br/>to. The&#160;IO&#160;class defines factory&#160;methods&#160;new,&#160;open,&#160;popen, and&#160;pipe, but these are low-<br/>level&#160;methods&#160;with&#160;operating&#160;system&#160;dependencies,&#160;and&#160;they&#160;are&#160;not&#160;documented&#160;here.<br/>The&#160;subsections&#160;that&#160;follow&#160;describe&#160;more&#160;common&#160;ways&#160;to&#160;obtain&#160;IO&#160;objects.&#160;(And<br/><a href="Rubys.html#380">§9.8 includes examples that create&#160;</a>IO&#160;objects that communicate across the network.)<br/>
<b>9.7.1.1 &#160;Opening files<br/></b>One&#160;of&#160;the&#160;most&#160;common&#160;kinds&#160;of&#160;IO&#160;is&#160;the&#160;reading&#160;and&#160;writing&#160;of&#160;files.&#160;The&#160;File&#160;class<br/>defines&#160;some&#160;utility&#160;methods&#160;(described&#160;below)&#160;that&#160;read&#160;the&#160;entire&#160;contents&#160;of&#160;a&#160;file<br/>with&#160;one&#160;call.&#160;Often,&#160;however,&#160;you&#160;will&#160;instead&#160;open&#160;a&#160;file&#160;to&#160;obtain&#160;a&#160;File&#160;object and<br/>then use&#160;IO&#160;methods to read from or write to the file.<br/>Use&#160;File.open&#160;(or&#160;File.new)&#160;to&#160;open&#160;a&#160;file.&#160;The&#160;first&#160;argument&#160;is&#160;the&#160;name&#160;of&#160;the&#160;file.<br/>This&#160;is&#160;usually&#160;specified&#160;as&#160;a&#160;string,&#160;but&#160;in&#160;Ruby&#160;1.9,&#160;you&#160;can&#160;use&#160;any&#160;object&#160;with&#160;a<br/>to_path&#160;method.&#160;Filenames&#160;are&#160;interpreted&#160;relative&#160;to&#160;the&#160;current&#160;working&#160;directory<br/>unless&#160;they&#160;are&#160;specified&#160;with&#160;an&#160;absolute&#160;path.&#160;Use&#160;forward&#160;slash&#160;characters&#160;to&#160;separate<br/>directories—Ruby&#160;&#160;automatically&#160;&#160;converts&#160;&#160;them&#160;&#160;into&#160;&#160;backslashes&#160;&#160;on&#160;&#160;Windows.&#160;&#160;The<br/>second&#160;argument&#160;to&#160;File.open&#160;is&#160;a&#160;short&#160;string&#160;that&#160;specifies&#160;how&#160;the&#160;file&#160;should&#160;be<br/>opened:<br/>
<b>356&#160;|&#160;Chapter 9:</b> <b>The Ruby Platform</b><br/>
<hr/>
<a name=371></a>f = File.open(&#34;data.txt&#34;, &#34;r&#34;) &#160; # Open file data.txt for reading<br/>out = File.open(&#34;out.txt&#34;, &#34;w&#34;) &#160;# Open file out.txt for writing<br/>
The&#160;second&#160;argument&#160;to&#160;File.open&#160;is&#160;a&#160;string&#160;that&#160;specifies&#160;the&#160;“file&#160;mode.”&#160;It&#160;must<br/>begin&#160;with&#160;one&#160;of&#160;the&#160;values&#160;in&#160;the&#160;following&#160;table.&#160;Add&#160;&#34;b&#34;&#160;to&#160;the&#160;mode&#160;string&#160;to&#160;prevent<br/>automatic&#160;line&#160;terminator&#160;conversion&#160;on&#160;Windows&#160;platforms.&#160;For&#160;text&#160;files,&#160;you&#160;may<br/>add&#160;the&#160;name&#160;of&#160;a&#160;character&#160;encoding&#160;to&#160;the&#160;mode&#160;string.&#160;For&#160;binary&#160;files,&#160;you&#160;should<br/>add&#160;&#34;:binary&#34;<a href="Rubys.html#373">&#160;to the string. This is explained in §9.7.2.</a><br/>
<b>Mode</b><br/>
<b>Description</b><br/>
&#34;r&#34;<br/>
Open for reading. The default mode.<br/>
&#34;r+&#34;<br/>
Open for reading and writing. Start at beginning of file. Fail if file does not exist.<br/>
&#34;w&#34;<br/>
Open for writing. Create a new file or truncate an existing one.<br/>
&#34;w+&#34;<br/>
Like&#160;&#34;w&#34;, but allows reading of the file as well.<br/>
&#34;a&#34;<br/>
Open for writing, but append to the end of the file if it already exists.<br/>
&#34;a+&#34;<br/>
Like&#160;&#34;a&#34;, but allows reads also.<br/>
File.open&#160;(but&#160;not&#160;File.new)&#160;may&#160;be&#160;followed&#160;by&#160;a&#160;block.&#160;If&#160;a&#160;block&#160;is&#160;provided,&#160;then<br/>File.open&#160;doesn’t&#160;return&#160;the&#160;File&#160;object&#160;but&#160;instead&#160;passes&#160;it&#160;to&#160;the&#160;block,&#160;and&#160;auto-<br/>matically&#160;closes&#160;it&#160;when&#160;the&#160;block&#160;exits.&#160;The&#160;return&#160;value&#160;of&#160;the&#160;block&#160;becomes&#160;the<br/>return value of&#160;File.open:<br/>
File.open(&#34;log.txt&#34;, &#34;a&#34;) do |log| &#160; &#160; &#160;# Open for appending<br/>&#160; log.puts(&#34;INFO: Logging a message&#34;) &#160; # Output to the file<br/>end &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Automatically closed<br/>
<b>9.7.1.2 &#160;Kernel.open<br/></b>The&#160;Kernel&#160;method&#160;open&#160;works&#160;like&#160;File.open&#160;but&#160;is&#160;more&#160;flexible.&#160;If&#160;the&#160;filename&#160;begins<br/>with&#160;|, it is treated as an operating system command, and the returned stream is used<br/>for&#160;reading&#160;from&#160;and&#160;writing&#160;to&#160;that&#160;command&#160;process.&#160;This&#160;is&#160;platform-dependent,&#160;of<br/>course:<br/>
# How long has the server been up?<br/>uptime = open(&#34;|uptime&#34;) {|f| f.gets }<br/>
If&#160;the&#160;open-uri&#160;library&#160;has&#160;been&#160;loaded,&#160;then&#160;open&#160;can&#160;also&#160;be&#160;used&#160;to&#160;read&#160;from&#160;http<br/>and&#160;ftp&#160;URLs as if they were files:<br/>
require &#34;open-uri&#34; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Required library<br/>f = open(&#34;http://www.davidflanagan.com/&#34;) &#160;# Webpage as a file<br/>webpage = f.read &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Read it as one big string<br/>f.close &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Don't forget to close!<br/>
In&#160;Ruby&#160;1.9,&#160;if&#160;the&#160;argument&#160;to&#160;open&#160;has&#160;a&#160;method&#160;named&#160;to_open,&#160;then&#160;that&#160;method<br/>is called and should return an opened&#160;IO&#160;object.<br/>
<b>9.7 &#160;Input/Output&#160;|&#160;357</b><br/>
<hr/>
<a name=372></a><b>9.7.1.3 &#160;StringIO<br/></b>Another way to obtain&#160;an&#160;IO&#160;object is to use the&#160;stringio&#160;library to read from or write<br/>to a string:<br/>
require &#34;stringio&#34;<br/>input = StringIO.open(&#34;now is the time&#34;) &#160;# Read from this string<br/>buffer = &#34;&#34;<br/>output = StringIO.open(buffer, &#34;w&#34;) &#160; &#160; &#160; # Write into buffer<br/>
The&#160;StringIO&#160;class&#160;is&#160;not&#160;a&#160;subclass&#160;of&#160;IO,&#160;but&#160;it&#160;defines&#160;many&#160;of&#160;the&#160;same&#160;methods&#160;as<br/>IO&#160;does,&#160;and&#160;duck&#160;typing&#160;usually&#160;allows&#160;us&#160;to&#160;use&#160;a&#160;StringIO&#160;object&#160;in&#160;place&#160;of&#160;an&#160;IO<br/>object.<br/>
<b>9.7.1.4 &#160;Predefined streams<br/></b>Ruby&#160;predefines&#160;a&#160;number&#160;of&#160;streams&#160;that&#160;can&#160;be&#160;used&#160;without&#160;being&#160;created&#160;or&#160;opened.<br/>The&#160;&#160;global&#160;&#160;constants&#160;&#160;STDIN,&#160;&#160;STDOUT,&#160;&#160;and&#160;&#160;STDERR&#160;&#160;are&#160;&#160;the&#160;&#160;standard&#160;&#160;input&#160;&#160;stream,&#160;&#160;the<br/>standard output stream, and the standard error stream, respectively. By default, these<br/>streams&#160;are&#160;connected&#160;to&#160;the&#160;user’s&#160;console&#160;or&#160;a&#160;terminal&#160;window&#160;of&#160;some&#160;sort.&#160;De-<br/>pending&#160;on&#160;how&#160;your&#160;Ruby&#160;script&#160;is&#160;invoked,&#160;they&#160;may&#160;instead&#160;use&#160;a&#160;file,&#160;or&#160;even&#160;another<br/>process,&#160;as&#160;a&#160;source&#160;of&#160;input&#160;or&#160;a&#160;destination&#160;for&#160;output.&#160;Any&#160;Ruby&#160;program&#160;can&#160;read<br/>from&#160;&#160;standard&#160;&#160;input&#160;&#160;and&#160;&#160;write&#160;&#160;to&#160;&#160;standard&#160;&#160;output&#160;&#160;(for&#160;&#160;normal&#160;&#160;program&#160;&#160;output)&#160;&#160;or<br/>standard&#160;error&#160;(for&#160;error&#160;messages&#160;that&#160;should&#160;be&#160;seen&#160;even&#160;if&#160;the&#160;standard&#160;output&#160;is<br/>redirected&#160;to&#160;a&#160;file).&#160;The&#160;global&#160;variables&#160;$stdin,&#160;$stdout,&#160;and&#160;$stderr&#160;are&#160;initially&#160;set<br/>to&#160;the&#160;same&#160;values&#160;as&#160;the&#160;stream&#160;constants.&#160;Global&#160;functions&#160;like&#160;print&#160;and&#160;puts&#160;write<br/>to&#160;$stdout&#160;by&#160;default.&#160;If&#160;a&#160;script&#160;alters&#160;the&#160;value&#160;of&#160;this&#160;global&#160;variable,&#160;it&#160;will&#160;change<br/>the&#160;&#160;behavior&#160;&#160;of&#160;&#160;those&#160;&#160;methods.&#160;&#160;The&#160;&#160;true&#160;&#160;“standard&#160;&#160;output”&#160;&#160;will&#160;&#160;still&#160;&#160;be&#160;&#160;available<br/>through&#160;STDOUT, however.<br/>Another&#160;predefined&#160;stream&#160;is&#160;ARGF,&#160;or&#160;$&lt;.&#160;This&#160;stream&#160;has&#160;special&#160;behavior&#160;intended&#160;to<br/>make&#160;it&#160;simple&#160;to&#160;write&#160;scripts&#160;that&#160;read&#160;the&#160;files&#160;specified&#160;on&#160;the&#160;command&#160;line&#160;or&#160;from<br/>standard&#160;input.&#160;If&#160;there&#160;are&#160;command-line&#160;arguments&#160;to&#160;the&#160;Ruby&#160;script&#160;(in&#160;the&#160;ARGV&#160;or<br/>$*&#160;array),&#160;then&#160;the&#160;ARGF&#160;stream&#160;acts&#160;as&#160;if&#160;those&#160;files&#160;had&#160;been&#160;concatenated&#160;together&#160;and<br/>the&#160;single&#160;resulting&#160;file&#160;opened&#160;for&#160;reading.&#160;In&#160;order&#160;for&#160;this&#160;to&#160;work&#160;properly,&#160;a&#160;Ruby<br/>script&#160;that&#160;accepts&#160;command-line&#160;options&#160;other&#160;than&#160;filenames&#160;must&#160;first&#160;process&#160;those<br/>options&#160;and&#160;remove&#160;them&#160;from&#160;the&#160;ARGV&#160;array.&#160;If&#160;the&#160;ARGV&#160;array&#160;is&#160;empty,&#160;then&#160;ARGF&#160;is<br/>the same as&#160;STDIN<a href="Rubys.html#418">. (See §10.3.1 for further details about the&#160;</a>ARGF&#160;stream.)<br/>Finally, the&#160;DATA&#160;stream&#160;is&#160;designed&#160;for&#160;reading&#160;text&#160;that&#160;appears&#160;after&#160;the&#160;end&#160;of&#160;your<br/>Ruby&#160;script.&#160;This&#160;works&#160;only&#160;if&#160;your&#160;script&#160;includes&#160;the&#160;token&#160;__END__&#160;on&#160;a&#160;line&#160;by&#160;itself.<br/>That&#160;token&#160;marks&#160;the&#160;end&#160;of&#160;the&#160;program&#160;text.&#160;Any&#160;lines&#160;after&#160;the&#160;token&#160;may&#160;be&#160;read<br/>with the&#160;DATA&#160;stream.<br/>
<b>358&#160;|&#160;Chapter 9:</b> <b>The Ruby Platform</b><br/>
<hr/>
<a name=373></a><b>9.7.2 &#160;Streams and Encodings<br/></b>One&#160;of&#160;the&#160;most&#160;significant&#160;changes&#160;in&#160;Ruby&#160;1.9&#160;is&#160;support&#160;for&#160;multibyte&#160;character<br/>encodings.&#160;We&#160;saw&#160;<a href="Rubys.html#60">in&#160;§3.2&#160;</a>that&#160;there&#160;were&#160;many&#160;changes&#160;to&#160;the&#160;String&#160;class.&#160;There&#160;are<br/>similar changes to the&#160;IO&#160;class.<br/>In&#160;Ruby&#160;1.9,&#160;every&#160;stream&#160;can&#160;have&#160;two&#160;encodings&#160;associated&#160;with&#160;it.&#160;These&#160;are&#160;known<br/>as&#160;&#160;the&#160;&#160;external&#160;&#160;and&#160;&#160;internal&#160;&#160;encodings,&#160;&#160;and&#160;&#160;are&#160;&#160;returned&#160;&#160;by&#160;&#160;the&#160;&#160;external_encoding<br/>and&#160;internal_encoding&#160;methods&#160;of&#160;an&#160;&#160;IO&#160;object.&#160;The&#160;external&#160;encoding&#160;is&#160;the&#160;encoding<br/>of&#160;the&#160;text&#160;as&#160;stored&#160;in&#160;the&#160;file.&#160;If&#160;you&#160;do&#160;not&#160;explicitly&#160;specify&#160;an&#160;external&#160;encoding&#160;for<br/>a&#160;stream,&#160;the&#160;default&#160;external&#160;encoding&#160;(see&#160;<a href="Rubys.html#52">§2.4.2)&#160;</a>of&#160;the&#160;process&#160;is&#160;used.&#160;You&#160;can<br/>specify&#160;the&#160;default&#160;external&#160;encoding&#160;with&#160;the&#160;-E&#160;option&#160;(see&#160;<a href="Rubys.html#406">§10.1.3).&#160;</a>If&#160;you&#160;don’t<br/>specify&#160;the&#160;default&#160;external&#160;encoding,&#160;an&#160;appropriate&#160;default&#160;encoding&#160;is&#160;derived&#160;from<br/>your locale.<br/>The&#160;internal&#160;encoding&#160;of&#160;a&#160;stream&#160;is&#160;the&#160;desired&#160;encoding&#160;for&#160;text&#160;that&#160;is&#160;read&#160;from&#160;the<br/>stream.&#160;If&#160;you&#160;do&#160;not&#160;explicitly&#160;specify&#160;an&#160;internal&#160;encoding,&#160;the&#160;default&#160;internal&#160;en-<br/>coding&#160;(<a href="Rubys.html#52">§2.4.2)&#160;</a>will&#160;be&#160;used.&#160;If&#160;you&#160;did&#160;not&#160;explicitly&#160;specify&#160;a&#160;default&#160;internal&#160;encoding<br/>with&#160;the&#160;-E,&#160;or&#160;-U&#160;options&#160;<a href="Rubys.html#406">(§10.1.3)&#160;</a>then&#160;the&#160;default&#160;internal&#160;encoding&#160;is&#160;unset.&#160;If&#160;a<br/>stream&#160;has&#160;an&#160;internal&#160;encoding,&#160;then&#160;all&#160;strings&#160;read&#160;from&#160;it&#160;are&#160;automatically&#160;trans-<br/>coded,&#160;if&#160;necessary,&#160;to&#160;that&#160;encoding.&#160;If&#160;a&#160;stream&#160;does&#160;not&#160;have&#160;an&#160;internal&#160;encoding,<br/>then&#160;no&#160;transcoding&#160;is&#160;done:&#160;strings&#160;read&#160;from&#160;the&#160;stream&#160;are&#160;simply&#160;tagged&#160;with&#160;the<br/>external encoding (as by the&#160;String.force_encoding&#160;method).<br/>Specify&#160;the&#160;encoding&#160;of&#160;any&#160;IO&#160;object&#160;(including&#160;pipes&#160;and&#160;network&#160;sockets)&#160;with&#160;the<br/>set_encoding&#160;method.&#160;With&#160;two&#160;arguments,&#160;it&#160;specifies&#160;an&#160;external&#160;encoding&#160;and&#160;an<br/>internal&#160;encoding.&#160;You&#160;can&#160;also&#160;specify&#160;two&#160;encodings&#160;with&#160;a&#160;single&#160;string&#160;argument,<br/>which&#160;consists&#160;of&#160;two&#160;encoding&#160;names&#160;separated&#160;by&#160;a&#160;colon.&#160;Normally,&#160;however,&#160;a<br/>single&#160;argument&#160;specifies&#160;just&#160;an&#160;external&#160;encoding.&#160;The&#160;arguments&#160;can&#160;be&#160;strings&#160;or<br/>Encoding&#160;objects.&#160;The&#160;external&#160;encoding&#160;is&#160;always&#160;specified&#160;first,&#160;followed,&#160;optionally,<br/>by an internal encoding. For example:<br/>
f.set_encoding(&#34;iso-8859-1&#34;, &#34;utf-8&#34;) # Latin-1, transcoded to UTF-8<br/>f.set_encoding(&#34;iso-8859-1:utf-8&#34;) &#160; &#160;# Same as above<br/>f.set_encoding(Encoding::UTF-8) &#160; &#160; &#160; # UTF-8 text<br/>
set_encoding&#160;works&#160;for&#160;any&#160;kind&#160;of&#160;IO&#160;object.&#160;For&#160;files,&#160;however,&#160;it&#160;is&#160;often&#160;easiest&#160;to<br/>specify&#160;encoding&#160;when&#160;you&#160;open&#160;the&#160;file.&#160;You&#160;can&#160;do&#160;this&#160;by&#160;appending&#160;the&#160;encoding<br/>names to the file mode string. For example:<br/>
in = File.open(&#34;data.txt&#34;, &#34;r:utf-8&#34;); &#160; &#160; &#160; &#160; &#160; # Read UTF-8 text<br/>out = File.open(&#34;log&#34;, &#34;a:utf-8&#34;); &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Write UTF-8 text<br/>in = File.open(&#34;data.txt&#34;, &#34;r:iso8859-1:utf-8&#34;); # Latin-1 transcoded to UTF-8&#160;<br/>
Note&#160;that&#160;it&#160;is&#160;not&#160;usually&#160;necessary&#160;to&#160;specify&#160;two&#160;encodings&#160;for&#160;a&#160;stream&#160;that&#160;is&#160;to&#160;be<br/>used&#160;for&#160;output.&#160;In&#160;that&#160;case,&#160;the&#160;internal&#160;encoding&#160;is&#160;specified&#160;by&#160;the&#160;String&#160;objects<br/>that are written to the stream.<br/>
<b>9.7 &#160;Input/Output&#160;|&#160;359</b><br/>
<hr/>
<a name=374></a>The&#160;default&#160;external&#160;encoding&#160;is,&#160;by&#160;default,&#160;derived&#160;from&#160;the&#160;user’s&#160;locale&#160;settings&#160;and<br/>is&#160;often&#160;a&#160;multibyte&#160;encoding.&#160;In&#160;order&#160;to&#160;read&#160;binary&#160;data&#160;from&#160;a&#160;file,&#160;therefore,&#160;you<br/>must&#160;explicitly&#160;specify&#160;that&#160;you&#160;want&#160;unencoded&#160;bytes,&#160;or&#160;you’ll&#160;get&#160;characters&#160;in&#160;the<br/>default&#160;&#160;external&#160;&#160;encoding.&#160;&#160;To&#160;&#160;do&#160;&#160;this,&#160;&#160;open&#160;&#160;a&#160;&#160;file&#160;&#160;with&#160;&#160;mode&#160;&#160;&#34;r:binary&#34;,&#160;&#160;or&#160;&#160;pass<br/>Encoding::BINARY&#160;to&#160;set_encoding&#160;after opening the file:<br/>
File.open(&#34;data&#34;, &#34;r:binary&#34;) &#160;# Open a file for reading binary data<br/>
On Windows, you should open binary files with mode&#160;&#34;rb:binary&#34;&#160;or call&#160;binmode&#160;on<br/>the&#160;stream.&#160;This&#160;disables&#160;the&#160;automatic&#160;newline&#160;conversion&#160;performed&#160;by&#160;Windows,<br/>and is only necessary on that platform.<br/>Not&#160;every&#160;stream-reading&#160;method&#160;honors&#160;the&#160;encoding&#160;of&#160;a&#160;stream.&#160;Some&#160;lower-level<br/>reading&#160;methods&#160;take&#160;an&#160;argument&#160;that&#160;specifies&#160;the&#160;number&#160;of&#160;bytes&#160;to&#160;read.&#160;By&#160;their<br/>nature,&#160;these&#160;methods&#160;return&#160;unencoded&#160;strings&#160;of&#160;bytes&#160;rather&#160;than&#160;strings&#160;of&#160;text.&#160;The<br/>methods that do not specify a length to read do honor the encoding.<br/>
<b>9.7.3 &#160;Reading from a Stream<br/></b>The&#160;IO&#160;class&#160;defines&#160;a&#160;number&#160;of&#160;methods&#160;for&#160;reading&#160;from&#160;streams.&#160;They&#160;work&#160;only&#160;if<br/>the&#160;stream&#160;is&#160;readable,&#160;of&#160;course.&#160;You&#160;can&#160;read&#160;from&#160;STDIN,&#160;ARGF,&#160;and&#160;DATA,&#160;but&#160;not&#160;from<br/>STDOUT&#160;or&#160;STDERR.&#160;Files&#160;and&#160;StringIO&#160;objects&#160;are&#160;opened&#160;for&#160;reading&#160;by&#160;default,&#160;unless<br/>you explicitly open them for writing only.<br/>
<b>9.7.3.1 &#160;Reading lines<br/></b>IO&#160;defines a number of ways to read lines &#160;from a stream:<br/>
lines = ARGF.readlines &#160; &#160; &#160; &#160; # Read all input, return an array of lines<br/>line = DATA.readline &#160; &#160; &#160; &#160; &#160; # Read one line from stream<br/>print l while l = DATA.gets &#160; &#160;# Read until gets returns nil, at EOF<br/>DATA.each {|line| print line } # Iterate lines from stream until EOF<br/>DATA.each_line &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # An alias for each<br/>DATA.lines &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # An enumerator for each_line: Ruby 1.9<br/>
Here&#160;are&#160;some&#160;important&#160;notes&#160;on&#160;these&#160;line-reading&#160;methods.&#160;First,&#160;the&#160;readline&#160;and<br/>the&#160;gets&#160;method&#160;differ&#160;only&#160;in&#160;their&#160;handling&#160;of&#160;EOF&#160;(end-of-file:&#160;the&#160;condition&#160;that<br/>occurs&#160;when&#160;there&#160;is&#160;no&#160;more&#160;to&#160;read&#160;from&#160;a&#160;stream).&#160;gets&#160;returns&#160;nil&#160;if&#160;it&#160;is&#160;invoked<br/>on&#160;a&#160;stream&#160;at&#160;EOF.&#160;readline&#160;instead&#160;raises&#160;an&#160;EOFError.&#160;If&#160;you&#160;do&#160;not&#160;know&#160;how&#160;many<br/>lines&#160;to&#160;expect,&#160;use&#160;gets.&#160;If&#160;you&#160;expect&#160;another&#160;line&#160;(and&#160;it&#160;is&#160;an&#160;error&#160;if&#160;it&#160;is&#160;not&#160;there),<br/>then&#160;use&#160;readline.&#160;You&#160;can&#160;check&#160;whether&#160;a&#160;stream&#160;is&#160;already&#160;at&#160;EOF&#160;with&#160;the&#160;eof?<br/>method.<br/>Second,&#160;gets&#160;and&#160;readline&#160;implicitly&#160;set&#160;the&#160;global&#160;variable&#160;$_&#160;to&#160;the&#160;line&#160;of&#160;text&#160;they<br/>return.&#160;A&#160;number&#160;of&#160;global&#160;methods,&#160;such&#160;as&#160;print,&#160;use&#160;$_&#160;if&#160;they&#160;are&#160;not&#160;explicitly<br/>passed&#160;an&#160;argument.&#160;Therefore,&#160;the&#160;while&#160;loop&#160;in&#160;the&#160;code&#160;above&#160;could&#160;be&#160;written&#160;more<br/>succinctly as:<br/>
print while DATA.gets<br/>
<b>360&#160;|&#160;Chapter 9:</b> <b>The Ruby Platform</b><br/>
<hr/>
<a name=375></a>Relying&#160;on&#160;$_&#160;is&#160;useful&#160;for&#160;short&#160;scripts,&#160;but&#160;in&#160;longer&#160;programs,&#160;it&#160;is&#160;better&#160;style&#160;to<br/>explicitly use variables to store the lines of input you’ve read.<br/>Third,&#160;these&#160;methods&#160;are&#160;typically&#160;used&#160;for&#160;text&#160;(instead&#160;of&#160;binary)&#160;streams,&#160;and&#160;a&#160;“line”<br/>is&#160;defined&#160;as&#160;a&#160;sequence&#160;of&#160;bytes&#160;up&#160;to&#160;and&#160;including&#160;the&#160;default&#160;line&#160;terminator&#160;(newline<br/>on&#160;most&#160;platforms).&#160;The&#160;lines&#160;returned&#160;by&#160;these&#160;methods&#160;include&#160;the&#160;line&#160;terminator<br/>(although&#160;the&#160;last&#160;line&#160;in&#160;a&#160;file&#160;may&#160;not&#160;have&#160;one).&#160;Use&#160;String.chomp!&#160;to&#160;strip&#160;it&#160;off.&#160;The<br/>special&#160;global&#160;variable&#160;$/&#160;holds&#160;the&#160;line&#160;terminator.&#160;You&#160;can&#160;set&#160;$/&#160;to&#160;alter&#160;the&#160;default<br/>behavior&#160;of&#160;all&#160;the&#160;line-reading&#160;methods,&#160;or&#160;you&#160;can&#160;simply&#160;pass&#160;an&#160;alternate&#160;separator<br/>to&#160;any&#160;of&#160;the&#160;methods&#160;(including&#160;the&#160;each&#160;iterator).&#160;You&#160;might&#160;do&#160;this&#160;when&#160;reading<br/>comma-separated&#160;fields&#160;from&#160;a&#160;file,&#160;for&#160;example,&#160;or&#160;when&#160;reading&#160;a&#160;binary&#160;file&#160;that&#160;has<br/>some&#160;kind&#160;of&#160;“record&#160;separator”&#160;character.&#160;There&#160;are&#160;two&#160;special&#160;cases&#160;for&#160;the&#160;line<br/>terminator.&#160;If&#160;you&#160;specify&#160;nil,&#160;then&#160;the&#160;line-reading&#160;methods&#160;keep&#160;reading&#160;until&#160;EOF<br/>and&#160;return&#160;the&#160;entire&#160;contents&#160;of&#160;the&#160;stream&#160;as&#160;a&#160;single&#160;line.&#160;If&#160;you&#160;specify&#160;the&#160;empty<br/>string&#160;“”&#160;as&#160;the&#160;line&#160;terminator,&#160;then&#160;the&#160;line-reading&#160;methods&#160;read&#160;a&#160;paragraph&#160;at&#160;a<br/>time, looking for a blank line as the separator.<br/>In&#160;Ruby&#160;1.9,&#160;gets&#160;and&#160;readline&#160;accept&#160;an&#160;optional&#160;integer&#160;as&#160;the&#160;first&#160;argument&#160;or&#160;as<br/>the&#160;second&#160;after&#160;a&#160;separator&#160;string.&#160;If&#160;specified,&#160;this&#160;integer&#160;specifies&#160;the&#160;maximum<br/>number&#160;of&#160;bytes&#160;to&#160;read&#160;from&#160;the&#160;stream.&#160;This&#160;limit&#160;argument&#160;exists&#160;to&#160;prevent&#160;acci-<br/>dental&#160;&#160;reads&#160;&#160;of&#160;&#160;unexpectedly&#160;&#160;long&#160;&#160;lines,&#160;&#160;and&#160;&#160;these&#160;&#160;methods&#160;&#160;are&#160;&#160;exceptions&#160;&#160;to&#160;&#160;the<br/>previously&#160;cited&#160;rule;&#160;they&#160;return&#160;encoded&#160;character&#160;strings&#160;despite&#160;the&#160;fact&#160;that&#160;they<br/>have a limit argument measured in bytes.<br/>Finally,&#160;&#160;the&#160;&#160;line-reading&#160;&#160;methods&#160;&#160;gets,&#160;&#160;readline,&#160;&#160;and&#160;&#160;the&#160;&#160;each&#160;&#160;iterator&#160;&#160;(and&#160;&#160;its<br/>each_line&#160;alias)&#160;keep&#160;track&#160;of&#160;the&#160;number&#160;of&#160;lines&#160;they’ve&#160;read.&#160;You&#160;can&#160;query&#160;the&#160;line<br/>number&#160;of&#160;the&#160;most&#160;recently&#160;read&#160;line&#160;with&#160;the&#160;lineno&#160;method,&#160;and&#160;you&#160;can&#160;set&#160;that<br/>line&#160;number&#160;with&#160;lineno=&#160;accessor.&#160;Note&#160;that&#160;lineno&#160;does&#160;not&#160;actually&#160;count&#160;the&#160;num-<br/>ber&#160;of&#160;newlines&#160;in&#160;a&#160;file.&#160;It&#160;counts&#160;the&#160;number&#160;of&#160;times&#160;line-reading&#160;methods&#160;have&#160;been<br/>called, and may return different results if you use different line separator characters:<br/>
DATA.lineno = 0 &#160; &#160; # Start from line 0, even though data is at end of file<br/>DATA.readline &#160; &#160; &#160; # Read one line of data<br/>DATA.lineno &#160; &#160; &#160; &#160; # =&gt; 1<br/>$. &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; 1: magic global variable, implicitly set<br/>
<b>9.7.3.2 &#160;Reading entire files<br/></b>IO&#160;&#160;defines&#160;&#160;three&#160;&#160;class&#160;&#160;methods&#160;&#160;for&#160;&#160;reading&#160;&#160;files&#160;&#160;without&#160;&#160;ever&#160;&#160;opening&#160;&#160;an&#160;&#160;IO&#160;&#160;stream.<br/>IO.read&#160;reads&#160;an&#160;&#160;entire&#160;file&#160;(or&#160;a&#160;portion&#160;of&#160;a&#160;file)&#160;and&#160;returns&#160;it&#160;as&#160;a&#160;single&#160;string.<br/>IO.readlines&#160;reads&#160;an&#160;entire&#160;named&#160;file&#160;&#160;into&#160;an&#160;array&#160;of&#160;lines.&#160;And&#160;IO.foreach&#160;iterates&#160;<br/>over&#160;the&#160;lines&#160;of&#160;a&#160;named&#160;file.&#160;In&#160;Ruby&#160;1.9,&#160;you&#160;can&#160;pass&#160;a&#160;hash&#160;to&#160;these&#160;methods&#160;to<br/>specify the mode string and/or encoding of the file being read:<br/>
data = IO.read(&#34;data&#34;) &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Read and return the entire file<br/>data = IO.read(&#34;data&#34;, mode:&#34;rb&#34;) &#160; &#160; &#160; &#160; # Open with mode string &#34;rb&#34;<br/>data = IO.read(&#34;data&#34;, encoding:&#34;binary&#34;) # Read unencoded bytes<br/>data = IO.read(&#34;data&#34;, 4, 2) &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Read 4 bytes starting at byte 2<br/>data = IO.read(&#34;data&#34;, nil, 6) &#160; &#160; &#160; &#160; &#160; &#160;# Read from byte 6 to end-of-file<br/>
<b>9.7 &#160;Input/Output&#160;|&#160;361</b><br/>
<hr/>
<a name=376></a># Read lines into an array<br/>words = IO.readlines(&#34;/usr/share/dict/words&#34;)<br/>
# Read lines one at a time and initialize a hash<br/>words = {}<br/>IO.foreach(&#34;/usr/share/dict/words&#34;) {|w| words[w] = true}<br/>
In&#160;Ruby&#160;1.9&#160;you&#160;can&#160;use&#160;IO.copy_stream&#160;to&#160;read&#160;a&#160;file&#160;(or&#160;a&#160;portion)&#160;and&#160;write&#160;its&#160;content<br/>to a stream:<br/>
IO.copy_stream(&#34;/usr/share/dict/words&#34;, STDOUT) # Print the dictionary<br/>IO.copy_stream(&#34;/usr/share/dict/words&#34;, STDOUT, 10, 100) # Print bytes 100-109<br/>
Although&#160;these&#160;class&#160;methods&#160;are&#160;defined&#160;by&#160;the&#160;IO&#160;class,&#160;they&#160;operate&#160;on&#160;named&#160;files,<br/>and&#160;&#160;it&#160;&#160;is&#160;&#160;also&#160;&#160;common&#160;&#160;to&#160;&#160;see&#160;&#160;them&#160;&#160;invoked&#160;&#160;as&#160;&#160;class&#160;&#160;methods&#160;&#160;of&#160;&#160;File:&#160;&#160;File.read,<br/>File.readlines,&#160;File.foreach, and&#160;File.copy_stream.<br/>
The&#160;IO&#160;class&#160;also&#160;defines&#160;an&#160;instance&#160;method&#160;named&#160;read, which is similar to the class<br/>method&#160;with&#160;the&#160;same&#160;name;&#160;with&#160;no&#160;arguments&#160;it&#160;reads&#160;text&#160;until&#160;the&#160;end&#160;of&#160;the&#160;stream<br/>and returns it as an encoded string:<br/>
# An alternative to text = File.read(&#34;data.txt&#34;)<br/>f = File.open(&#34;data.txt&#34;) &#160;# Open a file<br/>text = f.read &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Read its contents as text<br/>f.close &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Close the file<br/>
The&#160;&#160;IO.read&#160;&#160;instance&#160;&#160;method&#160;&#160;can&#160;&#160;also&#160;&#160;be&#160;&#160;used&#160;&#160;with&#160;&#160;arguments&#160;&#160;to&#160;&#160;read&#160;&#160;a&#160;&#160;specified<br/>number of bytes from the stream. That use is described in the next section.<br/>
<b>9.7.3.3 &#160;Reading bytes and characters<br/></b>The&#160;IO&#160;class&#160;also&#160;defines&#160;methods&#160;for&#160;reading&#160;a&#160;stream&#160;one&#160;or&#160;more&#160;bytes&#160;or&#160;characters<br/>at&#160;a&#160;time,&#160;but&#160;these&#160;methods&#160;have&#160;changed&#160;substantially&#160;between&#160;Ruby&#160;1.8&#160;and&#160;Ruby<br/>1.9 because Ruby’s definition of a character has changed.<br/>In&#160;Ruby&#160;1.8,&#160;bytes&#160;and&#160;characters&#160;are&#160;the&#160;same&#160;thing,&#160;and&#160;the&#160;getc&#160;and&#160;readchar&#160;meth-<br/>ods&#160;read&#160;a&#160;single&#160;byte&#160;and&#160;return&#160;it&#160;as&#160;a&#160;Fixnum.&#160;Like&#160;gets,&#160;getc&#160;returns&#160;nil&#160;at&#160;EOF.&#160;And<br/>like&#160;readline,&#160;readchar&#160;raises&#160;EOFError&#160;if it is called at EOF.<br/>In&#160;Ruby&#160;1.9,&#160;getc&#160;and&#160;readchar&#160;have&#160;been&#160;modified&#160;to&#160;return&#160;a&#160;string&#160;of&#160;length&#160;1&#160;instead<br/>of&#160;a&#160;Fixnum.&#160;When&#160;reading&#160;from&#160;a&#160;stream&#160;with&#160;a&#160;multibyte&#160;encoding,&#160;these&#160;methods<br/>read&#160;as&#160;many&#160;bytes&#160;as&#160;necessary&#160;to&#160;read&#160;a&#160;complete&#160;character.&#160;If&#160;you&#160;want&#160;to&#160;read&#160;a<br/>string&#160;&#160;a&#160;&#160;byte&#160;&#160;at&#160;&#160;a&#160;&#160;time&#160;&#160;in&#160;&#160;Ruby&#160;&#160;1.9,&#160;&#160;use&#160;&#160;the&#160;&#160;new&#160;&#160;methods&#160;&#160;getbyte&#160;&#160;and&#160;&#160;readbyte.<br/>getbyte&#160;is like&#160;getc&#160;and&#160;gets: it returns&#160;nil&#160;at EOF. And&#160;readbyte&#160;is like&#160;readchar&#160;and<br/>readline: it raises&#160;EOFError.<br/>
Programs&#160;(like&#160;parsers)&#160;that&#160;read&#160;a&#160;stream&#160;one&#160;character&#160;at&#160;a&#160;time&#160;sometimes&#160;need&#160;to<br/>push&#160;a&#160;single&#160;character&#160;back&#160;into&#160;the&#160;stream’s&#160;buffer,&#160;so&#160;that&#160;it&#160;will&#160;be&#160;returned&#160;by&#160;the<br/>next&#160;read&#160;call.&#160;They&#160;can&#160;do&#160;this&#160;with&#160;ungetc.&#160;This&#160;method&#160;expects&#160;a&#160;Fixnum&#160;in&#160;Ruby&#160;1.8<br/>and&#160;a&#160;single&#160;character&#160;string&#160;in&#160;Ruby&#160;1.9.&#160;The&#160;character&#160;pushed&#160;back&#160;will&#160;be&#160;returned<br/>by the next call to&#160;getc&#160;or&#160;readchar:<br/>
<b>362&#160;|&#160;Chapter 9:</b> <b>The Ruby Platform</b><br/>
<hr/>
<a name=377></a>f = File.open(&#34;data&#34;, &#34;r:binary&#34;) # Open data file for binary reads&#160;<br/>c = f.getc &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Read the first byte as an integer<br/>f.ungetc(c) &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Push that byte back<br/>c = f.readchar &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Read it back again<br/>
You can also iterate and enumerate the characters and bytes of a stream: &#160; &#160;<br/>
f.each_byte {|b| ... } &#160; &#160; &#160;# Iterate through remaining bytes<br/>f.bytes &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # An enumerator for each_byte: Ruby 1.9<br/>f.each_char {|c} ...} &#160; &#160; &#160; # Iterate characters: Ruby 1.9<br/>f.chars &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # An enumerator for each_char: Ruby 1.9 &#160;<br/>
If&#160;you&#160;want&#160;to&#160;read&#160;more&#160;than&#160;one&#160;byte&#160;at&#160;a&#160;time,&#160;you&#160;have&#160;a&#160;choice&#160;of&#160;five&#160;methods,<br/>each with slightly different behavior:<br/>
readbytes(n)<br/>
Read exactly&#160;n&#160;bytes&#160;and&#160;return&#160;them&#160;as&#160;a&#160;string.&#160;Block,&#160;if&#160;necessary,&#160;until&#160;n&#160;bytes<br/>arrive. Raise&#160;EOFError&#160;if EOF occurs before&#160;n&#160;bytes are available.<br/>
readpartial(n, buffer=nil)<br/>
Read&#160;&#160;between&#160;&#160;1&#160;&#160;and&#160;&#160;n&#160;&#160;bytes&#160;&#160;and&#160;&#160;return&#160;&#160;them&#160;&#160;as&#160;&#160;a&#160;&#160;new&#160;&#160;binary&#160;&#160;string,&#160;&#160;or,&#160;&#160;if&#160;&#160;a<br/>String&#160;&#160;object&#160;&#160;is&#160;&#160;passed&#160;&#160;as&#160;&#160;the&#160;&#160;second&#160;&#160;argument,&#160;&#160;store&#160;&#160;them&#160;&#160;in&#160;&#160;that&#160;&#160;string<br/>(overwriting&#160;whatever&#160;text&#160;it&#160;contains).&#160;If&#160;one&#160;or&#160;more&#160;bytes&#160;are&#160;available&#160;for&#160;read-<br/>ing,&#160;this&#160;method&#160;returns&#160;them&#160;(up&#160;to&#160;a&#160;maximum&#160;of&#160;n)&#160;immediately.&#160;It&#160;blocks&#160;only<br/>if&#160;no&#160;bytes&#160;are&#160;available.&#160;This&#160;method&#160;raises&#160;EOFError&#160;if&#160;called&#160;when&#160;the&#160;stream&#160;is<br/>at EOF.<br/>
read(n=nil, buffer=nil)<br/>
Read&#160;n&#160;bytes&#160;(or&#160;fewer,&#160;if&#160;EOF&#160;is&#160;reached),&#160;blocking&#160;if&#160;necessary,&#160;until&#160;the&#160;bytes&#160;are<br/>ready.&#160;&#160;The&#160;&#160;bytes&#160;&#160;are&#160;&#160;returned&#160;&#160;as&#160;&#160;a&#160;&#160;binary&#160;&#160;string.&#160;&#160;If&#160;&#160;the&#160;&#160;second&#160;&#160;argument&#160;&#160;is&#160;&#160;an<br/>existing&#160;String&#160;object,&#160;then&#160;the&#160;bytes&#160;are&#160;stored&#160;in&#160;that&#160;object&#160;(replacing&#160;any&#160;ex-<br/>isting&#160;content)&#160;and&#160;the&#160;string&#160;is&#160;returned.&#160;If&#160;the&#160;stream&#160;is&#160;at&#160;EOF&#160;and&#160;n&#160;is&#160;specified,<br/>it returns&#160;nil.&#160;If&#160;called&#160;at&#160;EOF&#160;and&#160;n&#160;is&#160;omitted&#160;or&#160;is&#160;nil,&#160;then&#160;it&#160;returns&#160;the&#160;empty<br/>string&#160;&#34;&#34;.<br/>If&#160;n&#160;is&#160;nil&#160;or&#160;is&#160;omitted,&#160;then&#160;this&#160;method&#160;reads&#160;the&#160;rest&#160;of&#160;the&#160;stream&#160;and&#160;returns<br/>it as an encoded character string rather than an unencoded byte string.<br/>
read_nonblock(n, buffer=nil)<br/>
Read&#160;the&#160;bytes&#160;(up&#160;to&#160;a&#160;maximum&#160;of&#160;n)&#160;that&#160;are&#160;currently&#160;available&#160;for&#160;reading,&#160;and<br/>return them as a string, using the&#160;buffer&#160;string if it is specified. This method does<br/>not&#160;block.&#160;If&#160;there&#160;is&#160;no&#160;data&#160;ready&#160;to&#160;be&#160;read&#160;on&#160;the&#160;stream&#160;(this&#160;might&#160;occur&#160;with<br/>a&#160;&#160;networking&#160;&#160;socket&#160;&#160;or&#160;&#160;with&#160;&#160;STDIN,&#160;&#160;for&#160;&#160;example)&#160;&#160;this&#160;&#160;method&#160;&#160;raises&#160;&#160;a<br/>SystemCallError. If called at EOF, this method raises&#160;EOFError.<br/>This&#160;&#160;method&#160;&#160;is&#160;&#160;new&#160;&#160;in&#160;&#160;Ruby&#160;&#160;1.9.&#160;&#160;(Ruby&#160;&#160;1.9&#160;&#160;also&#160;&#160;defines&#160;&#160;other&#160;&#160;nonblocking&#160;&#160;IO<br/>methods, but they are low-level and are not covered here.)<br/>
sysread(n)<br/>
This method&#160;works&#160;like&#160;readbytes&#160;but&#160;operates&#160;at&#160;a&#160;lower&#160;level&#160;without&#160;buffering.<br/>Do&#160;not&#160;mix&#160;calls&#160;to&#160;sysread&#160;with&#160;any&#160;other&#160;line-&#160;or&#160;byte-reading&#160;methods;&#160;they&#160;are<br/>incompatible.<br/>
<b>9.7 &#160;Input/Output&#160;|&#160;363</b><br/>
<hr/>
<a name=378></a>Here is some example code you might use when reading a binary file:<br/>
f = File.open(&#34;data.bin&#34;, &#34;rb:binary&#34;) &#160;# No newline conversion, no encoding<br/>magic = f.readbytes(4) &#160; &#160; &#160; # First four bytes identify filetype<br/>exit unless magic == &#34;INTS&#34; &#160;# Magic number spells &#34;INTS&#34; (ASCII)<br/>bytes = f.read &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Read the rest of the file<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Encoding is binary, so this is a byte string<br/>data = bytes.unpack(&#34;i*&#34;) &#160; &#160;# Convert bytes to an array of integers<br/>
<b>9.7.4 &#160;Writing to a Stream<br/></b>The&#160;&#160;IO&#160;&#160;methods&#160;&#160;for&#160;&#160;writing&#160;&#160;to&#160;&#160;a&#160;&#160;stream&#160;&#160;mirror&#160;&#160;those&#160;&#160;for&#160;&#160;reading.&#160;&#160;The&#160;&#160;STDOUT&#160;&#160;and<br/>STDERR&#160;streams are writable, as are files opened in any mode other than&#160;&#34;r&#34;&#160;or&#160;&#34;rb&#34;.<br/>
IO&#160;defines a single&#160;putc&#160;method&#160;for&#160;writing&#160;single&#160;bytes&#160;or&#160;characters&#160;to&#160;a&#160;stream.&#160;This<br/>method&#160;accepts&#160;either&#160;a&#160;byte&#160;value&#160;or&#160;a&#160;single-character&#160;string&#160;as&#160;its&#160;argument,&#160;and<br/>therefore has not changed between Ruby 1.8 and 1.9:<br/>
o = STDOUT<br/># Single-character output<br/>o.putc(65) &#160; &#160; &#160; &#160; # Write single byte 65 (capital A)<br/>o.putc(&#34;B&#34;) &#160; &#160; &#160; &#160;# Write single byte 66 (capital B)<br/>o.putc(&#34;CD&#34;) &#160; &#160; &#160; # Write just the first byte of the string<br/>
The&#160;IO&#160;class&#160;defines&#160;a&#160;number&#160;of&#160;other&#160;methods&#160;for&#160;writing&#160;arbitrary&#160;strings.&#160;These<br/>methods&#160;differ&#160;from&#160;each&#160;other&#160;in&#160;the&#160;number&#160;of&#160;arguments&#160;they&#160;accept&#160;and&#160;whether<br/>or&#160;not&#160;line&#160;terminators&#160;are&#160;added.&#160;Recall&#160;that&#160;in&#160;Ruby&#160;1.9,&#160;textual&#160;output&#160;is&#160;transcoded<br/>to the external encoding of the stream, if one was specified:<br/>
o = STDOUT<br/># String output<br/>o &lt;&lt; x &#160; &#160; &#160; &#160; &#160; &#160; # Output x.to_s&#160;<br/>o &lt;&lt; x &lt;&lt; y &#160; &#160; &#160; &#160;# May be chained: output x.to_s + y.to_s<br/>o.print &#160; &#160; &#160; &#160; &#160; &#160;# Output $_ + $\<br/>o.print s &#160; &#160; &#160; &#160; &#160;# Output s.to_s + $\<br/>o.print s,t &#160; &#160; &#160; &#160;# Output s.to_s + t.to_s + $\<br/>o.printf fmt,*args # Outputs fmt%[args]<br/>o.puts &#160; &#160; &#160; &#160; &#160; &#160; # Output newline<br/>o.puts x &#160; &#160; &#160; &#160; &#160; # Output x.to_s.chomp plus newline<br/>o.puts x,y &#160; &#160; &#160; &#160; # Output x.to_s.chomp, newline, y.to_s.chomp, newline<br/>o.puts [x,y] &#160; &#160; &#160; # Same as above<br/>o.write s &#160; &#160; &#160; &#160; &#160;# Output s.to_s, returns s.to_s.length<br/>o.syswrite s &#160; &#160; &#160; # Low-level version of write<br/>
Output&#160;streams&#160;are&#160;appendable,&#160;like&#160;strings&#160;and&#160;arrays&#160;are,&#160;and&#160;you&#160;can&#160;write&#160;values<br/>to&#160;them&#160;with&#160;the&#160;&lt;&lt;&#160;operator.&#160;puts&#160;is&#160;one&#160;of&#160;the&#160;most&#160;common&#160;output&#160;methods.&#160;It<br/>converts&#160;each&#160;of&#160;its&#160;arguments&#160;to&#160;a&#160;string,&#160;and&#160;writes&#160;each&#160;one&#160;to&#160;the&#160;stream.&#160;If&#160;the<br/>string&#160;does&#160;not&#160;already&#160;end&#160;with&#160;a&#160;newline&#160;character,&#160;it&#160;adds&#160;one.&#160;If&#160;any&#160;of&#160;the&#160;arguments<br/>to&#160;puts&#160;is&#160;an&#160;array,&#160;the&#160;array&#160;is&#160;recursively&#160;expanded,&#160;and&#160;each&#160;element&#160;is&#160;printed&#160;on&#160;its<br/>own&#160;line&#160;as&#160;if&#160;it&#160;were&#160;passed&#160;directly&#160;as&#160;an&#160;argument&#160;to&#160;puts.&#160;The&#160;print&#160;method&#160;converts<br/>its&#160;arguments&#160;to&#160;strings,&#160;and&#160;outputs&#160;them&#160;to&#160;the&#160;stream.&#160;If&#160;the&#160;global&#160;field&#160;separator<br/>$,&#160;has&#160;been&#160;changed&#160;from&#160;its&#160;default&#160;value&#160;of&#160;nil,&#160;then&#160;that&#160;value&#160;is&#160;output&#160;between<br/>
<b>364&#160;|&#160;Chapter 9:</b> <b>The Ruby Platform</b><br/>
<hr/>
<a name=379></a>each&#160;of&#160;the&#160;arguments&#160;to&#160;print.&#160;If&#160;the&#160;output&#160;record&#160;separator&#160;$\&#160;has&#160;been&#160;changed<br/>from its default value of&#160;nil, then that value is output after all arguments are printed.<br/>The&#160;printf&#160;method&#160;expects&#160;a&#160;format&#160;string&#160;as&#160;its&#160;first&#160;argument,&#160;and&#160;interpolates&#160;the<br/>values&#160;of&#160;any&#160;additional&#160;arguments&#160;into&#160;that&#160;format&#160;string&#160;using&#160;the&#160;String&#160;%&#160;operator.<br/>It then outputs the interpolated string with no newline or record separator.<br/>
write&#160;simply&#160;outputs&#160;its&#160;single&#160;argument&#160;as&#160;&lt;&lt;&#160;does,&#160;and&#160;returns&#160;the&#160;number&#160;of&#160;bytes<br/>written. Finally,&#160;syswrite&#160;is&#160;a&#160;low-level,&#160;unbuffered,&#160;nontranscoding&#160;version&#160;of&#160;write.<br/>If&#160;you&#160;use&#160;syswrite,&#160;you&#160;must&#160;use&#160;that&#160;method&#160;exclusively,&#160;and&#160;not&#160;mix&#160;it&#160;with&#160;any<br/>other writing methods.<br/>
<b>9.7.5 &#160;Random Access Methods<br/></b>Some streams,&#160;such&#160;as&#160;those&#160;that&#160;represent&#160;network&#160;sockets,&#160;or&#160;user&#160;input&#160;at&#160;the&#160;con-<br/>sole,&#160;are&#160;sequential&#160;streams:&#160;once&#160;you&#160;have&#160;read&#160;or&#160;written&#160;from&#160;them,&#160;you&#160;cannot&#160;go<br/>back.&#160;Other&#160;streams,&#160;such&#160;as&#160;those&#160;that&#160;read&#160;from&#160;or&#160;write&#160;to&#160;files&#160;or&#160;strings,&#160;allow<br/>random&#160;access&#160;with&#160;the&#160;methods&#160;described&#160;here.&#160;If&#160;you&#160;attempt&#160;to&#160;use&#160;these&#160;methods<br/>on&#160;a&#160;stream&#160;that&#160;does&#160;not&#160;allow&#160;random&#160;access,&#160;they&#160;will&#160;raise&#160;a&#160;SystemCallException:<br/>
f = File.open(&#34;test.txt&#34;)<br/>f.pos &#160; &#160; &#160; &#160;# =&gt; 0: return the current position in bytes<br/>f.pos = 10 &#160; # skip to position 10<br/>f.tell &#160; &#160; &#160; # =&gt; 10: a synonym for pos<br/>f.rewind &#160; &#160; # go back to position 0, reset lineno to 0, also<br/>f.seek(10, IO::SEEK_SET) &#160;# Skip to absolute position 10<br/>f.seek(10, IO::SEEK_CUR) &#160;# Skip 10 bytes from current position<br/>f.seek(-10, IO::SEEK_END) # Skip to 10 bytes from end<br/>f.seek(0, IO::SEEK_END) &#160; # Skip to very end of file<br/>f.eof? &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# =&gt; true: we're at the end<br/>
If&#160;you&#160;use&#160;sysread&#160;or&#160;syswrite&#160;in&#160;your&#160;program,&#160;then&#160;use&#160;sysseek&#160;instead&#160;of&#160;seek&#160;for<br/>random&#160;access.&#160;sysseek&#160;is&#160;like&#160;seek&#160;except&#160;that&#160;it&#160;returns&#160;the&#160;new&#160;file&#160;position&#160;after&#160;each<br/>call:<br/>
pos = f.sysseek(0, IO::SEEK_CUR) &#160;# Get current position<br/>f.sysseek(0, IO::SEEK_SET) &#160; &#160; &#160; &#160;# Rewind stream<br/>f.sysseek(pos, IO::SEEK_SET) &#160; &#160; &#160;# Return to original position<br/>
<b>9.7.6 &#160;Closing, Flushing, and Testing Streams<br/></b>When&#160;you&#160;are&#160;done&#160;reading&#160;from&#160;or&#160;writing&#160;to&#160;a&#160;stream,&#160;you&#160;must&#160;close&#160;it&#160;with&#160;the<br/>close&#160;method.&#160;This&#160;flushes&#160;any&#160;buffered&#160;input&#160;or&#160;output,&#160;and&#160;also&#160;frees&#160;up&#160;operating<br/>system&#160;resources.&#160;A&#160;number&#160;of&#160;stream-opening&#160;methods&#160;allow&#160;you&#160;to&#160;associate&#160;a&#160;block<br/>with&#160;them.&#160;They&#160;pass&#160;the&#160;open&#160;stream&#160;to&#160;the&#160;block,&#160;and&#160;automatically&#160;close&#160;the&#160;stream<br/>when&#160;the&#160;block&#160;exits.&#160;Managing&#160;streams&#160;in&#160;this&#160;way&#160;ensures&#160;that&#160;they&#160;are&#160;properly<br/>closed even when exceptions are raised:<br/>
File.open(&#34;test.txt&#34;) do |f|<br/>&#160; # Use stream f here<br/>
<b>9.7 &#160;Input/Output&#160;|&#160;365</b><br/>
<hr/>
<a name=380></a>&#160; # Value of this block becomes return value of the open method<br/>end # f is automatically closed for us here<br/>
The alternative to using a block is to use an&#160;ensure&#160;clause of your own:<br/>
begin<br/>&#160; f = File.open(&#34;test.txt&#34;)<br/>&#160; # use stream f here<br/>ensure<br/>&#160; f.close if f<br/>end<br/>
Network&#160;sockets&#160;are&#160;implemented&#160;using&#160;IO&#160;objects&#160;that&#160;have&#160;separate&#160;read&#160;and&#160;write<br/>streams&#160;&#160;internally.&#160;&#160;You&#160;&#160;can&#160;&#160;use&#160;&#160;close_read&#160;&#160;and&#160;&#160;close_write&#160;&#160;to&#160;&#160;close&#160;&#160;these&#160;&#160;internal<br/>streams&#160;individually.&#160;Although&#160;files&#160;can&#160;be&#160;opened&#160;for&#160;reading&#160;and&#160;writing&#160;at&#160;the&#160;same<br/>time, you cannot use&#160;close_read&#160;and&#160;close_write&#160;on those&#160;IO&#160;objects.<br/>Ruby’s&#160;output&#160;methods&#160;(except&#160;syswrite)&#160;buffer&#160;output&#160;for&#160;efficiency.&#160;The&#160;output&#160;buf-<br/>fer&#160;is&#160;flushed&#160;at&#160;reasonable&#160;times,&#160;such&#160;as&#160;when&#160;a&#160;newline&#160;is&#160;output&#160;or&#160;when&#160;data&#160;is&#160;read<br/>from a corresponding input stream. There are times, however, when you may need to<br/>explicitly flush the output buffer to force output to be sent right away:<br/>
out.print 'wait&gt;' # Display a prompt<br/>out.flush &#160; &#160; &#160; &#160; # Manually flush output buffer to OS<br/>sleep(1) &#160; &#160; &#160; &#160; &#160;# Prompt appears before we go to sleep<br/>
out.sync = true &#160; # Automatically flush buffer after every write<br/>out.sync = false &#160;# Don't automatically flush<br/>out.sync &#160; &#160; &#160; &#160; &#160;# Return current sync mode<br/>out.fsync &#160; &#160; &#160; &#160; # Flush output buffer and ask OS to flush its buffers<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Returns nil if unsupported on current platform<br/>
IO&#160;defines several predicates for testing the state of a stream:<br/>
f.eof? &#160; &#160; &#160; # true if stream is at EOF<br/>f.closed? &#160; &#160;# true if stream has been closed<br/>f.tty? &#160; &#160; &#160; # true if stream is interactive<br/>
The&#160;only&#160;one&#160;of&#160;these&#160;methods&#160;that&#160;needs&#160;explanation&#160;is&#160;tty?.&#160;This&#160;method,&#160;and&#160;its<br/>alias&#160;isatty&#160;(with&#160;no&#160;question&#160;mark),&#160;returns&#160;true&#160;if&#160;the&#160;stream&#160;is&#160;connected&#160;to&#160;an<br/>interactive&#160;device&#160;such&#160;as&#160;a&#160;terminal&#160;window&#160;or&#160;a&#160;keyboard&#160;with&#160;(presumably)&#160;a&#160;human<br/>at&#160;it.&#160;They&#160;return&#160;false&#160;if&#160;the&#160;stream&#160;is&#160;a&#160;noninteractive&#160;one,&#160;such&#160;as&#160;a&#160;file,&#160;pipe,&#160;or<br/>socket.&#160;A&#160;program&#160;can&#160;use&#160;tty?&#160;to&#160;avoid&#160;prompting&#160;a&#160;user&#160;for&#160;input&#160;if&#160;STDIN&#160;has&#160;actually<br/>been redirected and is coming from a file, for example.<br/>
<b>9.8 &#160;Networking<br/></b>Ruby’s&#160;networking&#160;capabilities&#160;are&#160;provided&#160;by&#160;the&#160;standard&#160;library&#160;rather&#160;than&#160;by&#160;core<br/>classes.&#160;For&#160;this&#160;reason,&#160;the&#160;subsections&#160;that&#160;follow&#160;do&#160;not&#160;attempt&#160;to&#160;enumerate&#160;each<br/>available&#160;class&#160;or&#160;method.&#160;Instead,&#160;they&#160;demonstrate&#160;how&#160;to&#160;accomplish&#160;common&#160;net-<br/>working tasks with simple examples. Use&#160;<i>ri</i>&#160;for more complete documentation.<br/>
<b>366&#160;|&#160;Chapter 9:</b> <b>The Ruby Platform</b><br/>
<hr/>
<a name=381></a>At&#160;the&#160;lowest&#160;level,&#160;networking&#160;is&#160;accomplished&#160;with&#160;sockets,&#160;which&#160;are&#160;a&#160;kind&#160;of&#160;IO<br/>object.&#160;Once&#160;you&#160;have&#160;a&#160;socket&#160;opened,&#160;you&#160;can&#160;read&#160;data&#160;from,&#160;or&#160;write&#160;data&#160;to,&#160;another<br/>computer&#160;just&#160;as&#160;if&#160;you&#160;were&#160;reading&#160;from&#160;or&#160;writing&#160;to&#160;a&#160;file.&#160;The&#160;socket&#160;class&#160;hierarchy<br/>is&#160;somewhat&#160;confusing,&#160;but&#160;the&#160;details&#160;are&#160;not&#160;important&#160;in&#160;the&#160;following&#160;examples.<br/>Internet&#160;clients&#160;use&#160;the&#160;TCPSocket&#160;class,&#160;and&#160;Internet&#160;servers&#160;use&#160;the&#160;TCPServer&#160;class<br/>(also&#160;a&#160;socket).&#160;All&#160;socket&#160;classes&#160;are&#160;part&#160;of&#160;the&#160;standard&#160;library,&#160;so&#160;to&#160;use&#160;them&#160;in&#160;your<br/>Ruby program, you must first write:<br/>
require 'socket'<br/>
<b>9.8.1 &#160;A Very Simple Client<br/></b>To&#160;&#160;write&#160;&#160;Internet&#160;&#160;client&#160;&#160;applications,&#160;&#160;use&#160;&#160;the&#160;&#160;TCPSocket&#160;&#160;class.&#160;&#160;Obtain&#160;&#160;a&#160;&#160;TCPSocket<br/>instance&#160;with&#160;the&#160;TCPSocket.open&#160;class&#160;method,&#160;or&#160;with&#160;its&#160;synonym&#160;TCPSocket.new.<br/>Pass&#160;the&#160;name&#160;of&#160;the&#160;host&#160;to&#160;connect&#160;to&#160;as&#160;the&#160;first&#160;argument&#160;and&#160;the&#160;port&#160;as&#160;the&#160;second<br/>argument.&#160;(The&#160;port&#160;should&#160;be&#160;an&#160;integer&#160;between&#160;1&#160;and&#160;65535,&#160;specified&#160;as&#160;a&#160;Fixnum<br/>or&#160;String&#160;object.&#160;Different&#160;internet&#160;protocols&#160;use&#160;different&#160;ports.&#160;Web&#160;servers&#160;use&#160;port<br/>80&#160;by&#160;default,&#160;for&#160;example.&#160;You&#160;may&#160;also&#160;pass&#160;the&#160;name&#160;of&#160;an&#160;Internet&#160;service,&#160;such&#160;as<br/>“http”,&#160;as&#160;a&#160;string,&#160;in&#160;place&#160;of&#160;a&#160;port&#160;number,&#160;but&#160;this&#160;is&#160;not&#160;well&#160;documented&#160;and&#160;may<br/>be system dependent.)<br/>Once&#160;you&#160;have&#160;a&#160;socket&#160;open,&#160;you&#160;can&#160;read&#160;from&#160;it&#160;like&#160;any&#160;IO&#160;object.&#160;When&#160;done,<br/>remember&#160;to&#160;close&#160;it,&#160;as&#160;you&#160;would&#160;close&#160;a&#160;file.&#160;The&#160;following&#160;code&#160;is&#160;a&#160;very&#160;simple<br/>client&#160;that&#160;connects&#160;to&#160;a&#160;given&#160;host&#160;and&#160;port,&#160;reads&#160;any&#160;available&#160;data&#160;from&#160;the&#160;socket,<br/>and then exits:<br/>
require 'socket' &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Sockets are in standard library<br/>
host, port = ARGV &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Host and port from command line<br/>
s = TCPSocket.open(host, port) &#160;# Open a socket to host and port<br/>while line = s.gets &#160; &#160; &#160; &#160; &#160; &#160; # Read lines from the socket<br/>&#160; puts line.chop &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# And print with platform line terminator<br/>end<br/>s.close &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Close the socket when done<br/>
Like&#160;File.open,&#160;the&#160;TCPSocket.open&#160;method&#160;can&#160;be&#160;invoked&#160;with&#160;a&#160;block.&#160;In&#160;that&#160;form,<br/>it&#160;passes&#160;the&#160;open&#160;socket&#160;to&#160;the&#160;block&#160;and&#160;automatically&#160;closes&#160;the&#160;socket&#160;when&#160;the<br/>block returns. So we can also write this code like this:<br/>
require 'socket' &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;<br/>host, port = ARGV &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;&#160;<br/>TCPSocket.open(host, port) do |s| # Use block form of open<br/>&#160; while line = s.gets &#160; &#160; &#160; &#160; &#160; &#160;&#160;<br/>&#160; &#160; puts line.chop &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;<br/>&#160; end<br/>end &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Socket automatically closed<br/>
This&#160;&#160;client&#160;&#160;code&#160;&#160;is&#160;&#160;for&#160;&#160;use&#160;&#160;with&#160;&#160;services&#160;&#160;like&#160;&#160;the&#160;&#160;old-style&#160;&#160;(and&#160;&#160;now&#160;&#160;defunct)&#160;&#160;Unix<br/>“daytime”&#160;service.&#160;With&#160;services&#160;like&#160;these,&#160;the&#160;client&#160;doesn’t&#160;make&#160;a&#160;query;&#160;the&#160;client<br/>
<b>9.8 &#160;Networking&#160;|&#160;367</b><br/>
<hr/>
<a name=382></a>simply&#160;connects&#160;and&#160;the&#160;server&#160;sends&#160;a&#160;response.&#160;If&#160;you&#160;can’t&#160;find&#160;an&#160;Internet&#160;host<br/>running a server to test the client with, don’t despair—the next section shows how to<br/>write an equally simple time server.<br/>
<b>9.8.2 &#160;A Very Simple Server<br/></b>To&#160;write&#160;Internet&#160;servers,&#160;we&#160;use&#160;the&#160;TCPServer&#160;class.&#160;In essence, a&#160;TCPServer&#160;object is<br/>a&#160;factory&#160;for&#160;TCPSocket&#160;objects.&#160;Call&#160;TCPServer.open&#160;to&#160;specify&#160;a&#160;port&#160;for&#160;your&#160;service<br/>and create a&#160;TCPServer&#160;object. Next, call the&#160;accept&#160;method of the returned&#160;TCPServer<br/>object.&#160;This&#160;method&#160;waits&#160;until&#160;a&#160;client&#160;connects&#160;to&#160;the&#160;port&#160;you&#160;specified,&#160;and&#160;then<br/>returns a&#160;TCPSocket&#160;object that represents the connection to that client.<br/>The&#160;following&#160;code&#160;shows&#160;how&#160;we&#160;might&#160;write&#160;a&#160;simple&#160;time&#160;server.&#160;It&#160;listens&#160;for&#160;con-<br/>nections&#160;on&#160;port&#160;2000.&#160;When&#160;a&#160;client&#160;connects&#160;to&#160;that&#160;port,&#160;it&#160;sends&#160;the&#160;current&#160;time<br/>to&#160;the&#160;client&#160;and&#160;closes&#160;the&#160;socket,&#160;thereby&#160;terminating&#160;the&#160;connection&#160;with&#160;the&#160;client:<br/>
require 'socket' &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Get sockets from stdlib<br/>
server = TCPServer.open(2000) &#160;# Socket to listen on port 2000<br/>loop { &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Infinite loop: servers run forever<br/>&#160; client = server.accept &#160; &#160; &#160; # Wait for a client to connect<br/>&#160; client.puts(Time.now.ctime) &#160;# Send the time to the client<br/>&#160; client.close &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Disconnect from the client<br/>}<br/>
To&#160;test&#160;this&#160;code,&#160;run&#160;it&#160;in&#160;the&#160;background&#160;or&#160;in&#160;another&#160;terminal&#160;window.&#160;Then,&#160;run<br/>the simple client code from above with a command like this:<br/>
ruby client.rb localhost 2000<br/>
&#160;<br/>
<b>9.8.3 &#160;Datagrams<br/></b>Most&#160;Internet&#160;protocols&#160;are&#160;implemented&#160;using&#160;TCPSocket&#160;and&#160;TCPServer,&#160;as&#160;shown<br/>earlier.&#160;A&#160;lower-overhead&#160;alternative&#160;is&#160;to&#160;use&#160;UDP&#160;datagrams,&#160;with&#160;the&#160;UDPSocket&#160;class.<br/>UDP&#160;allows&#160;computers&#160;to&#160;send&#160;individual&#160;packets&#160;of&#160;data&#160;to&#160;other&#160;computers,&#160;without<br/>the&#160;overhead&#160;of&#160;establishing&#160;a&#160;persistent&#160;connection.&#160;The&#160;following&#160;client&#160;and&#160;server<br/>code&#160;demonstrate:&#160;the&#160;client&#160;sends&#160;a&#160;datagram&#160;containing&#160;a&#160;string&#160;of&#160;text&#160;to&#160;a&#160;specified<br/>host&#160;and&#160;port.&#160;The&#160;server,&#160;which&#160;should&#160;be&#160;running&#160;on&#160;that&#160;host&#160;and&#160;listening&#160;on&#160;that<br/>port,&#160;receives&#160;the&#160;text,&#160;converts&#160;it&#160;to&#160;uppercase&#160;(not&#160;much&#160;of&#160;a&#160;service,&#160;I&#160;know),&#160;and<br/>sends it back in a second datagram.<br/>The&#160;client&#160;code&#160;is&#160;first.&#160;Note&#160;that&#160;although&#160;UDPSocket&#160;objects&#160;are&#160;IO&#160;objects,&#160;datagrams<br/>are pretty different from other&#160;IO&#160;streams. For this reason, we avoid using&#160;IO&#160;methods<br/>and&#160;use&#160;the&#160;lower-level&#160;sending&#160;and&#160;receiving&#160;methods&#160;of&#160;UDPSocket.&#160;The&#160;second&#160;ar-<br/>gument&#160;to&#160;the&#160;send&#160;method&#160;specifies&#160;flags.&#160;It&#160;is&#160;required,&#160;even&#160;though&#160;we&#160;are&#160;not&#160;setting<br/>any&#160;flags.&#160;The&#160;argument&#160;to&#160;recvfrom&#160;specifies&#160;the&#160;maximum&#160;amount&#160;of&#160;data&#160;we&#160;are<br/>interested&#160;in&#160;receiving.&#160;In&#160;this&#160;case,&#160;we&#160;limit&#160;our&#160;client&#160;and&#160;server&#160;to&#160;transferring&#160;1<br/>kilobyte:<br/>
<b>368&#160;|&#160;Chapter 9:</b> <b>The Ruby Platform</b><br/>
<hr/>
<a name=383></a>require 'socket' &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Standard library<br/>
host, port, request = ARGV &#160; &#160; &#160; &#160; &#160; # Get args from command line<br/>
ds = UDPSocket.new &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Create datagram socket<br/>ds.connect(host, port) &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Connect to the port on the host<br/>ds.send(request, 0) &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Send the request text<br/>response,address = ds.recvfrom(1024) # Wait for a response (1kb max)<br/>puts response &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Print the response<br/>
The&#160;server&#160;code&#160;uses&#160;the&#160;UDPSocket&#160;class&#160;just&#160;as&#160;the&#160;client&#160;code&#160;does—there&#160;is&#160;no&#160;special<br/>UDPServer&#160;class&#160;for&#160;datagram-based&#160;servers.&#160;Instead&#160;of&#160;calling&#160;connect&#160;to&#160;connect&#160;the<br/>socket,&#160;our&#160;server&#160;calls&#160;bind&#160;to&#160;tell&#160;the&#160;socket&#160;what&#160;port&#160;to&#160;listen&#160;on.&#160;The&#160;server&#160;then<br/>uses&#160;&#160;send&#160;&#160;and&#160;&#160;recvfrom,&#160;&#160;just&#160;&#160;as&#160;&#160;the&#160;&#160;client&#160;&#160;does,&#160;&#160;but&#160;&#160;in&#160;&#160;the&#160;&#160;opposite&#160;&#160;order.&#160;&#160;It&#160;&#160;calls<br/>recvfrom&#160;to&#160;wait&#160;until&#160;it&#160;receives&#160;a&#160;datagram&#160;on&#160;the&#160;specified&#160;port.&#160;When&#160;that&#160;happens,<br/>it&#160;converts&#160;the&#160;text&#160;it&#160;receives&#160;to&#160;uppercase&#160;and&#160;sends&#160;it&#160;back.&#160;An&#160;important&#160;point&#160;to<br/>notice&#160;is&#160;that&#160;the&#160;recvfrom&#160;method&#160;returns&#160;two&#160;values.&#160;The&#160;first&#160;is&#160;the&#160;received&#160;data.<br/>The&#160;second&#160;is&#160;an&#160;array&#160;containing&#160;information&#160;about&#160;where&#160;that&#160;data&#160;came&#160;from.&#160;We<br/>extract&#160;host&#160;and&#160;port&#160;information&#160;from&#160;that&#160;array&#160;and&#160;use&#160;it&#160;to&#160;send&#160;the&#160;response&#160;back<br/>to the client:<br/>
require 'socket' &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Standard library<br/>
port = ARGV[0] &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # The port to listen on<br/>
ds = UDPSocket.new &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Create new socket<br/>ds.bind(nil, port) &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Make it listen on the port<br/>loop do &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Loop forever<br/>&#160; request,address=ds.recvfrom(1024) &#160;# Wait to receive something<br/>&#160; response = request.upcase &#160; &#160; &#160; &#160; &#160;# Convert request text to uppercase<br/>&#160; clientaddr = address[3] &#160; &#160; &#160; &#160; &#160; &#160;# What ip address sent the request?<br/>&#160; clientname = address[2] &#160; &#160; &#160; &#160; &#160; &#160;# What is the host name?<br/>&#160; clientport = address[1] &#160; &#160; &#160; &#160; &#160; &#160;# What port was it sent from<br/>&#160; ds.send(response, 0, &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Send the response back...<br/>&#160; &#160; &#160; &#160; &#160; clientaddr, clientport) &#160; &#160;# ...where it came from<br/>&#160; # Log the client connection<br/>&#160; puts &#34;Connection from: #{clientname} #{clientaddr} #{clientport}&#34;<br/>end<br/>
<b>9.8.4 &#160;A More Complex Client<br/></b>The&#160;following&#160;code&#160;is&#160;a&#160;more&#160;fully&#160;developed&#160;Internet&#160;client&#160;in&#160;the&#160;style&#160;of&#160;<i>telnet</i>.&#160;It<br/>connects&#160;to&#160;the&#160;specified&#160;host&#160;and&#160;port&#160;and&#160;then&#160;loops,&#160;reading&#160;a&#160;line&#160;of&#160;input&#160;from&#160;the<br/>console,&#160;sending&#160;it&#160;to&#160;the&#160;server,&#160;and&#160;then&#160;reading&#160;and&#160;printing&#160;the&#160;server’s&#160;response.<br/>It&#160;&#160;demonstrates&#160;&#160;how&#160;&#160;to&#160;&#160;determine&#160;&#160;the&#160;&#160;local&#160;&#160;and&#160;&#160;remote&#160;&#160;addresses&#160;&#160;of&#160;&#160;the&#160;&#160;network<br/>connection,&#160;&#160;adds&#160;&#160;exception&#160;&#160;handling,&#160;&#160;and&#160;&#160;uses&#160;&#160;the&#160;&#160;IO&#160;&#160;methods&#160;&#160;read_nonblock&#160;&#160;and<br/>readpartial&#160;described&#160;earlier&#160;in&#160;this&#160;chapter.&#160;The&#160;code&#160;is&#160;well-commented&#160;and&#160;should<br/>be self-explanatory:<br/>
require 'socket' &#160; &#160; # Sockets from standard library<br/>
<b>9.8 &#160;Networking&#160;|&#160;369</b><br/>
<hr/>
<a name=384></a>host, port = ARGV &#160; &#160;# Network host and port on command line<br/>
begin &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Begin for exception handling<br/>&#160; # Give the user some feedback while connecting.<br/>&#160; STDOUT.print &#34;Connecting...&#34; &#160; &#160; &#160;# Say what we're doing<br/>&#160; STDOUT.flush &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Make it visible right away<br/>&#160; s = TCPSocket.open(host, port) &#160; &#160;# Connect<br/>&#160; STDOUT.puts &#34;done&#34; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# And say we did it<br/>
&#160; # Now display information about the connection.<br/>&#160; local, peer = s.addr, s.peeraddr<br/>&#160; STDOUT.print &#34;Connected to #{peer[2]}:#{peer[1]}&#34;<br/>&#160; STDOUT.puts &#34; using local port #{local[1]}&#34;<br/>
&#160; # Wait just a bit, to see if the server sends any initial message.<br/>&#160; begin<br/>&#160; &#160; sleep(0.5) &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Wait half a second<br/>&#160; &#160; msg = s.read_nonblock(4096) &#160; &#160; # Read whatever is ready<br/>&#160; &#160; STDOUT.puts msg.chop &#160; &#160; &#160; &#160; &#160; &#160;# And display it<br/>&#160; rescue SystemCallError<br/>&#160; &#160; # If nothing was ready to read, just ignore the exception.<br/>&#160; end<br/>
&#160; # Now begin a loop of client/server interaction.<br/>&#160; loop do<br/>&#160; &#160; STDOUT.print '&gt; ' &#160; # Display prompt for local input<br/>&#160; &#160; STDOUT.flush &#160; &#160; &#160; &#160;# Make sure the prompt is visible<br/>&#160; &#160; local = STDIN.gets &#160;# Read line from the console<br/>&#160; &#160; break if !local &#160; &#160; # Quit if no input from console<br/>
&#160; &#160; s.puts(local) &#160; &#160; &#160; # Send the line to the server<br/>&#160; &#160; s.flush &#160; &#160; &#160; &#160; &#160; &#160; # Force it out<br/>
&#160; &#160; # Read the server's response and print out.<br/>&#160; &#160; # The server may send more than one line, so use readpartial<br/>&#160; &#160; # to read whatever it sends (as long as it all arrives in one chunk).<br/>&#160; &#160; response = s.readpartial(4096) # Read server's response<br/>&#160; &#160; puts(response.chop) &#160; &#160; &#160; &#160; &#160; &#160;# Display response to user<br/>&#160; end<br/>rescue &#160; &#160; &#160; &#160; &#160; # If anything goes wrong<br/>&#160; puts $! &#160; &#160; &#160; &#160;# Display the exception to the user<br/>ensure &#160; &#160; &#160; &#160; &#160; # And no matter what happens<br/>&#160; s.close if s &#160; # Don't forget to close the socket<br/>end<br/>
<b>9.8.5 &#160;A Multiplexing Server<br/></b>The&#160;simple&#160;time&#160;server&#160;shown&#160;earlier&#160;in&#160;this&#160;section&#160;never&#160;maintained&#160;a&#160;connection&#160;with<br/>any&#160;&#160;client—it&#160;&#160;would&#160;&#160;simply&#160;&#160;tell&#160;&#160;the&#160;&#160;client&#160;&#160;the&#160;&#160;time&#160;&#160;and&#160;&#160;disconnect.&#160;&#160;Many&#160;&#160;more<br/>sophisticated&#160;servers&#160;maintain&#160;a&#160;connection,&#160;and&#160;in&#160;order&#160;to&#160;be&#160;useful,&#160;they&#160;must&#160;allow<br/>multiple&#160;clients&#160;to&#160;connect&#160;and&#160;interact&#160;at&#160;the&#160;same&#160;time.&#160;One&#160;way&#160;to&#160;do&#160;this&#160;is&#160;with<br/>threads—each&#160;client&#160;runs&#160;in&#160;its&#160;own&#160;thread.&#160;We’ll&#160;see&#160;an&#160;example&#160;of&#160;a&#160;multithreaded<br/>
<b>370&#160;|&#160;Chapter 9:</b> <b>The Ruby Platform</b><br/>
<hr/>
<a name=385></a>server&#160;later&#160;in&#160;this&#160;chapter.&#160;The&#160;alternative&#160;that&#160;we’ll&#160;consider&#160;here&#160;is&#160;to&#160;write&#160;a&#160;multi-<br/>plexing server using the&#160;Kernel.select&#160;method.<br/>When&#160;a&#160;server&#160;has&#160;multiple&#160;clients&#160;connected,&#160;it&#160;cannot&#160;call&#160;a&#160;blocking&#160;method&#160;like<br/>gets&#160;on&#160;the&#160;socket&#160;of&#160;any&#160;one&#160;client.&#160;If&#160;it&#160;blocks&#160;waiting&#160;for&#160;input&#160;from&#160;one&#160;client,&#160;it<br/>won’t&#160;be&#160;able&#160;to&#160;receive&#160;input&#160;from&#160;other&#160;clients&#160;or&#160;accept&#160;connections&#160;from&#160;new&#160;clients.<br/>The&#160;select&#160;method&#160;solves&#160;this&#160;problem;&#160;it&#160;allows&#160;us&#160;to&#160;block&#160;on&#160;a&#160;whole&#160;array&#160;of&#160;IO<br/>objects,&#160;and&#160;returns&#160;when&#160;there&#160;is&#160;activity&#160;on&#160;any&#160;one&#160;of&#160;those&#160;objects.&#160;The&#160;return&#160;value<br/>of&#160;select&#160;is&#160;an&#160;array&#160;of&#160;arrays&#160;of&#160;IO&#160;objects.&#160;The&#160;first&#160;element&#160;of&#160;the&#160;array&#160;is&#160;the&#160;array<br/>of&#160;&#160;streams&#160;&#160;(sockets,&#160;&#160;in&#160;&#160;this&#160;&#160;case)&#160;&#160;that&#160;&#160;have&#160;&#160;data&#160;&#160;to&#160;&#160;be&#160;&#160;read&#160;&#160;(or&#160;&#160;a&#160;&#160;connection&#160;&#160;to&#160;&#160;be<br/>accepted).<br/>With&#160;that&#160;explanation&#160;of&#160;select,&#160;you&#160;should&#160;be&#160;able&#160;to&#160;understand&#160;the&#160;following&#160;server<br/>code.&#160;The&#160;service&#160;it&#160;implements&#160;is&#160;trivial—it&#160;simply&#160;reverses&#160;each&#160;line&#160;of&#160;client&#160;input<br/>and&#160;sends&#160;it&#160;back.&#160;It&#160;is&#160;the&#160;mechanism&#160;for&#160;handling&#160;multiple&#160;connections&#160;that&#160;is&#160;inter-<br/>esting.&#160;Note&#160;that&#160;we&#160;use&#160;select&#160;to&#160;monitor&#160;both&#160;the&#160;TCPServer&#160;object&#160;and&#160;each&#160;of&#160;the<br/>client&#160;TCPSocket&#160;objects. Also note that the server handles the case where a client asks<br/>to disconnect as well as the case where the client disconnects unexpectedly:<br/>
# This server reads a line of input from a client, reverses<br/># the line and sends it back. If the client sends the string &#34;quit&#34;<br/># it disconnects. It uses Kernel.select to handle multiple sessions.<br/>
require 'socket' &#160; &#160; &#160; &#160; &#160;&#160;<br/>
server = TCPServer.open(2000) # Listen on port 2000<br/>sockets = [server] &#160; &#160; &#160; &#160; &#160; &#160;# An array of sockets we'll monitor<br/>log = STDOUT &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Send log messages to standard out<br/>while true &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Servers loop forever<br/>&#160; ready = select(sockets) &#160; &#160; # Wait for a socket to be ready<br/>&#160; readable = ready[0] &#160; &#160; &#160; &#160; # These sockets are readable<br/>
&#160; readable.each do |socket| &#160; &#160; &#160; &#160; # Loop through readable sockets<br/>&#160; &#160; if socket == server &#160; &#160; &#160; &#160; &#160; &#160; # If the server socket is ready<br/>&#160; &#160; &#160; client = server.accept &#160; &#160; &#160; &#160;# Accept a new client<br/>&#160; &#160; &#160; sockets &lt;&lt; client &#160; &#160; &#160; &#160; &#160; &#160; # Add it to the set of sockets<br/>&#160; &#160; &#160; # Tell the client what and where it has connected.<br/>&#160; &#160; &#160; client.puts &#34;Reversal service v0.01 running on #{Socket.gethostname}&#34;<br/>&#160; &#160; &#160; # And log the fact that the client connected<br/>&#160; &#160; &#160; log.puts &#34;Accepted connection from #{client.peeraddr[2]}&#34;<br/>&#160; &#160; else &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Otherwise, a client is ready<br/>&#160; &#160; &#160; input = socket.gets &#160; &#160; &#160; &#160; &#160; # Read input from the client<br/>
&#160; &#160; &#160; # If no input, the client has disconnected<br/>&#160; &#160; &#160; if !input &#160;&#160;<br/>&#160; &#160; &#160; &#160; log.puts &#34;Client on #{socket.peeraddr[2]} disconnected.&#34;<br/>&#160; &#160; &#160; &#160; sockets.delete(socket) &#160; &#160; &#160;# Stop monitoring this socket<br/>&#160; &#160; &#160; &#160; socket.close &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Close it<br/>&#160; &#160; &#160; &#160; next &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# And go on to the next<br/>&#160; &#160; &#160; end<br/>
&#160; &#160; &#160; input.chop! &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Trim client's input<br/>
<b>9.8 &#160;Networking&#160;|&#160;371</b><br/>
<hr/>
<a name=386></a>&#160; &#160; &#160; if (input == &#34;quit&#34;) &#160; &#160; &#160; &#160; &#160;# If the client asks to quit<br/>&#160; &#160; &#160; &#160; socket.puts(&#34;Bye!&#34;); &#160; &#160; &#160; &#160;# Say goodbye<br/>&#160; &#160; &#160; &#160; log.puts &#34;Closing connection to #{socket.peeraddr[2]}&#34;<br/>&#160; &#160; &#160; &#160; sockets.delete(socket) &#160; &#160; &#160;# Stop monitoring the socket<br/>&#160; &#160; &#160; &#160; socket.close &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Terminate the session<br/>&#160; &#160; &#160; else &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Otherwise, client is not quitting<br/>&#160; &#160; &#160; &#160; socket.puts(input.reverse) &#160;# So reverse input and send it back<br/>&#160; &#160; &#160; end<br/>&#160; &#160; end<br/>&#160; end<br/>end<br/>
<b>9.8.6 &#160;Fetching Web Pages<br/></b>We can use the socket library to implement any Internet protocol. Here, for example,<br/>is code to fetch the content of a web page:<br/>
require 'socket' &#160; &#160; &#160; &#160; &#160; # We need sockets<br/>&#160;<br/>host = 'www.example.com' &#160; # The web server<br/>port = 80 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Default HTTP port<br/>path = &#34;/index.html&#34; &#160; &#160; &#160; # The file we want&#160;<br/>
# This is the HTTP request we send to fetch a file<br/>request = &#34;GET #{path} HTTP/1.0\r\n\r\n&#34;<br/>
socket = TCPSocket.open(host,port) &#160;# Connect to server<br/>socket.print(request) &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Send request<br/>response = socket.read &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Read complete response<br/># Split response at first blank line into headers and body<br/>headers,body = response.split(&#34;\r\n\r\n&#34;, 2)&#160;<br/>print body &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# And display it<br/>
HTTP&#160;is&#160;a&#160;complex&#160;protocol,&#160;and&#160;the&#160;simple&#160;code&#160;above&#160;only&#160;really&#160;handles&#160;straight-<br/>forward&#160;cases.&#160;You&#160;might&#160;prefer&#160;to&#160;use&#160;a&#160;prebuilt&#160;library&#160;like&#160;Net::HTTP&#160;for&#160;working<br/>with HTTP. Here is code that does the equivalent of the previous code:<br/>
require 'net/http' &#160; &#160; &#160; &#160; # The library we need<br/>host = 'www.example.com' &#160; # The web server<br/>path = '/index.html' &#160; &#160; &#160; # The file we want&#160;<br/>
http = Net::HTTP.new(host) &#160; &#160; &#160;# Create a connection<br/>headers, body = http.get(path) &#160;# Request the file<br/>if headers.code == &#34;200&#34; &#160; &#160; &#160; &#160;# Check the status code &#160;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # NOTE: code is not a number!<br/>&#160; print body &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Print body if we got it<br/>else &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Otherwise<br/>&#160; puts &#34;#{headers.code} #{headers.message}&#34; # Display error message<br/>end<br/>
Similar&#160;libraries&#160;exist&#160;for&#160;working&#160;with&#160;the&#160;FTP,&#160;SMTP,&#160;POP,&#160;and&#160;IMAP&#160;protocols.<br/>Details of those standard libraries are beyond the scope of this book.<br/>
<b>372&#160;|&#160;Chapter 9:</b> <b>The Ruby Platform</b><br/>
<hr/>
<a name=387></a>Finally, recall that the&#160;open-uri&#160;library described earlier in the chapter makes fetching<br/>a web page even easier:<br/>
require 'open-uri'<br/>open(&#34;http://www.example.com/index.html&#34;) {|f|<br/>&#160; puts f.read<br/>}<br/>
<b>9.9 &#160;Threads and Concurrency<br/></b>Traditional&#160;programs&#160;have&#160;a&#160;single&#160;“thread&#160;of&#160;execution”:&#160;the&#160;statements&#160;or&#160;instruc-<br/>tions&#160;&#160;that&#160;&#160;comprise&#160;&#160;the&#160;&#160;program&#160;&#160;are&#160;&#160;executed&#160;&#160;sequentially&#160;&#160;until&#160;&#160;the&#160;&#160;program<br/>terminates.&#160;A&#160;<i>multithreaded</i>&#160;program&#160;has&#160;more&#160;than&#160;one&#160;thread&#160;of&#160;execution.&#160;Within<br/>each&#160;thread,&#160;statements&#160;are&#160;executed&#160;sequentially,&#160;but&#160;the&#160;threads&#160;themselves&#160;may&#160;be<br/>executed&#160;&#160;in&#160;&#160;parallel—on&#160;&#160;a&#160;&#160;multicore&#160;&#160;CPU,&#160;&#160;for&#160;&#160;example.&#160;&#160;Often&#160;&#160;(on&#160;&#160;single-core,<br/>single-CPU&#160;machines,&#160;for&#160;instance),&#160;multiple&#160;threads&#160;are&#160;not&#160;actually&#160;executed&#160;in&#160;par-<br/>allel, but parallelism is simulated by interleaving the execution of the threads.<br/>Programs&#160;such&#160;as&#160;image&#160;processing&#160;software&#160;that&#160;perform&#160;a&#160;lot&#160;of&#160;calculations&#160;are&#160;said<br/>to be&#160;<i>compute-bound</i>.&#160;They&#160;can&#160;only&#160;benefit&#160;from&#160;multithreading&#160;if&#160;there&#160;are&#160;actually<br/>multiple&#160;CPUs&#160;to&#160;run&#160;computations&#160;in&#160;parallel.&#160;Most&#160;programs&#160;are&#160;not&#160;fully&#160;compute-<br/>bound,&#160;however.&#160;Many,&#160;such&#160;as&#160;web&#160;browsers,&#160;spend&#160;most&#160;of&#160;their&#160;time&#160;waiting&#160;for<br/>network&#160;or&#160;file&#160;I/O.&#160;Programs&#160;like&#160;these&#160;are&#160;said&#160;to&#160;be&#160;<i>IO-bound</i>.&#160;IO-bound programs<br/>can&#160;be&#160;usefully&#160;multithreaded&#160;even&#160;when&#160;there&#160;is&#160;only&#160;a&#160;single&#160;CPU&#160;available.&#160;A&#160;web<br/>browser&#160;might&#160;render&#160;an&#160;image&#160;in&#160;one&#160;thread&#160;while&#160;another&#160;thread&#160;is&#160;waiting&#160;for&#160;the<br/>next image to be downloaded from the network.<br/>Ruby makes it easy to write multi-threaded programs with the&#160;Thread&#160;class. To start a<br/>new&#160;thread,&#160;just&#160;associate&#160;a&#160;block&#160;with&#160;a&#160;call&#160;to&#160;Thread.new.&#160;A&#160;new&#160;thread&#160;will&#160;be&#160;created<br/>to&#160;execute&#160;the&#160;code&#160;in&#160;the&#160;block,&#160;and&#160;the&#160;original&#160;thread&#160;will&#160;return&#160;from&#160;Thread.new<br/>immediately and resume execution with the next statement:<br/>
# Thread #1 is running here<br/>Thread.new {<br/>&#160; # Thread #2 runs this code<br/>}<br/># Thread #1 runs this code<br/>
We’ll&#160;begin&#160;our&#160;coverage&#160;of&#160;threads&#160;by&#160;explaining&#160;Ruby’s&#160;thread&#160;model&#160;and&#160;API&#160;in&#160;some<br/>detail.&#160;&#160;These&#160;&#160;introductory&#160;&#160;sections&#160;&#160;explain&#160;&#160;things&#160;&#160;such&#160;&#160;as&#160;&#160;thread&#160;&#160;lifecycle,&#160;&#160;thread<br/>scheduling,&#160;and&#160;thread&#160;states.&#160;With&#160;that&#160;introductory&#160;material&#160;as&#160;prerequisite,&#160;we&#160;move<br/>on&#160;&#160;to&#160;&#160;present&#160;&#160;example&#160;&#160;code&#160;&#160;and&#160;&#160;to&#160;&#160;cover&#160;&#160;advanced&#160;&#160;topics&#160;&#160;such&#160;&#160;as&#160;&#160;thread<br/>synchronization.<br/>Finally,&#160;it&#160;is&#160;worth&#160;noting&#160;that&#160;Ruby&#160;programs&#160;can&#160;also&#160;achieve&#160;concurrency&#160;at&#160;the&#160;level<br/>of&#160;the&#160;operating&#160;system&#160;process&#160;by&#160;running&#160;external&#160;executables&#160;or&#160;by&#160;forking&#160;new<br/>copies&#160;of&#160;the&#160;Ruby&#160;interpreter.&#160;Doing&#160;this&#160;is&#160;operating&#160;system-dependent,&#160;however,&#160;and<br/>
<b>9.9 &#160;Threads and Concurrency&#160;|&#160;373</b><br/>
<hr/>
<a name=388></a>is&#160;covered&#160;only&#160;briefly&#160;in&#160;<a href="Rubys.html#403">Chapter&#160;10.&#160;</a>For&#160;further&#160;information,&#160;use&#160;<i>ri</i>&#160;to&#160;look&#160;up&#160;the<br/>methods&#160;Kernel.system,&#160;Kernel.exec,&#160;Kernel.fork,&#160;IO.popen,&#160;and&#160;the&#160;module&#160;Process.<br/>
<b>Threads and Platform Dependencies</b><br/>
Different operating systems implement threads differently. And different Ruby imple-<br/>mentations&#160;&#160;layer&#160;&#160;Ruby&#160;&#160;threads&#160;&#160;on&#160;&#160;top&#160;&#160;of&#160;&#160;operating&#160;&#160;system&#160;&#160;threads&#160;&#160;differently.&#160;&#160;The<br/>standard C implementation of Ruby 1.8,&#160;for example, uses only a single native thread<br/>and&#160;runs&#160;all&#160;Ruby&#160;threads&#160;within&#160;that&#160;one&#160;native&#160;thread.&#160;This&#160;means&#160;that&#160;in&#160;Ruby&#160;1.8<br/>threads&#160;are&#160;very&#160;lightweight,&#160;but&#160;that&#160;they&#160;never&#160;run&#160;in&#160;parallel,&#160;even&#160;on&#160;multicore<br/>CPUs.<br/>
Ruby&#160;1.9&#160;is&#160;different:&#160;it&#160;allocates&#160;a&#160;native&#160;thread&#160;for&#160;each&#160;Ruby&#160;thread.&#160;But&#160;because<br/>some&#160;of&#160;the&#160;C&#160;libraries&#160;used&#160;in&#160;this&#160;implementation&#160;are&#160;not&#160;themselves&#160;thread-safe,<br/>Ruby&#160;1.9&#160;is&#160;very&#160;conservative&#160;and&#160;never&#160;allows&#160;more&#160;than&#160;one&#160;of&#160;its&#160;native&#160;threads&#160;to<br/>run&#160;at&#160;the&#160;same&#160;time.&#160;(This&#160;restriction&#160;may&#160;be&#160;relaxed&#160;in&#160;later&#160;releases&#160;of&#160;1.9,&#160;if&#160;the&#160;C<br/>code can be made thread-safe.)<br/>
JRuby,&#160;the&#160;Java&#160;implementation&#160;of&#160;Ruby,&#160;maps&#160;each&#160;Ruby&#160;thread&#160;to&#160;a&#160;Java&#160;thread.&#160;But<br/>the&#160;implementation&#160;and&#160;behavior&#160;of&#160;Java&#160;threads&#160;depends,&#160;in&#160;turn,&#160;on&#160;the&#160;implemen-<br/>tation&#160;of&#160;the&#160;Java&#160;virtual&#160;machine.&#160;Modern&#160;Java&#160;implementations&#160;typically&#160;implement<br/>Java threads as native threads and allow true parallel processing on multicore CPUs.<br/>
<b>9.9.1 &#160;Thread Lifecycle<br/></b>As&#160;described&#160;above,&#160;new&#160;threads&#160;are&#160;created&#160;with&#160;Thread.new.&#160;You&#160;can&#160;also&#160;use&#160;the<br/>synonyms&#160;Thread.start&#160;and&#160;Thread.fork.&#160;There&#160;is&#160;no&#160;need&#160;to&#160;start&#160;a&#160;thread&#160;after&#160;cre-<br/>ating&#160;it;&#160;it&#160;begins&#160;running&#160;automatically&#160;when&#160;CPU&#160;resources&#160;become&#160;available.&#160;The<br/>value&#160;of&#160;the&#160;Thread.new&#160;invocation&#160;is&#160;a&#160;Thread&#160;object.&#160;The&#160;Thread&#160;class&#160;defines&#160;a&#160;number<br/>of methods to query and manipulate the thread while it is running.<br/>A&#160;thread&#160;runs&#160;the&#160;code&#160;in&#160;the&#160;block&#160;associated&#160;with&#160;the&#160;call&#160;to&#160;Thread.new&#160;and&#160;then&#160;it<br/>stops&#160;running.&#160;The&#160;value&#160;of&#160;the&#160;last&#160;expression&#160;in&#160;that&#160;block&#160;is&#160;the&#160;value&#160;of&#160;the&#160;thread,<br/>and&#160;can&#160;be&#160;obtained&#160;by&#160;calling&#160;the&#160;value&#160;method&#160;of&#160;the&#160;Thread&#160;object.&#160;If&#160;the&#160;thread&#160;has<br/>run&#160;to&#160;completion,&#160;then&#160;the&#160;value&#160;returns&#160;the&#160;thread’s&#160;value&#160;right&#160;away.&#160;Otherwise,&#160;the<br/>value&#160;method blocks and does not return until the thread has completed.<br/>
The&#160;class&#160;method&#160;Thread.current&#160;returns&#160;the&#160;Thread&#160;object&#160;that&#160;represents&#160;the&#160;current<br/>thread.&#160;This&#160;allows&#160;threads&#160;to&#160;manipulate&#160;themselves.&#160;The&#160;class&#160;method&#160;Thread.main<br/>returns the&#160;Thread&#160;object&#160;that&#160;represents&#160;the&#160;main&#160;thread—this&#160;is&#160;the&#160;initial&#160;thread&#160;of<br/>execution that began when the Ruby program was started.<br/>
<b>9.9.1.1 &#160;The main thread<br/></b>The&#160;main&#160;thread&#160;is&#160;special:&#160;the&#160;Ruby&#160;interpreter&#160;stops&#160;running&#160;when&#160;the&#160;main&#160;thread<br/>is&#160;done.&#160;It&#160;does&#160;this&#160;even&#160;if&#160;the&#160;main&#160;thread&#160;has&#160;created&#160;other&#160;threads&#160;that&#160;are&#160;still<br/>running.&#160;You&#160;must&#160;ensure,&#160;therefore,&#160;that&#160;your&#160;main&#160;thread&#160;does&#160;not&#160;end&#160;while&#160;other<br/>
<b>374&#160;|&#160;Chapter 9:</b> <b>The Ruby Platform</b><br/>
<hr/>
<a name=389></a>threads&#160;are&#160;still&#160;running.&#160;One&#160;way&#160;to&#160;do&#160;this&#160;is&#160;to&#160;write&#160;your&#160;main&#160;thread&#160;in&#160;the&#160;form<br/>of&#160;an&#160;infinite&#160;loop.&#160;Another&#160;way&#160;is&#160;to&#160;explicitly&#160;wait&#160;for&#160;the&#160;threads&#160;you&#160;care&#160;about&#160;to<br/>complete. We’ve already mentioned that you can call the&#160;value&#160;method of a thread to<br/>wait&#160;for&#160;it&#160;to&#160;finish.&#160;If&#160;you&#160;don’t&#160;care&#160;about&#160;the&#160;value&#160;of&#160;your&#160;threads,&#160;you&#160;can&#160;wait&#160;with<br/>the&#160;join&#160;method instead.<br/>The&#160;following&#160;method&#160;waits&#160;until&#160;all&#160;threads,&#160;other&#160;than&#160;the&#160;main&#160;thread&#160;and&#160;the&#160;current<br/>thread (which may be the same thing), have exited:<br/>
# Wait for all threads (other than the current thread and<br/># main thread) to stop running.<br/># Assumes that no new threads are started while waiting.<br/>def join_all<br/>&#160; main = Thread.main &#160; &#160; &#160; &#160;# The main thread<br/>&#160; current = Thread.current &#160;# The current thread<br/>&#160; all = Thread.list &#160; &#160; &#160; &#160; # All threads still running<br/>&#160; # Now call join on each thread<br/>&#160; all.each {|t| t.join unless t == current or t == main }<br/>end<br/>
<b>9.9.1.2 &#160;Threads and unhandled exceptions<br/></b>If&#160;an&#160;exception&#160;is&#160;raised&#160;in&#160;the&#160;main&#160;thread,&#160;and&#160;is&#160;not&#160;handled&#160;anywhere,&#160;the&#160;Ruby<br/>interpreter&#160;prints&#160;a&#160;message&#160;and&#160;exits.&#160;In&#160;threads&#160;other&#160;than&#160;the&#160;main&#160;thread,&#160;unhandled<br/>exceptions&#160;cause&#160;the&#160;thread&#160;to&#160;stop&#160;running.&#160;By&#160;default,&#160;however,&#160;this&#160;does&#160;not&#160;cause<br/>the&#160;interpreter&#160;to&#160;print&#160;a&#160;message&#160;or&#160;exit.&#160;If&#160;a&#160;thread&#160;t&#160;exits&#160;because&#160;of&#160;an&#160;unhandled<br/>exception,&#160;&#160;and&#160;&#160;another&#160;&#160;thread&#160;&#160;s&#160;&#160;calls&#160;&#160;t.join&#160;&#160;or&#160;&#160;t.value,&#160;&#160;then&#160;&#160;the&#160;&#160;exception&#160;&#160;that<br/>occurred in&#160;t&#160;is raised in the thread&#160;s.<br/>If&#160;you&#160;would&#160;like&#160;any&#160;unhandled&#160;exception&#160;in&#160;any&#160;thread&#160;to&#160;cause&#160;the&#160;interpreter&#160;to<br/>exit, use the class method&#160;Thread.abort_on_exception=:<br/>
Thread.abort_on_exception = true<br/>
If&#160;you&#160;want&#160;an&#160;unhandled&#160;exception&#160;in&#160;one&#160;particular&#160;thread&#160;to&#160;cause&#160;the&#160;interpreter<br/>to exit, use the instance method by the same name:<br/>
t = Thread.new { ... }<br/>t.abort_on_exception = true<br/>
<b>9.9.2 &#160;Threads and Variables<br/></b>One&#160;of&#160;the&#160;key&#160;features&#160;of&#160;threads&#160;is&#160;that&#160;they&#160;can&#160;share&#160;access&#160;to&#160;variables.&#160;Because<br/>threads&#160;are&#160;defined&#160;by&#160;blocks,&#160;they&#160;have&#160;access&#160;to&#160;whatever&#160;variables&#160;(local&#160;variables,<br/>instance variables, global variables, and so on) are in the scope of the block:<br/>
x = 0<br/>
t1 = Thread.new do<br/>&#160; # This thread can query and set the variable x<br/>end<br/>
<b>9.9 &#160;Threads and Concurrency&#160;|&#160;375</b><br/>
<hr/>
<a name=390></a>t2 = Thread.new do<br/>&#160; # This thread and also query and set x<br/>&#160; # And it can query and set t1 and t2 as well. &#160;&#160;<br/>end<br/>
When&#160;two&#160;or&#160;more&#160;threads&#160;read&#160;and&#160;write&#160;the&#160;same&#160;variables&#160;concurrently,&#160;they&#160;must<br/>be&#160;careful&#160;that&#160;they&#160;do&#160;so&#160;correctly.&#160;We’ll&#160;have&#160;more&#160;to&#160;say&#160;about&#160;this&#160;when&#160;we&#160;consider<br/>thread synchronization below.<br/>
<b>9.9.2.1 &#160;Thread-private variables<br/></b>Variables&#160;defined&#160;within&#160;the&#160;block&#160;of&#160;a&#160;thread&#160;are&#160;private&#160;to&#160;that&#160;thread&#160;and&#160;are&#160;not<br/>visible&#160;to&#160;any&#160;other&#160;thread.&#160;This&#160;is&#160;simply&#160;a&#160;consequence&#160;of&#160;Ruby’s&#160;variable&#160;scoping<br/>rules.<br/>We&#160;often&#160;want&#160;a&#160;thread&#160;to&#160;have&#160;its&#160;own&#160;private&#160;copy&#160;of&#160;a&#160;variable&#160;so&#160;that&#160;its&#160;behavior<br/>does&#160;not&#160;change&#160;if&#160;the&#160;value&#160;of&#160;that&#160;variable&#160;changes.&#160;Consider&#160;the&#160;following&#160;code,<br/>which&#160;attempts&#160;to&#160;create&#160;three&#160;threads&#160;that&#160;print&#160;(respectively)&#160;the&#160;numbers&#160;1,&#160;2,&#160;and&#160;3:<br/>
n = 1<br/>while n &lt;= 3<br/>&#160; Thread.new { puts n }<br/>&#160; n += 1<br/>end&#160;<br/>
In&#160;some&#160;circumstances,&#160;in&#160;some&#160;implementations,&#160;this&#160;code&#160;might&#160;work&#160;as&#160;expected<br/>and&#160;print&#160;the&#160;numbers&#160;1,&#160;2,&#160;and&#160;3.&#160;In&#160;other&#160;circumstances&#160;or&#160;in&#160;other&#160;implementations,<br/>it&#160;might&#160;not.&#160;It&#160;is&#160;perfectly&#160;possible&#160;(if&#160;newly&#160;created&#160;threads&#160;do&#160;not&#160;run&#160;right&#160;away)&#160;for<br/>the&#160;code&#160;to&#160;print&#160;4,&#160;4,&#160;and&#160;4,&#160;for&#160;example.&#160;Each&#160;thread&#160;reads&#160;a&#160;shared&#160;copy&#160;of&#160;the&#160;variable<br/>n,&#160;and&#160;the&#160;value&#160;of&#160;that&#160;variable&#160;changes&#160;as&#160;the&#160;loop&#160;executes.&#160;The&#160;value&#160;printed&#160;by&#160;the<br/>thread depends on when that thread runs in relation to the parent thread.<br/>To&#160;solve&#160;this&#160;problem,&#160;we&#160;pass&#160;the&#160;current&#160;value&#160;of&#160;n&#160;to&#160;the&#160;Thread.new&#160;method,&#160;and<br/>assign&#160;the&#160;current&#160;value&#160;of&#160;that&#160;variable&#160;to&#160;a&#160;block&#160;parameter.&#160;Block&#160;parameters&#160;are<br/>private&#160;to&#160;the&#160;block&#160;(but&#160;see&#160;<a href="Rubys.html#156">§5.4.3&#160;</a>for&#160;cautions),&#160;and&#160;this&#160;private&#160;value&#160;is&#160;not&#160;shared<br/>between threads:<br/>
n = 1<br/>while n &lt;= 3<br/>&#160; # Get a private copy of the current value of n in x<br/>&#160; Thread.new(n) {|x| puts x }<br/>&#160; n += 1<br/>end&#160;<br/>
Note&#160;that&#160;another&#160;way&#160;to&#160;solve&#160;this&#160;problem&#160;is&#160;to&#160;use&#160;an&#160;iterator&#160;instead&#160;of&#160;a&#160;while&#160;loop.<br/>In&#160;this&#160;case,&#160;the&#160;value&#160;of&#160;n&#160;is&#160;private&#160;to&#160;the&#160;outer&#160;block&#160;and&#160;never&#160;changes&#160;during&#160;the<br/>execution of that block:<br/>
1.upto(3) {|n| Thread.new { puts n }}<br/>
<b>376&#160;|&#160;Chapter 9:</b> <b>The Ruby Platform</b><br/>
<hr/>
<a name=391></a><b>9.9.2.2 &#160;Thread-local variables<br/></b>Certain&#160;of&#160;Ruby’s&#160;special&#160;global&#160;variables&#160;are&#160;<i>thread-local</i>:&#160;they&#160;may&#160;have&#160;different&#160;val-<br/>ues&#160;in&#160;different&#160;threads.&#160;$SAFE&#160;(see&#160;<a href="Rubys.html#423">§10.5)&#160;</a>and&#160;$~&#160;(see&#160;<a href="Rubys.html#332">Table&#160;9-3)&#160;</a>are&#160;examples.&#160;This<br/>means&#160;that&#160;if&#160;two&#160;threads&#160;are&#160;performing&#160;regular&#160;expression&#160;matching&#160;concurrently,<br/>they&#160;&#160;will&#160;&#160;see&#160;&#160;different&#160;&#160;values&#160;&#160;of&#160;&#160;$~,&#160;&#160;and&#160;&#160;performing&#160;&#160;a&#160;&#160;match&#160;&#160;in&#160;&#160;one&#160;&#160;thread&#160;&#160;will&#160;&#160;not<br/>interfere with the results of a match performed in another thread.<br/>The&#160;Thread&#160;class&#160;provides&#160;hash-like&#160;behavior.&#160;It&#160;defines&#160;[]&#160;and&#160;[]=&#160;instance&#160;methods<br/>that&#160;allow&#160;you&#160;to&#160;associate&#160;arbitrary&#160;values&#160;with&#160;any&#160;symbol.&#160;(If&#160;you&#160;use&#160;a&#160;string&#160;instead,<br/>it&#160;will&#160;be&#160;converted&#160;to&#160;a&#160;symbol.&#160;Unlike&#160;true&#160;hashes,&#160;the&#160;Thread&#160;class&#160;only&#160;allows&#160;symbols<br/>as&#160;keys.)&#160;The&#160;values&#160;associated&#160;with&#160;these&#160;symbols&#160;behave&#160;like&#160;thread-local&#160;variables.<br/>They&#160;are&#160;not&#160;private&#160;like&#160;block-local&#160;variables&#160;because&#160;any&#160;thread&#160;can&#160;look&#160;up&#160;a&#160;value<br/>in&#160;any&#160;other&#160;thread.&#160;But&#160;they&#160;are&#160;not&#160;shared&#160;variables&#160;either,&#160;since&#160;each&#160;thread&#160;can&#160;have<br/>its own copy.<br/>As&#160;an&#160;example,&#160;suppose&#160;that&#160;we’ve&#160;created&#160;threads&#160;to&#160;download&#160;files&#160;from&#160;a&#160;web&#160;server.<br/>The&#160;main&#160;thread&#160;might&#160;want&#160;to&#160;monitor&#160;the&#160;progress&#160;of&#160;the&#160;download.&#160;To&#160;enable&#160;this,<br/>each thread might do the following:<br/>
Thread.current[:progress] = bytes_received<br/>
The&#160;main&#160;thread&#160;could&#160;then&#160;determine&#160;the&#160;total&#160;bytes&#160;downloaded&#160;with&#160;code&#160;like&#160;this:<br/>
total = 0<br/>download_threads.each {|t| total += t[:progress] }<br/>
Along&#160;with&#160;[]&#160;and&#160;[]=,&#160;Thread&#160;also&#160;defines&#160;a&#160;key?&#160;method&#160;to&#160;test&#160;whether&#160;a&#160;given&#160;key<br/>exists&#160;for&#160;a&#160;thread.&#160;The&#160;keys&#160;method&#160;returns&#160;an&#160;array&#160;of&#160;symbols&#160;representing&#160;the&#160;de-<br/>fined&#160;keys&#160;for&#160;the&#160;thread.&#160;This&#160;code&#160;could&#160;be&#160;better&#160;written&#160;as&#160;follows,&#160;so&#160;that&#160;it&#160;works<br/>for&#160;threads&#160;that&#160;have&#160;not&#160;yet&#160;started&#160;running&#160;and&#160;have&#160;not&#160;defined&#160;the&#160;:progress&#160;key&#160;yet:<br/>
total = 0<br/>download_threads.each {|t| total += t[:progress] if t.key?(:progress)}<br/>
<b>9.9.3 &#160;Thread Scheduling<br/></b>Ruby&#160;interpreters&#160;often&#160;have&#160;more&#160;threads&#160;to&#160;run&#160;than&#160;there&#160;are&#160;CPUs&#160;available&#160;to&#160;run<br/>them.&#160;When&#160;true&#160;parallel&#160;processing&#160;is&#160;not&#160;possible,&#160;it&#160;is&#160;simulated&#160;by&#160;sharing&#160;a&#160;CPU<br/>among&#160;threads.&#160;The&#160;process&#160;for&#160;sharing&#160;a&#160;CPU&#160;among&#160;threads&#160;is&#160;called&#160;thread&#160;sched-<br/>uling.&#160;Depending&#160;on&#160;the&#160;implementation&#160;and&#160;platform,&#160;thread&#160;scheduling&#160;may&#160;be&#160;done<br/>by the Ruby interpreter, or it may be handled by the underlying operating system.<br/>
<b>9.9.3.1 &#160;Thread priorities<br/></b>The&#160;first&#160;factor&#160;that&#160;affects&#160;thread&#160;scheduling&#160;is&#160;<i>thread&#160;priority</i>:&#160;high-priority&#160;threads<br/>are&#160;scheduled&#160;before&#160;low-priority&#160;threads.&#160;More&#160;precisely,&#160;a&#160;thread&#160;will&#160;only&#160;get&#160;CPU<br/>time if there are no higher-priority threads waiting to run.<br/>
<b>9.9 &#160;Threads and Concurrency&#160;|&#160;377</b><br/>
<hr/>
<a name=392></a>Set&#160;and&#160;query&#160;the&#160;priority&#160;of&#160;a&#160;Ruby&#160;Thread&#160;object with&#160;priority=&#160;and&#160;priority. Note<br/>that&#160;there&#160;is&#160;no&#160;way&#160;to&#160;set&#160;the&#160;priority&#160;of&#160;a&#160;thread&#160;before&#160;it&#160;starts&#160;running.&#160;A&#160;thread&#160;can,<br/>however, raise or lower its own priority as the first action it takes.<br/>A&#160;newly&#160;created&#160;thread&#160;starts&#160;at&#160;the&#160;same&#160;priority&#160;as&#160;the&#160;thread&#160;that&#160;created&#160;it.&#160;The&#160;main<br/>thread starts off at priority 0.<br/>Like&#160;many&#160;aspects&#160;of&#160;threading,&#160;thread&#160;priorities&#160;are&#160;dependent&#160;on&#160;the&#160;implementation<br/>of&#160;Ruby&#160;and&#160;on&#160;the&#160;underlying&#160;operating&#160;system.&#160;Under&#160;Linux,&#160;for&#160;example,&#160;nonpri-<br/>vileged&#160;threads&#160;cannot&#160;have&#160;their&#160;priorities&#160;raised&#160;or&#160;lowered.&#160;So&#160;in&#160;Ruby&#160;1.9&#160;(which<br/>uses native threads) on Linux, the thread priority setting is ignored.<br/>
<b>9.9.3.2 &#160;Thread preemption and Thread.pass<br/></b>When&#160;multiple&#160;threads&#160;of&#160;the&#160;same&#160;priority&#160;need&#160;to&#160;share&#160;the&#160;CPU,&#160;it&#160;is&#160;up&#160;to&#160;the&#160;thread<br/>scheduler&#160;to&#160;decide&#160;when,&#160;and&#160;for&#160;how&#160;long,&#160;each&#160;thread&#160;runs.&#160;Some&#160;schedulers&#160;are<br/>preempting,&#160;which&#160;means&#160;that&#160;they&#160;allow&#160;a&#160;thread&#160;to&#160;run&#160;only&#160;for&#160;a&#160;fixed&#160;amount&#160;of<br/>time&#160;before&#160;allowing&#160;another&#160;thread&#160;of&#160;the&#160;same&#160;priority&#160;to&#160;run.&#160;Other&#160;schedulers&#160;are<br/>not&#160;preempting:&#160;once&#160;a&#160;thread&#160;starts&#160;running,&#160;it&#160;keeps&#160;running&#160;unless&#160;it&#160;sleeps,&#160;blocks<br/>for I/O, or a higher-priority thread wakes up.<br/>If a long-running compute-bound thread (i.e., one that does not ever block for I/O) is<br/>running&#160;on&#160;a&#160;nonpreempting&#160;scheduler,&#160;it&#160;will&#160;“starve”&#160;other&#160;threads&#160;of&#160;the&#160;same&#160;pri-<br/>ority,&#160;&#160;and&#160;&#160;they&#160;&#160;will&#160;&#160;never&#160;&#160;get&#160;&#160;a&#160;&#160;chance&#160;&#160;to&#160;&#160;run.&#160;&#160;To&#160;&#160;avoid&#160;&#160;this&#160;&#160;issue,&#160;&#160;long-running<br/>compute-bound&#160;threads&#160;should&#160;periodically&#160;call&#160;Thread.pass&#160;to&#160;ask&#160;the&#160;scheduler&#160;to<br/>yield the CPU to another thread.<br/>
<b>9.9.4 &#160;Thread States<br/></b>A&#160;Ruby&#160;thread&#160;may&#160;be&#160;in&#160;one&#160;of&#160;five&#160;possible&#160;states.&#160;The&#160;two&#160;most&#160;interesting&#160;states&#160;are<br/>for&#160;live&#160;threads:&#160;a&#160;thread&#160;that&#160;is&#160;alive&#160;is&#160;<i>runnable</i>&#160;or&#160;<i>sleeping</i>.&#160;A&#160;runnable&#160;thread&#160;is&#160;one<br/>that&#160;is&#160;currently&#160;running,&#160;or&#160;that&#160;is&#160;ready&#160;and&#160;eligible&#160;to&#160;run&#160;the&#160;next&#160;time&#160;there&#160;are&#160;CPU<br/>resources&#160;for&#160;it.&#160;A&#160;sleeping&#160;thread&#160;is&#160;one&#160;that&#160;is&#160;sleeping&#160;(see&#160;&#160;Kernel.sleep),&#160;that&#160;is<br/>waiting&#160;for&#160;I/O,&#160;or&#160;that&#160;has&#160;stopped&#160;itself&#160;(see&#160;Thread.stop&#160;below).&#160;Threads&#160;typically<br/>go back and forth between the runnable and sleeping states.<br/>There&#160;are&#160;two&#160;thread&#160;states&#160;for&#160;threads&#160;that&#160;are&#160;no&#160;longer&#160;alive.&#160;A&#160;terminated&#160;thread<br/>has either terminated normally or has terminated abnormally with an exception.<br/>Finally,&#160;there&#160;is&#160;one&#160;transitional&#160;state.&#160;A&#160;thread&#160;that&#160;has&#160;been&#160;killed&#160;(see&#160;Thread.kill<br/>below) but that has not yet terminated is said to be&#160;<i>aborting</i>.<br/>
<b>9.9.4.1 &#160;Querying thread state<br/></b>The&#160;Thread&#160;class&#160;defines&#160;several&#160;instance&#160;methods&#160;for&#160;testing&#160;the&#160;status&#160;of&#160;a&#160;thread.<br/>alive?&#160;returns&#160;true&#160;if a thread is runnable or sleeping.&#160;stop?&#160;returns&#160;true&#160;if a thread is<br/>in&#160;any&#160;state&#160;other&#160;than&#160;runnable.&#160;Finally,&#160;the&#160;status&#160;method&#160;returns&#160;the&#160;state&#160;of&#160;the<br/>
<b>378&#160;|&#160;Chapter 9:</b> <b>The Ruby Platform</b><br/>
<hr/>
<a name=393></a>thread.&#160;There&#160;are&#160;five&#160;possible&#160;return&#160;values&#160;corresponding&#160;to&#160;the&#160;five&#160;possible&#160;states<br/>as shown in the following table.<br/>
<b>Thread state</b><br/>
<b>Return value</b><br/>
Runnable<br/>
&#34;run&#34;<br/>
Sleeping<br/>
&#34;sleep&#34;<br/>
Aborting<br/>
&#34;aborting&#34;<br/>
Terminated normally<br/>
false<br/>
Terminated with exception<br/>
nil<br/>
<b>9.9.4.2 &#160;Altering state: pausing, waking, and killing threads<br/></b>Threads&#160;are&#160;created&#160;in&#160;the&#160;<i>runnable</i>&#160;state,&#160;and&#160;are&#160;eligible&#160;to&#160;run&#160;right&#160;away.&#160;A&#160;thread<br/>can&#160;pause&#160;itself—enter&#160;the&#160;<i>sleeping</i>&#160;state—by&#160;calling&#160;Thread.stop.&#160;This&#160;is&#160;a&#160;class&#160;method<br/>that&#160;operates&#160;on&#160;the&#160;current&#160;thread—there&#160;is&#160;no&#160;equivalent&#160;instance&#160;method,&#160;so&#160;one<br/>thread&#160;cannot&#160;force&#160;another&#160;thread&#160;to&#160;pause.&#160;Calling&#160;Thread.stop&#160;is&#160;effectively&#160;the&#160;same<br/>thing&#160;as&#160;calling&#160;Kernel.sleep&#160;with&#160;no&#160;argument:&#160;the&#160;thread&#160;pauses&#160;forever&#160;(or&#160;until<br/>woken up, as explained below).<br/>Threads&#160;&#160;also&#160;&#160;temporarily&#160;&#160;enter&#160;&#160;the&#160;&#160;<i>sleeping</i>&#160;&#160;state&#160;&#160;if&#160;&#160;they&#160;&#160;call&#160;&#160;Kernel.sleep&#160;&#160;with&#160;&#160;an<br/>argument.&#160;In&#160;this&#160;case,&#160;they&#160;automatically&#160;wake&#160;up&#160;and&#160;reenter&#160;the&#160;<i>runnable</i>&#160;state&#160;after<br/>(approximately)&#160;the&#160;specified&#160;number&#160;of&#160;seconds&#160;pass.&#160;Calling&#160;blocking&#160;IO&#160;methods<br/>may&#160;also&#160;cause&#160;a&#160;thread&#160;to&#160;sleep&#160;until&#160;the&#160;IO&#160;operation&#160;completes—in&#160;fact,&#160;it&#160;is&#160;the<br/>inherent&#160;latency&#160;of&#160;IO&#160;operations&#160;that&#160;makes&#160;threading&#160;worthwhile&#160;even&#160;on&#160;single-CPU<br/>systems.<br/>A&#160;thread&#160;that&#160;has&#160;paused&#160;itself&#160;with&#160;Thread.stop&#160;or&#160;Kernel.sleep&#160;can&#160;be&#160;started&#160;again<br/>(even&#160;if&#160;the&#160;sleep&#160;time&#160;has&#160;not&#160;expired&#160;yet)&#160;with&#160;the&#160;instance&#160;methods&#160;wakeup&#160;and&#160;run.<br/>Both&#160;methods&#160;switch&#160;the&#160;thread&#160;from&#160;the&#160;<i>sleeping</i>&#160;state&#160;to&#160;the&#160;<i>runnable</i>&#160;state.&#160;The&#160;run<br/>method&#160;also&#160;invokes&#160;the&#160;thread&#160;scheduler.&#160;This&#160;causes&#160;the&#160;current&#160;thread&#160;to&#160;yield&#160;the<br/>CPU,&#160;&#160;and&#160;&#160;may&#160;&#160;cause&#160;&#160;the&#160;&#160;newly&#160;&#160;awoken&#160;&#160;thread&#160;&#160;to&#160;&#160;start&#160;&#160;running&#160;&#160;right&#160;&#160;away.&#160;&#160;The<br/>wakeup&#160;method wakes the specified thread without yielding the CPU.<br/>
A&#160;thread&#160;can&#160;switch&#160;itself&#160;from&#160;the&#160;<i>runnable</i>&#160;state&#160;to&#160;one&#160;of&#160;the&#160;<i>terminated</i>&#160;states&#160;simply<br/>by&#160;exiting&#160;its&#160;block&#160;or&#160;by&#160;raising&#160;an&#160;exception.&#160;Another&#160;way&#160;for&#160;a&#160;thread&#160;to&#160;terminate<br/>normally&#160;is&#160;by&#160;calling&#160;Thread.exit.&#160;Note&#160;that&#160;any&#160;ensure&#160;clauses&#160;are&#160;processed&#160;before<br/>a thread exits in this way.<br/>A&#160;thread&#160;can&#160;forcibly&#160;terminate&#160;another&#160;thread&#160;by&#160;invoking&#160;the&#160;instance&#160;method&#160;kill<br/>on&#160;&#160;the&#160;&#160;thread&#160;&#160;to&#160;&#160;be&#160;&#160;terminated.&#160;&#160;terminate&#160;&#160;and&#160;&#160;exit&#160;&#160;are&#160;&#160;synonyms&#160;&#160;for&#160;&#160;kill.&#160;&#160;These<br/>methods&#160;put&#160;the&#160;killed&#160;thread&#160;into&#160;the&#160;<i>terminated&#160;normally</i>&#160;state.&#160;The&#160;killed&#160;thread&#160;runs<br/>any&#160;&#160;ensure&#160;&#160;clauses&#160;&#160;before&#160;&#160;it&#160;&#160;actually&#160;&#160;dies.&#160;&#160;The&#160;&#160;kill!&#160;&#160;method&#160;&#160;(and&#160;&#160;its&#160;&#160;synonyms<br/>terminate!&#160;and&#160;exit!) terminate a thread but do not allow any&#160;ensure&#160;clauses to run.<br/>
The&#160;thread&#160;termination&#160;methods&#160;described&#160;so&#160;far&#160;all&#160;force&#160;a&#160;thread&#160;to&#160;the&#160;<i>terminated<br/>normally</i>&#160;state.&#160;You&#160;can&#160;raise&#160;an&#160;exception&#160;within&#160;another&#160;thread&#160;with&#160;the&#160;instance<br/>
<b>9.9 &#160;Threads and Concurrency&#160;|&#160;379</b><br/>
<hr/>
<a name=394></a>method&#160;raise.&#160;If&#160;the&#160;thread&#160;cannot&#160;handle&#160;the&#160;exception&#160;you&#160;have&#160;imposed&#160;on&#160;it,&#160;it&#160;will<br/>enter the&#160;<i>terminated with exception</i>&#160;state.&#160;The&#160;threads&#160;ensure&#160;clauses&#160;are&#160;processed&#160;as<br/>they would normally be during the course of exception propagation.<br/>Killing a thread is a dangerous thing to do unless you have some way of knowing that<br/>the&#160;thread&#160;is&#160;not&#160;in&#160;the&#160;middle&#160;of&#160;altering&#160;the&#160;shared&#160;state&#160;of&#160;your&#160;system.&#160;Killing&#160;a<br/>thread&#160;with&#160;one&#160;of&#160;the&#160;!&#160;methods&#160;is&#160;even&#160;more&#160;dangerous&#160;because&#160;the&#160;killed&#160;thread&#160;may<br/>leave&#160;files,&#160;sockets,&#160;or&#160;other&#160;resources&#160;open.&#160;If&#160;a&#160;thread&#160;must&#160;be&#160;able&#160;to&#160;exit&#160;upon&#160;com-<br/>mand,&#160;it&#160;is&#160;better&#160;to&#160;have&#160;it&#160;periodically&#160;check&#160;the&#160;state&#160;of&#160;a&#160;flag&#160;variable&#160;and&#160;terminate<br/>itself safely and gracefully if or when the flag becomes set.<br/>
<b>9.9.5 &#160;Listing Threads and Thread Groups<br/></b>The&#160;Thread.list&#160;method&#160;returns&#160;an&#160;array&#160;of&#160;Thread&#160;objects&#160;representing&#160;all&#160;live&#160;(running<br/>or sleeping) threads. When a thread exits, it is removed from this array.<br/>Every&#160;thread&#160;other&#160;than&#160;the&#160;main&#160;thread&#160;is&#160;created&#160;by&#160;some&#160;other&#160;thread.&#160;Threads&#160;could,<br/>therefore,&#160;be&#160;organized&#160;into&#160;a&#160;tree&#160;structure,&#160;with&#160;every&#160;thread&#160;having&#160;a&#160;parent&#160;and&#160;a<br/>set&#160;of&#160;children.&#160;The&#160;Thread&#160;class&#160;does&#160;not&#160;maintain&#160;this&#160;information,&#160;however:&#160;threads<br/>are&#160;usually&#160;considered&#160;autonomous&#160;rather&#160;than&#160;subordinate&#160;to&#160;the&#160;thread&#160;that&#160;created<br/>them.<br/>If&#160;&#160;you&#160;&#160;want&#160;&#160;to&#160;&#160;impose&#160;&#160;some&#160;&#160;order&#160;&#160;onto&#160;&#160;a&#160;&#160;subset&#160;&#160;of&#160;&#160;threads,&#160;&#160;you&#160;&#160;can&#160;&#160;create&#160;&#160;a<br/>ThreadGroup&#160;object and add threads to it:<br/>
group = ThreadGroup.new<br/>3.times {|n| group.add(Thread.new { do_task(n) }}<br/>
New&#160;threads&#160;are&#160;initially&#160;placed&#160;in&#160;the&#160;group&#160;to&#160;which&#160;their&#160;parent&#160;belongs.&#160;Use&#160;the<br/>instance&#160;method&#160;group&#160;to&#160;query&#160;the&#160;ThreadGroup&#160;to&#160;which&#160;a&#160;thread&#160;belongs.&#160;And&#160;use<br/>
&#160;<br/>
the&#160;&#160;list&#160;&#160;method&#160;&#160;of&#160;&#160;ThreadGroup&#160;&#160;to&#160;&#160;obtain&#160;&#160;an&#160;&#160;array&#160;&#160;of&#160;&#160;threads&#160;&#160;in&#160;&#160;a&#160;&#160;group.&#160;&#160;Like&#160;&#160;the<br/>class&#160;method&#160;Thread.list,&#160;the&#160;instance&#160;method&#160;ThreadGroup.list&#160;returns&#160;only&#160;threads<br/>that&#160;have&#160;not&#160;terminated&#160;yet.&#160;You&#160;can&#160;use&#160;this&#160;list&#160;method&#160;to&#160;define&#160;methods&#160;that<br/>operate&#160;on&#160;all&#160;threads&#160;in&#160;a&#160;group.&#160;Such&#160;a&#160;method&#160;might&#160;lower&#160;the&#160;priority&#160;of&#160;all&#160;threads<br/>in the group, for example.<br/>The&#160;feature&#160;of&#160;the&#160;ThreadGroup&#160;class&#160;that&#160;makes&#160;it&#160;more&#160;useful&#160;than&#160;a&#160;simple&#160;array&#160;of<br/>threads&#160;is&#160;its&#160;enclose&#160;method.&#160;Once&#160;a&#160;thread&#160;group&#160;has&#160;been&#160;enclosed,&#160;threads&#160;may&#160;not<br/>be&#160;removed&#160;from&#160;it&#160;and&#160;new&#160;threads&#160;cannot&#160;be&#160;added&#160;to&#160;it.&#160;The&#160;threads&#160;in&#160;the&#160;group<br/>may&#160;create&#160;new&#160;threads,&#160;and&#160;these&#160;new&#160;threads&#160;will&#160;become&#160;members&#160;of&#160;the&#160;group.&#160;An<br/>enclosed&#160;ThreadGroup&#160;is&#160;useful&#160;when&#160;you&#160;run&#160;untrusted&#160;Ruby&#160;code&#160;under&#160;the&#160;$SAFE<br/><a href="Rubys.html#423">variable (see §10.5) and want to keep track of any threads spawned by that code.</a><br/>
<b>9.9.6 &#160;Threading Examples<br/></b>Now&#160;that&#160;we’ve&#160;explained&#160;Ruby’s&#160;thread&#160;model&#160;and&#160;thread&#160;API,&#160;we’ll&#160;take&#160;a&#160;look&#160;at<br/>some actual examples of multithreaded code.<br/>
<b>380&#160;|&#160;Chapter 9:</b> <b>The Ruby Platform</b><br/>
<hr/>
<a name=395></a><b>9.9.6.1 &#160;Reading files concurrently<br/></b>The&#160;most&#160;common&#160;use&#160;of&#160;Ruby’s&#160;threads&#160;is&#160;in&#160;programs&#160;that&#160;are&#160;IO-bound.&#160;They&#160;allow<br/>programs&#160;to&#160;keep&#160;busy&#160;even&#160;while&#160;waiting&#160;for&#160;input&#160;from&#160;the&#160;user,&#160;the&#160;filesystem,&#160;or<br/>the&#160;network.&#160;The&#160;following&#160;code,&#160;for&#160;example,&#160;defines&#160;a&#160;method&#160;conread&#160;(for concur-<br/>rent&#160;read)&#160;that&#160;takes&#160;an&#160;array&#160;of&#160;filenames&#160;and&#160;returns&#160;a&#160;hash&#160;mapping&#160;those&#160;names&#160;to<br/>the&#160;contents&#160;of&#160;those&#160;files.&#160;It&#160;uses&#160;threads&#160;to&#160;read&#160;those&#160;files&#160;concurrently,&#160;and&#160;is&#160;really<br/>intended&#160;for&#160;use&#160;with&#160;the&#160;open-uri&#160;module,&#160;which&#160;allows&#160;HTTP&#160;and&#160;FTP&#160;URLs&#160;to&#160;be<br/>opened with&#160;Kernel.open&#160;and read as if they were files:<br/>
# Read files concurrently. Use with the &#34;open-uri&#34; module to fetch URLs.<br/># Pass an array of filenames. Returns a hash mapping filenames to content.<br/>def conread(filenames)<br/>&#160; h = {} &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Empty hash of results<br/>
&#160; # Create one thread for each file<br/>&#160; filenames.each do |filename| &#160; &#160; &#160;# For each named file<br/>&#160; &#160; h[filename] = Thread.new do &#160; &#160; # Create a thread, map to filename<br/>&#160; &#160; &#160; open(filename) {|f| f.read } &#160;# Open and read the file<br/>&#160; &#160; end &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Thread value is file contents<br/>&#160; end<br/>
&#160; # Iterate through the hash, waiting for each thread to complete.<br/>&#160; # Replace the thread in the hash with its value (the file contents)<br/>&#160; h.each_pair do |filename, thread|&#160;<br/>&#160; &#160; begin<br/>&#160; &#160; &#160; h[filename] = thread.value &#160; &#160;# Map filename to file contents<br/>&#160; &#160; rescue<br/>&#160; &#160; &#160; h[filename] = $! &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Or to the exception raised<br/>&#160; &#160; end<br/>&#160; end<br/>end<br/>
<b>9.9.6.2 &#160;A Multithreaded Server<br/></b>Another,&#160;almost&#160;canonical,&#160;use&#160;case&#160;for&#160;threads&#160;is&#160;for&#160;writing&#160;servers&#160;that&#160;can&#160;commu-<br/>nicate with more than one client at a time. We saw how to do this using multiplexing<br/>with&#160;Kernel.select,&#160;but&#160;a&#160;somewhat&#160;simpler&#160;(though&#160;possibly&#160;less&#160;scalable)&#160;solution<br/>uses threads:<br/>
require 'socket'<br/>
# This method expects a socket connected to a client.<br/># It reads lines from the client, reverses them and sends them back.<br/># Multiple threads may run this method at the same time.<br/>def handle_client(c)<br/>&#160; while true<br/>&#160; &#160; input = c.gets.chop &#160; &#160; # Read a line of input from the client<br/>&#160; &#160; break if !input &#160; &#160; &#160; &#160; # Exit if no more input<br/>&#160; &#160; break if input==&#34;quit&#34; &#160;# or if the client asks to.<br/>&#160; &#160; c.puts(input.reverse) &#160; # Otherwise, respond to client.<br/>&#160; &#160; c.flush &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Force our output out<br/>&#160; end<br/>
<b>9.9 &#160;Threads and Concurrency&#160;|&#160;381</b><br/>
<hr/>
<a name=396></a>&#160; c.close &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Close the client socket<br/>end<br/>
server = TCPServer.open(2000) # Listen on port 2000<br/>
while true &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Servers loop forever<br/>&#160; client = server.accept &#160; &#160; &#160;# Wait for a client to connect<br/>&#160; Thread.start(client) do |c| # Start a new thread&#160;<br/>&#160; &#160; handle_client(c) &#160; &#160; &#160; &#160; &#160;# And handle the client on that thread<br/>&#160; end<br/>end<br/>
<b>9.9.6.3 &#160;Concurrent iterators<br/></b>Although&#160;&#160;IO-bound&#160;&#160;tasks&#160;&#160;are&#160;&#160;the&#160;&#160;typical&#160;&#160;use&#160;&#160;case&#160;&#160;for&#160;&#160;Ruby’s&#160;&#160;threads,&#160;&#160;they&#160;&#160;are&#160;&#160;not<br/>restricted to that use. The following code adds a method&#160;conmap&#160;(for concurrent map)<br/>to&#160;the&#160;Enumerable&#160;module.&#160;It&#160;works&#160;like&#160;map&#160;but&#160;processes&#160;each&#160;element&#160;of&#160;the&#160;input<br/>array using a separate thread:<br/>
module Enumerable &#160; &#160; &#160; &#160; &#160; # Open the Enumerable module<br/>&#160; def conmap(&amp;block) &#160; &#160; &#160; &#160;# Define a new method that expects a block<br/>&#160; &#160; threads = [] &#160; &#160; &#160; &#160; &#160; &#160;# Start with an empty array of threads<br/>&#160; &#160; self.each do |item| &#160; &#160; # For each enumerable item<br/>&#160; &#160; &#160; # Invoke the block in a new thread, and remember the thread<br/>&#160; &#160; &#160; threads &lt;&lt; Thread.new { block.call(item) }<br/>&#160; &#160; end<br/>&#160; &#160; # Now map the array of threads to their values&#160;<br/>&#160; &#160; threads.map {|t| t.value } # And return the array of values<br/>&#160; end<br/>end<br/>
And here’s a similar concurrent version of the&#160;each&#160;iterator:<br/>
module Enumerable<br/>&#160; def concurrently<br/>&#160; &#160; map {|item| Thread.new { yield item }}.each {|t| t.join }<br/>&#160; end<br/>end<br/>
The&#160;code&#160;is&#160;succinct&#160;and&#160;challenging:&#160;if&#160;you&#160;can&#160;make&#160;sense&#160;of&#160;it,&#160;you&#160;are&#160;well&#160;on&#160;your<br/>way to mastery of Ruby syntax and Ruby iterators.<br/>Recall&#160;that&#160;in&#160;Ruby&#160;1.9,&#160;standard&#160;iterators&#160;that&#160;are&#160;not&#160;passed&#160;a&#160;block&#160;return&#160;an&#160;enu-<br/>merator&#160;object.&#160;This&#160;means&#160;that&#160;given&#160;the&#160;concurrently&#160;method&#160;defined&#160;earlier&#160;and&#160;a<br/>Hash&#160;object&#160;h, we can write:<br/>
h.each_pair.concurrently {|*pair| process(pair)}<br/>
<b>9.9.7 &#160;Thread Exclusion and Deadlock<br/></b>If&#160;two&#160;threads&#160;share&#160;access&#160;to&#160;the&#160;same&#160;data,&#160;and&#160;at&#160;least&#160;one&#160;of&#160;the&#160;threads&#160;modifies<br/>that&#160;data,&#160;you&#160;must&#160;take&#160;special&#160;care&#160;to&#160;ensure&#160;that&#160;no&#160;thread&#160;can&#160;ever&#160;see&#160;the&#160;data&#160;in<br/>
<b>382&#160;|&#160;Chapter 9:</b> <b>The Ruby Platform</b><br/>
<hr/>
<a name=397></a>an&#160;inconsistent&#160;state.&#160;This&#160;is&#160;called&#160;<i>thread exclusion</i>. A&#160;couple&#160;of&#160;examples&#160;will&#160;explain<br/>why it is necessary.<br/>First,&#160;suppose&#160;that&#160;two&#160;threads&#160;are&#160;processing&#160;files&#160;and&#160;each&#160;thread&#160;increments&#160;a&#160;shared<br/>variable&#160;in&#160;order&#160;to&#160;keep&#160;track&#160;of&#160;the&#160;total&#160;number&#160;of&#160;files&#160;processed.&#160;The&#160;problem&#160;is<br/>that&#160;incrementing&#160;a&#160;variable&#160;is&#160;not&#160;an&#160;<i>atomic</i>&#160;operation.&#160;That&#160;means&#160;that&#160;it&#160;does&#160;not<br/>happen&#160;in&#160;a&#160;single&#160;step:&#160;to&#160;increment&#160;a&#160;variable,&#160;a&#160;Ruby&#160;program&#160;must&#160;read&#160;its&#160;value,<br/>add&#160;1,&#160;and&#160;then&#160;store&#160;the&#160;new&#160;value&#160;back&#160;into&#160;the&#160;variable.&#160;Suppose&#160;that&#160;our&#160;counter<br/>is at&#160;100,&#160;and&#160;imagine&#160;the&#160;following&#160;interleaved&#160;execution&#160;of&#160;the&#160;two&#160;threads.&#160;The&#160;first<br/>thread&#160;reads&#160;the&#160;value&#160;100,&#160;but&#160;before&#160;it&#160;can&#160;add&#160;1,&#160;the&#160;scheduler&#160;stops&#160;running&#160;the&#160;first<br/>thread&#160;and&#160;allows&#160;the&#160;second&#160;thread&#160;to&#160;run.&#160;Now&#160;the&#160;second&#160;thread&#160;reads&#160;the&#160;value<br/>100,&#160;adds&#160;1,&#160;and&#160;stores&#160;101&#160;back&#160;into&#160;the&#160;counter&#160;variable.&#160;This&#160;second&#160;thread&#160;now&#160;starts<br/>to&#160;read&#160;a&#160;new&#160;file,&#160;which&#160;causes&#160;it&#160;to&#160;block&#160;and&#160;allows&#160;the&#160;first&#160;thread&#160;to&#160;resume.&#160;The<br/>first&#160;thread&#160;now&#160;adds&#160;1&#160;to&#160;100&#160;and&#160;stores&#160;the&#160;result.&#160;Both&#160;threads&#160;have&#160;incremented&#160;the<br/>counter, but its value is&#160;101&#160;instead of&#160;102.<br/>Another&#160;classic&#160;example&#160;of&#160;the&#160;need&#160;for&#160;thread&#160;exclusion&#160;involves&#160;an&#160;electronic&#160;banking<br/>application.&#160;Suppose&#160;one&#160;thread&#160;is&#160;processing&#160;a&#160;transfer&#160;of&#160;money&#160;from&#160;a&#160;savings&#160;ac-<br/>count&#160;to&#160;a&#160;checking&#160;account,&#160;and&#160;another&#160;thread&#160;is&#160;generating&#160;monthly&#160;reports&#160;to&#160;be<br/>sent&#160;out&#160;to&#160;customers.&#160;Without&#160;proper&#160;exclusion,&#160;the&#160;report-generation&#160;thread&#160;might<br/>read&#160;the&#160;customers’&#160;account&#160;data&#160;after&#160;funds&#160;had&#160;been&#160;subtracted&#160;from&#160;savings&#160;but<br/>before they had been added to checking.<br/>We&#160;resolve&#160;problems&#160;like&#160;these&#160;by&#160;using&#160;a&#160;cooperative&#160;locking&#160;mechanism.&#160;Each&#160;thread<br/>that&#160;wants&#160;to&#160;access&#160;shared&#160;data&#160;must&#160;first&#160;<i>lock</i>&#160;that&#160;data.&#160;The&#160;lock&#160;is&#160;represented&#160;by&#160;a<br/>Mutex&#160;(short&#160;for&#160;“mutual&#160;exclusion”)&#160;object.&#160;To&#160;lock&#160;a&#160;Mutex,&#160;you&#160;call&#160;its&#160;lock&#160;method.<br/>When&#160;you’re&#160;done&#160;reading&#160;or&#160;altering&#160;the&#160;shared&#160;data,&#160;you&#160;call&#160;the&#160;unlock&#160;method&#160;of<br/>the&#160;Mutex.&#160;The&#160;lock&#160;method&#160;blocks&#160;when&#160;called&#160;on&#160;a&#160;Mutex&#160;that’s&#160;already&#160;locked,&#160;and<br/>it&#160;does&#160;not&#160;return&#160;until&#160;the&#160;caller&#160;has&#160;successfully&#160;obtained&#160;a&#160;lock.&#160;If&#160;each&#160;thread&#160;that<br/>accesses&#160;the&#160;shared&#160;data&#160;locks&#160;and&#160;unlocks&#160;the&#160;Mutex&#160;correctly,&#160;no&#160;thread&#160;will&#160;see&#160;the<br/>data in an inconsistent state and we won’t have problems like those we’ve described.<br/>
Mutex&#160;is&#160;a&#160;core&#160;class&#160;in&#160;Ruby&#160;1.9&#160;and&#160;is&#160;part&#160;of&#160;the&#160;standard&#160;thread&#160;library&#160;in&#160;Ruby&#160;1.8.<br/>Instead of using the&#160;lock&#160;and&#160;unlock&#160;methods&#160;explicitly,&#160;it&#160;is&#160;more&#160;common&#160;to&#160;use&#160;the<br/>synchronize&#160;method&#160;and&#160;associate&#160;a&#160;block&#160;with&#160;it.&#160;synchronize&#160;locks&#160;the&#160;Mutex,&#160;runs<br/>the&#160;code&#160;in&#160;the&#160;block,&#160;and&#160;then&#160;unlocks&#160;the&#160;Mutex&#160;in&#160;an&#160;ensure&#160;clause&#160;so&#160;that&#160;exceptions<br/>are&#160;properly&#160;handled.&#160;Here&#160;is&#160;a&#160;simple&#160;model&#160;of&#160;our&#160;bank&#160;account&#160;example,&#160;using&#160;a<br/>Mutex&#160;object to synchronize thread access to shared account data:<br/>
require 'thread' &#160;# For Mutex class in Ruby 1.8<br/>
# A BankAccount has a name, a checking amount, and a savings amount.<br/>class BankAccount<br/>&#160; def init(name, checking, savings)<br/>&#160; &#160; @name,@checking,@savings = name,checking,savings&#160;<br/>&#160; &#160; @lock = Mutex.new &#160; &#160; &#160; &#160; # For thread safety<br/>&#160; end<br/>
<b>9.9 &#160;Threads and Concurrency&#160;|&#160;383</b><br/>
<hr/>
<a name=398></a>&#160; # Lock account and transfer money from savings to checking<br/>&#160; def transfer_from_savings(x)<br/>&#160; &#160; @lock.synchronize {<br/>&#160; &#160; &#160; @savings -= x<br/>&#160; &#160; &#160; @checking += x<br/>&#160; &#160; }<br/>&#160; end<br/>
&#160; # Lock account and report current balances<br/>&#160; def report<br/>&#160; &#160; @lock.synchronize {<br/>&#160; &#160; &#160; &#34;#@name\nChecking: #@checking\nSavings: #@savings&#34;<br/>&#160; &#160; }<br/>&#160; end<br/>end<br/>
<b>9.9.7.1 &#160;Deadlock<br/></b>When&#160;we&#160;start&#160;using&#160;Mutex&#160;objects&#160;for&#160;thread&#160;exclusion&#160;we&#160;must&#160;be&#160;careful&#160;to&#160;avoid<br/><i>deadlock</i>.&#160;Deadlock&#160;is&#160;the&#160;condition&#160;that&#160;occurs&#160;when&#160;all&#160;threads&#160;are&#160;waiting&#160;to&#160;acquire<br/>a&#160;resource&#160;held&#160;by&#160;another&#160;thread.&#160;Because&#160;all&#160;threads&#160;are&#160;blocked,&#160;they&#160;cannot&#160;release<br/>the&#160;locks&#160;they&#160;hold.&#160;And&#160;because&#160;they&#160;cannot&#160;release&#160;the&#160;locks,&#160;no&#160;other&#160;thread&#160;can<br/>acquire those locks.<br/>A&#160;classic&#160;deadlock&#160;scenario&#160;involves&#160;two&#160;threads&#160;and&#160;two&#160;Mutex&#160;objects.&#160;Thread&#160;1&#160;locks<br/>Mutex&#160;1&#160;and&#160;then&#160;attempts&#160;to&#160;lock&#160;Mutex&#160;2.&#160;Meanwhile,&#160;thread&#160;2&#160;locks&#160;Mutex&#160;2&#160;and&#160;then<br/>attempts&#160;to&#160;lock&#160;Mutex&#160;1.&#160;Neither&#160;thread&#160;can&#160;acquire&#160;the&#160;lock&#160;it&#160;needs,&#160;and&#160;neither&#160;thread<br/>can release the lock the other one needs, so both threads block forever:<br/>
# Classic deadlock: two threads and two locks<br/>require 'thread'<br/>
m,n = Mutex.new, Mutex.new<br/>
t = Thread.new {<br/>&#160; m.lock<br/>&#160; puts &#34;Thread t locked Mutex m&#34;<br/>&#160; sleep 1<br/>&#160; puts &#34;Thread t waiting to lock Mutex n&#34;<br/>&#160; n.lock<br/>}<br/>
s = Thread.new {<br/>&#160; n.lock<br/>&#160; puts &#34;Thread s locked Mutex n&#34;<br/>&#160; sleep 1<br/>&#160; puts &#34;Thread s waiting to lock Mutex m&#34;<br/>&#160; m.lock<br/>}<br/>
t.join<br/>s.join<br/>
<b>384&#160;|&#160;Chapter 9:</b> <b>The Ruby Platform</b><br/>
<hr/>
<a name=399></a>The&#160;way&#160;to&#160;avoid&#160;this&#160;kind&#160;of&#160;deadlock&#160;is&#160;to&#160;always&#160;lock&#160;resources&#160;in&#160;the&#160;same&#160;order.<br/>If the second thread locked&#160;m&#160;before locking&#160;n, then deadlock would not occur.<br/>Note&#160;that&#160;deadlock&#160;is&#160;possible&#160;even&#160;without&#160;using&#160;Mutex&#160;objects.&#160;Calling&#160;join&#160;on&#160;a<br/>thread that calls&#160;Thread.stop&#160;will&#160;deadlock&#160;both&#160;threads,&#160;unless&#160;there&#160;is&#160;a&#160;third&#160;thread<br/>that can awaken the stopped thread.<br/>Bear in mind that some Ruby implementations can detect simple deadlocks like these<br/>and abort with an error, but this is not guaranteed.<br/>
<b>9.9.8 &#160;Queue and SizedQueue<br/></b>The&#160;standard&#160;thread&#160;library&#160;defines&#160;the&#160;Queue&#160;and&#160;SizedQueue&#160;data&#160;structures&#160;specifically<br/>for&#160;concurrent&#160;programming.&#160;They&#160;implement&#160;thread-safe&#160;FIFO&#160;queues&#160;and&#160;are&#160;inten-<br/>ded&#160;for&#160;a&#160;producer/consumer&#160;model&#160;of&#160;programming.&#160;Under&#160;this&#160;model,&#160;one&#160;thread<br/>produces&#160;values&#160;of&#160;some&#160;sort&#160;and&#160;places&#160;them&#160;on&#160;a&#160;queue&#160;with&#160;the&#160;enq&#160;(enqueue)&#160;meth-<br/>od&#160;or&#160;its&#160;synonym&#160;push.&#160;Another&#160;thread&#160;“consumes”&#160;these&#160;values,&#160;removing&#160;them&#160;from<br/>the queue with the&#160;deq&#160;(dequeue) method as needed. (The&#160;pop&#160;and&#160;shift&#160;methods are<br/>synonyms for&#160;deq.)<br/>The&#160;key&#160;features&#160;of&#160;Queue&#160;that&#160;make&#160;it&#160;suitable&#160;for&#160;concurrent&#160;programming&#160;is&#160;that&#160;the<br/>deq&#160;method&#160;blocks&#160;if&#160;the&#160;queue&#160;is&#160;empty&#160;and&#160;waits&#160;until&#160;the&#160;producer&#160;thread&#160;adds&#160;a<br/>value&#160;to&#160;the&#160;queue.&#160;The&#160;Queue&#160;and&#160;SizedQueue&#160;classes&#160;implement&#160;the&#160;same&#160;basic&#160;API,<br/>but&#160;the&#160;SizedQueue&#160;variant&#160;has&#160;a&#160;maximum&#160;size.&#160;If&#160;the&#160;queue&#160;is&#160;already&#160;at&#160;its&#160;maximum<br/>size,&#160;then&#160;the&#160;method&#160;for&#160;adding&#160;a&#160;value&#160;to&#160;the&#160;queue&#160;will&#160;block&#160;until&#160;the&#160;consumer<br/>thread removes a value from the queue.<br/>As with Ruby’s other collection classes, you can determine the number of elements in<br/>a&#160;queue&#160;with&#160;size&#160;or&#160;length,&#160;and&#160;you&#160;can&#160;determine&#160;if&#160;a&#160;queue&#160;is&#160;empty&#160;with&#160;empty?.<br/>Specify&#160;the&#160;maximum&#160;size&#160;of&#160;a&#160;SizedQueue&#160;when&#160;you&#160;call&#160;SizedQueue.new.&#160;After&#160;creating<br/>a&#160;SizedQueue, you can query and alter its maximum size with&#160;max&#160;and&#160;max=.<br/>Earlier&#160;&#160;in&#160;&#160;this&#160;&#160;chapter,&#160;&#160;we&#160;&#160;saw&#160;&#160;how&#160;&#160;to&#160;&#160;add&#160;&#160;a&#160;&#160;concurrent&#160;&#160;map&#160;&#160;method&#160;&#160;to&#160;&#160;the<br/>Enumerable&#160;module.&#160;We&#160;now&#160;define&#160;a&#160;method&#160;that&#160;combines&#160;a&#160;concurrent&#160;map&#160;with&#160;a<br/>concurrent&#160;inject.&#160;It&#160;creates&#160;a&#160;thread&#160;for&#160;each&#160;element&#160;of&#160;the&#160;enumerable&#160;collection<br/>and&#160;uses&#160;that&#160;thread&#160;to&#160;apply&#160;a&#160;mapping&#160;Proc.&#160;The&#160;value&#160;returned&#160;by&#160;that&#160;Proc&#160;is&#160;en-<br/>queued&#160;on&#160;a&#160;Queue&#160;object.&#160;One&#160;final&#160;thread&#160;acts&#160;as&#160;a&#160;consumer;&#160;it&#160;removes&#160;values&#160;from<br/>the queue and passes them to the injection&#160;Proc&#160;as they become available.<br/>We&#160;call&#160;this&#160;concurrent&#160;injection&#160;method&#160;conject,&#160;and&#160;you&#160;could&#160;use&#160;it&#160;like&#160;this&#160;to<br/>concurrently&#160;compute&#160;the&#160;sum&#160;of&#160;the&#160;squares&#160;of&#160;the&#160;values&#160;in&#160;an&#160;array.&#160;Note&#160;that&#160;a<br/>sequential&#160;&#160;algorithm&#160;&#160;would&#160;&#160;almost&#160;&#160;certainly&#160;&#160;be&#160;&#160;faster&#160;&#160;for&#160;&#160;a&#160;&#160;simple&#160;&#160;sum-of-squares<br/>example like this:<br/>
a = [-2,-1,0,1,2]<br/>mapper = lambda {|x| x*x } &#160; &#160; &#160; &#160; &#160; &#160; # Compute squares<br/>injector = lambda {|total,x| total+x } # Compute sum<br/>a.conject(0, mapper, injector) &#160; &#160; &#160; &#160; # =&gt; 10<br/>
<b>9.9 &#160;Threads and Concurrency&#160;|&#160;385</b><br/>
<hr/>
<a name=400></a>The code for this&#160;conject&#160;method is as follows—note the use of a&#160;Queue&#160;object and its<br/>enq&#160;and&#160;deq&#160;methods:<br/>
module Enumerable<br/>&#160; # Concurrent inject: expects an initial value and two Procs<br/>&#160; def conject(initial, mapper, injector)<br/>&#160; &#160; # Use a Queue to pass values from mapping threads to injector thread<br/>&#160; &#160; q = Queue.new &#160;&#160;<br/>&#160; &#160; count = 0 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # How many items?<br/>&#160; &#160; each do |item| &#160; &#160; &#160; &#160; &#160; &#160;# For each item<br/>&#160; &#160; &#160; Thread.new do &#160; &#160; &#160; &#160; &#160; # Create a new thread<br/>&#160; &#160; &#160; &#160; q.enq(mapper[item]) &#160; # Map and enqueue mapped value<br/>&#160; &#160; &#160; end<br/>&#160; &#160; &#160; count += 1 &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Count items<br/>&#160; &#160; end<br/>
&#160; &#160; t = Thread.new do &#160; &#160; &#160; &#160; # Create injector thread<br/>&#160; &#160; &#160; x = initial &#160; &#160; &#160; &#160; &#160; &#160; # Start with specified initial value<br/>&#160; &#160; &#160; while(count &gt; 0) &#160; &#160; &#160; &#160;# Loop once for each item<br/>&#160; &#160; &#160; &#160; x = injector[x,q.deq] # Dequeue value and inject<br/>&#160; &#160; &#160; &#160; count -= 1 &#160; &#160; &#160; &#160; &#160; &#160;# Count down<br/>&#160; &#160; &#160; end<br/>&#160; &#160; &#160; x &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Thread value is injected value<br/>&#160; &#160; end<br/>
&#160; &#160; t.value &#160; # Wait for injector thread and return its value<br/>&#160; end<br/>end<br/>
<b>9.9.9 &#160;Condition Variables and Queues<br/></b>There&#160;is&#160;something&#160;important&#160;to&#160;notice&#160;about&#160;the&#160;Queue&#160;class:&#160;the&#160;deq&#160;method&#160;can&#160;block.<br/>Normally,&#160;we&#160;only&#160;think&#160;of&#160;blocking&#160;as&#160;happening&#160;with&#160;IO&#160;methods&#160;(or&#160;when&#160;calling<br/>join&#160;on&#160;a&#160;thread&#160;or&#160;lock&#160;on&#160;a&#160;Mutex).&#160;In&#160;multithreaded&#160;programming,&#160;however,&#160;it&#160;is<br/>sometimes&#160;necessary&#160;to&#160;have&#160;a&#160;thread&#160;wait&#160;for&#160;some&#160;condition&#160;(outside&#160;of&#160;the&#160;control<br/>of&#160;that&#160;thread)&#160;to&#160;become&#160;true.&#160;In&#160;the&#160;case&#160;of&#160;the&#160;Queue&#160;class,&#160;the&#160;condition&#160;is&#160;the&#160;non-<br/>empty&#160;status&#160;of&#160;the&#160;queue:&#160;if&#160;the&#160;queue&#160;is&#160;empty,&#160;then&#160;a&#160;consumer&#160;thread&#160;must&#160;wait<br/>until a producer thread calls&#160;enq&#160;and makes the queue nonempty.<br/>Making&#160;a&#160;thread&#160;wait&#160;until&#160;some&#160;other&#160;thread&#160;tells&#160;it&#160;that&#160;it&#160;can&#160;go&#160;again&#160;is&#160;accomplished<br/>most&#160;cleanly&#160;with&#160;a&#160;ConditionVariable.&#160;Like&#160;Queue,&#160;ConditionVariable&#160;is&#160;part&#160;of&#160;the<br/>standard&#160;thread&#160;library.&#160;Create&#160;a&#160;ConditionVariable&#160;with&#160;ConditionVariable.new.&#160;Make<br/>a&#160;thread&#160;wait&#160;on&#160;the&#160;condition&#160;with&#160;the&#160;wait&#160;method.&#160;Wake&#160;one&#160;waiting&#160;thread&#160;with<br/>signal.&#160;Wake&#160;all&#160;waiting&#160;threads&#160;with&#160;broadcast.&#160;There&#160;is&#160;one&#160;slightly&#160;tricky&#160;part&#160;to&#160;the<br/>use&#160;of&#160;condition&#160;variables:&#160;in&#160;order&#160;to&#160;make&#160;things&#160;work&#160;correctly,&#160;the&#160;waiting&#160;thread<br/>must&#160;pass&#160;a&#160;locked&#160;Mutex&#160;object&#160;to&#160;the&#160;wait&#160;method.&#160;This&#160;mutex&#160;will&#160;be&#160;temporarily<br/>unlocked&#160;while&#160;the&#160;thread&#160;waits,&#160;and&#160;it&#160;will&#160;be&#160;locked&#160;again&#160;when&#160;the&#160;thread&#160;wakes&#160;up.<br/>We&#160;conclude&#160;our&#160;coverage&#160;of&#160;threads&#160;with&#160;a&#160;utility&#160;class&#160;that&#160;is&#160;sometimes&#160;useful&#160;in<br/>multithreaded&#160;programs.&#160;It&#160;is&#160;called&#160;Exchanger,&#160;and&#160;it&#160;allows&#160;two&#160;threads&#160;to&#160;swap&#160;ar-<br/>bitrary&#160;values.&#160;Suppose&#160;we&#160;have&#160;threads&#160;t1&#160;and&#160;t2&#160;and&#160;an&#160;Exchanger&#160;object&#160;e.&#160;t1&#160;calls<br/>
<b>386&#160;|&#160;Chapter 9:</b> <b>The Ruby Platform</b><br/>
<hr/>
<a name=401></a>e.exchange(1).&#160;This&#160;method&#160;then&#160;blocks&#160;(using&#160;a&#160;ConditionVariable,&#160;of&#160;course)&#160;until<br/>t2&#160;calls&#160;e.exchange(2).&#160;This&#160;second&#160;thread&#160;does&#160;not&#160;block,&#160;it&#160;simply&#160;returns&#160;&#160;1—the<br/>value&#160;passed&#160;by&#160;t1.&#160;Now&#160;that&#160;the&#160;second&#160;thread&#160;has&#160;called&#160;exchange,&#160;t1&#160;wakes&#160;up&#160;again<br/>and returns&#160;2&#160;from the&#160;exchange&#160;method.<br/>The&#160;Exchanger&#160;implementation&#160;shown&#160;here&#160;is&#160;somewhat&#160;complex,&#160;but&#160;it&#160;demonstrates<br/>a&#160;typical&#160;use&#160;of&#160;the&#160;ConditionVariable&#160;class.&#160;One&#160;interesting&#160;feature&#160;of&#160;this&#160;code&#160;is&#160;that<br/>it&#160;uses&#160;two&#160;Mutex&#160;objects.&#160;One&#160;of&#160;them&#160;is&#160;used&#160;to&#160;synchronize&#160;access&#160;to&#160;the&#160;exchange<br/>method&#160;and&#160;is&#160;passed&#160;to&#160;the&#160;wait&#160;method&#160;of&#160;the&#160;condition&#160;variable.&#160;The&#160;other&#160;Mutex&#160;is<br/>used&#160;to&#160;determine&#160;whether&#160;the&#160;calling&#160;thread&#160;is&#160;the&#160;first&#160;or&#160;the&#160;second&#160;thread&#160;to&#160;invoke<br/>exchange.&#160;&#160;Instead&#160;&#160;of&#160;&#160;using&#160;&#160;lock&#160;&#160;with&#160;&#160;this&#160;&#160;Mutex,&#160;&#160;this&#160;&#160;class&#160;&#160;uses&#160;&#160;the&#160;&#160;nonblocking<br/>try_lock&#160;method.&#160;If&#160;@first.try_lock&#160;returns&#160;true,&#160;then&#160;the&#160;calling&#160;thread&#160;is&#160;the&#160;first<br/>thread. Otherwise, it is the second thread:<br/>
require 'thread'<br/>
class Exchanger<br/>&#160; def initialize<br/>&#160; &#160; # These variables will hold the two values to be exchanged.<br/>&#160; &#160; @first_value = @second_value = nil<br/>&#160; &#160; # This Mutex protects access to the exchange method.<br/>&#160; &#160; @lock = Mutex.new<br/>&#160; &#160; # This Mutex allows us to determine whether we're the first or<br/>&#160; &#160; # second thread to call exchange.<br/>&#160; &#160; @first = Mutex.new<br/>&#160; &#160; # This ConditionVariable allows the first thread to wait for<br/>&#160; &#160; # the arrival of the second thread.<br/>&#160; &#160; @second = ConditionVariable.new<br/>&#160; end<br/>
&#160; # Exchange this value for the value passed by the other thread.<br/>&#160; def exchange(value)<br/>&#160; &#160; @lock.synchronize do &#160; &#160; &#160;# Only one thread can call this method at a time<br/>&#160; &#160; &#160; if @first.try_lock &#160; &#160; &#160;# We are the first thread<br/>&#160; &#160; &#160; &#160; @first_value = value &#160;# Store the first thread's argument<br/>&#160; &#160; &#160; &#160; # Now wait until the second thread arrives.<br/>&#160; &#160; &#160; &#160; # This temporarily unlocks the Mutex while we wait, so&#160;<br/>&#160; &#160; &#160; &#160; # that the second thread can call this method, too<br/>&#160; &#160; &#160; &#160; @second.wait(@lock) &#160; # Wait for second thread&#160;<br/>&#160; &#160; &#160; &#160; @first.unlock &#160; &#160; &#160; &#160; # Get ready for the next exchange<br/>&#160; &#160; &#160; &#160; @second_value &#160; &#160; &#160; &#160; # Return the second thread's value<br/>&#160; &#160; &#160; else &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Otherwise, we're the second thread<br/>&#160; &#160; &#160; &#160; @second_value = value # Store the second value<br/>&#160; &#160; &#160; &#160; @second.signal &#160; &#160; &#160; &#160;# Tell the first thread we're here<br/>&#160; &#160; &#160; &#160; @first_value &#160; &#160; &#160; &#160; &#160;# Return the first thread's value<br/>&#160; &#160; &#160; end<br/>&#160; &#160; end<br/>&#160; end<br/>end<br/>
<b>9.9 &#160;Threads and Concurrency&#160;|&#160;387</b><br/>
<hr/>
<a name=402></a><hr/>
<a name=403></a><img src="Ruby-403_1.jpg"/><br/>
<b>CHAPTER&#160;10</b><br/>
<b>The Ruby Environment</b><br/>
<b>389</b><br/>
<hr/>
<a name=404></a>This chapter&#160;is&#160;a&#160;catch-all&#160;for&#160;Ruby&#160;programming&#160;topics&#160;that&#160;have&#160;not&#160;been&#160;discussed<br/>elsewhere.&#160;Most&#160;of&#160;the&#160;features&#160;covered&#160;here&#160;have&#160;to&#160;do&#160;with&#160;the&#160;interface&#160;between<br/>Ruby&#160;and&#160;the&#160;operating&#160;system&#160;on&#160;which&#160;it&#160;is&#160;running.&#160;As&#160;such,&#160;some&#160;of&#160;these&#160;features<br/>are&#160;OS-dependent.&#160;Similarly,&#160;many&#160;of&#160;the&#160;features&#160;may&#160;be&#160;implementation&#160;dependent:<br/>not&#160;&#160;every&#160;&#160;Ruby&#160;&#160;interpreter&#160;&#160;will&#160;&#160;implement&#160;&#160;them&#160;&#160;in&#160;&#160;the&#160;&#160;same&#160;&#160;way.&#160;&#160;Topics&#160;&#160;covered<br/>include:<br/>
•&#160;The Ruby interpreter’s command-line arguments and environment variables.<br/>•&#160;The top-level execution environment: global functions, variables, and constants.<br/>•&#160;Shortcuts&#160;for&#160;text&#160;processing&#160;scripts:&#160;global&#160;functions,&#160;variables,&#160;and&#160;interpreter<br/>
options,&#160;usually&#160;inspired&#160;by&#160;the&#160;Perl&#160;programming&#160;language,&#160;that&#160;make&#160;it&#160;possible<br/>to write short but powerful Ruby programs for processing text files.<br/>
•&#160;OS&#160;commands:&#160;running&#160;shell&#160;commands&#160;and&#160;invoking&#160;executables&#160;in&#160;the&#160;under-<br/>
lying&#160;operating&#160;system.&#160;These&#160;are&#160;features&#160;that&#160;allow&#160;Ruby&#160;to&#160;be&#160;used&#160;as&#160;a&#160;scripting<br/>or “glue” language.<br/>
•&#160;Security:&#160;how&#160;to&#160;reduce&#160;the&#160;risk&#160;of&#160;SQL&#160;injection&#160;and&#160;similar&#160;attacks&#160;with&#160;Ruby’s<br/>
tainting&#160;&#160;mechanism,&#160;&#160;and&#160;&#160;how&#160;&#160;to&#160;&#160;“sandbox”&#160;&#160;untrusted&#160;&#160;Ruby&#160;&#160;code&#160;&#160;with&#160;&#160;$SAFE<br/>execution levels.<br/>
<b>10.1 &#160;Invoking the Ruby Interpreter<br/></b>The&#160;standard&#160;C-based&#160;Ruby&#160;implementation&#160;is&#160;invoked&#160;from&#160;the&#160;command&#160;line&#160;like<br/>this:<br/>
ruby [<i>options</i>] [--]&#160;<i>program</i>&#160;[<i>arguments</i>]<br/>
<i>options</i>&#160;&#160;is&#160;&#160;zero&#160;&#160;or&#160;&#160;more&#160;&#160;command-line&#160;&#160;arguments&#160;&#160;that&#160;&#160;affect&#160;&#160;the&#160;&#160;operation&#160;&#160;of&#160;&#160;the<br/>interpreter. The legal arguments are described shortly.<br/>
<i>program</i>&#160;is&#160;the&#160;name&#160;of&#160;the&#160;file&#160;that&#160;holds&#160;the&#160;Ruby&#160;program&#160;to&#160;be&#160;run.&#160;If&#160;the&#160;name&#160;of<br/>the&#160;program&#160;begins&#160;with&#160;a&#160;hyphen,&#160;precede&#160;it&#160;with&#160;--&#160;to&#160;force&#160;it&#160;to&#160;be&#160;treated&#160;as&#160;a<br/>program&#160;name&#160;rather&#160;than&#160;as&#160;an&#160;option.&#160;If&#160;you&#160;use&#160;a&#160;single&#160;hyphen&#160;as&#160;the&#160;program<br/>name,&#160;or&#160;omit&#160;<i>program</i>&#160;and&#160;<i>arguments</i>&#160;altogether,&#160;the&#160;interpreter&#160;will&#160;read&#160;program&#160;text<br/>from standard input.<br/>Finally,&#160;<i>arguments</i>&#160;is&#160;any&#160;number&#160;of&#160;additional&#160;tokens&#160;on&#160;the&#160;command&#160;line.&#160;These<br/>tokens become the elements of the&#160;ARGV&#160;array.<br/>The&#160;subsections&#160;that&#160;follow&#160;describe&#160;the&#160;options&#160;supported&#160;by&#160;the&#160;standard&#160;C-based<br/>Ruby&#160;implementation.&#160;Note&#160;that&#160;you&#160;may&#160;set&#160;the&#160;&#160;RUBYOPT&#160;environment&#160;variable&#160;to<br/>include&#160;any&#160;of&#160;the&#160;-W,&#160;-w,&#160;-v,&#160;-d,&#160;-I,&#160;-r,&#160;-K,&#160;-E,&#160;and&#160;-T&#160;options.&#160;These&#160;will&#160;automatically<br/>be&#160;applied&#160;to&#160;every&#160;invocation&#160;of&#160;the&#160;interpreter,&#160;as&#160;if&#160;they&#160;were&#160;specified&#160;on&#160;the&#160;com-<br/>mand line, unless the command line includes&#160;--disable-rubyopt.<br/>
<b>390&#160;|&#160;Chapter 10:</b> <b>The Ruby Environment</b><br/>
<hr/>
<a name=405></a><b>10.1.1 &#160;Common Options<br/></b>The&#160;following&#160;options&#160;are&#160;probably&#160;the&#160;most&#160;commonly&#160;used.&#160;Most&#160;Ruby&#160;implemen-<br/>tations&#160;can&#160;be&#160;expected&#160;to&#160;support&#160;these&#160;options&#160;or&#160;to&#160;provide&#160;a&#160;work-alike&#160;alternative:<br/>
-w<br/>
This&#160;&#160;option&#160;&#160;enables&#160;&#160;warnings&#160;&#160;about&#160;&#160;deprecated&#160;&#160;or&#160;&#160;problematic&#160;&#160;code&#160;&#160;and&#160;&#160;sets<br/>$VERBOSE&#160;to&#160;true.&#160;Many&#160;Ruby&#160;programmers&#160;use&#160;this&#160;option&#160;routinely&#160;to&#160;ensure&#160;that<br/>their code is clean.<br/>
-e<i>&#160;script</i><br/>
This&#160;option&#160;runs&#160;the&#160;Ruby&#160;code&#160;in&#160;<i>script</i>.&#160;If&#160;more&#160;than&#160;one&#160;-e&#160;option&#160;is&#160;specified,<br/>their&#160;associated&#160;scripts&#160;are&#160;treated&#160;as&#160;separate&#160;lines&#160;of&#160;code.&#160;Also,&#160;if&#160;one&#160;or&#160;more<br/>-e&#160;option&#160;is&#160;specified,&#160;the&#160;interpreter&#160;does&#160;not&#160;load&#160;or&#160;run&#160;any&#160;<i>program</i>&#160;specified&#160;on<br/>the command line.<br/>To&#160;enable&#160;succinct&#160;one-liner&#160;scripts,&#160;Ruby&#160;code&#160;specified&#160;with&#160;the&#160;-e&#160;option&#160;may<br/>use the&#160;Regexp&#160;matching shortcut explained later in this chapter.<br/>
-I<i>&#160;path</i><br/>
This&#160;option&#160;adds&#160;the&#160;directories&#160;in&#160;<i>path</i>&#160;to&#160;the&#160;beginning&#160;of&#160;the&#160;global&#160;$LOAD_PATH<br/>array.&#160;This&#160;specifies&#160;directories&#160;to&#160;be&#160;searched&#160;by&#160;the&#160;load&#160;and&#160;require&#160;methods<br/>(but does not affect the loading of the&#160;<i>program</i>&#160;specified on the command line).<br/>Multiple&#160;-I&#160;options&#160;may&#160;appear&#160;in&#160;the&#160;command&#160;line&#160;and&#160;each&#160;may&#160;list&#160;one&#160;or&#160;more<br/>directories.&#160;If&#160;multiple&#160;directories&#160;are&#160;specified&#160;with&#160;a&#160;single&#160;-I&#160;option,&#160;they&#160;should<br/>be&#160;separated&#160;from&#160;each&#160;other&#160;with&#160;:&#160;on&#160;Unix&#160;and&#160;Unix-like&#160;systems&#160;and&#160;with&#160;;&#160;on<br/>Windows systems.<br/>
-r<i>&#160;library</i><br/>
This&#160;option&#160;loads&#160;the&#160;specified&#160;<i>library</i>&#160;before&#160;running&#160;the&#160;specified&#160;program.&#160;This<br/>option works as if the first line of the program were:<br/>
require '<i>library</i>'<br/>
The&#160;space&#160;between&#160;the&#160;-r&#160;and&#160;the&#160;name&#160;of&#160;the&#160;library&#160;is&#160;optional&#160;and&#160;often&#160;omitted.<br/>
-rubygems<br/>
This&#160;frequently&#160;used&#160;command-line&#160;argument&#160;is&#160;not&#160;a&#160;true&#160;option&#160;but&#160;simply&#160;a<br/>clever&#160;application&#160;of&#160;the&#160;-r&#160;option.&#160;It&#160;loads&#160;the&#160;module&#160;named&#160;ubygems&#160;(with&#160;no&#160;r)<br/>from&#160;the&#160;standard&#160;library.&#160;Conveniently,&#160;the&#160;ubygems&#160;module&#160;simply&#160;loads&#160;the&#160;real<br/>rubygems&#160;module.&#160;Ruby&#160;1.9&#160;can&#160;load&#160;installed&#160;gems&#160;without&#160;this&#160;module,&#160;so&#160;this<br/>option is only necessary in Ruby 1.8.<br/>
--disable-gems<br/>
This&#160;Ruby&#160;1.9&#160;option&#160;prevents&#160;the&#160;addition&#160;of&#160;gem&#160;installation&#160;directories&#160;to&#160;the<br/>default&#160;load&#160;path.&#160;If&#160;you&#160;have&#160;many&#160;gems&#160;installed,&#160;and&#160;you&#160;are&#160;running&#160;a&#160;program<br/>that&#160;does&#160;not&#160;use&#160;those&#160;gems&#160;(or&#160;a&#160;program&#160;that&#160;explicitly&#160;manages&#160;its&#160;own&#160;de-<br/>pendencies with the&#160;gem&#160;method),&#160;you&#160;may&#160;find&#160;that&#160;your&#160;program&#160;startup&#160;time&#160;is<br/>reduced with this option.<br/>
<b>10.1 &#160;Invoking the Ruby Interpreter&#160;|&#160;391</b><br/>
<hr/>
<a name=406></a>-d,&#160;--debug<br/>
These&#160;options&#160;set&#160;the&#160;global&#160;variables&#160;$DEBUG&#160;and&#160;$VERBOSE&#160;to&#160;true.&#160;Your&#160;program,<br/>or&#160;library&#160;code,&#160;used&#160;by&#160;your&#160;program&#160;may&#160;print&#160;debugging&#160;output&#160;or&#160;take&#160;other<br/>action when these variables are set.<br/>
-h<br/>
This option displays a list of interpreter options and exits.<br/>
<b>10.1.2 &#160;Warnings and Information Options<br/></b>The&#160;&#160;following&#160;&#160;options&#160;&#160;control&#160;&#160;the&#160;&#160;type&#160;&#160;or&#160;&#160;the&#160;&#160;amount&#160;&#160;of&#160;&#160;information&#160;&#160;the&#160;&#160;Ruby<br/>interpreter displays:<br/>
-W,&#160;-W2,&#160;--verbose<br/>
These&#160;are&#160;all&#160;synonyms&#160;for&#160;-w:&#160;they&#160;enable&#160;verbose&#160;warnings&#160;and&#160;set&#160;$VERBOSE&#160;to<br/>true.<br/>
-W0<br/>
This option suppresses all warnings.<br/>
-v<br/>
This&#160;option&#160;prints&#160;the&#160;Ruby&#160;version&#160;number.&#160;If&#160;no&#160;program&#160;is&#160;specified,&#160;it&#160;exits<br/>rather&#160;than&#160;reading&#160;a&#160;program&#160;from&#160;standard&#160;input.&#160;If&#160;a&#160;program&#160;is&#160;specified,&#160;run<br/>it as if&#160;--verbose&#160;(or&#160;-w) had been specified.<br/>
--version,&#160;--copyright,&#160;--help<br/>
These&#160;options&#160;print&#160;Ruby&#160;version&#160;number,&#160;copyright&#160;information,&#160;or&#160;command-<br/>line&#160;help&#160;and&#160;exit.&#160;--help&#160;is&#160;a&#160;synonym&#160;for&#160;-h.&#160;--version&#160;differs&#160;from&#160;-v&#160;in&#160;that&#160;it<br/>never runs a specified program.<br/>
<b>10.1.3 &#160;Encoding Options<br/></b>The&#160;following&#160;options&#160;are&#160;used&#160;to&#160;specify&#160;the&#160;default&#160;external&#160;encoding&#160;of&#160;the&#160;Ruby<br/>process&#160;and&#160;the&#160;default&#160;source&#160;encoding&#160;for&#160;files&#160;that&#160;do&#160;not&#160;specify&#160;their&#160;own&#160;encoding<br/>with&#160;a&#160;coding&#160;comment.&#160;If&#160;none&#160;of&#160;these&#160;options&#160;is&#160;specified,&#160;then&#160;the&#160;default&#160;external<br/>encoding&#160;&#160;is&#160;&#160;derived&#160;&#160;from&#160;&#160;the&#160;&#160;locale&#160;&#160;and&#160;&#160;the&#160;&#160;default&#160;&#160;source&#160;&#160;encoding&#160;&#160;is&#160;&#160;ASCII&#160;&#160;(see<br/><a href="Rubys.html#50">§2.4 for more on source encoding and default external encoding):</a><br/>
-K<i>&#160;code</i><br/>
In&#160;Ruby&#160;1.8,&#160;this&#160;option&#160;specifies&#160;the&#160;source&#160;encoding&#160;of&#160;the&#160;script&#160;and&#160;sets&#160;the<br/>global&#160;variable&#160;$KCODE.&#160;In&#160;Ruby&#160;1.9,&#160;it&#160;sets&#160;the&#160;default&#160;external&#160;encoding&#160;of&#160;the&#160;Ruby<br/>process and specifies a default source encoding.<br/>Specify a&#160;<i>code</i>&#160;of&#160;a,&#160;A,&#160;n, or&#160;N&#160;for ASCII;&#160;u&#160;or&#160;U&#160;for Unicode;&#160;e&#160;or&#160;E&#160;for EUC-JP; and<br/>s&#160;or&#160;S&#160;for SJIS. (EUC-JP and SJIS are common Japanese encodings.)<br/>
-E<i>&#160;encodings</i>,&#160;--encoding=<i>&#160;encodings</i><br/>
These&#160;Ruby&#160;1.9&#160;options&#160;allow&#160;you&#160;to&#160;specify&#160;the&#160;default&#160;external&#160;encoding,&#160;the<br/>default&#160;internal&#160;encoding&#160;or&#160;both.&#160;The&#160;<i>encodings</i>&#160;string&#160;is&#160;the&#160;case-insensitive&#160;name<br/>
<b>392&#160;|&#160;Chapter 10:</b> <b>The Ruby Environment</b><br/>
<hr/>
<a name=407></a>of&#160;one&#160;or&#160;two&#160;encodings,&#160;separated&#160;by&#160;a&#160;colon.&#160;To&#160;specify&#160;just&#160;a&#160;default&#160;external<br/>encoding,&#160;simply&#160;use&#160;the&#160;name&#160;of&#160;the&#160;desired&#160;encoding.&#160;To&#160;specify&#160;two&#160;encodings,<br/>list&#160;the&#160;default&#160;external&#160;first,&#160;followed&#160;by&#160;a&#160;colon&#160;and&#160;the&#160;default&#160;internal.&#160;To&#160;specify<br/>just&#160;a&#160;default&#160;internal&#160;encoding,&#160;use&#160;a&#160;colon&#160;followed&#160;by&#160;the&#160;default&#160;internal&#160;en-<br/>coding name.<br/>
-U<br/>
Specifies a default internal encoding of UTF-8. Equivalent to&#160;--encoding=:utf-8.<br/>
<b>10.1.4 &#160;Text Processing Options<br/></b>The&#160;following&#160;options&#160;alter&#160;Ruby’s&#160;default&#160;text&#160;processing&#160;behavior,&#160;or&#160;are&#160;helpful&#160;when<br/>writing one-line scripts with the&#160;-e&#160;option:<br/>
-0<i>&#160;xxx</i><br/>
This&#160;option&#160;is&#160;the&#160;digit&#160;0,&#160;not&#160;the&#160;letter&#160;O.&#160;<i>xxx</i>&#160;should&#160;be&#160;between&#160;zero&#160;and&#160;three<br/>octal&#160;digits.&#160;When&#160;specified,&#160;these&#160;digits&#160;are&#160;the&#160;ASCII&#160;code&#160;of&#160;the&#160;input&#160;record<br/>separator&#160;character&#160;and&#160;set&#160;the&#160;$/&#160;variable.&#160;This&#160;defines&#160;“a&#160;line”&#160;for&#160;gets&#160;and&#160;similar<br/>methods.&#160;-0&#160;by&#160;itself&#160;sets&#160;$/&#160;to&#160;character&#160;code&#160;0.&#160;-00&#160;is&#160;special;&#160;it&#160;puts&#160;Ruby&#160;into<br/>“paragraph&#160;&#160;mode”&#160;&#160;in&#160;&#160;which&#160;&#160;lines&#160;&#160;are&#160;&#160;separated&#160;&#160;by&#160;&#160;two&#160;&#160;adjacent&#160;&#160;newline<br/>characters.<br/>
-a<br/>
This option automatically&#160;splits&#160;each&#160;line&#160;of&#160;input&#160;into&#160;fields&#160;and&#160;stores&#160;the&#160;fields<br/>in&#160;$F.&#160;This&#160;option&#160;only&#160;works&#160;with&#160;-n&#160;or&#160;-p&#160;looping&#160;options&#160;and&#160;adds&#160;the&#160;code<br/>$F = $_.split&#160;at the start of each iteration. See also&#160;-F.<br/>
-F<i>&#160;fieldsep</i><br/>
This option sets the input field&#160;separator&#160;$;&#160;to&#160;fieldsep. This affects the behavior<br/>
&#160;<br/>
of&#160;split&#160;when called with no arguments. See&#160;-a.<br/>fieldsep&#160;may&#160;be&#160;a&#160;single&#160;character&#160;or&#160;an&#160;arbitrary&#160;regular&#160;expression,&#160;without&#160;the<br/>delimiting&#160;slashes.&#160;Depending&#160;on&#160;your&#160;shell,&#160;you&#160;may&#160;need&#160;to&#160;quote&#160;or&#160;double&#160;the<br/>backslashes in any regular expression specified on the command line.<br/>
-i<i>&#160;[ext]</i><br/>
This&#160;option&#160;edits&#160;the&#160;files&#160;specified&#160;on&#160;the&#160;command&#160;line&#160;in&#160;place.&#160;Lines&#160;are&#160;read<br/>from&#160;the&#160;files&#160;specified&#160;on&#160;the&#160;command&#160;line,&#160;and&#160;output&#160;goes&#160;back&#160;to&#160;those&#160;same<br/>files.&#160;&#160;If&#160;&#160;<i>ext</i>&#160;&#160;is&#160;&#160;specified,&#160;&#160;a&#160;&#160;backup&#160;&#160;copy&#160;&#160;of&#160;&#160;the&#160;&#160;files&#160;&#160;is&#160;&#160;made,&#160;&#160;adding&#160;&#160;<i>ext</i>&#160;&#160;to&#160;&#160;the<br/>filename.<br/>
-l<br/>
This&#160;option&#160;makes&#160;the&#160;output&#160;record&#160;separator&#160;$\&#160;the&#160;same&#160;as&#160;the&#160;input&#160;record<br/>separator&#160;$/&#160;(see&#160;-0),&#160;so&#160;that&#160;that&#160;line&#160;ending&#160;is&#160;automatically&#160;added&#160;to&#160;text&#160;output<br/>with&#160;print.&#160;This&#160;option&#160;is&#160;intended&#160;for&#160;use&#160;with&#160;-p&#160;or&#160;-n.&#160;When&#160;used&#160;with&#160;one&#160;of<br/>those&#160;options,&#160;it&#160;automatically&#160;calls&#160;chop&#160;to&#160;remove&#160;the&#160;input&#160;record&#160;separator&#160;from<br/>each line of input.<br/>
<b>10.1 &#160;Invoking the Ruby Interpreter&#160;|&#160;393</b><br/>
<hr/>
<a name=408></a>-n<br/>
This option runs the program as if it were enclosed in the following loop:<br/>
while gets &#160; &#160; &#160; &#160; &#160; &#160; # Read a line of input into $_<br/>&#160; $F = split if $-a &#160; &#160;# Split $_ into fields if -a was specified<br/>&#160; chop! if $-l &#160; &#160; &#160; &#160; # Chop line ending off $_ if -l was specified<br/>&#160; # Program text here<br/>end<br/>
This&#160;option&#160;works&#160;in&#160;Ruby&#160;1.9&#160;even&#160;though&#160;the&#160;global&#160;functions&#160;chop!&#160;and&#160;split<br/>are no longer available in that version of the language.<br/>This option is often used with&#160;-e. See also&#160;-p.<br/>
-p<br/>
This option runs the program as if it were written in the following loop:<br/>
while gets &#160; &#160; &#160; &#160; &#160; &#160; # Read a line of input into $_<br/>&#160; $F = split if $-a &#160; &#160;# Split $_ into fields if -a was specified<br/>&#160; chop! if $-l &#160; &#160; &#160; &#160; # Chop line ending off $_ if -l was specified<br/>&#160; # Program text here<br/>&#160; print &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Output $_ (adding $/ if -l was specified)<br/>end<br/>
This&#160;option&#160;works&#160;in&#160;Ruby&#160;1.9&#160;even&#160;though&#160;the&#160;global&#160;functions&#160;chop!&#160;and&#160;split<br/>are no longer available in that version of the language.<br/>This option is often used with&#160;-e. See also&#160;-n.<br/>
<b>10.1.5 &#160;Miscellaneous Options<br/></b>The following options don’t fit into any of the previous categories:<br/>
-c<br/>
This option parses the program and report any syntax errors, but does not run it.<br/>
-C<i>&#160;dir</i>,&#160;-X<i>&#160;dir</i><br/>
These options change the current directory to&#160;dir&#160;before running the program.<br/>
-s<br/>
When&#160;&#160;this&#160;&#160;option&#160;&#160;is&#160;&#160;specified,&#160;&#160;the&#160;&#160;interpreter&#160;&#160;preprocesses&#160;&#160;any&#160;&#160;arguments&#160;&#160;that<br/>appear&#160;after&#160;the&#160;program&#160;name&#160;and&#160;begin&#160;with&#160;a&#160;hyphen.&#160;For&#160;arguments&#160;of&#160;the<br/>form&#160;-x=y,&#160;it&#160;sets&#160;$x&#160;to&#160;y.&#160;For&#160;arguments&#160;of&#160;the&#160;form&#160;-x,&#160;it&#160;sets&#160;$x&#160;to&#160;true.&#160;The<br/>preprocessed arguments are removed from&#160;ARGV.<br/>
-S<br/>
This&#160;option&#160;looks&#160;for&#160;the&#160;specified&#160;program&#160;file&#160;relative&#160;to&#160;the&#160;path&#160;specified&#160;in&#160;the<br/>RUBY_PATH&#160;environment&#160;variable.&#160;If&#160;it&#160;is&#160;not&#160;found&#160;there,&#160;it&#160;looks&#160;for&#160;it&#160;relative&#160;to<br/>the&#160;PATH&#160;environment variable. And if it is still not found, it looks for it normally.<br/>
-T<i>&#160;n</i><br/>
This option sets&#160;$SAFE&#160;to&#160;<i>n</i>, or to&#160;1&#160;if&#160;<i>n</i><a href="Rubys.html#423">&#160;is omitted. See §10.5 for more.</a><br/>
<b>394&#160;|&#160;Chapter 10:</b> <b>The Ruby Environment</b><br/>
<hr/>
<a name=409></a>-x<i>&#160;[dir]</i><br/>
This&#160;option&#160;extracts&#160;Ruby&#160;source&#160;from&#160;the&#160;program&#160;file&#160;by&#160;discarding&#160;any&#160;lines<br/>before&#160;the&#160;first&#160;that&#160;starts&#160;#!ruby.&#160;For&#160;compatibility&#160;with&#160;the&#160;capital&#160;-X&#160;option,&#160;this<br/>option also allows a directory to be specified.<br/>
<b>10.2 &#160;The Top-Level Environment<br/></b>When&#160;the&#160;Ruby&#160;interpreter&#160;starts,&#160;a&#160;number&#160;of&#160;classes,&#160;modules,&#160;constants,&#160;and&#160;global<br/>variables&#160;&#160;and&#160;&#160;global&#160;&#160;functions&#160;&#160;are&#160;&#160;defined&#160;&#160;and&#160;&#160;available&#160;&#160;for&#160;&#160;use&#160;&#160;by&#160;&#160;programs.&#160;&#160;The<br/>subsections that follow list these predefined features.<br/>
<b>10.2.1 &#160;Predefined Modules and Classes<br/></b>When the Ruby 1.8 interpreter starts, the following modules are defined:<br/>
Comparable &#160; &#160; &#160;FileTest &#160; &#160; &#160; &#160;Marshal &#160; &#160; &#160; &#160; Precision<br/>Enumerable &#160; &#160; &#160;GC &#160; &#160; &#160; &#160; &#160; &#160; &#160;Math &#160; &#160; &#160; &#160; &#160; &#160;Process<br/>Errno &#160; &#160; &#160; &#160; &#160; Kernel &#160; &#160; &#160; &#160; &#160;ObjectSpace &#160; &#160; Signal<br/>
These classes are defined on startup:<br/>
Array &#160; &#160; &#160; &#160; &#160; File &#160; &#160; &#160; &#160; &#160; &#160;Method &#160; &#160; &#160; &#160; &#160;String<br/>Bignum &#160; &#160; &#160; &#160; &#160;Fixnum &#160; &#160; &#160; &#160; &#160;Module &#160; &#160; &#160; &#160; &#160;Struct<br/>Binding &#160; &#160; &#160; &#160; Float &#160; &#160; &#160; &#160; &#160; NilClass &#160; &#160; &#160; &#160;Symbol<br/>Class &#160; &#160; &#160; &#160; &#160; Hash &#160; &#160; &#160; &#160; &#160; &#160;Numeric &#160; &#160; &#160; &#160; Thread<br/>Continuation &#160; &#160;IO &#160; &#160; &#160; &#160; &#160; &#160; &#160;Object &#160; &#160; &#160; &#160; &#160;ThreadGroup<br/>Data &#160; &#160; &#160; &#160; &#160; &#160;Integer &#160; &#160; &#160; &#160; Proc &#160; &#160; &#160; &#160; &#160; &#160;Time<br/>Dir &#160; &#160; &#160; &#160; &#160; &#160; MatchData &#160; &#160; &#160; Range &#160; &#160; &#160; &#160; &#160; TrueClass<br/>FalseClass &#160; &#160; &#160;MatchingData &#160; &#160;Regexp &#160; &#160; &#160; &#160; &#160;UnboundMethod<br/>
The following exception classes are also defined:<br/>
ArgumentError &#160; &#160; &#160; &#160; &#160; NameError &#160; &#160; &#160; &#160; &#160; &#160; &#160; SignalException<br/>EOFError &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;NoMemoryError &#160; &#160; &#160; &#160; &#160; StandardError<br/>Exception &#160; &#160; &#160; &#160; &#160; &#160; &#160; NoMethodError &#160; &#160; &#160; &#160; &#160; SyntaxError<br/>FloatDomainError &#160; &#160; &#160; &#160;NotImplementedError &#160; &#160; SystemCallError<br/>IOError &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; RangeError &#160; &#160; &#160; &#160; &#160; &#160; &#160;SystemExit<br/>IndexError &#160; &#160; &#160; &#160; &#160; &#160; &#160;RegexpError &#160; &#160; &#160; &#160; &#160; &#160; SystemStackError<br/>Interrupt &#160; &#160; &#160; &#160; &#160; &#160; &#160; RuntimeError &#160; &#160; &#160; &#160; &#160; &#160;ThreadError<br/>LoadError &#160; &#160; &#160; &#160; &#160; &#160; &#160; ScriptError &#160; &#160; &#160; &#160; &#160; &#160; TypeError<br/>LocalJumpError &#160; &#160; &#160; &#160; &#160;SecurityError &#160; &#160; &#160; &#160; &#160; ZeroDivisionError<br/>
Ruby 1.9 adds the following modules, classes, and exceptions:<br/>
BasicObject &#160; &#160; FiberError &#160; &#160; &#160;Mutex &#160; &#160; &#160; &#160; &#160; VM<br/>Fiber &#160; &#160; &#160; &#160; &#160; KeyError &#160; &#160; &#160; &#160;StopIteration<br/>
You&#160;can&#160;check&#160;the&#160;predefined&#160;modules,&#160;classes,&#160;and&#160;exceptions&#160;in&#160;your&#160;implementation<br/>with code like this:<br/>
# Print all modules (excluding classes)<br/>puts Module.constants.sort.select {|x| eval(x.to_s).instance_of? Module}<br/>
# Print all classes (excluding exceptions)<br/>
<b>10.2 &#160;The Top-Level Environment&#160;|&#160;395</b><br/>
<hr/>
<a name=410></a>puts Module.constants.sort.select {|x|<br/>&#160; c = eval(x.to_s)<br/>&#160; c.is_a? Class and not c.ancestors.include? Exception<br/>}<br/>
# Print all exceptions<br/>puts Module.constants.sort.select {|x|<br/>&#160; c = eval(x.to_s)<br/>&#160; c.instance_of? Class and c.ancestors.include? Exception<br/>}<br/>
<b>10.2.2 &#160;Top-Level Constants<br/></b>When&#160;&#160;the&#160;&#160;Ruby&#160;&#160;interpreter&#160;&#160;starts,&#160;&#160;the&#160;&#160;following&#160;&#160;top-level&#160;&#160;constants&#160;&#160;are&#160;&#160;defined&#160;&#160;(in<br/>addition&#160;to&#160;the&#160;modules&#160;and&#160;classes&#160;listed&#160;previously).&#160;A&#160;module&#160;that&#160;defines&#160;a&#160;constant<br/>by&#160;the&#160;same&#160;name&#160;can&#160;still&#160;access&#160;these&#160;top-level&#160;constants&#160;by&#160;explicitly&#160;prefixing&#160;them<br/>with&#160;::. You can list the top-level constants in your implementation with:<br/>
ruby -e 'puts Module.constants.sort.reject{|x| eval(x.to_s).is_a? Module}'<br/>
ARGF<br/>
An&#160;IO&#160;object&#160;providing&#160;access&#160;to&#160;a&#160;virtual&#160;concatenation&#160;of&#160;files&#160;named&#160;in&#160;ARGV, or<br/>to standard input if&#160;ARGV&#160;is empty. A synonym for&#160;$&lt;.<br/>
ARGV<br/>
An&#160;array&#160;containing&#160;the&#160;arguments&#160;specified&#160;on&#160;the&#160;command&#160;line.&#160;A&#160;synonym&#160;for<br/>$*.<br/>
DATA<br/>
If&#160;your&#160;program&#160;file&#160;includes&#160;the&#160;token&#160;__END__&#160;on&#160;a&#160;line&#160;by&#160;itself,&#160;then&#160;this&#160;constant<br/>is&#160;&#160;defined&#160;&#160;to&#160;&#160;be&#160;&#160;a&#160;&#160;stream&#160;&#160;that&#160;&#160;allows&#160;&#160;access&#160;&#160;to&#160;&#160;the&#160;&#160;lines&#160;&#160;of&#160;&#160;the&#160;&#160;file&#160;&#160;following<br/>__END__.&#160;&#160;If&#160;&#160;the&#160;&#160;program&#160;&#160;file&#160;&#160;does&#160;&#160;not&#160;&#160;include&#160;&#160;__END__,&#160;&#160;then&#160;&#160;this&#160;&#160;constant&#160;&#160;is&#160;&#160;not<br/>defined.<br/>
ENV<br/>
An&#160;object&#160;that&#160;behaves&#160;like&#160;a&#160;hash&#160;and&#160;provides&#160;access&#160;to&#160;the&#160;environment&#160;variable<br/>settings in effect for the interpreter.<br/>
FALSE<br/>
A deprecated synonym for&#160;false.<br/>
NIL<br/>
A deprecated synonym for&#160;nil.<br/>
RUBY_PATCHLEVEL<br/>
A string indicating the patchlevel for the interpreter.<br/>
RUBY_PLATFORM<br/>
A string indicating the platform of the Ruby interpreter.<br/>
RUBY_RELEASE_DATE<br/>
A string indicating the release date of the Ruby interpreter.<br/>
<b>396&#160;|&#160;Chapter 10:</b> <b>The Ruby Environment</b><br/>
<hr/>
<a name=411></a>RUBY_VERSION<br/>
A&#160;string&#160;indicating&#160;the&#160;version&#160;of&#160;the&#160;Ruby&#160;language&#160;supported&#160;by&#160;the&#160;interpreter.<br/>
STDERR<br/>
The&#160;standard&#160;error&#160;output&#160;stream.&#160;This&#160;is&#160;the&#160;default&#160;value&#160;of&#160;the&#160;$stderr&#160;variable.<br/>
STDIN<br/>
The standard input stream. This is the default value of the&#160;$stdin&#160;variable.<br/>
STDOUT<br/>
The standard output stream. This is the default value of the&#160;$stdout&#160;variable.<br/>
TOPLEVEL_BINDING<br/>
A&#160;Binding&#160;object representing the bindings in the top-level scope.<br/>
TRUE<br/>
A deprecated synonym for&#160;true.<br/>
<b>10.2.3 &#160;Global Variables<br/></b>The Ruby interpreter&#160;predefines&#160;a&#160;number&#160;of&#160;global&#160;variables&#160;that&#160;your&#160;programs&#160;can<br/>use.&#160;Many&#160;of&#160;these&#160;variables&#160;are&#160;special&#160;in&#160;some&#160;way.&#160;Some&#160;use&#160;punctuation&#160;characters<br/>in&#160;their&#160;names.&#160;(The&#160;English.rb&#160;module&#160;defines&#160;English-language&#160;alternatives&#160;to&#160;the<br/>punctuation.&#160;Add&#160;require 'English'&#160;to&#160;your&#160;program&#160;if&#160;you&#160;want&#160;to&#160;use&#160;these&#160;verbose<br/>alternatives.)&#160;Some&#160;are&#160;read-only&#160;and&#160;may&#160;not&#160;be&#160;assigned&#160;to.&#160;And&#160;some&#160;are&#160;thread-<br/>local,&#160;so&#160;that&#160;each&#160;thread&#160;of&#160;a&#160;Ruby&#160;program&#160;may&#160;see&#160;a&#160;different&#160;value&#160;of&#160;the&#160;variable.<br/>Finally,&#160;some&#160;global&#160;variables&#160;($_,&#160;$~,&#160;and&#160;the&#160;pattern-matching&#160;variables&#160;derived&#160;from<br/>it)&#160;are&#160;method-local:&#160;although&#160;the&#160;variable&#160;is&#160;globally&#160;accessible,&#160;its&#160;value&#160;is&#160;local&#160;to&#160;the<br/>current&#160;method.&#160;If&#160;a&#160;method&#160;sets&#160;the&#160;value&#160;of&#160;one&#160;of&#160;these&#160;magic&#160;globals,&#160;it&#160;does&#160;not<br/>alter the value seen by the code that invokes that method.<br/>You&#160;can&#160;obtain&#160;the&#160;complete&#160;list&#160;of&#160;global&#160;variables&#160;predefined&#160;by&#160;your&#160;Ruby&#160;interpreter<br/>with:<br/>
ruby -e 'puts global_variables.sort'<br/>
To include the verbose names from the&#160;English&#160;module in your listing, try:<br/>
ruby -rEnglish -e 'puts global_variables.sort'<br/>
The subsections that follow document the predefined global variables by category.<br/>
<b>10.2.3.1 &#160;Global settings<br/></b>These&#160;&#160;global&#160;&#160;variables&#160;&#160;hold&#160;&#160;configuration&#160;&#160;settings&#160;&#160;and&#160;&#160;specify&#160;&#160;information,&#160;&#160;such&#160;&#160;as<br/>command-line&#160;&#160;arguments,&#160;&#160;about&#160;&#160;the&#160;&#160;environment&#160;&#160;in&#160;&#160;which&#160;&#160;the&#160;&#160;Ruby&#160;&#160;program&#160;&#160;is<br/>running:<br/>
$*<br/>
A read-only synonym for the&#160;ARGV&#160;constant. English synonym:&#160;$ARGV.<br/>
<b>10.2 &#160;The Top-Level Environment&#160;|&#160;397</b><br/>
<hr/>
<a name=412></a>$$<br/>
The&#160;process&#160;ID&#160;of&#160;the&#160;current&#160;Ruby&#160;process.&#160;Read-only.&#160;English&#160;synonyms:&#160;$PID,<br/>$PROCESS_ID.<br/>
$?<br/>
The&#160;exit&#160;status&#160;of&#160;the&#160;last&#160;process&#160;terminated.&#160;Read-only&#160;and&#160;thread-local.&#160;English<br/>synonym:&#160;$CHILD_STATUS.<br/>
$DEBUG,&#160;$-d<br/>
Set to&#160;true&#160;if the&#160;-d&#160;or&#160;--debug&#160;options were set on the command line.<br/>
$KCODE,&#160;$-K<br/>
In&#160;Ruby&#160;1.8,&#160;this&#160;variable&#160;holds&#160;a&#160;string&#160;that&#160;names&#160;the&#160;current&#160;text&#160;encoding.&#160;Its<br/>value&#160;is&#160;“NONE”,&#160;“UTF8”,&#160;“SJIS”&#160;or&#160;“EUC”.&#160;This&#160;value&#160;can&#160;be&#160;set&#160;with&#160;the&#160;inter-<br/>preter&#160;option&#160;-K.&#160;This&#160;variable&#160;no&#160;longer&#160;works&#160;in&#160;Ruby&#160;1.9&#160;and&#160;using&#160;it&#160;causes&#160;a<br/>warning.<br/>
$LOADED_FEATURES,&#160;$&#34;<br/>
An array of strings naming the files that have been loaded. Read-only.<br/>
$LOAD_PATH,&#160;$:,&#160;$-I<br/>
An array&#160;of&#160;strings&#160;holding&#160;the&#160;directories&#160;to&#160;be&#160;searched&#160;when&#160;loading&#160;files&#160;with<br/>the&#160;load&#160;and&#160;require&#160;methods.&#160;This&#160;variable&#160;is&#160;read-only,&#160;but&#160;you&#160;can&#160;alter&#160;the<br/>contents&#160;of&#160;the&#160;array&#160;to&#160;which&#160;it&#160;refers,&#160;appending&#160;or&#160;prepending&#160;new&#160;directories<br/>to the path, for example.<br/>
$PROGRAM_NAME,&#160;$0<br/>
The&#160;name&#160;of&#160;the&#160;file&#160;that&#160;holds&#160;the&#160;Ruby&#160;program&#160;currently&#160;being&#160;executed.&#160;The<br/>value&#160;will&#160;be&#160;“-”&#160;if&#160;the&#160;program&#160;is&#160;read&#160;from&#160;standard&#160;input,&#160;or&#160;“-e”&#160;if&#160;the&#160;program<br/>was specified with a&#160;-e&#160;option. Note that this is different from&#160;$FILENAME.<br/>
$SAFE<br/>
The&#160;current&#160;safe&#160;level&#160;for&#160;program&#160;execution.&#160;See&#160;<a href="Rubys.html#423">§10.5&#160;</a>for&#160;details.&#160;This&#160;variable<br/>may&#160;be&#160;set&#160;from&#160;the&#160;command&#160;line&#160;with&#160;the&#160;-T&#160;option.&#160;The&#160;value&#160;of&#160;this&#160;variable<br/>is thread-local.<br/>
$VERBOSE,&#160;$-v,&#160;$-w<br/>
True&#160;if&#160;the&#160;-v,&#160;-w,&#160;or&#160;--verbose&#160;command-line&#160;option&#160;is&#160;specified.&#160;nil&#160;if&#160;-W0&#160;was<br/>specified.&#160;false&#160;otherwise.&#160;You&#160;can&#160;set&#160;this&#160;variable&#160;to&#160;nil&#160;to&#160;suppress&#160;all&#160;warnings.<br/>
<b>10.2.3.2 &#160;Exception-handling globals<br/></b>The&#160;following&#160;two&#160;global&#160;variables&#160;are&#160;useful&#160;in&#160;rescue&#160;clauses&#160;when&#160;an&#160;exception&#160;has<br/>been raised:<br/>
$!<br/>
The&#160;last&#160;exception&#160;object&#160;raised.&#160;The&#160;exception&#160;object&#160;can&#160;also&#160;be&#160;accessed&#160;using<br/>the&#160;=&gt;&#160;syntax&#160;in&#160;the&#160;declaration&#160;of&#160;the&#160;rescue&#160;clause.&#160;The&#160;value&#160;of&#160;this&#160;variable&#160;is<br/>thread-local. English synonym:&#160;$ERROR_INFO.<br/>
<b>398&#160;|&#160;Chapter 10:</b> <b>The Ruby Environment</b><br/>
<hr/>
<a name=413></a>$@<br/>
The&#160;&#160;stack&#160;&#160;trace&#160;&#160;of&#160;&#160;the&#160;&#160;last&#160;&#160;exception,&#160;&#160;equivalent&#160;&#160;to&#160;&#160;$!.backtrace.&#160;&#160;This&#160;&#160;value&#160;&#160;is<br/>thread-local. English synonym:&#160;$ERROR_POSITION.<br/>
<b>10.2.3.3 &#160;Streams and text-processing globals<br/></b>The&#160;following&#160;globals&#160;are&#160;IO&#160;streams&#160;and&#160;variables&#160;that&#160;affect&#160;the&#160;default&#160;behavior&#160;of<br/>text-processing&#160;Kernel<a href="Rubys.html#417">&#160;methods. You’ll find examples of their use in §10.3:</a><br/>
$_<br/>
The&#160;last&#160;string&#160;read&#160;by&#160;the&#160;Kernel&#160;methods&#160;gets&#160;and&#160;readline.&#160;This&#160;value&#160;is&#160;thread-<br/>local&#160;and&#160;method-local.&#160;A&#160;number&#160;of&#160;&#160;Kernel&#160;methods&#160;operate&#160;implicitly&#160;on&#160;$_.<br/>English synonym:&#160;$LAST_READ_LINE.<br/>
$&lt;<br/>
A&#160;read-only&#160;synonym&#160;for&#160;the&#160;ARGF&#160;stream:&#160;an&#160;IO-like&#160;object&#160;providing&#160;access&#160;to&#160;a<br/>virtual&#160;concatenation&#160;of&#160;the&#160;files&#160;specified&#160;on&#160;the&#160;command-line,&#160;or&#160;to&#160;standard<br/>input&#160;if&#160;no&#160;files&#160;were&#160;specified.&#160;Kernel&#160;read&#160;methods,&#160;such&#160;as&#160;gets, read from this<br/>stream. Note that this stream is not always the same as&#160;$stdin. English synonym:<br/>$DEFAULT_INPUT.<br/>
$stdin<br/>
The&#160;standard&#160;input&#160;stream.&#160;The&#160;initial&#160;value&#160;of&#160;this&#160;variable&#160;is&#160;the&#160;constant&#160;STDIN.<br/>Many Ruby program read from&#160;ARGF&#160;or&#160;$&lt;&#160;instead of&#160;$stdin.<br/>
$stdout,&#160;$&gt;<br/>
The&#160;standard&#160;output&#160;stream,&#160;and&#160;the&#160;destination&#160;of&#160;the&#160;printing&#160;methods&#160;of&#160;Kernel:<br/>puts,&#160;print,&#160;printf, etc. English synonym:&#160;$DEFAULT_OUTPUT.<br/>
$stderr<br/>
The&#160;standard&#160;error&#160;output&#160;stream.&#160;The&#160;initial&#160;value&#160;of&#160;this&#160;variable&#160;is&#160;the&#160;constant<br/>STDERR.<br/>
$FILENAME<br/>
The name&#160;of&#160;the&#160;file&#160;currently&#160;being&#160;read&#160;from&#160;ARGF. Equivalent to&#160;ARGF.filename.<br/>Read-only.<br/>
$.<br/>
The&#160;&#160;number&#160;&#160;of&#160;&#160;the&#160;&#160;last&#160;&#160;line&#160;&#160;read&#160;&#160;from&#160;&#160;the&#160;&#160;current&#160;&#160;input&#160;&#160;file.&#160;&#160;Equivalent&#160;&#160;to<br/>ARGF.lineno. English synonyms:&#160;$NR,&#160;$INPUT_LINE_NUMBER.<br/>
$/,&#160;$-0<br/>
The&#160;input&#160;record&#160;separator&#160;(newline&#160;by&#160;default).&#160;gets&#160;and&#160;readline&#160;use this value<br/>by&#160;default&#160;to&#160;determine&#160;line&#160;boundaries.&#160;You&#160;can&#160;set&#160;this&#160;value&#160;with&#160;the&#160;-0&#160;inter-<br/>preter option. English synonyms:&#160;$RS,&#160;$INPUT_RECORD_SEPARATOR.<br/>
$\<br/>
The&#160;output&#160;record&#160;separator.&#160;The&#160;default&#160;value&#160;is&#160;nil,&#160;but&#160;is&#160;set&#160;to&#160;$/&#160;when&#160;the<br/>interpreter&#160;option&#160;-l&#160;is&#160;used.&#160;If&#160;non-nil,&#160;the&#160;output&#160;record&#160;separator&#160;is&#160;output&#160;after<br/>
<b>10.2 &#160;The Top-Level Environment&#160;|&#160;399</b><br/>
<hr/>
<a name=414></a>every&#160;call&#160;to&#160;print&#160;(but&#160;not&#160;puts&#160;or&#160;other&#160;output&#160;methods).&#160;English&#160;synonyms:&#160;$ORS,<br/>$OUTPUT_RECORD_SEPARATOR.<br/>
$,<br/>
The&#160;separator&#160;output&#160;between&#160;the&#160;arguments&#160;to&#160;print&#160;and&#160;the&#160;default&#160;separator<br/>for&#160;<br/>
Array.join.&#160;<br/>
The&#160;<br/>
default&#160;<br/>
is&#160;<br/>
nil.&#160;<br/>
English&#160;<br/>
synonyms:&#160;<br/>
$OFS,<br/>
$OUTPUT_FIELD_SEPARATOR.<br/>
$;,&#160;$-F<br/>
The&#160;default&#160;field&#160;separator&#160;used&#160;by&#160;split.&#160;The&#160;default&#160;is&#160;nil,&#160;but&#160;you&#160;can&#160;specify&#160;a<br/>value with the interpreter option&#160;-F. English synonyms:&#160;$FS,&#160;$FIELD_SEPARATOR.<br/>
$F<br/>
This&#160;variable&#160;is&#160;defined&#160;if&#160;the&#160;Ruby&#160;interpreter&#160;is&#160;invoked&#160;with&#160;the&#160;-a&#160;option&#160;and<br/>either&#160;-n&#160;or&#160;-p. It holds the fields of the current input line, as returned by&#160;split.<br/>
<b>10.2.3.4 &#160;Pattern-matching globals<br/></b>The&#160;&#160;following&#160;&#160;globals&#160;&#160;are&#160;&#160;thread-local&#160;&#160;and&#160;&#160;method-local&#160;&#160;and&#160;&#160;are&#160;&#160;set&#160;&#160;by&#160;&#160;any&#160;&#160;Regexp<br/>pattern-matching operation:<br/>
$~<br/>
The&#160;MatchData&#160;object&#160;produced&#160;by&#160;the&#160;last&#160;pattern&#160;matching&#160;operation.&#160;This&#160;value<br/>is&#160;thread-local&#160;and&#160;method-local.&#160;The&#160;other&#160;pattern-matching&#160;globals&#160;described<br/>here&#160;are&#160;derived&#160;from&#160;this&#160;one.&#160;Setting&#160;this&#160;variable&#160;to&#160;a&#160;new&#160;MatchData&#160;object&#160;alters<br/>the value of the other variables. English synonym:&#160;$MATCH_INFO.<br/>
$&amp;<br/>
The&#160;&#160;most&#160;&#160;recently&#160;&#160;matched&#160;&#160;text.&#160;&#160;Equivalent&#160;&#160;to&#160;&#160;$~[0].&#160;&#160;Read-only,&#160;&#160;thread-local,<br/>method-local, and derived from&#160;$~. English synonym:&#160;$MATCH.<br/>
$`<br/>
The&#160;&#160;string&#160;&#160;preceding&#160;&#160;the&#160;&#160;match&#160;&#160;in&#160;&#160;the&#160;&#160;last&#160;&#160;pattern&#160;&#160;match.&#160;&#160;Equivalent&#160;&#160;to<br/>$~.pre_match.&#160;Read-only,&#160;thread-local,&#160;method-local,&#160;and&#160;derived&#160;from&#160;$~.&#160;English<br/>synonym:&#160;$PREMATCH.<br/>
$'<br/>
The&#160;&#160;string&#160;&#160;following&#160;&#160;the&#160;&#160;match&#160;&#160;in&#160;&#160;the&#160;&#160;last&#160;&#160;pattern&#160;&#160;match.&#160;&#160;Equivalent&#160;&#160;to<br/>$~.post_match&#160;Read-only,&#160;thread-local,&#160;method-local,&#160;and&#160;derived&#160;from&#160;$~.&#160;English<br/>synonym:&#160;$POSTMATCH.<br/>
$+<br/>
The&#160;string&#160;corresponding&#160;to&#160;the&#160;last&#160;successfully&#160;matched&#160;group&#160;in&#160;the&#160;last&#160;pattern<br/>match.&#160;&#160;Read-only,&#160;&#160;thread-local,&#160;&#160;method-local,&#160;&#160;and&#160;&#160;derived&#160;&#160;from&#160;&#160;$~.&#160;&#160;English<br/>synonym:&#160;$LAST_PAREN_MATCH.<br/>
<b>400&#160;|&#160;Chapter 10:</b> <b>The Ruby Environment</b><br/>
<hr/>
<a name=415></a><b>10.2.3.5 &#160;Command-line option globals<br/></b>Ruby&#160;&#160;defines&#160;&#160;a&#160;&#160;number&#160;&#160;of&#160;&#160;global&#160;&#160;variables&#160;&#160;that&#160;&#160;correspond&#160;&#160;to&#160;&#160;the&#160;&#160;state&#160;&#160;or&#160;&#160;value&#160;&#160;of<br/>interpreter&#160;command-line&#160;options.&#160;The&#160;variables&#160;$-0,&#160;$-F,&#160;$-I,&#160;$-K,&#160;$-d,&#160;$-v,&#160;and&#160;$-w<br/>have synonyms and are included in the previous sections:<br/>
$-a<br/>
true&#160;if the interpreter option&#160;-a&#160;was specified;&#160;false&#160;otherwise. Read-only.<br/>
$-i<br/>
nil&#160;if the interpreter option&#160;-i&#160;was&#160;not&#160;specified.&#160;Otherwise,&#160;this&#160;variable&#160;is&#160;set&#160;to<br/>the backup file extension specified with&#160;-i.<br/>
$-l<br/>
true&#160;if the&#160;-l&#160;option was specified. Read-only.<br/>
$-p<br/>
true&#160;if the interpreter option&#160;-p&#160;was specified;&#160;false&#160;otherwise. Read-only.<br/>
$-W<br/>
In&#160;Ruby&#160;1.9,&#160;this&#160;global&#160;variable&#160;specifies&#160;the&#160;current&#160;verbose&#160;level.&#160;It&#160;is&#160;0&#160;if&#160;the<br/>-W0&#160;option was used, and is&#160;2&#160;if any of the options&#160;-w,&#160;-v, or&#160;--verbose&#160;were used.<br/>Otherwise, this variable is&#160;1. Read-only.<br/>
<b>10.2.4 &#160;Predefined Global Functions<br/></b>The&#160;Kernel&#160;module,&#160;which&#160;is&#160;included&#160;by&#160;Object,&#160;defines&#160;a&#160;number&#160;of&#160;private&#160;instance<br/>methods&#160;that&#160;serve&#160;as&#160;global&#160;functions.&#160;Because&#160;they&#160;are&#160;private,&#160;they&#160;must&#160;be&#160;invoked<br/>functionally,&#160;&#160;without&#160;&#160;an&#160;&#160;explicit&#160;&#160;receiver&#160;&#160;object.&#160;&#160;And&#160;&#160;because&#160;&#160;they&#160;&#160;are&#160;&#160;included&#160;&#160;by<br/>Object,&#160;they&#160;can&#160;be&#160;invoked&#160;anywhere—no&#160;matter&#160;what&#160;the&#160;value&#160;of&#160;self&#160;is, it will be<br/>an&#160;object,&#160;and&#160;these&#160;methods&#160;can&#160;be&#160;implicitly&#160;invoked&#160;on&#160;it.&#160;The&#160;functions&#160;defined&#160;by<br/>Kernel&#160;can&#160;be&#160;grouped&#160;into&#160;several&#160;categories,&#160;most&#160;of&#160;which&#160;are&#160;covered&#160;elsewhere&#160;in<br/>this chapter or elsewhere in this book.<br/>
<b>10.2.4.1 &#160;Keyword functions<br/></b>The&#160;following&#160;Kernel&#160;functions&#160;behave&#160;like&#160;language&#160;keywords&#160;and&#160;are&#160;documented<br/>elsewhere in this book:<br/>
block_given? &#160; &#160;iterator? &#160; &#160; &#160; loop &#160; &#160; &#160; &#160; &#160; &#160;require<br/>callcc &#160; &#160; &#160; &#160; &#160;lambda &#160; &#160; &#160; &#160; &#160;proc &#160; &#160; &#160; &#160; &#160; &#160;throw<br/>catch &#160; &#160; &#160; &#160; &#160; load &#160; &#160; &#160; &#160; &#160; &#160;raise<br/>
<b>10.2.4.2 &#160;Text input, output, and manipulation functions<br/></b>Kernel&#160;defines&#160;the&#160;following&#160;functions&#160;most&#160;of&#160;which&#160;are&#160;global&#160;variants&#160;of&#160;IO&#160;methods.<br/><a href="Rubys.html#417">They are covered in more detail in §10.3:</a><br/>
format &#160; &#160; &#160; &#160; &#160;print &#160; &#160; &#160; &#160; &#160; puts &#160; &#160; &#160; &#160; &#160; &#160;sprintf<br/>gets &#160; &#160; &#160; &#160; &#160; &#160;printf &#160; &#160; &#160; &#160; &#160;readline<br/>p &#160; &#160; &#160; &#160; &#160; &#160; &#160; putc &#160; &#160; &#160; &#160; &#160; &#160;readlines<br/>
<b>10.2 &#160;The Top-Level Environment&#160;|&#160;401</b><br/>
<hr/>
<a name=416></a>In&#160;Ruby&#160;1.8&#160;(but&#160;not&#160;1.9),&#160;Kernel&#160;also&#160;defines&#160;the&#160;following&#160;global&#160;variants&#160;of&#160;String<br/>methods that operate implicitly on&#160;$_:<br/>
chomp &#160; chop &#160; &#160;gsub &#160; &#160;scan &#160; &#160;sub<br/>chomp! &#160;chop! &#160; gsub! &#160; split &#160; sub!<br/>
<b>10.2.4.3 &#160;OS methods<br/></b>The following&#160;Kernel&#160;functions&#160;allow&#160;a&#160;Ruby&#160;program&#160;to&#160;interface&#160;with&#160;the&#160;operating<br/>system.&#160;They&#160;are&#160;platform-dependent&#160;and&#160;are&#160;covered&#160;<a href="Rubys.html#419">in&#160;§10.4.&#160;</a>Note&#160;that&#160;`&#160;is&#160;the&#160;spe-<br/>cially&#160;named&#160;backtick&#160;method&#160;that&#160;returns&#160;the&#160;text&#160;output&#160;by&#160;an&#160;arbitrary&#160;OS&#160;shell<br/>command:<br/>
` &#160; &#160; &#160; fork &#160; &#160;select &#160;system &#160;trap<br/>exec &#160; &#160;open &#160; &#160;syscall test<br/>
<b>10.2.4.4 &#160;Warnings, failures, and exiting<br/></b>The following&#160;Kernel&#160;functions&#160;display&#160;warnings,&#160;raise&#160;exceptions,&#160;cause&#160;the&#160;program<br/>to&#160;exit,&#160;or&#160;register&#160;blocks&#160;of&#160;code&#160;to&#160;be&#160;run&#160;when&#160;the&#160;program&#160;terminates.&#160;They&#160;are<br/><a href="Rubys.html#419">documented along with OS-specific methods in §10.4:</a><br/>
abort &#160; at_exit exit &#160; &#160;exit! &#160; fail &#160; &#160;warn<br/>
<b>10.2.4.5 &#160;Reflection functions<br/></b>The&#160;following&#160;Kernel&#160;functions&#160;are&#160;part&#160;of&#160;Ruby’s&#160;reflection&#160;API&#160;and&#160;were&#160;described&#160;in<br/><a href="Rubys.html#279">Chapter 8:</a><br/>
binding &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; set_trace_func<br/>caller &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;singleton_method_added<br/>eval &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;singleton_method_removed<br/>global_variables &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;singleton_method_undefined<br/>local_variables &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; trace_var<br/>method_missing &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;untrace_var<br/>remove_instance_variable<br/>
<b>10.2.4.6 &#160;Conversion functions<br/></b>The&#160;following&#160;Kernel&#160;functions&#160;attempt&#160;to&#160;convert&#160;their&#160;arguments&#160;to&#160;a&#160;new&#160;type.&#160;They<br/><a href="Rubys.html#95">were described in §3.8.7.3:</a><br/>
Array &#160; Float &#160; Integer String<br/>
<b>10.2.4.7 &#160;Miscellaneous Kernel functions<br/></b>The following miscellaneous&#160;Kernel&#160;functions don’t fit into the previous categories:<br/>
autoload &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;rand &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;srand<br/>autoload? &#160; &#160; &#160; &#160; &#160; &#160; &#160; sleep<br/>
rand&#160;and&#160;srand&#160;are&#160;for&#160;generating&#160;random&#160;numbers,&#160;and&#160;are&#160;documented&#160;in&#160;<a href="Rubys.html#339">§9.3.7.<br/></a>autoload&#160;and&#160;autoload?&#160;are&#160;covered&#160;<a href="Rubys.html#270">in&#160;§7.6.3.&#160;</a>And&#160;sleep&#160;is&#160;covered&#160;<a href="Rubys.html#387">in&#160;§9.9&#160;</a><a href="Rubys.html#422">and&#160;§10.4.4.</a><br/>
<b>402&#160;|&#160;Chapter 10:</b> <b>The Ruby Environment</b><br/>
<hr/>
<a name=417></a><b>10.2.5 &#160;User-Defined Global Functions<br/></b>When&#160;you&#160;define&#160;a&#160;method&#160;with&#160;def&#160;inside&#160;a&#160;class&#160;or&#160;module&#160;declaration&#160;and&#160;do&#160;not<br/>specify&#160;a&#160;receiver&#160;object&#160;for&#160;the&#160;method,&#160;the&#160;method&#160;is&#160;created&#160;as&#160;a&#160;public&#160;instance<br/>method&#160;of&#160;self,&#160;where&#160;self&#160;is&#160;the&#160;class&#160;or&#160;module&#160;you&#160;are&#160;defining.&#160;Using&#160;def&#160;at&#160;the<br/>top&#160;level,&#160;outside&#160;of&#160;any&#160;class&#160;or&#160;module,&#160;is&#160;different&#160;in&#160;two&#160;important&#160;ways.&#160;First,&#160;top-<br/>level&#160;methods&#160;are&#160;instance&#160;methods&#160;of&#160;Object&#160;(even&#160;though&#160;self&#160;is&#160;not&#160;Object).&#160;Second,<br/>top-level methods are always private.<br/>
<b>Top-Level self: the Main Object</b><br/>
Because&#160;top-level&#160;methods&#160;become&#160;instance&#160;methods&#160;of&#160;Object,&#160;you&#160;might&#160;expect&#160;that<br/>the&#160;value&#160;of&#160;self&#160;would&#160;be&#160;Object.&#160;In&#160;fact,&#160;however,&#160;top-level&#160;methods&#160;are&#160;a&#160;special<br/>case:&#160;methods&#160;are&#160;defined&#160;in&#160;Object,&#160;but&#160;self&#160;is&#160;a&#160;different&#160;object.&#160;This&#160;special&#160;top-level<br/>object is known as the “main” object, and there is not much to say about it. The class<br/>of the&#160;main&#160;object&#160;is&#160;Object,&#160;and&#160;it&#160;has&#160;a&#160;singleton&#160;to_s&#160;method&#160;that&#160;returns&#160;the&#160;string<br/>“main”.<br/>
The&#160;fact&#160;that&#160;top-level&#160;methods&#160;are&#160;defined&#160;in&#160;Object&#160;means&#160;that&#160;they&#160;are&#160;inherited&#160;by<br/>all&#160;objects&#160;(including&#160;Module&#160;and&#160;Class)&#160;and&#160;(if&#160;not&#160;overridden)&#160;can&#160;be&#160;used&#160;within&#160;any<br/>class&#160;or&#160;instance&#160;method&#160;definition.&#160;(You&#160;can&#160;review&#160;Ruby’s&#160;method&#160;name&#160;resolution<br/>algorithm&#160;in&#160;<a href="Rubys.html#272">§7.8&#160;</a>to&#160;convince&#160;yourself&#160;of&#160;this.)&#160;The&#160;fact&#160;that&#160;top-level&#160;methods&#160;are<br/>private&#160;means&#160;that&#160;they&#160;must&#160;be&#160;invoked&#160;like&#160;functions,&#160;without&#160;an&#160;explicit&#160;receiver.<br/>In&#160;this&#160;way,&#160;Ruby&#160;mimics&#160;a&#160;procedural&#160;programming&#160;paradigm&#160;within&#160;its&#160;strictly&#160;object-<br/>oriented framework.<br/>
<b>10.3 &#160;Practical Extraction and Reporting Shortcuts<br/></b>Ruby&#160;was&#160;influenced&#160;by&#160;the&#160;scripting&#160;language&#160;Perl,&#160;whose&#160;name&#160;is&#160;an&#160;acronym&#160;for<br/>Practical&#160;Extraction&#160;and&#160;Reporting&#160;Language.&#160;Because&#160;of&#160;this,&#160;Ruby&#160;includes&#160;a&#160;number<br/>of&#160;global&#160;functions&#160;that&#160;make&#160;it&#160;easy&#160;to&#160;write&#160;programs&#160;that&#160;extract&#160;information&#160;from<br/>files&#160;and&#160;generate&#160;reports.&#160;In&#160;the&#160;object-oriented&#160;paradigm,&#160;input&#160;and&#160;output&#160;functions<br/>are&#160;methods&#160;of&#160;IO,&#160;and&#160;string&#160;manipulation&#160;functions&#160;are&#160;methods&#160;of&#160;String.&#160;For&#160;prag-<br/>matic&#160;reasons,&#160;however,&#160;it&#160;is&#160;useful&#160;to&#160;have&#160;global&#160;functions&#160;that&#160;read&#160;from&#160;and&#160;write<br/>to&#160;predefined&#160;input&#160;and&#160;output&#160;streams.&#160;In&#160;addition&#160;to&#160;providing&#160;these&#160;global&#160;functions,<br/>Ruby&#160;follows&#160;Perl&#160;further&#160;and&#160;defines&#160;special&#160;behavior&#160;for&#160;the&#160;functions:&#160;many&#160;of&#160;them<br/>operate&#160;implicitly&#160;on&#160;the&#160;special&#160;method-local&#160;variable&#160;$_.&#160;This&#160;variable&#160;holds&#160;the&#160;last<br/>line&#160;read&#160;from&#160;the&#160;input&#160;stream.&#160;The&#160;underscore&#160;character&#160;is&#160;mnemonic:&#160;it&#160;looks&#160;like&#160;a<br/>line.&#160;(Most&#160;of&#160;Ruby’s&#160;global&#160;variables&#160;that&#160;use&#160;punctuation&#160;characters&#160;are&#160;inherited<br/>from&#160;Perl.)&#160;In&#160;addition&#160;to&#160;the&#160;global&#160;input&#160;and&#160;output&#160;functions,&#160;there&#160;are&#160;several&#160;global<br/>string&#160;processing&#160;functions&#160;that&#160;work&#160;like&#160;the&#160;String&#160;methods&#160;but&#160;operate&#160;implicitly<br/>on&#160;$_.<br/>These&#160;global&#160;functions&#160;and&#160;variables&#160;are&#160;intended&#160;as&#160;shortcuts&#160;for&#160;short&#160;and&#160;simple<br/>Ruby scripts. It is generally considered bad form to rely on them in larger programs.<br/>
<b>10.3 &#160;Practical Extraction and Reporting Shortcuts&#160;|&#160;403</b><br/>
<hr/>
<a name=418></a><b>10.3.1 &#160;Input Functions<br/></b>The global functions&#160;gets,&#160;readline, and&#160;readlines&#160;are&#160;just&#160;like&#160;the&#160;IO&#160;methods by the<br/>same names (see&#160;<a href="Rubys.html#374">§9.7.3.1), but they operate implicitly on the&#160;</a>$&lt;&#160;stream (which is also<br/>available&#160;as&#160;the&#160;constant&#160;known&#160;as&#160;ARGF).&#160;Like&#160;the&#160;methods&#160;of&#160;IO,&#160;these&#160;global&#160;functions<br/>implicitly set&#160;$_.<br/>
$&lt;&#160;&#160;behaves&#160;&#160;like&#160;&#160;an&#160;&#160;IO&#160;&#160;object,&#160;&#160;but&#160;&#160;it&#160;&#160;is&#160;&#160;not&#160;&#160;an&#160;&#160;IO&#160;&#160;object.&#160;&#160;(Its&#160;&#160;class&#160;&#160;method&#160;&#160;returns<br/>Object,&#160;&#160;and&#160;&#160;its&#160;&#160;to_s&#160;&#160;method&#160;&#160;returns&#160;&#160;“ARGF”.)&#160;&#160;The&#160;&#160;precise&#160;&#160;behavior&#160;&#160;of&#160;&#160;this&#160;&#160;stream&#160;&#160;is<br/>complicated.&#160;If&#160;the&#160;ARGV&#160;array&#160;is&#160;empty,&#160;then&#160;$&lt;&#160;is&#160;the&#160;same&#160;as&#160;STDIN:&#160;the&#160;standard&#160;input<br/>stream.&#160;If&#160;ARGV&#160;is&#160;not&#160;empty,&#160;then&#160;Ruby&#160;assumes&#160;that&#160;it&#160;is&#160;a&#160;list&#160;of&#160;filenames.&#160;In&#160;this&#160;case,<br/>$&lt;&#160;behaves&#160;as&#160;if&#160;it&#160;were&#160;reading&#160;from&#160;the&#160;concatenation&#160;of&#160;each&#160;of&#160;those&#160;files.&#160;This&#160;does<br/>not&#160;correctly&#160;capture&#160;the&#160;behavior&#160;of&#160;$&lt;,&#160;however.&#160;When&#160;the&#160;first&#160;read&#160;request&#160;for&#160;$&lt;<br/>occurs,&#160;Ruby&#160;uses&#160;ARGV.shift&#160;to&#160;remove&#160;the&#160;first&#160;filename&#160;from&#160;ARGV.&#160;It&#160;opens&#160;and&#160;reads<br/>from&#160;that&#160;file.&#160;When&#160;the&#160;end&#160;of&#160;that&#160;file&#160;is&#160;reached,&#160;Ruby&#160;repeats&#160;the&#160;process,&#160;shifting<br/>the&#160;next&#160;filename&#160;out&#160;of&#160;ARGV&#160;and&#160;opening&#160;that&#160;file.&#160;$&lt;&#160;does&#160;not&#160;report&#160;end-of-file&#160;until<br/>there are no more file names in&#160;ARGV.<br/>What&#160;this&#160;means&#160;is&#160;that&#160;your&#160;Ruby&#160;scripts&#160;can&#160;alter&#160;ARGV&#160;(to&#160;process&#160;command-line<br/>options,&#160;&#160;for&#160;&#160;example)&#160;&#160;before&#160;&#160;beginning&#160;&#160;to&#160;&#160;read&#160;&#160;from&#160;&#160;$&lt;.&#160;&#160;Your&#160;&#160;script&#160;&#160;can&#160;&#160;also&#160;&#160;add<br/>additional files to&#160;ARGV&#160;as it runs, and&#160;$&lt;&#160;will use these files.<br/>
<b>10.3.2 &#160;Deprecated Extraction Functions<br/></b>In&#160;Ruby&#160;1.8&#160;and&#160;before,&#160;the&#160;global&#160;functions&#160;chomp,&#160;chomp!,&#160;chop,&#160;chop!,&#160;gsub,&#160;gsub!,<br/>scan,&#160;split,&#160;sub,&#160;and&#160;sub!&#160;work&#160;like&#160;the&#160;same-named&#160;methods&#160;of&#160;String,&#160;but&#160;operate<br/>implicitly&#160;on&#160;$_.&#160;Furthermore,&#160;chomp,&#160;chop,&#160;gsub,&#160;and&#160;sub&#160;assign&#160;their&#160;result&#160;back&#160;into<br/>$_,&#160;&#160;which&#160;&#160;means&#160;&#160;that&#160;&#160;they&#160;&#160;are&#160;&#160;effectively&#160;&#160;synonyms&#160;&#160;for&#160;&#160;their&#160;&#160;exclamation-mark<br/>versions.<br/>These global functions have been removed in Ruby 1.9, so they should not be used in<br/>new code.<br/>
<b>10.3.3 &#160;Reporting Functions<br/></b>Kernel&#160;defines&#160;a&#160;number&#160;of&#160;global&#160;functions&#160;for&#160;sending&#160;output&#160;to&#160;$stdout.&#160;(This&#160;global<br/>variable&#160;initially&#160;refers&#160;to&#160;the&#160;standard&#160;output&#160;stream,&#160;STDOUT,&#160;of&#160;the&#160;Ruby&#160;process,&#160;but<br/>you can alter its value and change the behavior of the functions described here.)<br/>
puts,&#160;print,&#160;printf&#160;and&#160;putc&#160;are&#160;equivalent&#160;to&#160;the&#160;same-named&#160;methods&#160;of&#160;STDOUT&#160;(see<br/><a href="Rubys.html#378">§9.7.4).&#160;</a>Recall&#160;that&#160;puts&#160;appends&#160;a&#160;newline&#160;to&#160;its&#160;output&#160;if&#160;there&#160;is&#160;not&#160;one&#160;there&#160;already.<br/>print,&#160;on&#160;the&#160;other&#160;hand,&#160;does&#160;not&#160;automatically&#160;append&#160;a&#160;newline,&#160;but&#160;it&#160;does&#160;append<br/>the output record separator&#160;$\, if that global variable has been set.<br/>The&#160;global&#160;function&#160;p&#160;is&#160;one&#160;with&#160;no&#160;analog&#160;in&#160;the&#160;IO&#160;class.&#160;It&#160;is&#160;intended&#160;for&#160;debugging,<br/>and&#160;its&#160;short&#160;name&#160;makes&#160;it&#160;very&#160;easy&#160;to&#160;type.&#160;It&#160;calls&#160;the&#160;inspect&#160;method&#160;of&#160;each&#160;of&#160;its<br/>arguments&#160;and&#160;passes&#160;the&#160;resulting&#160;strings&#160;to&#160;puts. Recall that&#160;inspect&#160;is equivalent to<br/>
<b>404&#160;|&#160;Chapter 10:</b> <b>The Ruby Environment</b><br/>
<hr/>
<a name=419></a>to_s&#160;by&#160;default,&#160;but&#160;that&#160;some&#160;classes&#160;redefine&#160;it&#160;to&#160;provide&#160;more&#160;developer-friendly<br/>output&#160;suitable&#160;for&#160;debugging.&#160;If&#160;you&#160;require&#160;the&#160;pp&#160;library,&#160;you&#160;can&#160;use&#160;the&#160;pp&#160;function<br/>in place of&#160;p&#160;to&#160;“pretty&#160;print”&#160;your&#160;debugging&#160;output.&#160;(This&#160;is&#160;useful&#160;for&#160;printing&#160;large<br/>arrays and hashes.)<br/>The&#160;printf&#160;method&#160;mentioned&#160;earlier&#160;expects&#160;a&#160;format&#160;string&#160;as&#160;its&#160;first&#160;argument&#160;and<br/>substitutes the value of its remaining arguments into that string before outputting the<br/>result.&#160;You&#160;can&#160;also&#160;format&#160;into&#160;a&#160;string&#160;without&#160;sending&#160;the&#160;result&#160;to&#160;$stdout&#160;with&#160;the<br/>global&#160;function&#160;sprintf&#160;or&#160;its&#160;synonym&#160;format.&#160;These&#160;work&#160;like&#160;the&#160;%&#160;operator&#160;of&#160;String.<br/>
<b>10.3.4 &#160;One-Line Script Shortcuts<br/></b>Earlier&#160;in&#160;this&#160;chapter,&#160;we&#160;described&#160;the&#160;-e&#160;option&#160;to&#160;the&#160;interpreter&#160;for&#160;executing&#160;single-<br/>line&#160;Ruby&#160;scripts&#160;(often&#160;used&#160;in&#160;conjunction&#160;with&#160;the&#160;-n&#160;and&#160;-p&#160;looping&#160;options).&#160;There<br/>is&#160;one&#160;special&#160;shortcut&#160;inherited&#160;from&#160;Perl&#160;that&#160;is&#160;allowed&#160;only&#160;in&#160;scripts&#160;specified&#160;with<br/>-e.<br/>
If&#160;a&#160;script&#160;is&#160;specified&#160;with&#160;-e,&#160;and&#160;a&#160;regular&#160;expression&#160;literal&#160;appears&#160;by&#160;itself&#160;in&#160;a<br/>conditional&#160;expression&#160;(part&#160;of&#160;an&#160;if,&#160;unless,&#160;while,&#160;or&#160;until&#160;statement&#160;or&#160;modifier),<br/>then&#160;the&#160;regular&#160;expression&#160;is&#160;implicitly&#160;compared&#160;to&#160;$_.&#160;If&#160;you&#160;want&#160;to&#160;print&#160;all&#160;lines<br/>in a file that begin with the letter A, for example, you can write:<br/>
ruby -n -e 'print if /^A/' datafile<br/>
If&#160;this&#160;same&#160;script&#160;was&#160;stored&#160;in&#160;a&#160;file&#160;and&#160;run&#160;without&#160;the&#160;-e&#160;option,&#160;it&#160;would&#160;still&#160;work,<br/>but&#160;it&#160;would&#160;print&#160;a&#160;warning&#160;(even&#160;without&#160;-w).&#160;To&#160;avoid&#160;the&#160;warning,&#160;you’d&#160;have&#160;to<br/>make the comparison explicit instead:<br/>
print if $_ =~ /^A/<br/>
&#160;<br/>
<b>10.4 &#160;Calling the OS<br/></b>Ruby supports a number of&#160;global&#160;functions&#160;for&#160;interacting&#160;with&#160;the&#160;operating&#160;system<br/>to&#160;execute&#160;programs,&#160;fork&#160;new&#160;processes,&#160;handle&#160;signals,&#160;and&#160;so&#160;on.&#160;Ruby&#160;was&#160;initially<br/>developed&#160;for&#160;Unix-like&#160;operating&#160;systems,&#160;and&#160;many&#160;of&#160;these&#160;OS-related&#160;functions<br/>reflect&#160;that&#160;heritage.&#160;By&#160;their&#160;very&#160;nature,&#160;these&#160;functions&#160;are&#160;less&#160;portable&#160;than&#160;most<br/>others,&#160;and&#160;some&#160;may&#160;not&#160;be&#160;implemented&#160;at&#160;all&#160;on&#160;Windows&#160;and&#160;other&#160;non-Unix<br/>platforms.&#160;The&#160;subsections&#160;that&#160;follow&#160;describe&#160;some&#160;of&#160;the&#160;most&#160;commonly&#160;used&#160;of<br/>the&#160;OS-dependent&#160;functions.&#160;Functions,&#160;such&#160;a&#160;syscall,&#160;that&#160;are&#160;particularly&#160;low-level<br/>or platform-dependent are not covered here.<br/>
<b>10.4.1 &#160;Invoking OS Commands<br/></b>The&#160;Kernel.`&#160;method&#160;expects&#160;a&#160;single&#160;string&#160;argument&#160;representing&#160;an&#160;OS&#160;shell&#160;com-<br/>mand.&#160;It&#160;starts&#160;a&#160;subshell&#160;and&#160;passes&#160;the&#160;specified&#160;text&#160;to&#160;it.&#160;The&#160;return&#160;value&#160;is&#160;the&#160;text<br/>printed&#160;to&#160;standard&#160;output.&#160;This&#160;method&#160;is&#160;typically&#160;invoked&#160;using&#160;special&#160;syntax;&#160;it&#160;is<br/>
<b>10.4 &#160;Calling the OS&#160;|&#160;405</b><br/>
<hr/>
<a name=420></a>invoked&#160;on&#160;string&#160;literals&#160;surrounded&#160;by&#160;backquotes&#160;or&#160;on&#160;string&#160;literals&#160;delimited&#160;with<br/>%x<a href="Rubys.html#67">&#160;(see §3.2.1.6). For example:</a><br/>
os = `uname` &#160; &#160; &#160; &#160; &#160; &#160; # String literal and method invocation in one<br/>os = %x{uname} &#160; &#160; &#160; &#160; &#160; # Another quoting syntax<br/>os = Kernel.`(&#34;uname&#34;) &#160; # Invoke the method explicitly<br/>
This&#160;method&#160;does&#160;not&#160;simply&#160;invoke&#160;the&#160;specified&#160;executable;&#160;it&#160;invokes&#160;a&#160;shell,&#160;which<br/>means that shell features such as filename wildcard expansion are available:<br/>
files = `echo *.xml`<br/>
Another&#160;way&#160;to&#160;start&#160;a&#160;process&#160;and&#160;read&#160;its&#160;output&#160;is&#160;with&#160;the&#160;Kernel.open&#160;function.<br/>This&#160;method&#160;is&#160;a&#160;variant&#160;on&#160;File.open&#160;and&#160;is&#160;most&#160;often&#160;used&#160;to&#160;open&#160;files.&#160;(And&#160;if&#160;you<br/>require 'open-uri'&#160;from&#160;the&#160;standard&#160;library,&#160;it&#160;can&#160;also&#160;be&#160;used&#160;to&#160;open&#160;HTTP&#160;and<br/>FTP&#160;URLs.)&#160;But&#160;if&#160;the&#160;first&#160;character&#160;of&#160;the&#160;specified&#160;“filename”&#160;is&#160;the&#160;pipe&#160;character<br/>|,&#160;then&#160;it&#160;instead&#160;opens&#160;a&#160;pipe&#160;to&#160;read&#160;from&#160;and/or&#160;write&#160;to&#160;the&#160;specified&#160;shell&#160;command:<br/>
pipe = open(&#34;|echo *.xml&#34;)<br/>files = pipe.readline<br/>pipe.close<br/>
If&#160;you&#160;want&#160;to&#160;invoke&#160;a&#160;command&#160;in&#160;a&#160;shell,&#160;but&#160;are&#160;not&#160;interested&#160;in&#160;its&#160;output,&#160;use&#160;the<br/>Kernel.system&#160;method&#160;instead.&#160;When&#160;passed&#160;a&#160;single&#160;string,&#160;it&#160;executes&#160;that&#160;string&#160;in<br/>a&#160;shell,&#160;waits&#160;for&#160;the&#160;command&#160;to&#160;complete,&#160;and&#160;returns&#160;true&#160;on&#160;success&#160;or&#160;false&#160;on<br/>failure.&#160;If&#160;you&#160;pass&#160;multiple&#160;arguments&#160;to&#160;system,&#160;the&#160;first&#160;argument&#160;is&#160;the&#160;name&#160;of&#160;the<br/>program&#160;to&#160;invoke,&#160;and&#160;remaining&#160;arguments&#160;are&#160;its&#160;command-line&#160;arguments.&#160;In&#160;this<br/>case no shell expansion is performed on those arguments.<br/>A&#160;lower-level&#160;way&#160;to&#160;invoke&#160;an&#160;arbitrary&#160;executable&#160;is&#160;with&#160;the&#160;exec&#160;function.&#160;This<br/>function&#160;never&#160;returns:&#160;it&#160;simply&#160;replaces&#160;the&#160;currently&#160;running&#160;Ruby&#160;process&#160;with&#160;the<br/>specified&#160;executable.&#160;This&#160;might&#160;be&#160;useful&#160;if&#160;you&#160;are&#160;writing&#160;a&#160;Ruby&#160;script&#160;that&#160;is&#160;simply<br/>a&#160;wrapper&#160;to&#160;launch&#160;some&#160;other&#160;program.&#160;Usually,&#160;however,&#160;it&#160;is&#160;used&#160;in&#160;conjunction<br/>with the&#160;fork&#160;function, which is described in the next section.<br/>
<b>10.4.2 &#160;Forking and Processes<br/></b><a href="Rubys.html#387">§9.9 described</a>&#160;Ruby’s&#160;API&#160;for&#160;writing&#160;multithreaded&#160;programs.&#160;Another&#160;approach&#160;to<br/>achieving&#160;concurrency&#160;in&#160;Ruby&#160;is&#160;to&#160;use&#160;multiple&#160;Ruby&#160;processes.&#160;Do&#160;this&#160;with&#160;the<br/>fork&#160;function&#160;or&#160;its&#160;Process.fork&#160;synonym.&#160;The&#160;easiest&#160;way&#160;to&#160;use&#160;this&#160;function&#160;is&#160;with<br/>a block:<br/>
fork {<br/>&#160; puts &#34;Hello from the child process: #$$&#34;<br/>}<br/>puts &#34;Hello from the parent process: #$$&#34;<br/>
When&#160;used&#160;this&#160;way,&#160;the&#160;original&#160;Ruby&#160;process&#160;continues&#160;with&#160;the&#160;code&#160;that&#160;appears<br/>after the block and the new Ruby process executes the code in the block.<br/>
<b>406&#160;|&#160;Chapter 10:</b> <b>The Ruby Environment</b><br/>
<hr/>
<a name=421></a>When&#160;invoked&#160;without&#160;a&#160;block,&#160;fork&#160;behaves&#160;differently.&#160;In&#160;the&#160;parent&#160;process,&#160;the&#160;call<br/>to&#160;fork&#160;returns&#160;an&#160;integer&#160;which&#160;is&#160;the&#160;process&#160;ID&#160;of&#160;the&#160;newly&#160;created&#160;child&#160;process.<br/>In&#160;the&#160;child&#160;process,&#160;the&#160;same&#160;call&#160;to&#160;fork&#160;returns&#160;nil.&#160;So&#160;the&#160;previous&#160;code&#160;could&#160;also<br/>be written like this:<br/>
pid = fork<br/>if (pid)<br/>&#160; puts &#34;Hello from parent process: #$$&#34;<br/>&#160; puts &#34;Created child process #{pid}&#34; &#160;&#160;<br/>else<br/>&#160; puts Hello from child process: #$$&#34;<br/>end<br/>
One&#160;very&#160;important&#160;difference&#160;between&#160;processes&#160;and&#160;threads&#160;is&#160;that&#160;processes&#160;do&#160;not<br/>share&#160;memory.&#160;When&#160;you&#160;call&#160;fork,&#160;the&#160;new&#160;Ruby&#160;process&#160;starts&#160;off&#160;as&#160;an&#160;exact&#160;duplicate<br/>of&#160;the&#160;parent&#160;process.&#160;But&#160;any&#160;changes&#160;it&#160;makes&#160;to&#160;the&#160;process&#160;state&#160;(by&#160;altering&#160;or<br/>creating&#160;objects)&#160;are&#160;done&#160;in&#160;its&#160;own&#160;address&#160;space.&#160;The&#160;child&#160;process&#160;cannot&#160;alter&#160;the<br/>data structures of the parent, nor can the parent alter the structures seen by the child.<br/>If you need your parent and child processes to be able to communicate, use&#160;open, and<br/>pass “|-”&#160;as&#160;the&#160;first&#160;argument.&#160;This&#160;opens&#160;a&#160;pipe&#160;to&#160;a&#160;newly&#160;forked&#160;Ruby&#160;process.&#160;The<br/>open&#160;call&#160;yields&#160;to&#160;the&#160;associated&#160;block&#160;in&#160;both&#160;the&#160;parent&#160;and&#160;the&#160;child.&#160;In&#160;the&#160;child,<br/>the&#160;block&#160;receives&#160;nil.&#160;In&#160;the&#160;parent,&#160;however,&#160;an&#160;IO&#160;object&#160;is&#160;passed&#160;to&#160;the&#160;block.<br/>Reading from this&#160;IO&#160;object&#160;returns&#160;data&#160;written&#160;by&#160;the&#160;child.&#160;And&#160;data&#160;written&#160;to&#160;the<br/>IO&#160;&#160;object&#160;&#160;becomes&#160;&#160;available&#160;&#160;for&#160;&#160;reading&#160;&#160;through&#160;&#160;the&#160;&#160;child’s&#160;&#160;standard&#160;&#160;input.&#160;&#160;For<br/>example:<br/>
open(&#34;|-&#34;, &#34;r+&#34;) do |child|<br/>&#160; if child<br/>&#160; &#160; # This is the parent process<br/>&#160; &#160; child.puts(&#34;Hello child&#34;) &#160; &#160; &#160; # Send to child<br/>&#160; &#160; response = child.gets &#160; &#160; &#160; &#160; &#160; # Read from child<br/>&#160; &#160; puts &#34;Child said: #{response}&#34;<br/>&#160; else<br/>&#160; &#160; # This is the child process<br/>&#160; &#160; from_parent = gets &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Read from parent<br/>&#160; &#160; STDERR.puts &#34;Parent said: #{from_parent}&#34;<br/>&#160; &#160; puts(&#34;Hi Mom!&#34;) &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Send to parent<br/>&#160; end<br/>end<br/>
The&#160;Kernel.exec&#160;function&#160;is&#160;useful&#160;in&#160;conjunction&#160;with&#160;the&#160;fork&#160;function&#160;or&#160;the&#160;open<br/>method.&#160;We&#160;saw&#160;earlier&#160;that&#160;you&#160;can&#160;use&#160;the&#160;`&#160;and&#160;system&#160;functions&#160;to&#160;send&#160;an&#160;arbitrary<br/>command&#160;to&#160;the&#160;operating&#160;system&#160;shell.&#160;Both&#160;of&#160;those&#160;methods&#160;are&#160;synchronous,&#160;how-<br/>ever;&#160;&#160;they&#160;&#160;don’t&#160;&#160;return&#160;&#160;until&#160;&#160;the&#160;&#160;command&#160;&#160;completes.&#160;&#160;If&#160;&#160;you&#160;&#160;want&#160;&#160;to&#160;&#160;execute&#160;&#160;an<br/>operating&#160;system&#160;command&#160;as&#160;a&#160;separate&#160;process,&#160;first&#160;use&#160;fork&#160;to&#160;create&#160;a&#160;child&#160;process,<br/>and&#160;then&#160;call&#160;exec&#160;in&#160;the&#160;child&#160;to&#160;run&#160;the&#160;command.&#160;A&#160;call&#160;to&#160;exec&#160;never&#160;returns;&#160;it<br/>replaces&#160;the&#160;current&#160;process&#160;with&#160;a&#160;new&#160;process.&#160;The&#160;arguments&#160;to&#160;exec&#160;are&#160;the&#160;same<br/>as&#160;those&#160;to&#160;system.&#160;If&#160;there&#160;is&#160;only&#160;one,&#160;it&#160;is&#160;treated&#160;as&#160;a&#160;shell&#160;command.&#160;If&#160;there&#160;are<br/>
<b>10.4 &#160;Calling the OS&#160;|&#160;407</b><br/>
<hr/>
<a name=422></a>multiple&#160;arguments,&#160;then&#160;the&#160;first&#160;identifies&#160;the&#160;executable&#160;to&#160;invoke,&#160;and&#160;any&#160;remaining<br/>arguments become the “ARGV” for that executable:<br/>
open(&#34;|-&#34;, &#34;r&#34;) do |child|<br/>&#160; if child<br/>&#160; &#160; # This is the parent process<br/>&#160; &#160; files = child.readlines &#160; # Read the output of our child<br/>&#160; &#160; child.close<br/>&#160; else<br/>&#160; &#160; # This is the child process<br/>&#160; &#160; exec(&#34;/bin/ls&#34;, &#34;-l&#34;) &#160; &#160; # Run another executable<br/>&#160; end<br/>end<br/>
Working&#160;with&#160;processes&#160;is&#160;a&#160;low-level&#160;programming&#160;task&#160;and&#160;the&#160;details&#160;are&#160;beyond<br/>the&#160;scope&#160;of&#160;this&#160;book.&#160;If&#160;you&#160;want&#160;to&#160;know&#160;more,&#160;start&#160;by&#160;using&#160;<i>ri</i>&#160;to&#160;read&#160;about&#160;the<br/>other methods of the&#160;Process&#160;module.<br/>
<b>10.4.3 &#160;Trapping Signals<br/></b>Most&#160;operating&#160;systems&#160;allow&#160;asynchronous&#160;signals&#160;to&#160;be&#160;sent&#160;to&#160;a&#160;running&#160;process.<br/>This&#160;is&#160;what&#160;happens,&#160;for&#160;example,&#160;when&#160;the&#160;user&#160;types&#160;Ctrl-C&#160;to&#160;abort&#160;a&#160;program.<br/>Most&#160;&#160;shell&#160;&#160;programs&#160;&#160;send&#160;&#160;a&#160;&#160;signal&#160;&#160;named&#160;&#160;“SIGINT”&#160;&#160;(for&#160;&#160;interrupt)&#160;&#160;in&#160;&#160;response&#160;&#160;to<br/>Ctrl-C.&#160;And&#160;the&#160;default&#160;response&#160;to&#160;this&#160;signal&#160;is&#160;usually&#160;to&#160;abort&#160;the&#160;program.&#160;Ruby<br/>allows&#160;programs&#160;to&#160;“trap”&#160;signals&#160;and&#160;define&#160;their&#160;own&#160;signal&#160;handlers.&#160;This&#160;is&#160;done<br/>with the&#160;Kernel.trap&#160;method (or its synonym&#160;Signal.trap). For example, if you don’t<br/>want to allow the user to use Ctrl-C to abort:<br/>
trap &#34;SIGINT&#34; {<br/>&#160; puts &#34;Ignoring SIGINT&#34;<br/>}<br/>
Instead&#160;of&#160;passing&#160;a&#160;block&#160;to&#160;the&#160;trap&#160;method,&#160;you&#160;can&#160;equivalently&#160;pass&#160;a&#160;Proc&#160;object.<br/>If&#160;you&#160;simply&#160;want&#160;to&#160;silently&#160;ignore&#160;a&#160;signal,&#160;you&#160;can&#160;also&#160;pass&#160;the&#160;string&#160;“IGNORE” as<br/>the&#160;second&#160;argument.&#160;Pass&#160;“DEFAULT”&#160;as&#160;the&#160;second&#160;argument&#160;to&#160;restore&#160;the&#160;OS&#160;default<br/>behavior for a signal.<br/>In long-running programs such as servers, it can be useful to define signal handlers to<br/>make&#160;the&#160;server&#160;reread&#160;its&#160;configuration&#160;file,&#160;dump&#160;its&#160;usage&#160;statistics&#160;to&#160;the&#160;log,&#160;or&#160;enter<br/>debugging&#160;mode,&#160;for&#160;example.&#160;On&#160;Unix-like&#160;operating&#160;systems,&#160;SIGUSR1&#160;and&#160;SIGUSR2<br/>are commonly used for such purposes.<br/>
<b>10.4.4 &#160;Terminating Programs<br/></b>There&#160;are&#160;a&#160;number&#160;of&#160;related&#160;Kernel&#160;methods&#160;for&#160;terminating&#160;program&#160;or&#160;performing<br/>related&#160;actions.&#160;The&#160;exit&#160;function&#160;is&#160;the&#160;most&#160;straightforward.&#160;It&#160;raises&#160;a&#160;SystemExit<br/>exception,&#160;which,&#160;if&#160;uncaught,&#160;causes&#160;the&#160;program&#160;to&#160;exit.&#160;Before&#160;the&#160;exit&#160;occurs,&#160;how-<br/>ever,&#160;END&#160;blocks&#160;and&#160;any&#160;shutdown&#160;handlers&#160;registered&#160;with&#160;Kernel.at_exit&#160;are&#160;run.<br/>To&#160;exit&#160;immediately,&#160;use&#160;exit!&#160;instead.&#160;Both&#160;methods&#160;accept&#160;an&#160;integer&#160;argument&#160;that<br/>
<b>408&#160;|&#160;Chapter 10:</b> <b>The Ruby Environment</b><br/>
<hr/>
<a name=423></a>specifies&#160;the&#160;process&#160;exit&#160;code&#160;that&#160;is&#160;reported&#160;to&#160;the&#160;operating&#160;system.&#160;Process.exit<br/>and&#160;Process.exit!&#160;are synonyms for these two&#160;Kernel&#160;functions.<br/>The&#160;abort&#160;function&#160;prints&#160;the&#160;specified&#160;error&#160;message&#160;to&#160;the&#160;standard&#160;output&#160;stream<br/>and then calls&#160;exit(1).<br/>
fail&#160;is&#160;simply&#160;a&#160;synonym&#160;for&#160;raise,&#160;and&#160;it&#160;is&#160;intended&#160;for&#160;cases&#160;in&#160;which&#160;the&#160;exception<br/>raised&#160;is&#160;expected&#160;to&#160;terminate&#160;the&#160;program.&#160;Like&#160;abort,&#160;fail&#160;causes&#160;a&#160;message&#160;to&#160;be<br/>displayed when the program exits. For example:<br/>
fail &#34;Unknown option #{switch}&#34;<br/>
The&#160;warn&#160;function&#160;is&#160;related&#160;to&#160;abort&#160;and&#160;fail:&#160;it&#160;prints&#160;a&#160;warning&#160;message&#160;to&#160;standard<br/>error&#160;(unless&#160;warnings&#160;have&#160;been&#160;explicitly&#160;disabled&#160;with&#160;-W0).&#160;Note,&#160;however,&#160;that&#160;this<br/>function does not raise an exception or cause the program to exit.<br/>
sleep&#160;is&#160;another&#160;related&#160;function&#160;that&#160;does&#160;not&#160;cause&#160;the&#160;program&#160;to&#160;exit.&#160;Instead,&#160;it<br/>simply causes the program (or at least the current thread of the program) to pause for<br/>the specified number of seconds.<br/>
<b>10.5 &#160;Security<br/></b>Ruby’s&#160;security&#160;system&#160;provides&#160;a&#160;mechanism&#160;for&#160;writing&#160;programs&#160;that&#160;work&#160;with<br/>untrusted&#160;data&#160;and&#160;untrusted&#160;code.&#160;There&#160;are&#160;two&#160;parts&#160;to&#160;the&#160;security&#160;system.&#160;The&#160;first<br/>is&#160;a&#160;mechanism&#160;for&#160;distinguishing&#160;safe&#160;data&#160;from&#160;untrusted,&#160;or&#160;<i>tainted</i>,&#160;data.&#160;The&#160;second<br/>is&#160;a&#160;technique&#160;for&#160;<i>restricted execution</i>,&#160;which&#160;allows&#160;you&#160;to&#160;“lock&#160;down”&#160;the&#160;Ruby&#160;en-<br/>vironment&#160;and&#160;prevents&#160;the&#160;Ruby&#160;interpreter&#160;from&#160;performing&#160;potentially&#160;dangerous<br/>operations&#160;on&#160;tainted&#160;data.&#160;This&#160;serves&#160;to&#160;prevent&#160;things&#160;like&#160;SQL&#160;injection&#160;attacks&#160;in<br/>which&#160;malicious&#160;input&#160;alters&#160;a&#160;program’s&#160;behavior.&#160;Restricted&#160;execution can be taken<br/>a&#160;step&#160;further&#160;so&#160;that&#160;untrusted&#160;(and&#160;possibly&#160;malicious)&#160;code&#160;can&#160;be&#160;executed&#160;without<br/>fear that it will delete files, steal data, or otherwise cause harm.<br/>This&#160;discussion&#160;of&#160;Ruby’s&#160;security&#160;mechanisms&#160;is&#160;specific&#160;to&#160;the&#160;reference&#160;implemen-<br/>tation.&#160;&#160;Other&#160;&#160;implementations&#160;&#160;may&#160;&#160;differ.&#160;&#160;JRuby,&#160;&#160;in&#160;&#160;particular,&#160;&#160;makes&#160;&#160;very&#160;&#160;little<br/>attempt&#160;(at&#160;the&#160;time&#160;of&#160;this&#160;writing)&#160;to&#160;emulate&#160;the&#160;restricted&#160;execution&#160;modes&#160;of&#160;the<br/>reference&#160;implementation.&#160;Furthermore,&#160;keep&#160;in&#160;mind&#160;that&#160;Ruby’s&#160;security&#160;model&#160;has<br/>not&#160;received&#160;the&#160;kind&#160;of&#160;careful&#160;and&#160;prolonged&#160;scrutiny&#160;that&#160;Java’s&#160;security&#160;architecture<br/>has.&#160;This&#160;section&#160;explains&#160;how&#160;Ruby’s&#160;security&#160;architecture&#160;is&#160;supposed&#160;to&#160;work,&#160;but<br/>bugs yet to be discovered may allow the restrictions to be circumvented.<br/>
<b>10.5.1 &#160;Tainted Data<br/></b>Every&#160;object&#160;in&#160;Ruby&#160;is&#160;either&#160;tainted&#160;or&#160;untainted.&#160;Literal&#160;values&#160;in&#160;program&#160;source<br/>code&#160;are&#160;untainted.&#160;Values&#160;that&#160;are&#160;derived&#160;from&#160;the&#160;external&#160;environment&#160;are&#160;tainted.<br/>These&#160;&#160;include&#160;&#160;strings&#160;&#160;read&#160;&#160;from&#160;&#160;the&#160;&#160;command-line&#160;&#160;(ARGV)&#160;&#160;or&#160;&#160;environment&#160;&#160;variables<br/>(ENV)&#160;and&#160;also&#160;any&#160;data&#160;read&#160;from&#160;files,&#160;sockets,&#160;or&#160;other&#160;streams.&#160;The&#160;environment<br/>variable&#160;PATH&#160;is&#160;a&#160;special&#160;case:&#160;it&#160;is&#160;tainted&#160;only&#160;if&#160;one&#160;or&#160;more&#160;of&#160;the&#160;directories&#160;it&#160;contains<br/>
<b>10.5 &#160;Security&#160;|&#160;409</b><br/>
<hr/>
<a name=424></a>is&#160;&#160;world-writable.&#160;&#160;Importantly,&#160;&#160;taintedness&#160;&#160;is&#160;&#160;contagious,&#160;&#160;so&#160;&#160;objects&#160;&#160;derived&#160;&#160;from<br/>tainted objects are also tainted.<br/>The&#160;Object&#160;methods&#160;taint,&#160;tainted?,&#160;and&#160;untaint&#160;allow&#160;you&#160;to&#160;mark&#160;an&#160;untainted&#160;object<br/>as&#160;tainted,&#160;test&#160;the&#160;taintedness&#160;of&#160;an&#160;object,&#160;and&#160;untaint&#160;a&#160;tainted&#160;object.&#160;You&#160;should<br/>untaint&#160;a&#160;tainted&#160;object&#160;only&#160;if&#160;your&#160;code&#160;has&#160;inspected&#160;it&#160;and&#160;determined&#160;that&#160;it&#160;is&#160;safe<br/>despite its unsafe origin or derivation.<br/>In&#160;Ruby&#160;1.8,&#160;any&#160;objects&#160;created&#160;by&#160;untrusted&#160;code&#160;(i.e.&#160;code&#160;run&#160;under&#160;the&#160;“Safe&#160;level<br/>4”&#160;restrictions&#160;described&#160;below)&#160;are&#160;also&#160;tainted.&#160;Furthermore,&#160;that&#160;untrusted&#160;code&#160;is<br/>not allowed to modify untainted objects.<br/>Ruby&#160;1.9&#160;adds&#160;an&#160;“untrusted”&#160;flag&#160;to&#160;each&#160;object&#160;and&#160;separates&#160;the&#160;notions&#160;of&#160;taint&#160;and<br/>trust.&#160;In&#160;Ruby&#160;1.9,&#160;objects&#160;created&#160;by&#160;untrusted&#160;code&#160;are&#160;both&#160;tainted&#160;and&#160;untrusted,<br/>and&#160;untrusted&#160;code&#160;is&#160;not&#160;allowed&#160;to&#160;modify&#160;trusted&#160;objects,&#160;regardless&#160;of&#160;whether&#160;those<br/>objects&#160;&#160;are&#160;&#160;tainted&#160;&#160;or&#160;&#160;not.&#160;&#160;You&#160;&#160;can&#160;&#160;test&#160;&#160;whether&#160;&#160;an&#160;&#160;object&#160;&#160;is&#160;&#160;untrusted&#160;&#160;with&#160;&#160;the<br/>untrusted?&#160;method. You can force an object to be untrusted (so it can be modified by<br/>untrusted&#160;code,&#160;for&#160;example)&#160;with&#160;the&#160;untrust&#160;method,&#160;and&#160;you&#160;can&#160;make&#160;an&#160;object<br/>trusted&#160;again&#160;with&#160;the&#160;trust&#160;method.&#160;These&#160;three&#160;Object&#160;methods&#160;parallel&#160;tainted?,<br/>taint, and&#160;untaint.<br/>
<b>10.5.2 &#160;Restricted Execution and Safe Levels<br/></b>Ruby&#160;&#160;can&#160;&#160;execute&#160;&#160;programs&#160;&#160;with&#160;&#160;<i>security&#160;&#160;checking</i>&#160;&#160;turned&#160;&#160;on.&#160;&#160;The&#160;&#160;global&#160;&#160;variable<br/>$SAFE&#160;determines&#160;the&#160;level&#160;of&#160;the&#160;security&#160;check.&#160;The&#160;default&#160;safe&#160;level&#160;is&#160;normally&#160;0,<br/>but&#160;is&#160;1&#160;for&#160;Ruby&#160;programs&#160;that&#160;run&#160;<i>setuid</i>&#160;or&#160;<i>setgid</i>.&#160;(These&#160;are&#160;Unix&#160;terms&#160;for&#160;a&#160;program<br/>that&#160;runs&#160;with&#160;privileges&#160;beyond&#160;those&#160;of&#160;the&#160;user&#160;that&#160;invokes&#160;it.)&#160;Legal&#160;safe&#160;levels&#160;are<br/>the&#160;integers&#160;0,&#160;1,&#160;2,&#160;3,&#160;and&#160;4.&#160;You&#160;can&#160;explicitly&#160;set&#160;the&#160;safe&#160;level&#160;with&#160;the&#160;-T&#160;command-<br/>line&#160;&#160;option&#160;&#160;to&#160;&#160;the&#160;&#160;Ruby&#160;&#160;interpreter.&#160;&#160;You&#160;&#160;can&#160;&#160;also&#160;&#160;set&#160;&#160;the&#160;&#160;safe&#160;&#160;level&#160;&#160;by&#160;&#160;assigning&#160;&#160;to<br/>$SAFE.&#160;Note,&#160;however,&#160;that&#160;you&#160;can&#160;only&#160;increase&#160;the&#160;value—it&#160;is&#160;never&#160;possible&#160;to&#160;lower<br/>this value:<br/>
$SAFE=1 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# upgrade the safe level<br/>$SAFE=4 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# upgrade the safe level even higher<br/>$SAFE=0 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;# SecurityError! &#160;you can't do it<br/>
$SAFE&#160;is&#160;thread-local.&#160;In&#160;other&#160;words,&#160;the&#160;value&#160;of&#160;$SAFE&#160;in&#160;a&#160;thread&#160;may&#160;be&#160;changed<br/>without&#160;affecting&#160;the&#160;value&#160;in&#160;other&#160;threads.&#160;Using&#160;this&#160;feature,&#160;threads&#160;can&#160;be&#160;sand-<br/>boxed for untrusted programs:<br/>
Thread.start { &#160; &#160; # Create a &#34;sandbox&#34; thread<br/>&#160; $SAFE = 4 &#160; &#160; &#160; &#160;# Restrict execution in this thread only<br/>&#160; ... &#160; &#160; &#160; &#160; &#160; &#160; &#160;# Untrusted code can be run here<br/>}<br/>
Proc&#160;objects&#160;have&#160;their&#160;own&#160;copy&#160;of&#160;the&#160;global&#160;$SAFE&#160;variable.&#160;When&#160;a&#160;proc&#160;or&#160;a&#160;lambda<br/>is&#160;invoked&#160;with&#160;the&#160;call&#160;method&#160;(but&#160;not&#160;when&#160;invoked&#160;like&#160;a&#160;block&#160;with&#160;yield)&#160;it&#160;runs<br/>at&#160;the&#160;safe&#160;level&#160;in&#160;effect&#160;when&#160;it&#160;was&#160;defined,&#160;not&#160;the&#160;level&#160;in&#160;effect&#160;when&#160;it&#160;is&#160;invoked.<br/>
<b>410&#160;|&#160;Chapter 10:</b> <b>The Ruby Environment</b><br/>
<hr/>
<a name=425></a>Furthermore,&#160;if&#160;you&#160;set&#160;$SAFE&#160;in&#160;a&#160;proc&#160;or&#160;lambda,&#160;that&#160;setting&#160;remains&#160;local.&#160;This&#160;means<br/>that you can sandbox code without creating a new thread:<br/>
# Execute a block at the specified safe level<br/>def safely(level = 4)<br/>&#160; sandbox = lambda do # Set up a sandbox&#160;<br/>&#160; &#160; $SAFE = level &#160; &#160; # Go to the specified safe level for this lambda only<br/>&#160; &#160; yield &#160; &#160; &#160; &#160; &#160; &#160; # Invoke the block at that level<br/>&#160; end<br/>&#160; sandbox.call &#160; &#160; &#160; &#160;# Invoke the sandbox without changing $SAFE globally<br/>end<br/>
<b>10.5.2.1 &#160;Safe level 0<br/></b>Level 0 is the default safe level. No checks are performed on tainted data.<br/>
<b>10.5.2.2 &#160;Safe Level 1<br/></b>In&#160;this&#160;level,&#160;potentially&#160;dangerous&#160;operations&#160;using&#160;tainted&#160;data&#160;are&#160;forbidden.&#160;You<br/>can’t&#160;evaluate&#160;a&#160;string&#160;of&#160;code&#160;if&#160;the&#160;string&#160;is&#160;tainted;&#160;you&#160;can’t&#160;require&#160;a&#160;library&#160;if&#160;the<br/>library&#160;name&#160;is&#160;tainted;&#160;you&#160;can’t&#160;open&#160;a&#160;named&#160;file&#160;if&#160;the&#160;filename&#160;is&#160;tainted;&#160;and&#160;you<br/>can’t&#160;connect&#160;to&#160;a&#160;network&#160;host&#160;if&#160;the&#160;hostname&#160;is&#160;tainted.&#160;Programs,&#160;especially&#160;net-<br/>worked&#160;servers,&#160;that&#160;accept&#160;arbitrary&#160;input&#160;should&#160;probably&#160;use&#160;this&#160;safe&#160;level.&#160;This<br/>helps catch programming errors that use tainted data in unsafe ways.<br/>If&#160;you&#160;write&#160;a&#160;library&#160;that&#160;performs&#160;potentially&#160;dangerous&#160;operations—such&#160;as&#160;com-<br/>municating&#160;with&#160;a&#160;database&#160;server—you&#160;should&#160;check&#160;the&#160;value&#160;of&#160;$SAFE.&#160;If&#160;it&#160;is&#160;1&#160;or<br/>higher,&#160;your&#160;library&#160;should&#160;not&#160;operate&#160;on&#160;tainted&#160;objects.&#160;For&#160;example,&#160;you&#160;should<br/>not send a SQL query to a database if the string containing that query is tainted.<br/>Execution restrictions at safe level 1 include the following:<br/>
•&#160;Environment variables&#160;RUBYLIB&#160;and&#160;RUBYOPT&#160;are ignored at startup.<br/>•&#160;The current directory (.) isn’t included in&#160;$LOAD_PATH.<br/>•&#160;The command-line options&#160;-e,&#160;-i,&#160;-I,&#160;-r,&#160;-s,&#160;-S, and&#160;-X&#160;are prohibited.<br/>•&#160;Certain&#160;instance&#160;methods&#160;and&#160;class&#160;methods&#160;of&#160;Dir,&#160;IO,&#160;File,&#160;and&#160;FileTest&#160;are<br/>
prohibited for tainted arguments.<br/>
•&#160;test,&#160;eval,&#160;require,&#160;load, and&#160;trap&#160;may not be invoked with tainted arguments.<br/>
<b>10.5.2.3 &#160;Safe level 2<br/></b>Safe&#160;level&#160;2&#160;restricts&#160;operations&#160;on&#160;tainted&#160;data&#160;just&#160;as&#160;level&#160;1&#160;does,&#160;but&#160;also&#160;imposes<br/>additional&#160;restrictions&#160;on&#160;how&#160;files&#160;and&#160;processes&#160;can&#160;be&#160;manipulated,&#160;regardless&#160;of<br/>taint.&#160;There&#160;is&#160;little&#160;reason&#160;for&#160;a&#160;program&#160;to&#160;set&#160;its&#160;own&#160;safe&#160;level&#160;to&#160;2,&#160;but&#160;a&#160;system<br/>administrator&#160;might&#160;choose&#160;to&#160;run&#160;a&#160;program&#160;you&#160;have&#160;written&#160;at&#160;this&#160;safe&#160;level&#160;to&#160;ensure<br/>that&#160;it&#160;cannot&#160;create&#160;or&#160;delete&#160;directories,&#160;change&#160;file&#160;permissions,&#160;launch&#160;executables,<br/>load Ruby code from world-writable directories, and so on.<br/>Methods restricted at this safe level include:<br/>
<b>10.5 &#160;Security&#160;|&#160;411</b><br/>
<hr/>
<a name=426></a>Dir.chdir &#160; &#160; &#160; &#160; &#160; &#160; &#160; File.truncate &#160; &#160; &#160; &#160; &#160; Process.egid=<br/>Dir.chroot &#160; &#160; &#160; &#160; &#160; &#160; &#160;File.umask &#160; &#160; &#160; &#160; &#160; &#160; &#160;Process.fork<br/>Dir.mkdir &#160; &#160; &#160; &#160; &#160; &#160; &#160; IO.fctrl &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;Process.kill<br/>Dir.rmdir &#160; &#160; &#160; &#160; &#160; &#160; &#160; IO.ioctl &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;Process.setpgid<br/>File.chmod &#160; &#160; &#160; &#160; &#160; &#160; &#160;Kernel.exit! &#160; &#160; &#160; &#160; &#160; &#160;Process.setpriority<br/>File.chown &#160; &#160; &#160; &#160; &#160; &#160; &#160;Kernel.fork &#160; &#160; &#160; &#160; &#160; &#160; Process.setsid<br/>File.flock &#160; &#160; &#160; &#160; &#160; &#160; &#160;Kernel.syscall<br/>File.lstat &#160; &#160; &#160; &#160; &#160; &#160; &#160;Kernel.trap<br/>
In&#160;addition,&#160;safe&#160;level&#160;2&#160;prevents&#160;you&#160;from&#160;loading&#160;or&#160;requiring&#160;Ruby&#160;code&#160;or&#160;running<br/>executables stored in world-writable directories.<br/>
<b>10.5.2.4 &#160;Safe level 3<br/></b>Safe&#160;&#160;level&#160;&#160;3&#160;&#160;includes&#160;&#160;all&#160;&#160;of&#160;&#160;the&#160;&#160;restrictions&#160;&#160;of&#160;&#160;level&#160;&#160;2,&#160;&#160;and&#160;&#160;in&#160;&#160;addition,&#160;&#160;all&#160;&#160;objects—<br/>including&#160;literals&#160;in&#160;program&#160;source&#160;code&#160;(but&#160;not&#160;including&#160;predefined&#160;objects&#160;in&#160;the<br/>global&#160;environment)—are&#160;tainted&#160;when&#160;they&#160;are&#160;created.&#160;In&#160;Ruby&#160;1.9,&#160;objects&#160;created<br/>at&#160;this&#160;level&#160;are&#160;untrusted&#160;in&#160;addition&#160;to&#160;being&#160;tainted.&#160;Neither&#160;the&#160;untaint&#160;nor&#160;the<br/>trust&#160;methods may be called at this level.<br/>
Safe level 3 is an intermediate step toward level 4 and is not commonly used.<br/>
<b>10.5.2.5 &#160;Safe level 4<br/></b>This&#160;level&#160;extends&#160;safe&#160;level&#160;3&#160;by&#160;preventing&#160;any&#160;modifications&#160;to&#160;trusted&#160;objects&#160;(in-<br/>cluding&#160;making&#160;trusted&#160;objects&#160;untrusted).&#160;In&#160;Ruby&#160;1.8,&#160;trusted&#160;objects&#160;are&#160;untainted<br/>objects,&#160;which&#160;means&#160;that&#160;any&#160;tainted&#160;objects&#160;can&#160;be&#160;modified&#160;by&#160;untrusted&#160;code.&#160;In<br/>Ruby&#160;1.9,&#160;trust&#160;and&#160;taint&#160;are&#160;separate,&#160;and&#160;trusted&#160;objects&#160;are&#160;those&#160;created&#160;at&#160;safe&#160;level<br/>2&#160;or&#160;lower.&#160;This&#160;means&#160;that&#160;untrusted&#160;code&#160;can&#160;only&#160;modify&#160;objects&#160;created&#160;at&#160;safe&#160;level<br/>3&#160;or&#160;4,&#160;and&#160;also&#160;any&#160;objects&#160;that&#160;have&#160;been&#160;explicitly&#160;opened&#160;up&#160;to&#160;modifications&#160;with<br/>the&#160;untrust&#160;method.&#160;This&#160;effectively&#160;creates&#160;a&#160;sandbox&#160;in&#160;which&#160;untrusted&#160;code&#160;can&#160;be<br/>run&#160;without&#160;doing&#160;any&#160;harm.&#160;(In&#160;theory,&#160;at&#160;least—bugs&#160;in&#160;the&#160;implementation&#160;or&#160;de-<br/>ficiencies in the underlying security model may be found in the future.)<br/>Calling&#160;eval&#160;on&#160;a&#160;tainted&#160;string&#160;is&#160;prohibited&#160;in&#160;levels&#160;1,&#160;2,&#160;and&#160;3.&#160;In&#160;safe&#160;level&#160;4,&#160;it&#160;is<br/>allowed&#160;again&#160;because&#160;the&#160;restrictions&#160;on&#160;level&#160;4&#160;are&#160;stringent&#160;enough&#160;that&#160;the&#160;evaluated<br/>string can do no harm. Here is a way to evaluate arbitrary code in a level-4 sandbox:<br/>
def safe_eval(str)<br/>&#160; Thread.start { &#160; &#160; &#160; &#160; &#160; &#160;# Start sandbox thread<br/>&#160; &#160; $SAFE = 4 &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Upgrade safe level<br/>&#160; &#160; eval(str) &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Eval in the sandbox<br/>&#160; }.value &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; # Retrieve result<br/>end<br/>
In&#160;safe&#160;level&#160;4,&#160;you&#160;may&#160;not&#160;use&#160;require&#160;to&#160;load&#160;another&#160;file&#160;of&#160;Ruby&#160;code.&#160;You&#160;can&#160;use<br/>load,&#160;but&#160;only&#160;in&#160;wrapped&#160;form,&#160;with&#160;true&#160;as&#160;its&#160;second&#160;argument.&#160;This&#160;causes&#160;Ruby<br/>to&#160;sandbox&#160;the&#160;loaded&#160;file&#160;in&#160;an&#160;anonymous&#160;module&#160;so&#160;that&#160;any&#160;classes,&#160;modules,&#160;or<br/>constants&#160;it&#160;defines&#160;do&#160;not&#160;affect&#160;the&#160;global&#160;namespace.&#160;This&#160;means&#160;that&#160;code&#160;running<br/>
<b>412&#160;|&#160;Chapter 10:</b> <b>The Ruby Environment</b><br/>
<hr/>
<a name=427></a>under&#160;safe&#160;level&#160;4&#160;can&#160;load,&#160;but&#160;cannot&#160;use,&#160;classes&#160;and&#160;modules&#160;defined&#160;in&#160;external<br/>modules.<br/>You&#160;can&#160;further&#160;restrict&#160;a&#160;level-4&#160;sandbox&#160;by&#160;placing&#160;the&#160;sandbox&#160;thread&#160;(before&#160;setting<br/>$SAFE) into a&#160;ThreadGroup&#160;and calling&#160;enclose<a href="Rubys.html#394">&#160;on that group. See §9.9.5 for details.</a><br/>
As&#160;part&#160;of&#160;the&#160;sandbox&#160;it&#160;creates,&#160;safe&#160;level&#160;4&#160;prohibits&#160;additional&#160;operations&#160;including<br/>the following:<br/>
•&#160;require, unwrapped&#160;load,&#160;autoload, and&#160;include<br/>•&#160;Modifying&#160;Object&#160;class<br/>•&#160;Modifying untainted classes or modules<br/>•&#160;Metaprogramming methods<br/>•&#160;Manipulating threads other than current<br/>•&#160;Accessing thread local data<br/>•&#160;Terminating the process<br/>•&#160;File input/output<br/>•&#160;Modifying environment variables<br/>•&#160;Seeding the random number generator with&#160;srand<br/>
<b>10.5 &#160;Security&#160;|&#160;413</b><br/>
<hr/>
<a name=428></a><hr/>
<a name=429></a><b>Index</b><br/>
<b>Symbols</b><br/>
<a href="Rubys.html#413">$\ global variable, 399<br/></a><a href="Rubys.html#374">$_ global variable, 360, 399</a><br/>
<a href="Rubys.html#44">! operator, 30, 102, 107, 306</a><br/>
<a href="Rubys.html#414">$` global variable, 400</a><br/>
<a href="Rubys.html#69">!= operator, 55, 79, 106</a><br/>
<a href="Rubys.html#332">$~ global regexp variable, 318</a><br/>
<a href="Rubys.html#91">object equality and, 77</a><br/>
<a href="Rubys.html#330">$~ global variable, 316, 400</a><br/>
<a href="Rubys.html#116">!~ operator, 102, 106</a><br/>
% (percent sign)<br/>
<a href="Rubys.html#61">&#34; (quotation marks), 47</a><br/>
<a href="Rubys.html#58">modulo operator, using as, 44, 96, 102</a><br/>
<a href="Rubys.html#322">expressions, interpolating into strings, 308</a><br/>
<a href="Rubys.html#65">%Q sequence, using as, 51</a><br/>
# (hash)<br/>
<a href="Rubys.html#324">%r delimiter, 310</a><br/>
<a href="Rubys.html#16">comments and, 2, 26, 36</a><br/>
<a href="Rubys.html#67">%x syntax, 53</a><br/>
<a href="Rubys.html#62">string interpolation and, 48</a><br/>
<a href="Rubys.html#116">%= operator, 102</a><br/>
<a href="Rubys.html#325">#{ } interpolation in regexps, 311</a><br/>
<a href="Rubys.html#78">%q sequences, 64</a><br/>
<a href="Rubys.html#101">$ (dollar sign), 87</a><br/>
<a href="Rubys.html#78">%Q sequences, 64</a><br/>
global<br/>
&amp; (ampersand)<br/>
<a href="Rubys.html#44">variables and, 30</a><br/>
<a href="Rubys.html#205">method invocation and, 191</a><br/>
<a href="Rubys.html#45">keywords prefixes and, 31</a><br/>
<a href="Rubys.html#80">&amp; operator, 66, 102, 104</a><br/>
<a href="Rubys.html#329">regexp anchor, 315</a><br/>
<a href="Rubys.html#116">&amp;&amp; operator, 102, 107</a><br/>
<a href="Rubys.html#172">$! global variable, 158, 398</a><br/>
&#160;<br/>
<a href="Rubys.html#110">&amp;&amp;= operator, 96, 102</a><br/>
<a href="Rubys.html#412">$$ global variable, 398</a><br/>
<a href="Rubys.html#110">&amp;= operator, 96, 102</a><br/>
<a href="Rubys.html#414">$&amp; global variable, 400</a><br/>
<a href="Rubys.html#60">' (single quotes), using for string literals, 46</a><br/>
<a href="Rubys.html#414">$' global variable, 400</a><br/>
( ) (parentheses)<br/>
<a href="Rubys.html#411">$* global variable, 397</a><br/>
<a href="Rubys.html#17">functions/methods, using, 3</a><br/>
<a href="Rubys.html#414">$+ global variable, 400</a><br/>
<a href="Rubys.html#133">if statements and, 119</a><br/>
<a href="Rubys.html#414">$, global operator, 400</a><br/>
<a href="Rubys.html#47">method declarations, 33, 90, 183</a><br/>
<a href="Rubys.html#412">$-d global variable, 398</a><br/>
<a href="Rubys.html#197">optional, 183</a><br/>
<a href="Rubys.html#412">$-I global variable, 398</a><br/>
<a href="Rubys.html#113">parallel assignment and, 99</a><br/>
<a href="Rubys.html#412">$-K global variables, 398</a><br/>
<a href="Rubys.html#198">required, 184</a><br/>
<a href="Rubys.html#413">$. global variable, 399</a><br/>
<a href="Rubys.html#129">* (asterisk), 115</a><br/>
<a href="Rubys.html#413">$/ global variable, 399</a><br/>
<a href="Rubys.html#366">matching characters, 352</a><br/>
<a href="Rubys.html#267">$: global variable, 253, 398</a><br/>
<a href="Rubys.html#19">multiplication operator, 5, 44, 102</a><br/>
<a href="Rubys.html#414">$; global variable, 400</a><br/>
<a href="Rubys.html#318">repetition (strings), 304</a><br/>
<a href="Rubys.html#372">$&lt; global operator, 358, 399</a><br/>
variable-length method argument lists,<br/>
<a href="Rubys.html#413">$&gt; global operator, 399</a><br/>
<a href="Rubys.html#200">setting, 186</a><br/>
<a href="Rubys.html#412">$? global variable, 398</a><br/>
<a href="Rubys.html#58">** (exponentiation) operator, 44, 102, 103</a><br/>
<a href="Rubys.html#413">$@ global variable, 399</a><br/>
<a href="Rubys.html#110">**= operator, 96, 102</a><br/>
We’d like to hear your suggestions for improving our indexes. Send email to&#160;<i>index@oreilly.com</i>.<br/>
<b>415</b><br/>
<hr/>
<a name=430></a><a href="Rubys.html#110">*= operator, 96, 102</a><br/>
<a href="Rubys.html#194">method names and, 180</a><br/>
<a href="Rubys.html#19">+ (plus sign), 5, 44, 102</a><br/>
<a href="Rubys.html#20">nonoverridable operator, 6</a><br/>
<a href="Rubys.html#318">concatenation and, 304</a><br/>
<a href="Rubys.html#21">suffixes/prefixes punctuation, 7</a><br/>
<a href="Rubys.html#69">strings and, 55</a><br/>
<a href="Rubys.html#21">== operator, 7, 79, 102, 106</a><br/>
<a href="Rubys.html#117">unary, 103, 209</a><br/>
<a href="Rubys.html#90">object equality, testing, 76</a><br/>
<a href="Rubys.html#109">+= operator, 95, 102</a><br/>
<a href="Rubys.html#236">point equality and, 222</a><br/>
<a href="Rubys.html#117">+@ unary operator, 103</a><br/>
<a href="Rubys.html#211">proc equality and, 197</a><br/>
<a href="Rubys.html#129">, (comma), 115</a><br/>
<a href="Rubys.html#69">String class and, 55</a><br/>
<a href="Rubys.html#58">– (minus sign) operator, 44, 102</a><br/>
=== (see case equality operator)<br/>
<a href="Rubys.html#117">unary, 103</a><br/>
<a href="Rubys.html#81">=&gt; (arrow), 67, 115</a><br/>
<a href="Rubys.html#406">--debug command-line option, 392</a><br/>
<a href="Rubys.html#16">comments, using for, 2</a><br/>
<a href="Rubys.html#110">–= operator, 96</a><br/>
<a href="Rubys.html#40">=begin (multiline comments), 26</a><br/>
<a href="Rubys.html#116">–= operator, 102</a><br/>
<a href="Rubys.html#40">=end (multiline comments), 26</a><br/>
<a href="Rubys.html#208">-&gt; (arrow) characters, 194</a><br/>
<a href="Rubys.html#92">=~ operator, 78, 102, 106</a><br/>
<a href="Rubys.html#117">–@ unary operator, 103</a><br/>
<a href="Rubys.html#329">pattern matching and, 315–321</a><br/>
<a href="Rubys.html#101">. (dot), 87, 115</a><br/>
<a href="Rubys.html#69">&gt; (greater than) operator, 55, 79, 102</a><br/>
<a href="Rubys.html#367">directories, 353</a><br/>
&gt;=&#160;(greater&#160;than&#160;or&#160;equal)&#160;<a href="Rubys.html#69">operator,&#160;55,&#160;</a><a href="Rubys.html#93">79,&#160;</a><a href="Rubys.html#116">102,</a><br/>
matching characters and newlines (regular<br/>
<a href="Rubys.html#119">105</a><br/>
<a href="Rubys.html#328">expressions), 314</a><br/>
<a href="Rubys.html#116">&gt;&gt; operator, 102</a><br/>
<a href="Rubys.html#103">method declarations, 89</a><br/>
<a href="Rubys.html#110">&gt;&gt;= operator, 96, 102</a><br/>
<a href="Rubys.html#104">method invocations and, 90</a><br/>
<a href="Rubys.html#44">? (question mark), 30</a><br/>
<a href="Rubys.html#82">.. operator, 68, 102, 109–111</a><br/>
<a href="Rubys.html#366">matching characters with, 352</a><br/>
<a href="Rubys.html#116">... operator, 102, 109–111</a><br/>
<a href="Rubys.html#194">method names and, 180</a><br/>
/ (forward slash)<br/>
<a href="Rubys.html#116">?: operator, 102, 111, 127</a><br/>
<a href="Rubys.html#365">directory separator character, 351</a><br/>
<a href="Rubys.html#101">@ (at sign), 87</a><br/>
<a href="Rubys.html#58">division operator, 44</a><br/>
<a href="Rubys.html#244">class variables and, 230</a><br/>
Windows directory separator character,<br/>
<a href="Rubys.html#22">instance variables and, 8, 30</a><br/>
<a href="Rubys.html#365">351</a><br/>
<a href="Rubys.html#45">keywords prefixes and, 31</a><br/>
<a href="Rubys.html#40">/* ... */ (C-style) comments, 26</a><br/>
<a href="Rubys.html#244">@@ (class variables), 230</a><br/>
<a href="Rubys.html#110">/= operator, 96, 102</a><br/>
<a href="Rubys.html#19">[ ] (square-bracket array-index), 5, 56, 60, 64,</a><br/>
<a href="Rubys.html#129">: (colon), 115</a><br/>
<a href="Rubys.html#129">115</a><br/>
<a href="Rubys.html#101">:: (double colon), 87, 89, 115</a><br/>
<a href="Rubys.html#235">access to arrays/hashes, 221</a><br/>
<a href="Rubys.html#46">; (semicolons), as statement terminators, 32,</a><br/>
<a href="Rubys.html#318">strings, indexing, 304</a><br/>
<a href="Rubys.html#129">115</a><br/>
<a href="Rubys.html#19">[ ]= operator, 5, 10, 95</a><br/>
<a href="Rubys.html#69">&lt; (less than) operator, 55, 79, 102, 105</a><br/>
<a href="Rubys.html#356">storing key/values in hashes, 342</a><br/>
<a href="Rubys.html#19">&lt;&lt; operator, 5, 10, 102</a><br/>
\ (backslash)<br/>
<a href="Rubys.html#318">appending text, 304</a><br/>
<a href="Rubys.html#61">apostrophes, using inside string literals, 47</a><br/>
<a href="Rubys.html#362">set elements and, 348</a><br/>
<a href="Rubys.html#62">escapes, 48</a><br/>
<a href="Rubys.html#69">string operators and, 55</a><br/>
<a href="Rubys.html#46">line breaks, escaping, 32</a><br/>
<a href="Rubys.html#110">&lt;&lt;= operator, 96, 102</a><br/>
\ (slash)<br/>
<a href="Rubys.html#69">&lt;= (less than or equal) operator, 55, 79, 102,</a><br/>
<a href="Rubys.html#324">regular expressions and, 310</a><br/>
<a href="Rubys.html#119">105</a><br/>
<a href="Rubys.html#61">\&#34; (nonterminating quotation mark), 47</a><br/>
<a href="Rubys.html#83">&lt;=&gt; operator, 69, 102, 105, 225</a><br/>
<a href="Rubys.html#116">^ operator, 102, 104</a><br/>
<a href="Rubys.html#92">object order and, 78</a><br/>
<a href="Rubys.html#329">regexp anchor, 315</a><br/>
<a href="Rubys.html#361">SortedSet class and, 347</a><br/>
<a href="Rubys.html#110">^= operator, 96, 102</a><br/>
<a href="Rubys.html#84">testing membership in ranges, 70</a><br/>
_ (underscore)<br/>
<a href="Rubys.html#20">= (equals sign), 6, 30, 102</a><br/>
<a href="Rubys.html#102">constants, 88</a><br/>
embedded documents, writing comments<br/>
<a href="Rubys.html#57">integer literals, using, 43</a><br/>
<a href="Rubys.html#41">and, 27</a><br/>
<a href="Rubys.html#67">` (backtick) method (Kernel), 53</a><br/>
<b>416&#160;|&#160;Index</b><br/>
<hr/>
<a name=431></a><a href="Rubys.html#129">{ } (curly braces), 115</a><br/>
<a href="Rubys.html#157">passing to blocks, 143</a><br/>
<a href="Rubys.html#49">block structure and, 35</a><br/>
<a href="Rubys.html#214">procs/lambdas, passing to, 200</a><br/>
<a href="Rubys.html#17">iterators in blocks, using, 3</a><br/>
<a href="Rubys.html#410">ARGV stream, 396</a><br/>
<a href="Rubys.html#62">string interpolation and, 48</a><br/>
<a href="Rubys.html#58">arithmetic, 44</a><br/>
<a href="Rubys.html#155">syntax of blocks, 141</a><br/>
<a href="Rubys.html#95">coerce method and, 81</a><br/>
<a href="Rubys.html#64">Unicode escapes and, 50</a><br/>
<a href="Rubys.html#117">operations, 103</a><br/>
<a href="Rubys.html#80">| (Boolean) operator, 66, 102</a><br/>
<a href="Rubys.html#210">arity (proc/lambda), 196</a><br/>
<a href="Rubys.html#118">| operator, 104</a><br/>
Array class<br/>
<a href="Rubys.html#110">|= operator, 96, 102</a><br/>
<a href="Rubys.html#21">suffixes/prefixes punctuation, 7</a><br/>
<a href="Rubys.html#116">|| operator, 102, 107</a><br/>
<a href="Rubys.html#19">[ ] operator, 5</a><br/>
<a href="Rubys.html#110">||= operator, 96, 102</a><br/>
Array functions<br/>
<a href="Rubys.html#116">~ (tilde), 102, 104</a><br/>
<a href="Rubys.html#95">conversion functions and, 81</a><br/>
<a href="Rubys.html#349">Array.new method, 335</a><br/>
<b>A</b><br/>
<a href="Rubys.html#349">Array.[] method, 335<br/></a><a href="Rubys.html#17">arrays, 3, 64–67, 334–341</a><br/>
<a href="Rubys.html#371">&#34;a&#34; (append) file mode, 357</a><br/>
<a href="Rubys.html#235">access with [ ], 221</a><br/>
<a href="Rubys.html#407">-a command-line option, 393</a><br/>
<a href="Rubys.html#354">associative, 340</a><br/>
<a href="Rubys.html#63">\a escape (BEL character), 49</a><br/>
<a href="Rubys.html#352">comparison, 338</a><br/>
<a href="Rubys.html#329">\A regexp anchor, 315</a><br/>
<a href="Rubys.html#349">creating, 335</a><br/>
<a href="Rubys.html#371">&#34;a+&#34; (append and reading) file mode, 357</a><br/>
<a href="Rubys.html#349">elements, 335</a><br/>
<a href="Rubys.html#106">abbreviated assignments, 92, 95</a><br/>
<a href="Rubys.html#350">altering, 336</a><br/>
<a href="Rubys.html#393">aborting thread state, 379</a><br/>
<a href="Rubys.html#108">assigning to, 94</a><br/>
<a href="Rubys.html#231">accessors, 217–219</a><br/>
<a href="Rubys.html#357">hashes, extracting from, 343</a><br/>
<a href="Rubys.html#302">define_method and, 288</a><br/>
<a href="Rubys.html#351">iterating, 337</a><br/>
<a href="Rubys.html#17">methods, 3</a><br/>
<a href="Rubys.html#201">methods, passing to, 187</a><br/>
<a href="Rubys.html#363">add method (Set), 349</a><br/>
<a href="Rubys.html#351">searching, 337</a><br/>
<a href="Rubys.html#363">add? method (Set), 349</a><br/>
<a href="Rubys.html#351">sorting, 337</a><br/>
<a href="Rubys.html#304">alias chaining, 290–296</a><br/>
<a href="Rubys.html#353">stacks and queues, 339</a><br/>
<a href="Rubys.html#195">alias keyword, 181</a><br/>
<a href="Rubys.html#200">variable-length method arguments, 186</a><br/>
<a href="Rubys.html#195">aliases (method), 181</a><br/>
<a href="Rubys.html#129">arrows (=&gt;), 115</a><br/>
<a href="Rubys.html#289">alias_method method (Module), 275</a><br/>
<a href="Rubys.html#16">comments, using for, 2</a><br/>
<a href="Rubys.html#347">all? method (Enumerable), 333</a><br/>
ASCII<br/>
<a href="Rubys.html#256">allocate keyword, 242</a><br/>
<a href="Rubys.html#63">\a escape, 49</a><br/>
ampersand (&amp;)<br/>
<a href="Rubys.html#50">default source encoding, 36</a><br/>
<a href="Rubys.html#205">method invocation and, 191</a><br/>
<a href="Rubys.html#20">assignments, 6, 92–100</a><br/>
(see also &amp;)<br/>
<a href="Rubys.html#109">abbreviated, 95</a><br/>
<a href="Rubys.html#249">ancestry, 235, 267</a><br/>
<a href="Rubys.html#126">operators, 112</a><br/>
<a href="Rubys.html#116">AND (&amp;) operator, 102</a><br/>
<a href="Rubys.html#111">parallel, 97</a><br/>
<a href="Rubys.html#117">and keyword, 103, 107</a><br/>
<a href="Rubys.html#354">assoc method (Array), 340</a><br/>
<a href="Rubys.html#347">any? method (Enumerable), 333</a><br/>
<a href="Rubys.html#81">associative arrays, 67, 340</a><br/>
<a href="Rubys.html#61">apostrophes ('), using inside string literals, 47</a><br/>
<a href="Rubys.html#129">asterisk (*), 115</a><br/>
append operator (see &gt;&gt;)<br/>
<a href="Rubys.html#366">matching characters (Dir class), 352</a><br/>
<a href="Rubys.html#64">arbitrary delimiters for string literals, 50</a><br/>
<a href="Rubys.html#19">multiplication operator, 5, 44</a><br/>
<a href="Rubys.html#372">ARGF stream, 358, 360, 396</a><br/>
<a href="Rubys.html#318">repetition (strings), 304</a><br/>
<a href="Rubys.html#173">ArgumentError, 159</a><br/>
variable-length method argument lists,<br/>
arguments<br/>
<a href="Rubys.html#200">setting, 186</a><br/>
<a href="Rubys.html#200">arbitrary number, setting, 186</a><br/>
<a href="Rubys.html#101">at sign (@), 87</a><br/>
<a href="Rubys.html#203">block, 189–192</a><br/>
<a href="Rubys.html#244">class variables and, 230</a><br/>
<a href="Rubys.html#199">method, 185–192</a><br/>
<a href="Rubys.html#22">instance variables and, 8, 30</a><br/>
<a href="Rubys.html#202">parameters, mapping to, 188</a><br/>
<b>Index&#160;|&#160;417</b><br/>
<hr/>
<a name=432></a><a href="Rubys.html#45">keywords prefixes and, 31</a><br/>
<a href="Rubys.html#123">Boolean flip-flops, 109</a><br/>
<a href="Rubys.html#233">attr method (Module), 219</a><br/>
<a href="Rubys.html#80">Boolean operators, 66, 82</a><br/>
<a href="Rubys.html#108">attributes, 94, 214, 217</a><br/>
<a href="Rubys.html#46">break statement, 32, 142, 146, 148</a><br/>
(see also accessors)<br/>
<a href="Rubys.html#164">next keyword and, 150</a><br/>
<a href="Rubys.html#302">define_method and, 288</a><br/>
<a href="Rubys.html#213">procs/lambdas/blocks and, 199</a><br/>
methods<br/>
<a href="Rubys.html#167">throw and catch methods, 153</a><br/>
<a href="Rubys.html#289">accessor, defining, 275</a><br/>
<a href="Rubys.html#73">bytesize method (String), 59</a><br/>
<a href="Rubys.html#232">attr_accessor method (Module), 218</a><br/>
<a href="Rubys.html#289">define_method and, 275</a><br/>
<b>C</b><br/>
<a href="Rubys.html#232">attr_reader method (Module), 218</a><br/>
<a href="Rubys.html#289">define_method and, 275</a><br/>
<a href="Rubys.html#408">-c command-line option, 394</a><br/>
<a href="Rubys.html#180">at_exit method (Kernel), 166</a><br/>
<a href="Rubys.html#408">-C command-line option, 394</a><br/>
<a href="Rubys.html#271">autoload? function, 257</a><br/>
<a href="Rubys.html#40">C-style (/* ... */) comments, 26<br/></a><a href="Rubys.html#186">call method (Continuation), 172</a><br/>
<b>B</b><br/>
<a href="Rubys.html#288">call method (Method), 274<br/></a><a href="Rubys.html#204">call method (Proc), 190</a><br/>
<a href="Rubys.html#63">\b (backspace character) escape, 49</a><br/>
<a href="Rubys.html#293">caller method (Kernel), 279</a><br/>
<a href="Rubys.html#329">\B (nonword boundary) regexp anchor, 315</a><br/>
<a href="Rubys.html#26">Cardinal, 12</a><br/>
<a href="Rubys.html#329">\b (word boundary) regexp anchor, 315</a><br/>
<a href="Rubys.html#63">carriage return (\r) escape, 49</a><br/>
backslash (\)<br/>
<a href="Rubys.html#21">case equality (===) operator, 7, 75, 102, 106</a><br/>
<a href="Rubys.html#61">apostrophes, using inside string literals, 47</a><br/>
<a href="Rubys.html#139">case keyword and, 125</a><br/>
<a href="Rubys.html#62">escapes, 48</a><br/>
<a href="Rubys.html#43">case sensitivity, 29</a><br/>
<a href="Rubys.html#46">line breaks, escaping, 32</a><br/>
<a href="Rubys.html#69">string comparison and, 55</a><br/>
<a href="Rubys.html#63">backspace character (\b) escape, 49</a><br/>
<a href="Rubys.html#137">case statement, 123</a><br/>
<a href="Rubys.html#67">backtick (`) method (Kernel), 53</a><br/>
<a href="Rubys.html#69">casecmp method (String), 55</a><br/>
<a href="Rubys.html#293">backtraces, 279</a><br/>
<a href="Rubys.html#160">catch statement, 146, 153</a><br/>
<a href="Rubys.html#249">BasicObject class, 235</a><br/>
<a href="Rubys.html#252">chaining methods, 238</a><br/>
<a href="Rubys.html#179">BEGIN keyword, 165</a><br/>
characters<br/>
<a href="Rubys.html#53">program execution and, 39</a><br/>
<a href="Rubys.html#70">accessing, 56–58</a><br/>
<a href="Rubys.html#57">BigDecimal class, 43, 323</a><br/>
<a href="Rubys.html#68">literals, 54</a><br/>
<a href="Rubys.html#19">Bignum class, 5, 42</a><br/>
<a href="Rubys.html#72">multibyte, 58–64</a><br/>
<a href="Rubys.html#58">arithmetic and, 44</a><br/>
<a href="Rubys.html#232">Class class (Module), 218</a><br/>
<a href="Rubys.html#59">bit-manipulation operators and, 45</a><br/>
<a href="Rubys.html#249">class hierarchy, 235</a><br/>
<a href="Rubys.html#74">BINARY encodings, 60</a><br/>
class keyword<br/>
<a href="Rubys.html#59">binary floating-point, 45</a><br/>
<a href="Rubys.html#229">creating classes, 215</a><br/>
<a href="Rubys.html#323">binary strings, 309</a><br/>
<a href="Rubys.html#280">class method (Object), 266</a><br/>
<a href="Rubys.html#216">binding method (Proc), 202</a><br/>
<a href="Rubys.html#242">class methods, 228</a><br/>
<a href="Rubys.html#283">Binding object, 269</a><br/>
<a href="Rubys.html#253">inheritance of, 239</a><br/>
<a href="Rubys.html#219">binding UnboundMethod objects, 205</a><br/>
<a href="Rubys.html#273">lookup, 259</a><br/>
<a href="Rubys.html#374">binmode method (IO), 360</a><br/>
<a href="Rubys.html#256">Class#new method, 242</a><br/>
<a href="Rubys.html#59">bit-manipulation operators, 45</a><br/>
<a href="Rubys.html#256">Class::new method, 242</a><br/>
<a href="Rubys.html#17">blocks, 3–4, 140, 176</a><br/>
<a href="Rubys.html#16">classes, 2, 8–10, 395</a><br/>
<a href="Rubys.html#203">arguments, 189–192</a><br/>
<a href="Rubys.html#49">block structure and, 35</a><br/>
<a href="Rubys.html#157">passing to, 143–146</a><br/>
<a href="Rubys.html#228">defining, 214–232, 268</a><br/>
<a href="Rubys.html#282">evaluating, 268–271</a><br/>
<a href="Rubys.html#170">exceptions, defining, 156</a><br/>
<a href="Rubys.html#49">structure, 35</a><br/>
<a href="Rubys.html#42">identifiers and, 28</a><br/>
<a href="Rubys.html#155">syntax, 141</a><br/>
<a href="Rubys.html#245">instance variables, 231</a><br/>
<a href="Rubys.html#297">thread safety and, 283</a><br/>
<a href="Rubys.html#101">variables, 87, 230</a><br/>
<a href="Rubys.html#155">values of, 141</a><br/>
<a href="Rubys.html#364">classify method (Set), 350</a><br/>
<a href="Rubys.html#156">variable scope, 142</a><br/>
<a href="Rubys.html#284">class_eval method (Module), 270, 279, 288</a><br/>
<b>418&#160;|&#160;Index</b><br/>
<hr/>
<a name=433></a><a href="Rubys.html#284">class_exec method (Module), 270</a><br/>
<a href="Rubys.html#17">iterators in blocks, using, 3</a><br/>
<a href="Rubys.html#257">clone method (Object), 243–245</a><br/>
<a href="Rubys.html#62">string interpolation and, 48</a><br/>
<a href="Rubys.html#379">close method (IO), 365</a><br/>
<a href="Rubys.html#155">syntax of blocks, 141</a><br/>
<a href="Rubys.html#214">closures, 200–203</a><br/>
<a href="Rubys.html#64">Unicode escapes and, 50</a><br/>
<a href="Rubys.html#216">bindings and, 202</a><br/>
<a href="Rubys.html#210">curry method (Proc), 196</a><br/>
<a href="Rubys.html#50">coding comments, 36</a><br/>
<a href="Rubys.html#210">currying, procs and lambdas, 196</a><br/>
<a href="Rubys.html#95">coerce method (Numeric), 81<br/></a><a href="Rubys.html#146">collect method (Enumerable), 132, 329</a><br/>
<b>D</b><br/>
<a href="Rubys.html#143">collections, 129, 328–350</a><br/>
<a href="Rubys.html#342">iterating/converting and, 328</a><br/>
<a href="Rubys.html#328">\d (digits) regexp character class, 314</a><br/>
<a href="Rubys.html#345">searching, 331</a><br/>
<a href="Rubys.html#328">\D (nondigits) regexp character class, 314</a><br/>
<a href="Rubys.html#344">sorting, 330</a><br/>
<a href="Rubys.html#406">-d command-line option, 392</a><br/>
<a href="Rubys.html#129">colon (:), 115</a><br/>
<a href="Rubys.html#50">DATA stream, 36, 360, 396</a><br/>
<a href="Rubys.html#129">comma (,), 115</a><br/>
<a href="Rubys.html#56">datatypes, 42–84</a><br/>
<a href="Rubys.html#404">command-line options, 390</a><br/>
<a href="Rubys.html#78">arrays, 64–67</a><br/>
<a href="Rubys.html#27">command-line tools, 13</a><br/>
<a href="Rubys.html#68">character literals, 54</a><br/>
<a href="Rubys.html#16">comments, 2, 36, 59</a><br/>
<a href="Rubys.html#81">hashes, 67–68</a><br/>
<a href="Rubys.html#40">lexical structure and, 26</a><br/>
<a href="Rubys.html#56">numbers, 42–46</a><br/>
<a href="Rubys.html#119">Comparable module, 105, 250</a><br/>
<a href="Rubys.html#68">string operators, 54</a><br/>
<a href="Rubys.html#69">comparison operators, 55, 105</a><br/>
<a href="Rubys.html#60">text and, 46–64</a><br/>
<a href="Rubys.html#53">compiled languages, 39</a><br/>
<a href="Rubys.html#339">dates and times, 325</a><br/>
<a href="Rubys.html#57">Complex class, 43, 323</a><br/>
<a href="Rubys.html#339">DateTime class, 325</a><br/>
<a href="Rubys.html#387">compute-bound programs, 373</a><br/>
<a href="Rubys.html#398">deadlocks, 384</a><br/>
<a href="Rubys.html#387">concurrency, 373–387</a><br/>
<a href="Rubys.html#412">$DEBUG variable, 398</a><br/>
<a href="Rubys.html#396">iterators, 382</a><br/>
decimal point (.), using floating-point literals<br/>
<a href="Rubys.html#154">modification, 140</a><br/>
<a href="Rubys.html#57">and, 43</a><br/>
<a href="Rubys.html#388">platform dependencies and, 374</a><br/>
<a href="Rubys.html#19">def keyword, 5</a><br/>
<a href="Rubys.html#388">thread lifecycle and, 374</a><br/>
<a href="Rubys.html#191">methods, defining, 177</a><br/>
<a href="Rubys.html#180">threads for, 166</a><br/>
<a href="Rubys.html#52">default external encoding, 38</a><br/>
<a href="Rubys.html#125">conditional (?:) operator, 111</a><br/>
<a href="Rubys.html#52">default internal encoding, 38</a><br/>
<a href="Rubys.html#132">conditionals, 118–127</a><br/>
<a href="Rubys.html#199">default parameters of methods, 185</a><br/>
<a href="Rubys.html#137">case statements, 123</a><br/>
<a href="Rubys.html#117">defined? keyword, 103, 113</a><br/>
<a href="Rubys.html#132">if statements, 118–121</a><br/>
<a href="Rubys.html#295">define_finalizer method (ObjectSpace), 281</a><br/>
<a href="Rubys.html#102">constants, 88, 229, 271–272</a><br/>
<a href="Rubys.html#288">define_method method (Module), 274, 288</a><br/>
<a href="Rubys.html#108">assigning, 94</a><br/>
<a href="Rubys.html#357">delete method (Hash), 343</a><br/>
<a href="Rubys.html#255">inheritance of, 241</a><br/>
<a href="Rubys.html#363">delete method (Set), 349</a><br/>
<a href="Rubys.html#298">missing, 284</a><br/>
<a href="Rubys.html#363">delete? method (Set), 349</a><br/>
<a href="Rubys.html#229">constructors, 215</a><br/>
<a href="Rubys.html#357">delete_if method (Hash), 343</a><br/>
<a href="Rubys.html#298">const_missing method, 284</a><br/>
<a href="Rubys.html#363">delete_if method (Set), 349</a><br/>
<a href="Rubys.html#163">continue keyword, 149</a><br/>
<a href="Rubys.html#64">delimiters (arbitrary), 50</a><br/>
<a href="Rubys.html#83">continuous ranges, 69</a><br/>
<a href="Rubys.html#418">deprecated extraction functions, 404</a><br/>
<a href="Rubys.html#160">control flow, 146–154</a><br/>
<a href="Rubys.html#249">descendants of classes, 235</a><br/>
<a href="Rubys.html#18">control structures, 4, 118–172</a><br/>
<a href="Rubys.html#364">Dir class, 350</a><br/>
<a href="Rubys.html#295">custom, 281–284</a><br/>
<a href="Rubys.html#367">chdir method, 353</a><br/>
<a href="Rubys.html#93">conversions (object), 79–82</a><br/>
<a href="Rubys.html#366">entries method, 352</a><br/>
<a href="Rubys.html#181">coroutines, 167</a><br/>
<a href="Rubys.html#366">foreach method, 352</a><br/>
<a href="Rubys.html#84">cover? method (Range), 70</a><br/>
<a href="Rubys.html#367">glob method, 353</a><br/>
<a href="Rubys.html#129">curly braces ({ }), 115</a><br/>
<a href="Rubys.html#370">mkdir method, 356</a><br/>
<a href="Rubys.html#49">block structure and, 35</a><br/>
<a href="Rubys.html#370">rmdir method, 356<br/>unlink method, 356</a><br/>
<b>Index&#160;|&#160;419</b><br/>
<hr/>
<a name=434></a><a href="Rubys.html#367">Dir.glob method, 353</a><br/>
<a href="Rubys.html#320">each_line method (String), 306</a><br/>
<a href="Rubys.html#364">directories, 350–356</a><br/>
<a href="Rubys.html#358">each_pair method (Hash), 344</a><br/>
<a href="Rubys.html#369">creating, deleting, and renaming, 355</a><br/>
<a href="Rubys.html#343">each_slice method (Enumerable), 329</a><br/>
<a href="Rubys.html#366">listing, 352</a><br/>
<a href="Rubys.html#342">each_with_index method (Enumerable), 328</a><br/>
<a href="Rubys.html#365">separator character (/), 351</a><br/>
<a href="Rubys.html#226">eigenclass, 212, 246, 257–258</a><br/>
<a href="Rubys.html#404">--disable-rubyopt command-line option, 390</a><br/>
<a href="Rubys.html#274">class method lookup, 260</a><br/>
discrete<br/>
<a href="Rubys.html#272">method lookup and, 258</a><br/>
<a href="Rubys.html#84">membership, 70</a><br/>
<a href="Rubys.html#133">else keyword, 119, 124, 162, 178</a><br/>
<a href="Rubys.html#83">ranges, 69</a><br/>
<a href="Rubys.html#134">elsif keyword, 120</a><br/>
<a href="Rubys.html#364">divide method (Set), 350</a><br/>
<a href="Rubys.html#40">embedded documents, 26</a><br/>
<a href="Rubys.html#58">division, 44</a><br/>
<a href="Rubys.html#21">empty? method (Array/Hash), 7</a><br/>
<a href="Rubys.html#58">divmod method (Numeric), 44</a><br/>
<a href="Rubys.html#230">encapsulation, 216</a><br/>
<a href="Rubys.html#267">.dll files, loading extensions, 253</a><br/>
<a href="Rubys.html#75">encode! method (String), 61</a><br/>
<a href="Rubys.html#49">do keyword, 35, 141</a><br/>
<a href="Rubys.html#74">Encoding class, 60, 62</a><br/>
<a href="Rubys.html#141">while loops and, 127</a><br/>
<a href="Rubys.html#406">--encoding command-line option, 392</a><br/>
<a href="Rubys.html#41">documentation comments, 27</a><br/>
<a href="Rubys.html#52">__ENCODING__ keyword, 38</a><br/>
<a href="Rubys.html#101">dollar sign ($), 87</a><br/>
<a href="Rubys.html#334">encoding method (Regexp), 320</a><br/>
global<br/>
<a href="Rubys.html#74">encoding method (String), 60</a><br/>
<a href="Rubys.html#44">variables and, 30</a><br/>
<a href="Rubys.html#52">encoding options, 38, 392</a><br/>
<a href="Rubys.html#45">keywords prefixes and, 31</a><br/>
<a href="Rubys.html#77">Encoding.aliases method, 63</a><br/>
<a href="Rubys.html#280">domain-specific languages (DSLs), 266, 296–</a><br/>
<a href="Rubys.html#74">Encoding.compatible? method, 60</a><br/>
<a href="Rubys.html#313">299</a><br/>
<a href="Rubys.html#53">Encoding.default_external method, 39, 63</a><br/>
<a href="Rubys.html#101">dot (.), 87, 115</a><br/>
<a href="Rubys.html#77">Encoding.default_internal method, 63</a><br/>
<a href="Rubys.html#367">directories and, 353</a><br/>
<a href="Rubys.html#77">Encoding.find method, 63</a><br/>
matching characters and newlines (regular<br/>
<a href="Rubys.html#53">Encoding.locale_charmap method, 39, 63</a><br/>
<a href="Rubys.html#328">expressions), 314</a><br/>
<a href="Rubys.html#77">Encoding.name_list method, 63</a><br/>
<a href="Rubys.html#103">method declarations, 89</a><br/>
<a href="Rubys.html#43">END keyword, 29, 165</a><br/>
<a href="Rubys.html#104">method invocations and, 90</a><br/>
<a href="Rubys.html#49">end keyword, 35</a><br/>
<a href="Rubys.html#101">double colon (::), 87, 89, 115</a><br/>
<a href="Rubys.html#133">if statement and, 119</a><br/>
<a href="Rubys.html#61">double-quoted string literals, 47</a><br/>
<a href="Rubys.html#50">__END__ token, 36, 358</a><br/>
<a href="Rubys.html#146">downto method (Integer), 132</a><br/>
<a href="Rubys.html#374">end-of-file (EOF), 360, 362</a><br/>
<a href="Rubys.html#346">drop method (Enumerable), 332</a><br/>
<a href="Rubys.html#176">ensure keyword, 162–164, 178</a><br/>
<a href="Rubys.html#346">drop_while method (Enumerable), 332</a><br/>
Enumerable&#160;<a href="Rubys.html#17">module,&#160;3,&#160;</a><a href="Rubys.html#72">58,&#160;</a><a href="Rubys.html#144">130–140,&#160;</a><a href="Rubys.html#146">132,&#160;</a><a href="Rubys.html#264">250,</a><br/>
<a href="Rubys.html#280">DSLs (domain-specific languages), 266, 296–</a><br/>
<a href="Rubys.html#342">328–334</a><br/>
<a href="Rubys.html#313">299</a><br/>
<a href="Rubys.html#219">functions, applying functions to, 205</a><br/>
<a href="Rubys.html#90">duck typing, 76, 220, 223</a><br/>
<a href="Rubys.html#201">max method and, 187</a><br/>
<a href="Rubys.html#257">dup method (Object), 243–245</a><br/>
<a href="Rubys.html#321">String class and, 307</a><br/>
<a href="Rubys.html#344">Enumerable::Enumerator class, 330</a><br/>
<b>E</b><br/>
<a href="Rubys.html#149">enumerators, 135<br/></a><a href="Rubys.html#410">ENV stream, 396</a><br/>
<a href="Rubys.html#63">\e (ESC) escape, 49</a><br/>
<a href="Rubys.html#404">environment, 390–413</a><br/>
<a href="Rubys.html#324">e (regular expression) modifier, 310</a><br/>
<a href="Rubys.html#374">EOF (end-of-file), 360, 362</a><br/>
<a href="Rubys.html#25">-e command-line option, 11, 391</a><br/>
<a href="Rubys.html#374">eof? method (IO), 360</a><br/>
<a href="Rubys.html#406">-E command-line option, 392</a><br/>
<a href="Rubys.html#249">EOFError, 235</a><br/>
<a href="Rubys.html#52">-E option, 38</a><br/>
<a href="Rubys.html#82">eql? method (Object), 68, 77, 224</a><br/>
<a href="Rubys.html#144">each method (Enumerable), 130</a><br/>
<a href="Rubys.html#90">equal? method (Object), 76</a><br/>
<a href="Rubys.html#72">each method (String), 58</a><br/>
<a href="Rubys.html#82">equality, 68</a><br/>
<a href="Rubys.html#320">each_byte method (String), 306</a><br/>
<a href="Rubys.html#20">equals sign (=), 6, 30, 102</a><br/>
<a href="Rubys.html#321">each_char method (String), 307<br/></a><a href="Rubys.html#343">each_cons method (Enumerable), 329</a><br/>
<b>420&#160;|&#160;Index</b><br/>
<hr/>
<a name=435></a>embedded documents, writing comments<br/>
<a href="Rubys.html#366">fnmatch method, 352</a><br/>
<a href="Rubys.html#41">and, 27</a><br/>
<a href="Rubys.html#366">identical? method, 352</a><br/>
<a href="Rubys.html#194">method names and, 180</a><br/>
<a href="Rubys.html#369">link method, 355</a><br/>
<a href="Rubys.html#21">suffixes/prefixes punctuation, 7</a><br/>
<a href="Rubys.html#370">open method, 356</a><br/>
<a href="Rubys.html#173">$ERROR_INFO global variable, 159</a><br/>
<a href="Rubys.html#376">read method, 362</a><br/>
<a href="Rubys.html#63">ESC (\e) escape, 49</a><br/>
<a href="Rubys.html#376">readlines method, 362</a><br/>
<a href="Rubys.html#62">escapes, 48</a><br/>
<a href="Rubys.html#369">rename method, 355</a><br/>
<a href="Rubys.html#61">double-quoted string literals and, 47</a><br/>
<a href="Rubys.html#369">symlink method, 355</a><br/>
<a href="Rubys.html#64">Unicode, 50</a><br/>
<a href="Rubys.html#101">__FILE__ keyword, 87</a><br/>
<a href="Rubys.html#43">EUC characters, 29</a><br/>
<a href="Rubys.html#293">tracing and, 279</a><br/>
<a href="Rubys.html#51">EUC-JP, 37</a><br/>
<a href="Rubys.html#49">file structure, 35</a><br/>
<a href="Rubys.html#216">eval method (Binding), 202, 269</a><br/>
<a href="Rubys.html#369">File.chmod method, 355</a><br/>
<a href="Rubys.html#282">eval method (Kernel), 268, 269, 279</a><br/>
<a href="Rubys.html#365">File.expand_path method, 351</a><br/>
<a href="Rubys.html#94">Exception objects, 80</a><br/>
<a href="Rubys.html#366">File.fnmatch method, 352</a><br/>
<a href="Rubys.html#168">exceptions, 154–165</a><br/>
<a href="Rubys.html#366">File.identical? method, 352</a><br/>
<a href="Rubys.html#169">classes and objects, 155</a><br/>
<a href="Rubys.html#369">File.truncate method, 355</a><br/>
<a href="Rubys.html#175">exceptions during handling, 161</a><br/>
<a href="Rubys.html#369">File.unlink method, 355</a><br/>
<a href="Rubys.html#192">methods, handling, 178</a><br/>
<a href="Rubys.html#369">File.utime method, 355</a><br/>
<a href="Rubys.html#172">rescue clause and, 158–162</a><br/>
<a href="Rubys.html#365">File::ALT_SEPARATOR method, 351</a><br/>
<a href="Rubys.html#44">exclamation point (!), 30</a><br/>
<a href="Rubys.html#366">File::FNM_PATHNAME method, 352</a><br/>
(see also !)<br/>
<a href="Rubys.html#367">File::Stat method, 353</a><br/>
<a href="Rubys.html#194">method names and, 180</a><br/>
<a href="Rubys.html#413">$FILENAME global variable, 399</a><br/>
<a href="Rubys.html#397">exclusion (thread), 383</a><br/>
<a href="Rubys.html#364">files, 350–356</a><br/>
<a href="Rubys.html#82">exclusive (ranges), 68</a><br/>
<a href="Rubys.html#376">bytes and characters, reading, 362</a><br/>
<a href="Rubys.html#40">execution of programs, 26–40</a><br/>
<a href="Rubys.html#369">creating, deleting, and renaming, 355</a><br/>
<a href="Rubys.html#93">explicit conversions, 79</a><br/>
<a href="Rubys.html#370">opening, 356</a><br/>
<a href="Rubys.html#58">exponentiation (**) operator, 44, 102, 103</a><br/>
<a href="Rubys.html#375">reading entire, 361</a><br/>
<a href="Rubys.html#18">expressions, 4, 86–115</a><br/>
<a href="Rubys.html#373">specifying encodings, 359</a><br/>
<a href="Rubys.html#151">external iterators, 137–140, 330</a><br/>
<a href="Rubys.html#367">testing, 353</a><br/>
<a href="Rubys.html#373">external_encoding method (IO), 359</a><br/>
<a href="Rubys.html#365">Windows, 351</a><br/>
&#160;<br/>
<a href="Rubys.html#345">find method (Enumerable), 331</a><br/>
<b>F</b><br/>
<a href="Rubys.html#345">find_index method (Enumerable), 331<br/></a><a href="Rubys.html#346">first method (Enumerable), 332</a><br/>
<a href="Rubys.html#63">\f (form feed character) escape, 49</a><br/>
<a href="Rubys.html#335">fixed_encoding? method (Regexp), 321</a><br/>
<a href="Rubys.html#407">-F command-line option, 393</a><br/>
<a href="Rubys.html#19">Fixnum objects, 5, 42</a><br/>
<a href="Rubys.html#414">$F global variable, 400</a><br/>
<a href="Rubys.html#58">arithmetic and, 44</a><br/>
<a href="Rubys.html#256">factory methods, 242</a><br/>
<a href="Rubys.html#59">bit-manipulation operators and, 45</a><br/>
<a href="Rubys.html#325">regular expression, 311</a><br/>
<a href="Rubys.html#57">integer literals and, 43</a><br/>
<a href="Rubys.html#86">false keyword, 72, 86</a><br/>
<a href="Rubys.html#88">object identity and, 74</a><br/>
<a href="Rubys.html#132">conditionals and, 118</a><br/>
<a href="Rubys.html#87">references and, 73</a><br/>
<a href="Rubys.html#133">else keyword and, 119</a><br/>
<a href="Rubys.html#364">flatten method (Set), 350</a><br/>
<a href="Rubys.html#356">fetch method (Hash), 342, 345</a><br/>
<a href="Rubys.html#364">flatten! method (Set), 350</a><br/>
<a href="Rubys.html#181">Fiber.new method, 167</a><br/>
<a href="Rubys.html#123">flip-flops, 109–111</a><br/>
<a href="Rubys.html#182">Fiber.yield method, 168</a><br/>
<a href="Rubys.html#59">Float class, 45</a><br/>
<a href="Rubys.html#181">fibers, 167–172</a><br/>
<a href="Rubys.html#95">Float function (Kernel), 81</a><br/>
<a href="Rubys.html#185">advanced features, 171</a><br/>
<a href="Rubys.html#57">floating-point literals, 43</a><br/>
<a href="Rubys.html#182">argument/return values and, 168</a><br/>
<a href="Rubys.html#132">flow-of-control, 118</a><br/>
File class<br/>
<a href="Rubys.html#160">statements, 146</a><br/>
<a href="Rubys.html#369">copy_stream method, 355</a><br/>
for keyword<br/>
<a href="Rubys.html#365">expand_path method, 351</a><br/>
<b>Index&#160;|&#160;421</b><br/>
<hr/>
<a name=436></a><a href="Rubys.html#143">in keyword and, 129</a><br/>
<a href="Rubys.html#62">string interpolation and, 48</a><br/>
<a href="Rubys.html#75">force_encoding method (String), 61</a><br/>
<a href="Rubys.html#158">Hash.each_pair method, 144</a><br/>
<a href="Rubys.html#420">forking, 406</a><br/>
<a href="Rubys.html#355">Hash.new method, 341, 345</a><br/>
<a href="Rubys.html#63">form feed character (\f) escape, 49</a><br/>
<a href="Rubys.html#82">hashcodes, 68</a><br/>
forward slash (/)<br/>
<a href="Rubys.html#17">hashes, 3, 67–68, 341–346</a><br/>
<a href="Rubys.html#365">directory separator character, 351</a><br/>
<a href="Rubys.html#235">access with [ ], 221</a><br/>
<a href="Rubys.html#58">division operator, 44</a><br/>
<a href="Rubys.html#357">arrays, extracting from, 343</a><br/>
<a href="Rubys.html#365">Window directory separator character, 351</a><br/>
<a href="Rubys.html#82">codes/tables, 68</a><br/>
<a href="Rubys.html#82">freeze method (Object), 68</a><br/>
<a href="Rubys.html#355">creating, 341</a><br/>
<a href="Rubys.html#98">frozen objects, 84</a><br/>
<a href="Rubys.html#358">default values, 344</a><br/>
<a href="Rubys.html#246">functional styles, 232</a><br/>
<a href="Rubys.html#357">entries, removing, 343</a><br/>
functions<br/>
<a href="Rubys.html#91">eql? method, using, 77</a><br/>
<a href="Rubys.html#221">composition, 207</a><br/>
<a href="Rubys.html#359">integer hashcodes, 345</a><br/>
<a href="Rubys.html#95">conversion, 81</a><br/>
<a href="Rubys.html#81">literals, 67</a><br/>
<a href="Rubys.html#210">currying, 196</a><br/>
<a href="Rubys.html#202">named method arguments, 188</a><br/>
<a href="Rubys.html#418">deprecated extraction, 404</a><br/>
<a href="Rubys.html#21">suffixes/prefixes punctuation, 7</a><br/>
<a href="Rubys.html#219">enumerable, applying to, 205</a><br/>
<a href="Rubys.html#19">[ ] operator, 5, 341</a><br/>
<a href="Rubys.html#219">functional programming, 205–212</a><br/>
<a href="Rubys.html#406">--help command-line option, 392</a><br/>
<a href="Rubys.html#222">memoization, 208</a><br/>
<a href="Rubys.html#65">&lt;&lt;here documents, 51–53</a><br/>
<a href="Rubys.html#17">parentheses (( )) and, 3</a><br/>
<a href="Rubys.html#291">hooks, 277–279</a><br/>
<a href="Rubys.html#221">partial application, 207<br/></a><a href="Rubys.html#415">predefined global, 401</a><br/>
<b>I</b><br/>
<a href="Rubys.html#418">reporting, 404<br/></a><a href="Rubys.html#417">user-defined global, 403</a><br/>
<a href="Rubys.html#324">i (regular expression) modifier, 310<br/></a><a href="Rubys.html#269">-I command-line option, 255, 391</a><br/>
<b>G</b><br/>
<a href="Rubys.html#407">-i command-line option, 393<br/></a><a href="Rubys.html#88">id method (deprecated), 74</a><br/>
<a href="Rubys.html#87">garbage collection, 73, 281</a><br/>
<a href="Rubys.html#295">id2ref method (ObjectSpace), 281</a><br/>
<a href="Rubys.html#295">GC module (garbage collection), 281</a><br/>
<a href="Rubys.html#107">idempotent expressions, 93</a><br/>
<a href="Rubys.html#248">Gem, 234</a><br/>
<a href="Rubys.html#42">identifiers, 28–30</a><br/>
<a href="Rubys.html#25">gem tool, 11, 14</a><br/>
<a href="Rubys.html#43">unicode characters and, 29</a><br/>
<a href="Rubys.html#73">getbyte method (String), 59</a><br/>
<a href="Rubys.html#18">if keyword, 4, 103, 118–121</a><br/>
<a href="Rubys.html#109">getter methods, 95</a><br/>
<a href="Rubys.html#125">?: (conditional) operator, 111</a><br/>
global<br/>
<a href="Rubys.html#135">modifier, as a, 121–122</a><br/>
<a href="Rubys.html#104">functions, 90</a><br/>
<a href="Rubys.html#57">immutable objects, 43, 226</a><br/>
<a href="Rubys.html#246">methods, 232</a><br/>
<a href="Rubys.html#94">implicit conversions, 80</a><br/>
<a href="Rubys.html#44">variables, 30, 88, 397–401</a><br/>
<a href="Rubys.html#143">in keyword, 129</a><br/>
<a href="Rubys.html#172">$! operator, 158</a><br/>
<a href="Rubys.html#265">includable namespace module, 251</a><br/>
<a href="Rubys.html#267">load path and, 253–255</a><br/>
<a href="Rubys.html#282">include? method (Module), 268</a><br/>
<a href="Rubys.html#69">greater than (&gt;) operator, 55, 79, 102</a><br/>
<a href="Rubys.html#82">include? method (Range), 68</a><br/>
greater&#160;than&#160;or&#160;equal&#160;(&gt;=)&#160;<a href="Rubys.html#69">operator,&#160;55,&#160;</a><a href="Rubys.html#93">79,&#160;</a><a href="Rubys.html#116">102,</a><br/>
<a href="Rubys.html#82">inclusive (ranges), 68</a><br/>
<a href="Rubys.html#119">105</a><br/>
indexes<br/>
<a href="Rubys.html#346">group_by method (Enumerable), 332</a><br/>
<a href="Rubys.html#70">arrays, 56</a><br/>
<a href="Rubys.html#333">gsub method (String), 319</a><br/>
<a href="Rubys.html#355">hashes, 341</a><br/>
<a href="Rubys.html#333">gsub! method (String), 319</a><br/>
<a href="Rubys.html#78">indexing arrays, 64<br/></a><a href="Rubys.html#248">inheritance, 234–241</a><br/>
<b>H</b><br/>
<a href="Rubys.html#253">class methods and, 239<br/></a><a href="Rubys.html#255">constants, 241</a><br/>
hash (#)<br/>
<a href="Rubys.html#253">instance variables, 239</a><br/>
<a href="Rubys.html#16">comments and, 2, 26, 36</a><br/>
<a href="Rubys.html#249">methods, 235</a><br/>
<b>422&#160;|&#160;Index</b><br/>
<hr/>
<a name=437></a>inherited method<br/>
<a href="Rubys.html#370">IO.new method, 356</a><br/>
<a href="Rubys.html#291">hooks and, 277</a><br/>
<a href="Rubys.html#370">IO.open method, 356</a><br/>
<a href="Rubys.html#229">initialize method, 215, 230, 231, 240</a><br/>
<a href="Rubys.html#370">IO.pipe method, 356</a><br/>
<a href="Rubys.html#256">factory methods, 242</a><br/>
<a href="Rubys.html#370">IO.popen method, 356</a><br/>
<a href="Rubys.html#256">object creation and initialization, 242</a><br/>
<a href="Rubys.html#375">IO.read method, 361</a><br/>
<a href="Rubys.html#246">private/protected methods and, 232</a><br/>
<a href="Rubys.html#375">IO.readlines method, 361</a><br/>
<a href="Rubys.html#261">singleton classes and, 247</a><br/>
<a href="Rubys.html#249">IOError, 235</a><br/>
<a href="Rubys.html#87">initialize method (Class), 73</a><br/>
<a href="Rubys.html#25">irb (interactive Ruby) tool, 11, 13, 269</a><br/>
<a href="Rubys.html#97">initialize_copy method, 83, 243–245</a><br/>
<a href="Rubys.html#26">IronRuby, 12</a><br/>
<a href="Rubys.html#219">inject iterator, 205</a><br/>
<a href="Rubys.html#89">is_a? method (Object), 75, 267</a><br/>
<a href="Rubys.html#146">inject method (Enumerable), 132, 334</a><br/>
<a href="Rubys.html#17">iterators, 3–4, 130–140</a><br/>
<a href="Rubys.html#370">input/output, 356–366</a><br/>
<a href="Rubys.html#24">classes/methods and, 10</a><br/>
<a href="Rubys.html#418">input functions, 404</a><br/>
<a href="Rubys.html#154">concurrent modification and, 140</a><br/>
<a href="Rubys.html#379">random access methods, 365</a><br/>
<a href="Rubys.html#147">custom, writing, 133–135</a><br/>
<a href="Rubys.html#378">streams, writing to, 364</a><br/>
<a href="Rubys.html#151">external, 137–140, 330</a><br/>
<a href="Rubys.html#26">inspect method, 12, 346</a><br/>
<a href="Rubys.html#145">numeric, 131</a><br/>
<a href="Rubys.html#28">installing gems, 14</a><br/>
<a href="Rubys.html#363">Set class and, 349</a><br/>
<a href="Rubys.html#22">instance variables, 8, 30, 88</a><br/>
<a href="Rubys.html#72">strings, 58</a><br/>
<a href="Rubys.html#107">assigning, 93<br/></a><a href="Rubys.html#245">classes, 231</a><br/>
<b>J</b><br/>
<a href="Rubys.html#253">inheritance and, 239</a><br/>
<a href="Rubys.html#248">instance_eval method (Object), 234, 270, 279</a><br/>
Java programming language, using equality<br/>
<a href="Rubys.html#284">instance_exec method (Object), 270</a><br/>
<a href="Rubys.html#91">operators, 77</a><br/>
<a href="Rubys.html#88">instance_of? method (Object), 74, 267</a><br/>
<a href="Rubys.html#26">JRuby, 12</a><br/>
<a href="Rubys.html#335">Integer function, 321<br/></a><a href="Rubys.html#95">Integer function (Kernel), 81</a><br/>
<b>K</b><br/>
integers<br/>
<a href="Rubys.html#51">-K command-line option, 37, 63</a><br/>
<a href="Rubys.html#57">literals, 43</a><br/>
<a href="Rubys.html#43">Kanji characters, 29</a><br/>
<a href="Rubys.html#85">intern method (String), 71</a><br/>
<a href="Rubys.html#412">$KCODE global variable, 398</a><br/>
<a href="Rubys.html#151">internal iterator, 137</a><br/>
<a href="Rubys.html#95">Kernel module, 81, 90, 251, 266</a><br/>
<a href="Rubys.html#373">internal_encoding method (IO), 359</a><br/>
<a href="Rubys.html#152">looping, 138</a><br/>
<a href="Rubys.html#322">internationalization, 308</a><br/>
<a href="Rubys.html#282">Kernel.eval method, 268</a><br/>
<a href="Rubys.html#25">interpreter (Ruby), 11–15, 390–395</a><br/>
<a href="Rubys.html#207">Kernel.lambda method, 193</a><br/>
<a href="Rubys.html#40">lexical structure and, 26</a><br/>
<a href="Rubys.html#208">Kernel.proc method, 194</a><br/>
<a href="Rubys.html#48">syntactic structure and, 34</a><br/>
<a href="Rubys.html#339">Kernel.rand method, 325</a><br/>
introspection (see reflection)<br/>
<a href="Rubys.html#81">keys, 67</a><br/>
<a href="Rubys.html#360">invert method (Hash), 346</a><br/>
<a href="Rubys.html#356">storing in hashes, 342</a><br/>
<a href="Rubys.html#103">invocations, 89–92, 176</a><br/>
<a href="Rubys.html#100">keyword literals, 86</a><br/>
<a href="Rubys.html#370">IO object, 356–366</a><br/>
<a href="Rubys.html#44">keywords, 30</a><br/>
<a href="Rubys.html#387">IO-bound programs, 373</a><br/>
<a href="Rubys.html#393">kill method, 379</a><br/>
<a href="Rubys.html#377">IO.bytes enumerator, 363</a><br/>
<a href="Rubys.html#393">kill! method, 379</a><br/>
<a href="Rubys.html#377">IO.chars enumerator, 363</a><br/>
<a href="Rubys.html#281">kind_of? method (Object), 267</a><br/>
<a href="Rubys.html#376">IO.copy_stream method, 362<br/></a><a href="Rubys.html#374">IO.each iterator, 360</a><br/>
<b>L</b><br/>
<a href="Rubys.html#377">IO.each_byte iterator, 363<br/>IO.each_char iterator, 363</a><br/>
<a href="Rubys.html#407">-l command-line option, 393</a><br/>
<a href="Rubys.html#374">IO.each_line iterator, 360</a><br/>
<a href="Rubys.html#161">lambdas, 147, 192–200</a><br/>
<a href="Rubys.html#375">IO.foreach method, 361</a><br/>
<a href="Rubys.html#209">invoking, 195</a><br/>
<a href="Rubys.html#374">IO.lines enumerator, 360</a><br/>
<a href="Rubys.html#208">literals, 194</a><br/>
<a href="Rubys.html#78">length method (Array), 64</a><br/>
<b>Index&#160;|&#160;423</b><br/>
<hr/>
<a name=438></a><a href="Rubys.html#70">length method (String), 56, 59</a><br/>
<a href="Rubys.html#347">max method (Enumerable), 333</a><br/>
<a href="Rubys.html#69">less than (&lt;) operator, 55, 79, 102, 105</a><br/>
<a href="Rubys.html#347">max_by method (Enumerable), 333</a><br/>
<a href="Rubys.html#69">less than or equal (&lt;=) operator, 55, 79, 102,</a><br/>
<a href="Rubys.html#84">member? method (Range), 70</a><br/>
<a href="Rubys.html#119">105</a><br/>
<a href="Rubys.html#355">memberships, 341</a><br/>
<a href="Rubys.html#40">lexical structure, 26–33, 36</a><br/>
<a href="Rubys.html#83">testing in ranges, 69</a><br/>
<a href="Rubys.html#87">lifetime of objects, 73</a><br/>
<a href="Rubys.html#222">memoization, 208</a><br/>
<a href="Rubys.html#101">__LINE__ keyword, 87</a><br/>
<a href="Rubys.html#271">metaclass, 257</a><br/>
<a href="Rubys.html#293">tracing and, 279</a><br/>
(see also eigenclass)<br/>
<a href="Rubys.html#42">literals, 28, 86</a><br/>
<a href="Rubys.html#30">metaprogramming, 16, 203, 219, 234, 266–</a><br/>
<a href="Rubys.html#68">characters, 54</a><br/>
<a href="Rubys.html#313">299</a><br/>
<a href="Rubys.html#81">hashes, 67</a><br/>
<a href="Rubys.html#217">Method class, 203</a><br/>
<a href="Rubys.html#57">integer and floating-point, 43</a><br/>
<a href="Rubys.html#288">method method (Object), 274</a><br/>
<a href="Rubys.html#60">strings, 46–54</a><br/>
<a href="Rubys.html#19">methods, 5, 176–212, 272–277, 272</a><br/>
<a href="Rubys.html#64">arbitrary delimiters and, 50</a><br/>
<a href="Rubys.html#231">accessors/attributes and, 217</a><br/>
<a href="Rubys.html#67">mutability and, 53</a><br/>
<a href="Rubys.html#195">aliases, 181</a><br/>
<a href="Rubys.html#266">load function, 252</a><br/>
<a href="Rubys.html#199">arguments, 185–192</a><br/>
<a href="Rubys.html#269">executing code, 255</a><br/>
<a href="Rubys.html#49">block structure and, 35</a><br/>
<a href="Rubys.html#267">load path, 253–255</a><br/>
<a href="Rubys.html#306">chaining for thread safety, 292</a><br/>
<a href="Rubys.html#412">$LOADED_FEATURES global variable, 398</a><br/>
<a href="Rubys.html#301">creating dynamically, 287–290</a><br/>
<a href="Rubys.html#267">$LOAD_PATH global variable, 253, 398</a><br/>
<a href="Rubys.html#288">defining, undefining, and aliasing, 274</a><br/>
<a href="Rubys.html#102">local variables, 88</a><br/>
<a href="Rubys.html#192">exception handling and, 178</a><br/>
<a href="Rubys.html#322">localization, 308</a><br/>
<a href="Rubys.html#170">exception objects and, 156</a><br/>
<a href="Rubys.html#397">lock method, 383</a><br/>
<a href="Rubys.html#256">factory, 242</a><br/>
<a href="Rubys.html#104">lookups (methods), 90, 258–262</a><br/>
<a href="Rubys.html#42">identifiers and, 28</a><br/>
<a href="Rubys.html#145">loop method, 131</a><br/>
<a href="Rubys.html#103">invocations, 89–92</a><br/>
<a href="Rubys.html#17">loops, 3, 127–130</a><br/>
<a href="Rubys.html#288">invoking, 274</a><br/>
<a href="Rubys.html#162">break keyword, 148</a><br/>
<a href="Rubys.html#192">invoking on objects, 178</a><br/>
<a href="Rubys.html#106">lvalues, 92</a><br/>
<a href="Rubys.html#379">IO random access, 365</a><br/>
<a href="Rubys.html#109">abbreviated assignment and, 95</a><br/>
<a href="Rubys.html#272">lookup/name resolution, 258–262</a><br/>
<a href="Rubys.html#111">parallel assignments and, 97</a><br/>
<a href="Rubys.html#217">Method objects, 203<br/></a><a href="Rubys.html#298">missing, 284</a><br/>
<b>M</b><br/>
<a href="Rubys.html#240">mutable, 226<br/></a><a href="Rubys.html#194">names, 180–183</a><br/>
<a href="Rubys.html#324">m (regular expression) modifier, 310</a><br/>
<a href="Rubys.html#335">numeric, 321</a><br/>
<a href="Rubys.html#53">main method, 39</a><br/>
<a href="Rubys.html#197">omitting parentheses in, 183</a><br/>
<a href="Rubys.html#207">makeproc method, 193</a><br/>
<a href="Rubys.html#195">operator, 181</a><br/>
<a href="Rubys.html#219">map iterator, 205</a><br/>
<a href="Rubys.html#250">overriding, 236–238</a><br/>
<a href="Rubys.html#144">map method (Enumerable), 130</a><br/>
<a href="Rubys.html#17">parentheses (( )) and, 3, 183–185</a><br/>
<a href="Rubys.html#81">maps, 67</a><br/>
<a href="Rubys.html#191">return values and, 177</a><br/>
<a href="Rubys.html#97">Marshal.dump method, 83</a><br/>
<a href="Rubys.html#191">simple, defining, 177–180</a><br/>
<a href="Rubys.html#97">Marshal.load method, 83, 245</a><br/>
<a href="Rubys.html#271">singleton, 257</a><br/>
<a href="Rubys.html#259">marshal_dump method, 245</a><br/>
<a href="Rubys.html#193">defining, 179</a><br/>
<a href="Rubys.html#259">marshal_load method, 245</a><br/>
<a href="Rubys.html#218">UnboundMethod objects, 204</a><br/>
<a href="Rubys.html#331">match method (Regexp/String), 317</a><br/>
<a href="Rubys.html#290">undefined, handling, 276</a><br/>
<a href="Rubys.html#330">MatchData object, 316</a><br/>
<a href="Rubys.html#193">undefining, 179</a><br/>
<a href="Rubys.html#20">Math module, 6, 322</a><br/>
visibility<br/>
<a href="Rubys.html#338">Matrix class, 324</a><br/>
<a href="Rubys.html#246">public, protected, and private, 232–234</a><br/>
<a href="Rubys.html#16">Matsumoto, Yukihiro (Matz), 2</a><br/>
<a href="Rubys.html#291">setting, 277</a><br/>
<a href="Rubys.html#25">Matz’s Ruby Implementation (MRI), 11</a><br/>
<a href="Rubys.html#290">method_missing method, 276, 284, 285</a><br/>
<a href="Rubys.html#201">max method, 187</a><br/>
<b>424&#160;|&#160;Index</b><br/>
<hr/>
<a name=439></a><a href="Rubys.html#310">XML output and, 296</a><br/>
<a href="Rubys.html#330">MatchData, and, 316</a><br/>
<a href="Rubys.html#347">min method (Enumerable), 333</a><br/>
<a href="Rubys.html#334">references in replacement strings, 320</a><br/>
<a href="Rubys.html#347">minmax method (Enumerable), 333</a><br/>
<a href="Rubys.html#102">NameError, 88</a><br/>
<a href="Rubys.html#347">minmax_by method (Enumerable), 333</a><br/>
<a href="Rubys.html#262">namespaces, 248–250</a><br/>
<a href="Rubys.html#58">minus sign (–) operator, 44, 102</a><br/>
<a href="Rubys.html#265">includable modules, 251</a><br/>
<a href="Rubys.html#117">unary, 103</a><br/>
<a href="Rubys.html#263">nested, 249</a><br/>
<a href="Rubys.html#347">min_by method (Enumerable), 333</a><br/>
<a href="Rubys.html#58">NaN (Not-a-Number), 44</a><br/>
<a href="Rubys.html#298">missing constants, 284</a><br/>
<a href="Rubys.html#59">negative numbers, 45</a><br/>
<a href="Rubys.html#298">missing methods, 284</a><br/>
<a href="Rubys.html#380">networking, 366–373</a><br/>
<a href="Rubys.html#264">mixin modules, 250</a><br/>
<a href="Rubys.html#256">new keyword, 242</a><br/>
<a href="Rubys.html#92">object order and, 78</a><br/>
<a href="Rubys.html#87">new method (Class), 73</a><br/>
<a href="Rubys.html#128">modifiers, 114, 121–122</a><br/>
<a href="Rubys.html#46">newlines, 32</a><br/>
<a href="Rubys.html#142">while and until as, 128</a><br/>
<a href="Rubys.html#26">using print methods and, 12</a><br/>
<a href="Rubys.html#119">Module class, 105, 218, 266</a><br/>
<a href="Rubys.html#61">\n escape, 47, 49</a><br/>
<a href="Rubys.html#282">Module.nesting method, 268</a><br/>
<a href="Rubys.html#163">next keyword, 149–151</a><br/>
<a href="Rubys.html#22">modules, 8–10, 247–252, 395</a><br/>
<a href="Rubys.html#152">next method, 138</a><br/>
<a href="Rubys.html#281">ancestry, 267</a><br/>
<a href="Rubys.html#16">nil keyword, 2, 72, 86</a><br/>
<a href="Rubys.html#270">autoloading, 256</a><br/>
<a href="Rubys.html#93">&lt;=&gt; operator and, 79</a><br/>
<a href="Rubys.html#49">block structure and, 35</a><br/>
<a href="Rubys.html#70">characters in strings, accessing, 56</a><br/>
<a href="Rubys.html#282">defining, 268</a><br/>
<a href="Rubys.html#132">conditionals, 118</a><br/>
<a href="Rubys.html#265">includable namespaces, 251</a><br/>
<a href="Rubys.html#133">else keyword and, 119</a><br/>
<a href="Rubys.html#266">loading and requiring, 252–257</a><br/>
<a href="Rubys.html#19">expressions and, 5</a><br/>
<a href="Rubys.html#264">mixins as, 250</a><br/>
<a href="Rubys.html#290">NoMethodError, 276</a><br/>
<a href="Rubys.html#262">namespaces as, 248–250</a><br/>
<a href="Rubys.html#128">nonoperators, 114</a><br/>
<a href="Rubys.html#266">module_function method, 252</a><br/>
<a href="Rubys.html#20">nonoverridable (=) operator, 6</a><br/>
<a href="Rubys.html#58">modulo (%) operator, 44, 96, 102</a><br/>
<a href="Rubys.html#61">nonterminating quotation mark (\&#34;), 47</a><br/>
<a href="Rubys.html#58">modulo method (Numeric), 44</a><br/>
<a href="Rubys.html#117">not keyword, 103, 107</a><br/>
<a href="Rubys.html#304">monkey patching, 290</a><br/>
<a href="Rubys.html#58">Not-a-Number (NaN), 44</a><br/>
<a href="Rubys.html#25">MRI (Matz’s Ruby Implementation), 11</a><br/>
<a href="Rubys.html#56">numbers, 42–46, 321–325</a><br/>
<a href="Rubys.html#72">multibyte characters, 58</a><br/>
<a href="Rubys.html#339">random, 325</a><br/>
<a href="Rubys.html#40">multiline comments, 26</a><br/>
<a href="Rubys.html#91">Numeric class, 77, 132, 321</a><br/>
<a href="Rubys.html#19">multiplication (*) operator, 5, 102</a><br/>
<a href="Rubys.html#145">numeric iterators, 131</a><br/>
multithreaded<br/>
<a href="Rubys.html#387">programs, 373</a><br/>
<b>O</b><br/>
<a href="Rubys.html#395">servers, 381</a><br/>
mutable<br/>
<a href="Rubys.html#324">o (regular expression) modifier, 310</a><br/>
<a href="Rubys.html#82">keys, 68</a><br/>
<a href="Rubys.html#20">Object class, 6, 266</a><br/>
<a href="Rubys.html#240">points, 226</a><br/>
<a href="Rubys.html#16">object-oriented, 2</a><br/>
<a href="Rubys.html#195">mutator methods, 181</a><br/>
<a href="Rubys.html#56">objects, 42, 72–84</a><br/>
<a href="Rubys.html#297">Mutex object, 283</a><br/>
<a href="Rubys.html#88">classes/types, 74<br/></a><a href="Rubys.html#93">conversion, 79–82</a><br/>
<b>N</b><br/>
<a href="Rubys.html#96">copying, 82<br/></a><a href="Rubys.html#255">creating and initialization, 241–247</a><br/>
<a href="Rubys.html#61">\n (newline), 47, 49</a><br/>
<a href="Rubys.html#90">equality, 76–78</a><br/>
<a href="Rubys.html#324">n (regular expression) modifier, 310</a><br/>
<a href="Rubys.html#170">exceptions, creating, 156</a><br/>
<a href="Rubys.html#408">-n command-line option, 394</a><br/>
<a href="Rubys.html#172">naming, 158</a><br/>
<a href="Rubys.html#76">name method (Encoding), 62</a><br/>
<a href="Rubys.html#98">freezing, 84</a><br/>
<a href="Rubys.html#104">name resolution (methods), 90, 258–262</a><br/>
<a href="Rubys.html#88">identity, 74</a><br/>
named captures<br/>
<a href="Rubys.html#87">lifetime, 73</a><br/>
<a href="Rubys.html#331">local variables, and, 317</a><br/>
<a href="Rubys.html#97">marshaling, 83</a><br/>
<b>Index&#160;|&#160;425</b><br/>
<hr/>
<a name=440></a><a href="Rubys.html#192">methods, invoking on, 178</a><br/>
<a href="Rubys.html#253">class methods, inheritance of, 239</a><br/>
<a href="Rubys.html#92">order, 78</a><br/>
<a href="Rubys.html#86">pointers, 72</a><br/>
<a href="Rubys.html#86">references, 72</a><br/>
<a href="Rubys.html#115">precedence, 101</a><br/>
<a href="Rubys.html#98">tainting, 84</a><br/>
<a href="Rubys.html#127">assignment operators and, 113</a><br/>
<a href="Rubys.html#295">ObjectSpace module, 281</a><br/>
<a href="Rubys.html#194">predicate methods, 180</a><br/>
<a href="Rubys.html#88">object_id method (Object), 74</a><br/>
<a href="Rubys.html#392">preemption (thread), 378</a><br/>
<a href="Rubys.html#419">one-line scripts, 405</a><br/>
<a href="Rubys.html#21">prefixes punctuation, 7</a><br/>
<a href="Rubys.html#24">open classes, 10</a><br/>
<a href="Rubys.html#100">primary expressions, 86</a><br/>
<a href="Rubys.html#371">open method (Kernel), 357</a><br/>
<a href="Rubys.html#86">primitive types, 72</a><br/>
<a href="Rubys.html#18">operators, 4, 100–115</a><br/>
<a href="Rubys.html#372">print function, IO streams and, 358</a><br/>
<a href="Rubys.html#126">assignments, 112</a><br/>
<a href="Rubys.html#26">print method, 12, 364</a><br/>
<a href="Rubys.html#233">defining, 219</a><br/>
<a href="Rubys.html#62">printf function, 48, 308</a><br/>
<a href="Rubys.html#195">methods, 181</a><br/>
<a href="Rubys.html#391">priorities (thread), 377</a><br/>
<a href="Rubys.html#42">punctuation and, 28</a><br/>
<a href="Rubys.html#20">private methods, 6, 90, 232–234</a><br/>
<a href="Rubys.html#197">optional parentheses, 183</a><br/>
<a href="Rubys.html#252">overriding, 238</a><br/>
<a href="Rubys.html#404">options (command-line), 390</a><br/>
<a href="Rubys.html#207">Proc.new method, 193, 199</a><br/>
<a href="Rubys.html#117">or keyword, 103, 107</a><br/>
<a href="Rubys.html#420">processes, 406</a><br/>
OR operator (see |)<br/>
<a href="Rubys.html#190">procs, 176, 192–200</a><br/>
<a href="Rubys.html#255">ORIGIN constant, 241</a><br/>
<a href="Rubys.html#206">creating, 192–195</a><br/>
<a href="Rubys.html#419">OS-dependent functions, 405</a><br/>
<a href="Rubys.html#211">equality, 197</a><br/>
<a href="Rubys.html#26">output, displaying, 12</a><br/>
<a href="Rubys.html#209">invoking, 195</a><br/>
<a href="Rubys.html#250">overriding methods, 236–238</a><br/>
<a href="Rubys.html#50">program encoding, 36–39<br/></a><a href="Rubys.html#53">program execution, 39</a><br/>
<b>P</b><br/>
<a href="Rubys.html#412">$PROGRAM_NAME global variable, 398<br/></a><a href="Rubys.html#246">protected methods, 232–234</a><br/>
<a href="Rubys.html#408">-p command-line option, 394</a><br/>
<a href="Rubys.html#246">public methods, 232–234</a><br/>
<a href="Rubys.html#28">package management systems, 14</a><br/>
<a href="Rubys.html#218">public_instance_method, 204</a><br/>
<a href="Rubys.html#20">parallel assignments, 6, 92, 97, 144</a><br/>
<a href="Rubys.html#217">public_method method, 203</a><br/>
<a href="Rubys.html#199">parameter defaults, 185</a><br/>
<a href="Rubys.html#288">public_send method, 274</a><br/>
<a href="Rubys.html#129">parentheses (( )), 115</a><br/>
<a href="Rubys.html#42">punctuation, 28</a><br/>
<a href="Rubys.html#17">function/methods, 3</a><br/>
<a href="Rubys.html#129">characters, 115</a><br/>
<a href="Rubys.html#133">if statements and, 119</a><br/>
<a href="Rubys.html#44">identifiers and, 30</a><br/>
<a href="Rubys.html#47">method declarations, 33, 90, 183–185</a><br/>
<a href="Rubys.html#21">suffixes/prefixes, 7</a><br/>
<a href="Rubys.html#197">optional, 183</a><br/>
<a href="Rubys.html#378">putc method, 364</a><br/>
<a href="Rubys.html#113">parallel assignment and, 99</a><br/>
<a href="Rubys.html#26">puts function, 12</a><br/>
<a href="Rubys.html#198">required, 184</a><br/>
<a href="Rubys.html#104">puts method (Kernel), 90</a><br/>
<a href="Rubys.html#221">partial application, 207<br/></a><a href="Rubys.html#346">partition method (Enumerable), 332<br/></a><a href="Rubys.html#329">pattern matching, 315–321</a><br/>
<b>Q</b><br/>
percent sign (see %)<br/>
<a href="Rubys.html#65">%Q sequences, 51</a><br/>
<a href="Rubys.html#331">Perl regular expression syntax, 317</a><br/>
<a href="Rubys.html#65">%q sequences, 51</a><br/>
<a href="Rubys.html#318">platform (Ruby), 304–387</a><br/>
<a href="Rubys.html#44">question mark (?), 30</a><br/>
<a href="Rubys.html#388">platform dependencies, 374</a><br/>
<a href="Rubys.html#366">matching characters with, 352</a><br/>
<a href="Rubys.html#19">plus sign (+), 5, 44, 102</a><br/>
<a href="Rubys.html#194">method names and, 180</a><br/>
<a href="Rubys.html#96">coerce method and, 82</a><br/>
<a href="Rubys.html#399">queue data structures, 385</a><br/>
<a href="Rubys.html#318">concatenation and, 304</a><br/>
<a href="Rubys.html#338">quo method (Numeric), 324</a><br/>
<a href="Rubys.html#69">strings and, 55</a><br/>
<a href="Rubys.html#61">quotation marks (&#34;), 47</a><br/>
<a href="Rubys.html#117">unary, 103, 209</a><br/>
<a href="Rubys.html#322">expressions, interpolating into strings, 308</a><br/>
<a href="Rubys.html#231">Point class, using accessors and attributes, 217<br/></a><a href="Rubys.html#249">Point3D class, 235, 241</a><br/>
<b>426&#160;|&#160;Index</b><br/>
<hr/>
<a name=441></a><b>R</b><br/>
<a href="Rubys.html#357">reject! method (Hash), 343<br/></a><a href="Rubys.html#59">remainder method (Numeric), 45</a><br/>
<a href="Rubys.html#63">\r (carriage return) escape, 49</a><br/>
<a href="Rubys.html#290">remove_method method (Module), 276</a><br/>
<a href="Rubys.html#371">&#34;r&#34; (reading) file mode, 357</a><br/>
<a href="Rubys.html#356">replace method (Hash), 342</a><br/>
<a href="Rubys.html#405">-r command-line option, 391</a><br/>
<a href="Rubys.html#28">require method, 14, 252</a><br/>
<a href="Rubys.html#324">%r delimiter, 310</a><br/>
<a href="Rubys.html#269">code, executing, 255</a><br/>
<a href="Rubys.html#371">&#34;r+&#34; (reading and writing) file mode, 357</a><br/>
<a href="Rubys.html#198">required parentheses, 184</a><br/>
raise method<br/>
<a href="Rubys.html#267">require_relative method, 253</a><br/>
<a href="Rubys.html#168">exceptions and, 154</a><br/>
<a href="Rubys.html#116">rescue keyword, 102</a><br/>
<a href="Rubys.html#170">exceptions, raising and, 156</a><br/>
<a href="Rubys.html#172">exceptions, handling, 158–162</a><br/>
<a href="Rubys.html#339">rand method, 325</a><br/>
<a href="Rubys.html#178">method, class, and module definitions, 164</a><br/>
<a href="Rubys.html#379">random access methods, 365</a><br/>
<a href="Rubys.html#192">methods and exception handling, 178</a><br/>
<a href="Rubys.html#71">Range object, 57</a><br/>
<a href="Rubys.html#175">retry statement and, 161</a><br/>
<a href="Rubys.html#21">ranges, 7, 68–70, 69, 109–111</a><br/>
<a href="Rubys.html#178">statement modifiers and, 164</a><br/>
(see also .. operator)<br/>
<a href="Rubys.html#45">reserved words, 31</a><br/>
<a href="Rubys.html#83">membership, testing, 69</a><br/>
<a href="Rubys.html#89">respond_to? method, 75, 267</a><br/>
<a href="Rubys.html#354">rassoc method (Array), 340</a><br/>
<a href="Rubys.html#160">retry keyword, 146, 152, 200</a><br/>
<a href="Rubys.html#57">Rational class, 43, 324</a><br/>
<a href="Rubys.html#175">rescue clause and, 161</a><br/>
<a href="Rubys.html#267">.rb source files, 253</a><br/>
<a href="Rubys.html#46">return keyword, 32, 120, 146–148</a><br/>
<a href="Rubys.html#41">rdoc tool, 27</a><br/>
<a href="Rubys.html#156">blocks and, 142</a><br/>
<a href="Rubys.html#377">read method, 363</a><br/>
<a href="Rubys.html#191">method values and, 177</a><br/>
<a href="Rubys.html#377">readbytes method, 363</a><br/>
<a href="Rubys.html#164">next statement and, 150</a><br/>
<a href="Rubys.html#374">readline method (IO), 360</a><br/>
<a href="Rubys.html#25">ri tools, 11, 13</a><br/>
<a href="Rubys.html#377">readpartial method, 363</a><br/>
<a href="Rubys.html#41">comments and, 27</a><br/>
<a href="Rubys.html#377">read_nonblock method, 363</a><br/>
<a href="Rubys.html#59">rounding errors, 45</a><br/>
<a href="Rubys.html#192">receiver, 178</a><br/>
<a href="Rubys.html#26">Rubinius, 12</a><br/>
(see also objects)<br/>
Ruby 1.8<br/>
<a href="Rubys.html#160">redo keyword, 146, 151, 200</a><br/>
<a href="Rubys.html#267">$LOAD_PATH, 253</a><br/>
references<br/>
<a href="Rubys.html#156">blocks and, 142</a><br/>
<a href="Rubys.html#102">constant, 88</a><br/>
<a href="Rubys.html#158">blocks, passing arguments, 144</a><br/>
<a href="Rubys.html#86">object, 72</a><br/>
<a href="Rubys.html#68">character literals, 54</a><br/>
<a href="Rubys.html#101">variable, 87</a><br/>
<a href="Rubys.html#51">encoding, specifying, 37</a><br/>
<a href="Rubys.html#217">reflection, 203, 266–299</a><br/>
<a href="Rubys.html#149">enumerators, 135</a><br/>
<a href="Rubys.html#21">Regexp, 7</a><br/>
<a href="Rubys.html#94">Exception objects and, 80</a><br/>
(see also regular expressions)<br/>
<a href="Rubys.html#81">hashes and, 67, 344</a><br/>
<a href="Rubys.html#324">Regexp objects, 310</a><br/>
<a href="Rubys.html#254">inheritance and class variables, 240</a><br/>
<a href="Rubys.html#92">=~ operator and, 78</a><br/>
<a href="Rubys.html#28">installing gem, 14</a><br/>
<a href="Rubys.html#325">compile method, 311</a><br/>
<a href="Rubys.html#72">iterating strings, 58</a><br/>
<a href="Rubys.html#325">new method, 311</a><br/>
<a href="Rubys.html#265">modules as mixins and, 251</a><br/>
<a href="Rubys.html#60">textual patterns and, 46</a><br/>
<a href="Rubys.html#77">multibyte characters and, 63</a><br/>
<a href="Rubys.html#325">Regexp.escape method, 311</a><br/>
<a href="Rubys.html#88">object identity and, 74</a><br/>
<a href="Rubys.html#330">Regexp.last_match method, 316</a><br/>
<a href="Rubys.html#202">parameters, mapping arguments to, 188</a><br/>
<a href="Rubys.html#325">Regexp.union method, 311</a><br/>
<a href="Rubys.html#198">parentheses, required, 184</a><br/>
regular expressions<br/>
<a href="Rubys.html#388">platform dependencies and, 374</a><br/>
<a href="Rubys.html#324">literals, 310</a><br/>
<a href="Rubys.html#326">regular expressions, 312</a><br/>
<a href="Rubys.html#334">named backreferences, 320</a><br/>
<a href="Rubys.html#166">retry statement and, 152</a><br/>
<a href="Rubys.html#330">named captures, in, 316, 317</a><br/>
<a href="Rubys.html#69">string operators, 55</a><br/>
<a href="Rubys.html#326">syntax, 312–315</a><br/>
<a href="Rubys.html#60">text in, 46</a><br/>
<a href="Rubys.html#146">reject method (Enumerable), 132</a><br/>
Ruby 1.9<br/>
<a href="Rubys.html#363">reject! method, 349</a><br/>
<b>Index&#160;|&#160;427</b><br/>
<hr/>
<a name=442></a><a href="Rubys.html#267">$LOAD_PATH, 253</a><br/>
<a href="Rubys.html#111">parallel assignments and, 97</a><br/>
<a href="Rubys.html#92">=== operator and, 78, 125<br/></a><a href="Rubys.html#201">arrays, passing to methods, 187</a><br/>
<b>S</b><br/>
<a href="Rubys.html#74">ASCII and BINARY encodings and, 60<br/></a><a href="Rubys.html#249">BasicObject class and, 235, 287</a><br/>
<a href="Rubys.html#328">\S (nonwhitespace) regexp character class, 314</a><br/>
<a href="Rubys.html#216">bindings and, 202</a><br/>
<a href="Rubys.html#324">s (regular expression) modifier, 310</a><br/>
<a href="Rubys.html#157">blocks and, 143</a><br/>
<a href="Rubys.html#63">\s (space character), 49</a><br/>
<a href="Rubys.html#68">character literals, 54</a><br/>
<a href="Rubys.html#328">\s (whitespace) regexp character class, 314</a><br/>
const_get method/const_defined? method,<br/>
<a href="Rubys.html#408">-s option, 394</a><br/>
<a href="Rubys.html#286">passing false, 272</a><br/>
<a href="Rubys.html#408">-S option, 394</a><br/>
<a href="Rubys.html#342">enumerable objects and, 328</a><br/>
<a href="Rubys.html#85">%s sequences, 71</a><br/>
<a href="Rubys.html#283">eval method and, 269</a><br/>
<a href="Rubys.html#412">$SAFE global variable, 398</a><br/>
<a href="Rubys.html#181">fibers for coroutines and, 167</a><br/>
<a href="Rubys.html#423">security, 409</a><br/>
<a href="Rubys.html#365">filenames and, 351</a><br/>
<a href="Rubys.html#146">select method (Enumerable), 132, 332</a><br/>
<a href="Rubys.html#28">gem and, 14</a><br/>
<a href="Rubys.html#100">self keyword, 86, 252</a><br/>
<a href="Rubys.html#268">gem command and, 254</a><br/>
<a href="Rubys.html#243">class methods and, 229</a><br/>
<a href="Rubys.html#81">hashes and, 67</a><br/>
<a href="Rubys.html#246">protected methods and, 232</a><br/>
<a href="Rubys.html#25">implementation and, 11</a><br/>
<a href="Rubys.html#262">self. prefix, 248</a><br/>
<a href="Rubys.html#288">invoking methods and, 274</a><br/>
<a href="Rubys.html#46">semicolons (;), as statement terminators, 32,</a><br/>
<a href="Rubys.html#72">iterating strings, 58</a><br/>
<a href="Rubys.html#129">115</a><br/>
<a href="Rubys.html#202">mapping arguments to, 188</a><br/>
<a href="Rubys.html#181">semicoroutines, 167</a><br/>
<a href="Rubys.html#267">modules, loading, 253</a><br/>
<a href="Rubys.html#288">send method (Object), 274</a><br/>
<a href="Rubys.html#73">multibyte characters and, 59</a><br/>
<a href="Rubys.html#132">sequential execution, 118</a><br/>
<a href="Rubys.html#116">operators and, 102</a><br/>
<a href="Rubys.html#73">setbyte method (String), 59</a><br/>
<a href="Rubys.html#210">Proc objects and, 196</a><br/>
<a href="Rubys.html#360">sets, 346–350</a><br/>
<a href="Rubys.html#218">public_instance_method and, 204</a><br/>
<a href="Rubys.html#362">adding/deleting elements, 348</a><br/>
<a href="Rubys.html#287">respond_to method (Object) and, 273</a><br/>
<a href="Rubys.html#109">setter methods, 95, 180, 218</a><br/>
<a href="Rubys.html#363">Set class and, 349</a><br/>
<a href="Rubys.html#373">set_encoding method (IO), 359</a><br/>
<a href="Rubys.html#294">stack traces and, 280</a><br/>
<a href="Rubys.html#294">set_trace_func method (Kernel), 280</a><br/>
<a href="Rubys.html#61">string literals and, 47</a><br/>
<a href="Rubys.html#215">shared variables, 201</a><br/>
<a href="Rubys.html#85">Symbol class and, 71</a><br/>
<a href="Rubys.html#50">shebang comments, 36</a><br/>
<a href="Rubys.html#60">text and, 46</a><br/>
shell commands, using backtick command<br/>
<a href="Rubys.html#392">thread scheduling and, 378</a><br/>
<a href="Rubys.html#67">execution, 53</a><br/>
<a href="Rubys.html#223">to_proc method and, 209</a><br/>
<a href="Rubys.html#358">shift method (Hash), 344</a><br/>
<a href="Rubys.html#46">whitespace and, 32</a><br/>
shift operator (see &lt;&lt;)<br/>
<a href="Rubys.html#25">ruby command, 11</a><br/>
<a href="Rubys.html#107">side effects of assignments, 93</a><br/>
Ruby operator<br/>
<a href="Rubys.html#422">signals, trapping, 408</a><br/>
<a href="Rubys.html#112">splat operator and, 98</a><br/>
<a href="Rubys.html#191">simple methods, 177–180</a><br/>
<a href="Rubys.html#318">Ruby platform, 304–387</a><br/>
<a href="Rubys.html#60">single quotes ('), using for string literals, 46</a><br/>
<a href="Rubys.html#25">ruby-lang.org, 11</a><br/>
<a href="Rubys.html#60">single-quoted string literals, 46</a><br/>
<a href="Rubys.html#28">RubyGems, 14, 254</a><br/>
<a href="Rubys.html#260">singleton classes, 246</a><br/>
<a href="Rubys.html#28">-rubygems command-line option, 14</a><br/>
<a href="Rubys.html#20">singleton methods, 6, 73, 179, 257–258</a><br/>
<a href="Rubys.html#28">RUBYOPT environment variable, 14, 390</a><br/>
<a href="Rubys.html#287">singleton_methods method (Object), 273</a><br/>
<a href="Rubys.html#410">RUBY_PATCHLEVEL constant, 396</a><br/>
<a href="Rubys.html#78">size method (Array), 64</a><br/>
<a href="Rubys.html#410">RUBY_PLATFORM constant, 396</a><br/>
<a href="Rubys.html#70">size method (String), 56, 59</a><br/>
<a href="Rubys.html#410">RUBY_RELEASE_DATE constant, 396</a><br/>
<a href="Rubys.html#399">SizedQueue data structures, 385</a><br/>
<a href="Rubys.html#411">RUBY_VERSION constant, 397</a><br/>
<a href="Rubys.html#51">SJIS, 37</a><br/>
<a href="Rubys.html#392">runnable threads, 378</a><br/>
<a href="Rubys.html#43">SJIS characters, 29</a><br/>
<a href="Rubys.html#106">rvalues, 92</a><br/>
slash (/)<br/>
<a href="Rubys.html#324">regular expressions and, 310</a><br/>
<b>428&#160;|&#160;Index</b><br/>
<hr/>
<a name=443></a><a href="Rubys.html#392">sleeping threads, 378</a><br/>
<a href="Rubys.html#40">structure of programs, 26–40</a><br/>
<a href="Rubys.html#332">slice method (String), 318</a><br/>
<a href="Rubys.html#333">sub method (String), 319</a><br/>
<a href="Rubys.html#19">slices (subarrays), 5</a><br/>
<a href="Rubys.html#333">sub! method (String), 319</a><br/>
<a href="Rubys.html#267">.so files, loading extensions, 253</a><br/>
<a href="Rubys.html#19">subarrays (slices), 5</a><br/>
<a href="Rubys.html#360">SortedSet class, 346</a><br/>
<a href="Rubys.html#248">subclassing, 234–241</a><br/>
<a href="Rubys.html#345">sort_by method (Enumerable), 331</a><br/>
<a href="Rubys.html#70">substrings, 56–58</a><br/>
<a href="Rubys.html#52">source encoding, 38</a><br/>
<a href="Rubys.html#83">succ method, 69</a><br/>
<a href="Rubys.html#63">space character (\s), 49</a><br/>
<a href="Rubys.html#31">Sudoku, 17</a><br/>
<a href="Rubys.html#46">spaces, 32</a><br/>
<a href="Rubys.html#21">suffixes punctuation, 7</a><br/>
<a href="Rubys.html#112">splat operator, 98</a><br/>
<a href="Rubys.html#252">super method, 238</a><br/>
<a href="Rubys.html#332">split method (String), 318</a><br/>
superclass method<br/>
<a href="Rubys.html#62">sprintf function, 48, 308</a><br/>
<a href="Rubys.html#291">hooks and, 277</a><br/>
<a href="Rubys.html#19">square-bracket array-index ([ ]), 5, 56, 60, 64,</a><br/>
<a href="Rubys.html#280">superclass method (Class), 266</a><br/>
<a href="Rubys.html#129">115</a><br/>
<a href="Rubys.html#140">switch statement, 126</a><br/>
<a href="Rubys.html#235">access to arrays/hashes, 221</a><br/>
<a href="Rubys.html#18">symbols, 4, 70, 209</a><br/>
<a href="Rubys.html#318">strings, indexing, 304</a><br/>
<a href="Rubys.html#297">synchronize method (Mutex), 283</a><br/>
<a href="Rubys.html#173">StandardError, 159, 235</a><br/>
synchronized<br/>
<a href="Rubys.html#128">statement modifiers, 114</a><br/>
<a href="Rubys.html#297">blocks, 283</a><br/>
<a href="Rubys.html#178">rescue keyword and, 164</a><br/>
<a href="Rubys.html#301">objects, 287</a><br/>
<a href="Rubys.html#46">statement terminators, 32</a><br/>
<a href="Rubys.html#47">syntactic structure, 33–35</a><br/>
<a href="Rubys.html#100">statements, 86, 118–172</a><br/>
<a href="Rubys.html#198">syntax, using parentheses and, 184</a><br/>
<a href="Rubys.html#413">$stderr global, 399</a><br/>
<a href="Rubys.html#377">sysread method, 363</a><br/>
<a href="Rubys.html#374">STDERR stream, 360, 397</a><br/>
<a href="Rubys.html#379">SystemCallException, 365</a><br/>
<a href="Rubys.html#413">$stdin global, 399<br/></a><a href="Rubys.html#372">STDIN stream, 358, 360, 397</a><br/>
<b>T</b><br/>
<a href="Rubys.html#413">$stdout global, 399<br/></a><a href="Rubys.html#372">STDOUT stream, 358, 360, 397</a><br/>
<a href="Rubys.html#61">\t (tab), 47, 49</a><br/>
<a href="Rubys.html#356">store method (Hash), 342</a><br/>
<a href="Rubys.html#408">-T option, 394</a><br/>
streams<br/>
<a href="Rubys.html#46">tab, 32, 49</a><br/>
<a href="Rubys.html#379">closing, flushing, and testing, 365</a><br/>
<a href="Rubys.html#61">\t escape, 47</a><br/>
<a href="Rubys.html#373">encoding and, 359</a><br/>
<a href="Rubys.html#82">tables (hash), 68</a><br/>
<a href="Rubys.html#370">opening, 356–359</a><br/>
<a href="Rubys.html#423">tainted data, 409</a><br/>
<a href="Rubys.html#374">reading from, 360–364</a><br/>
<a href="Rubys.html#98">tainted? method, 84</a><br/>
<a href="Rubys.html#413">text processing globals, 399</a><br/>
<a href="Rubys.html#346">take method (Enumerable), 332</a><br/>
<a href="Rubys.html#378">writing to, 364</a><br/>
<a href="Rubys.html#346">take_while method (Enumerable), 332</a><br/>
<a href="Rubys.html#60">String class, 46, 54, 304</a><br/>
<a href="Rubys.html#382">TCPServer class, 368</a><br/>
<a href="Rubys.html#92">=~ operator and, 78</a><br/>
<a href="Rubys.html#381">TCPSocket class, 367</a><br/>
<a href="Rubys.html#72">Enumerable module and, 58</a><br/>
<a href="Rubys.html#381">TCPSocket.open method, 367</a><br/>
<a href="Rubys.html#68">new method, 54</a><br/>
<a href="Rubys.html#393">terminated normally thread state, 379</a><br/>
<a href="Rubys.html#68">String.new method, 54</a><br/>
<a href="Rubys.html#393">terminated with exception thread state, 379</a><br/>
<a href="Rubys.html#90">StringIO class, 76, 358</a><br/>
<a href="Rubys.html#369">test method (Kernel), 355</a><br/>
<a href="Rubys.html#318">strings, 304–310</a><br/>
<a href="Rubys.html#60">text, 46–64, 308</a><br/>
<a href="Rubys.html#72">encodings, 58–64, 310</a><br/>
(see also strings)<br/>
<a href="Rubys.html#282">evaluating, 268–271</a><br/>
<a href="Rubys.html#322">formatting, 308</a><br/>
<a href="Rubys.html#322">formatting, 308</a><br/>
<a href="Rubys.html#413">global, 399</a><br/>
<a href="Rubys.html#72">iterating, 58</a><br/>
<a href="Rubys.html#407">text processing options, 393</a><br/>
<a href="Rubys.html#42">literals, 28, 46–54,&#160;</a><a href="Rubys.html#64">50</a><br/>
<a href="Rubys.html#98">thawing objects, 84</a><br/>
<a href="Rubys.html#68">operators, 54–56</a><br/>
Thread class<br/>
<a href="Rubys.html#332">pattern matching and, 318</a><br/>
<a href="Rubys.html#394">list method, 380<br/></a><a href="Rubys.html#180">new method, 166, 373</a><br/>
<b>Index&#160;|&#160;429</b><br/>
<hr/>
<a name=444></a><a href="Rubys.html#392">pass method, 378</a><br/>
<a href="Rubys.html#295">undefine_finalizer method (ObjectSpace), 281</a><br/>
<a href="Rubys.html#389">Thread.abort_on_exception method, 375</a><br/>
<a href="Rubys.html#193">undefining methods, 179</a><br/>
<a href="Rubys.html#180">Thread.new method, 166</a><br/>
underscore (_)<br/>
<a href="Rubys.html#394">ThreadGroup.list method, 380</a><br/>
<a href="Rubys.html#102">constants, 88</a><br/>
<a href="Rubys.html#387">threads, 373–387</a><br/>
<a href="Rubys.html#57">integer literals, using, 43</a><br/>
<a href="Rubys.html#396">exclusion and deadlock, 382</a><br/>
<a href="Rubys.html#376">ungetc method, 362</a><br/>
<a href="Rubys.html#180">of execution, 166</a><br/>
<a href="Rubys.html#389">unhandled exceptions, 375</a><br/>
<a href="Rubys.html#388">lifecycle, 374</a><br/>
Unicode<br/>
<a href="Rubys.html#297">safety, 283</a><br/>
<a href="Rubys.html#298">const_missing method and, 284</a><br/>
<a href="Rubys.html#391">scheduling, 377</a><br/>
<a href="Rubys.html#43">Unicode characters, 29</a><br/>
<a href="Rubys.html#392">states, 378</a><br/>
<a href="Rubys.html#61">escapes, 47, 50</a><br/>
<a href="Rubys.html#389">variables and, 375</a><br/>
<a href="Rubys.html#101">uninitialized variables, 87</a><br/>
<a href="Rubys.html#160">throw statement, 146, 153</a><br/>
<a href="Rubys.html#362">union method, 348</a><br/>
tilde (see ~)<br/>
<a href="Rubys.html#76">Universal Character Set (UCS), 62</a><br/>
<a href="Rubys.html#339">Time class, 325</a><br/>
<a href="Rubys.html#117">unless keyword, 103, 122</a><br/>
<a href="Rubys.html#17">times method, 3</a><br/>
<a href="Rubys.html#87">unreachable objects, 73</a><br/>
<a href="Rubys.html#144">times method (Integer), 130</a><br/>
<a href="Rubys.html#117">until keyword, 103</a><br/>
<a href="Rubys.html#40">tokens, 26</a><br/>
<a href="Rubys.html#142">modifiers, as, 128</a><br/>
<a href="Rubys.html#409">top-level environment, 395–403</a><br/>
<a href="Rubys.html#141">while loops and, 127</a><br/>
<a href="Rubys.html#411">TOPLEVEL_BINDING constant, 397</a><br/>
<a href="Rubys.html#294">untrace_var method (Kernel), 280</a><br/>
to_a method<br/>
<a href="Rubys.html#17">upto method, 3, 131</a><br/>
<a href="Rubys.html#349">arrays and, 335</a><br/>
<a href="Rubys.html#144">upto method (Integer), 130</a><br/>
<a href="Rubys.html#343">to_a method (Enumerable), 329</a><br/>
<a href="Rubys.html#43">UTF-8 encoding, 29, 37, 50, 320</a><br/>
<a href="Rubys.html#94">to_ary method, 80<br/></a><a href="Rubys.html#149">to_enum method, 135</a><br/>
<b>V</b><br/>
<a href="Rubys.html#94">to_hash method, 80<br/>to_int method, 80</a><br/>
<a href="Rubys.html#63">\v (vertical tab), 49</a><br/>
<a href="Rubys.html#365">to_path method, 351</a><br/>
<a href="Rubys.html#406">-v command-line option, 392</a><br/>
<a href="Rubys.html#223">to_proc method (Symbol), 209</a><br/>
<a href="Rubys.html#75">valid_encoding? method (String), 61</a><br/>
<a href="Rubys.html#96">to_s method, 82, 217, 346</a><br/>
<a href="Rubys.html#356">values, storing in hashes, 342</a><br/>
<a href="Rubys.html#93">to_s method (Object), 79</a><br/>
<a href="Rubys.html#200">variable-length argument lists and, 186</a><br/>
<a href="Rubys.html#361">to_set method (Enumerable), 347</a><br/>
<a href="Rubys.html#285">variables, 271–272</a><br/>
<a href="Rubys.html#85">to_sym method (String), 71</a><br/>
<a href="Rubys.html#172">$! (global), 158</a><br/>
<a href="Rubys.html#294">trace_var method (Kernel), 280</a><br/>
<a href="Rubys.html#107">assigning to, 93</a><br/>
<a href="Rubys.html#293">tracing, 279</a><br/>
<a href="Rubys.html#156">blocks and, 142</a><br/>
<a href="Rubys.html#411">TRUE constant, 397</a><br/>
<a href="Rubys.html#244">classes, 230</a><br/>
<a href="Rubys.html#86">true keyword, 72, 86</a><br/>
<a href="Rubys.html#22">instance, 8</a><br/>
<a href="Rubys.html#29">Try Ruby tutorial, 15</a><br/>
<a href="Rubys.html#200">method arguments and, 186</a><br/>
<a href="Rubys.html#173">TypeError, 159</a><br/>
<a href="Rubys.html#86">object references and, 72</a><br/>
<a href="Rubys.html#88">types (objects), 74, 266–268</a><br/>
<a href="Rubys.html#285">querying, setting, and testing, 271<br/></a><a href="Rubys.html#101">references, 87</a><br/>
<b>U</b><br/>
<a href="Rubys.html#215">shared, 201<br/></a><a href="Rubys.html#389">threads and, 375</a><br/>
<a href="Rubys.html#324">u (regular expression) modifier, 310</a><br/>
<a href="Rubys.html#101">uninitialized, 87</a><br/>
<a href="Rubys.html#61">\u (Unicode) escape, 47, 49</a><br/>
<a href="Rubys.html#338">Vector class, 324</a><br/>
<a href="Rubys.html#76">UCS (Universal Character Set), 62</a><br/>
<a href="Rubys.html#406">--verbose command-line option, 392</a><br/>
<a href="Rubys.html#383">UDPServer class, 369</a><br/>
<a href="Rubys.html#412">$VERBOSE global variable, 398</a><br/>
<a href="Rubys.html#117">unary +/–, 103, 209</a><br/>
<a href="Rubys.html#406">--version command-line option, 392</a><br/>
<a href="Rubys.html#218">UnboundMethod class, 204</a><br/>
<a href="Rubys.html#63">vertical tab (\v), 49</a><br/>
<a href="Rubys.html#193">undef keyword, 179</a><br/>
<b>430&#160;|&#160;Index</b><br/>
<hr/>
<a name=445></a><b>W<br/></b><a href="Rubys.html#328">\W (nonword) regexp character class, 314<br/>\w (word) regexp character class, 314<br/></a><a href="Rubys.html#371">&#34;w&#34; (writing) file mode, 357<br/></a><a href="Rubys.html#405">-w command-line option, 391<br/></a><a href="Rubys.html#406">-W command-line option, 392<br/></a><a href="Rubys.html#371">&#34;w+&#34; (writing and reading) file mode, 357<br/></a><a href="Rubys.html#406">-W0 command-line option, 392<br/>-W2 command-line option, 392<br/></a><a href="Rubys.html#295">weak reference objects, 281<br/></a><a href="Rubys.html#138">when keyword, 124<br/></a><a href="Rubys.html#117">while keyword, 103<br/></a><a href="Rubys.html#17">while loops, 3, 5, 127</a><br/>
<a href="Rubys.html#142">modifiers, as, 128<br/></a><a href="Rubys.html#166">retry statements and, 152</a><br/>
<a href="Rubys.html#46">whitespace, 32<br/></a><a href="Rubys.html#344">with_index (Enumerable), 330<br/></a><a href="Rubys.html#150">with_index method, 136</a><br/>
<b>X<br/></b><a href="Rubys.html#324">x (regular expression) modifier, 310<br/></a><a href="Rubys.html#408">-X option, 394<br/></a><a href="Rubys.html#409">-x option, 395<br/></a><a href="Rubys.html#67">%x syntax, 53<br/></a>XML, using method_missing method and,<br/>
<a href="Rubys.html#310">296</a><br/>
<b>Y</b><br/>
&#160;<br/>
<a href="Rubys.html#97">YAML, 83<br/></a><a href="Rubys.html#25">YARV, 11<br/></a><a href="Rubys.html#144">yield statement, 130</a><br/>
<a href="Rubys.html#156">blocks and, 142, 189<br/></a><a href="Rubys.html#236">coordinates, enumerating, 222<br/></a><a href="Rubys.html#147">custom iterators, writing, 133<br/></a><a href="Rubys.html#104">method invocations and, 90</a><br/>
<b>Z<br/></b><a href="Rubys.html#329">\Z regexp anchor, 315<br/>\z regexp anchor, 315<br/></a><a href="Rubys.html#58">ZeroDivisionError, 44<br/></a><a href="Rubys.html#343">zip method (Enumerable), 329</a><br/>
<b>Index&#160;|&#160;431</b><br/>
<hr/>
<a name=446></a><hr/>
<a name=447></a><b>About the Authors<br/>David&#160;Flanagan</b>&#160;is&#160;a&#160;computer&#160;programmer&#160;who&#160;spends&#160;most&#160;of&#160;his&#160;time&#160;writing&#160;about<br/>programming&#160;languages.&#160;His&#160;other&#160;books&#160;with&#160;O’Reilly&#160;include&#160;<i>JavaScript:&#160;The&#160;Defin-<br/>itive&#160;&#160;Guide</i>&#160;&#160;and&#160;&#160;<i>Java&#160;&#160;in&#160;&#160;a&#160;&#160;Nutshell</i>.&#160;&#160;David&#160;&#160;has&#160;&#160;a&#160;&#160;degree&#160;&#160;in&#160;&#160;computer&#160;&#160;science&#160;&#160;and<br/>engineering&#160;from&#160;the&#160;Massachusetts&#160;Institute&#160;of&#160;Technology.&#160;He&#160;lives&#160;with&#160;his&#160;wife&#160;and<br/>children&#160;in&#160;the&#160;U.S.&#160;Pacific&#160;Northwest&#160;between&#160;the&#160;cities&#160;of&#160;Seattle,&#160;Washington,&#160;and<br/>Vancouver, British Columbia.<br/><b>Yukihiro&#160;Matsumoto&#160;</b>(“Matz”),&#160;the&#160;creator&#160;of&#160;Ruby,&#160;is&#160;a&#160;professional&#160;programmer<br/>who&#160;worked&#160;for&#160;the&#160;Japanese&#160;open&#160;source&#160;company&#160;netlab.jp.&#160;Matz&#160;is&#160;also&#160;known&#160;as<br/>one&#160;of&#160;the&#160;open&#160;source&#160;evangelists&#160;in&#160;Japan.&#160;He’s&#160;released&#160;several&#160;open&#160;source&#160;products,<br/>including&#160;cmail,&#160;the&#160;Emacs-based&#160;mail&#160;user&#160;agent,&#160;written&#160;entirely&#160;in&#160;Emacs&#160;lisp.&#160;Ruby<br/>is his first piece of software that has become known outside of Japan.<br/>
<b>Colophon<br/></b>The&#160;animals&#160;on&#160;the&#160;cover&#160;of&#160;<i>The&#160;Ruby&#160;Programming&#160;Language</i>&#160;are&#160;Horned&#160;Sungem<br/>hummingbirds&#160;(<i>Heliactin&#160;bilophus</i>).&#160;These&#160;small&#160;birds&#160;are&#160;native&#160;to&#160;South&#160;America,<br/>living&#160;mainly&#160;in&#160;Brazil&#160;and&#160;Bolivia.&#160;They&#160;prefer&#160;dry,&#160;open&#160;habitats&#160;such&#160;as&#160;grasslands,<br/>and they avoid dense or humid forests.<br/>Hummingbirds&#160;have&#160;the&#160;fastest&#160;wingbeat&#160;of&#160;all&#160;birds,&#160;and&#160;the&#160;Horned&#160;Sungem&#160;is&#160;capable<br/>of&#160;90&#160;wingbeats&#160;per&#160;second.&#160;(Contrast&#160;that&#160;with&#160;the&#160;vulture,&#160;the&#160;slowest&#160;of&#160;all&#160;birds,<br/>capable&#160;of&#160;just&#160;1&#160;wingbeat&#160;per&#160;second.)&#160;Because&#160;hummingbirds&#160;are&#160;so&#160;fast&#160;and&#160;light,<br/>they&#160;are&#160;able&#160;to&#160;hover&#160;in&#160;mid-air&#160;by&#160;rapidly&#160;flapping&#160;their&#160;wings.&#160;They&#160;can&#160;also&#160;fly<br/>backward&#160;(the&#160;only&#160;birds&#160;who&#160;can&#160;do&#160;so)&#160;in&#160;order&#160;to&#160;keep&#160;position&#160;as&#160;they&#160;drink&#160;nectar<br/>from&#160;flowers.&#160;Their&#160;long,&#160;thin&#160;bills&#160;allow&#160;them&#160;to&#160;reach&#160;deep&#160;within&#160;blossoms.&#160;Fittingly,<br/>the&#160;Portuguese&#160;word&#160;for&#160;hummingbird&#160;is&#160;<i>beija-flor</i>,&#160;or&#160;“flower&#160;kisser.”&#160;The&#160;English<br/>word, of course, comes from the hum made by its fast-moving wings.<br/>The&#160;male&#160;Horned&#160;Sungem&#160;has&#160;tufts&#160;of&#160;red,&#160;blue,&#160;and&#160;gold&#160;feathers&#160;on&#160;either&#160;side&#160;of&#160;its<br/>head.&#160;Its&#160;back&#160;is&#160;iridescent&#160;green,&#160;its&#160;throat&#160;and&#160;breast&#160;are&#160;black,&#160;and&#160;its&#160;belly&#160;is&#160;white.<br/>It&#160;has&#160;a&#160;long,&#160;pointed&#160;tail.&#160;The&#160;female&#160;looks&#160;similar&#160;to&#160;the&#160;male&#160;but&#160;lacks&#160;the&#160;dramatic<br/>crown&#160;pattern.&#160;Because&#160;of&#160;the&#160;hummingbird’s&#160;vibrant&#160;colors,&#160;early&#160;Spanish&#160;explorers<br/>named it&#160;<i>Joyas voladoras</i>, or “flying jewel.”<br/>There&#160;are&#160;many&#160;myths&#160;about&#160;hummingbirds.&#160;In&#160;Brazil,&#160;a&#160;black&#160;hummingbird&#160;is&#160;a&#160;sign<br/>of&#160;&#160;a&#160;&#160;death&#160;&#160;in&#160;&#160;the&#160;&#160;family.&#160;&#160;The&#160;&#160;ancient&#160;&#160;Aztecs&#160;&#160;honored&#160;&#160;them,&#160;&#160;and&#160;&#160;priests&#160;&#160;used&#160;&#160;staffs<br/>covered&#160;with&#160;their&#160;feathers&#160;to&#160;remove&#160;curses.&#160;The&#160;hummingbird&#160;is&#160;also&#160;a&#160;symbol&#160;of<br/>resurrection,&#160;as&#160;Aztecs&#160;believed&#160;that&#160;dead&#160;warriors&#160;were&#160;reincarnated&#160;as&#160;these&#160;birds.<br/>The&#160;Aztec&#160;god&#160;of&#160;the&#160;Sun&#160;and&#160;war,&#160;Huitzilopochtli,&#160;was&#160;represented&#160;as&#160;one;&#160;his&#160;name<br/>means&#160;“Hummingbird&#160;from&#160;the&#160;south,”&#160;the&#160;south&#160;being&#160;the&#160;location&#160;of&#160;the&#160;spirit&#160;world.<br/>
<hr/>
<a name=448></a>The&#160;cover&#160;image&#160;is&#160;from&#160;J.&#160;G.&#160;Wood’s&#160;<i>Animate&#160;Creation</i>.&#160;The&#160;cover&#160;font&#160;is&#160;Adobe’s&#160;ITC<br/>Garamond.&#160;The&#160;text&#160;font&#160;is&#160;Linotype&#160;Birka,&#160;the&#160;heading&#160;font&#160;is&#160;Adobe&#160;Myriad&#160;Con-<br/>densed, and the code font is LucasFont’s TheSans Mono Condensed.<br/>
<hr/>
<a name="outline"></a><h1>Document Outline</h1>
<ul>
<li><a href="Rubys.html#7">Table of Contents</a></li>
<li><a href="Rubys.html#11">Preface</a>
<ul>
<li><a href="Rubys.html#11">Acknowledgments</a>
<ul>
<li><a href="Rubys.html#11">David Flanagan</a></li>
<li><a href="Rubys.html#12">Yukihiro Matsumoto</a></li>
</ul>
</li>
<li><a href="Rubys.html#12">Conventions Used in This Book</a></li>
<li><a href="Rubys.html#12">Using Code Examples</a></li>
<li><a href="Rubys.html#13">How to Contact Us</a></li>
<li><a href="Rubys.html#13">Safari® Enabled</a></li>
</ul>
</li>
<li><a href="Rubys.html#15">Chapter 1. Introduction</a>
<ul>
<li><a href="Rubys.html#16">1.1  A Tour of Ruby</a>
<ul>
<li><a href="Rubys.html#16">1.1.1  Ruby Is Object-Oriented</a></li>
<li><a href="Rubys.html#17">1.1.2  Blocks and Iterators</a></li>
<li><a href="Rubys.html#18">1.1.3  Expressions and Operators in Ruby</a></li>
<li><a href="Rubys.html#19">1.1.4  Methods</a></li>
<li><a href="Rubys.html#20">1.1.5  Assignment</a></li>
<li><a href="Rubys.html#21">1.1.6  Punctuation Suffixes and Prefixes</a></li>
<li><a href="Rubys.html#21">1.1.7  Regexp and Range</a></li>
<li><a href="Rubys.html#22">1.1.8  Classes and Modules</a></li>
<li><a href="Rubys.html#24">1.1.9  Ruby Surprises</a></li>
</ul>
</li>
<li><a href="Rubys.html#25">1.2  Try Ruby</a>
<ul>
<li><a href="Rubys.html#25">1.2.1  The Ruby Interpreter</a></li>
<li><a href="Rubys.html#26">1.2.2  Displaying Output</a></li>
<li><a href="Rubys.html#27">1.2.3  Interactive Ruby with irb</a></li>
<li><a href="Rubys.html#27">1.2.4  Viewing Ruby Documentation with ri</a></li>
<li><a href="Rubys.html#28">1.2.5  Ruby Package Management with gem</a></li>
<li><a href="Rubys.html#29">1.2.6  More Ruby Tutorials</a></li>
<li><a href="Rubys.html#29">1.2.7  Ruby Resources</a></li>
</ul>
</li>
<li><a href="Rubys.html#29">1.3  About This Book</a>
<ul>
<li><a href="Rubys.html#31">1.3.1  How to Read This Book</a></li>
</ul>
</li>
<li><a href="Rubys.html#31">1.4  A Sudoku Solver in Ruby</a></li>
</ul>
</li>
<li><a href="Rubys.html#39">Chapter 2. The Structure and Execution of Ruby Programs</a>
<ul>
<li><a href="Rubys.html#40">2.1  Lexical Structure</a>
<ul>
<li><a href="Rubys.html#40">2.1.1  Comments</a>
<ul>
<li><a href="Rubys.html#40">2.1.1.1  Embedded documents</a></li>
<li><a href="Rubys.html#41">2.1.1.2  Documentation comments</a></li>
</ul>
</li>
<li><a href="Rubys.html#42">2.1.2  Literals</a></li>
<li><a href="Rubys.html#42">2.1.3  Punctuation</a></li>
<li><a href="Rubys.html#42">2.1.4  Identifiers</a>
<ul>
<li><a href="Rubys.html#43">2.1.4.1  Case sensitivity</a></li>
<li><a href="Rubys.html#43">2.1.4.2  Unicode characters in identifiers</a></li>
<li><a href="Rubys.html#44">2.1.4.3  Punctuation in identifiers</a></li>
</ul>
</li>
<li><a href="Rubys.html#44">2.1.5  Keywords</a></li>
<li><a href="Rubys.html#46">2.1.6  Whitespace</a>
<ul>
<li><a href="Rubys.html#46">2.1.6.1  Newlines as statement terminators</a></li>
<li><a href="Rubys.html#47">2.1.6.2  Spaces and method invocations</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="Rubys.html#47">2.2  Syntactic Structure</a>
<ul>
<li><a href="Rubys.html#49">2.2.1  Block Structure in Ruby</a></li>
</ul>
</li>
<li><a href="Rubys.html#49">2.3  File Structure</a></li>
<li><a href="Rubys.html#50">2.4  Program Encoding</a>
<ul>
<li><a href="Rubys.html#51">2.4.1  Specifying Program Encoding</a></li>
<li><a href="Rubys.html#52">2.4.2  Source, External, and Internal Encodings</a></li>
</ul>
</li>
<li><a href="Rubys.html#53">2.5  Program Execution</a></li>
</ul>
</li>
<li><a href="Rubys.html#55">Chapter 3. Datatypes and Objects</a>
<ul>
<li><a href="Rubys.html#56">3.1  Numbers</a>
<ul>
<li><a href="Rubys.html#57">3.1.1  Integer Literals</a></li>
<li><a href="Rubys.html#57">3.1.2  Floating-Point Literals</a></li>
<li><a href="Rubys.html#58">3.1.3  Arithmetic in Ruby</a></li>
<li><a href="Rubys.html#59">3.1.4  Binary Floating-Point and Rounding Errors</a></li>
</ul>
</li>
<li><a href="Rubys.html#60">3.2  Text</a>
<ul>
<li><a href="Rubys.html#60">3.2.1  String Literals</a>
<ul>
<li><a href="Rubys.html#60">3.2.1.1  Single-quoted string literals</a></li>
<li><a href="Rubys.html#61">3.2.1.2  Double-quoted string literals</a></li>
<li><a href="Rubys.html#64">3.2.1.3  Unicode escapes</a></li>
<li><a href="Rubys.html#64">3.2.1.4  Arbitrary delimiters for string literals</a></li>
<li><a href="Rubys.html#65">3.2.1.5  Here documents</a></li>
<li><a href="Rubys.html#67">3.2.1.6  Backtick command execution</a></li>
<li><a href="Rubys.html#67">3.2.1.7  String literals and mutability</a></li>
<li><a href="Rubys.html#68">3.2.1.8  The String.new method</a></li>
</ul>
</li>
<li><a href="Rubys.html#68">3.2.2  Character Literals</a></li>
<li><a href="Rubys.html#68">3.2.3  String Operators</a></li>
<li><a href="Rubys.html#70">3.2.4  Accessing Characters and Substrings</a></li>
<li><a href="Rubys.html#72">3.2.5  Iterating Strings</a></li>
<li><a href="Rubys.html#72">3.2.6  String Encodings and Multibyte Characters</a>
<ul>
<li><a href="Rubys.html#73">3.2.6.1  Multibyte characters in Ruby 1.9</a></li>
<li><a href="Rubys.html#76">3.2.6.2  The Encoding class</a></li>
<li><a href="Rubys.html#77">3.2.6.3  Multibyte characters in Ruby 1.8</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="Rubys.html#78">3.3  Arrays</a></li>
<li><a href="Rubys.html#81">3.4  Hashes</a>
<ul>
<li><a href="Rubys.html#81">3.4.1  Hash Literals</a></li>
<li><a href="Rubys.html#82">3.4.2  Hash Codes, Equality, and Mutable Keys</a></li>
</ul>
</li>
<li><a href="Rubys.html#82">3.5  Ranges</a>
<ul>
<li><a href="Rubys.html#83">3.5.1  Testing Membership in a Range</a></li>
</ul>
</li>
<li><a href="Rubys.html#84">3.6  Symbols</a></li>
<li><a href="Rubys.html#86">3.7  True, False, and Nil</a></li>
<li><a href="Rubys.html#86">3.8  Objects</a>
<ul>
<li><a href="Rubys.html#86">3.8.1  Object References</a>
<ul>
<li><a href="Rubys.html#87">3.8.1.1  Immediate values</a></li>
</ul>
</li>
<li><a href="Rubys.html#87">3.8.2  Object Lifetime</a></li>
<li><a href="Rubys.html#88">3.8.3  Object Identity</a></li>
<li><a href="Rubys.html#88">3.8.4  Object Class and Object Type</a></li>
<li><a href="Rubys.html#90">3.8.5  Object Equality</a>
<ul>
<li><a href="Rubys.html#90">3.8.5.1  The equal? method</a></li>
<li><a href="Rubys.html#90">3.8.5.2  The == operator</a></li>
<li><a href="Rubys.html#91">3.8.5.3  The eql? method</a></li>
<li><a href="Rubys.html#91">3.8.5.4  The === operator</a></li>
<li><a href="Rubys.html#92">3.8.5.5  The =~ operator</a></li>
</ul>
</li>
<li><a href="Rubys.html#92">3.8.6  Object Order</a></li>
<li><a href="Rubys.html#93">3.8.7  Object Conversion</a>
<ul>
<li><a href="Rubys.html#93">3.8.7.1  Explicit conversions</a></li>
<li><a href="Rubys.html#94">3.8.7.2  Implicit conversions</a></li>
<li><a href="Rubys.html#95">3.8.7.3  Conversion functions</a></li>
<li><a href="Rubys.html#95">3.8.7.4  Arithmetic operator type coercions</a></li>
<li><a href="Rubys.html#96">3.8.7.5  Boolean type conversions</a></li>
</ul>
</li>
<li><a href="Rubys.html#96">3.8.8  Copying Objects</a></li>
<li><a href="Rubys.html#97">3.8.9  Marshaling Objects</a></li>
<li><a href="Rubys.html#98">3.8.10  Freezing Objects</a></li>
<li><a href="Rubys.html#98">3.8.11  Tainted and Untrusted Objects</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="Rubys.html#99">Chapter 4. Expressions and Operators</a>
<ul>
<li><a href="Rubys.html#100">4.1  Literals and Keyword Literals</a></li>
<li><a href="Rubys.html#101">4.2  Variable References</a>
<ul>
<li><a href="Rubys.html#101">4.2.1  Uninitialized Variables</a></li>
</ul>
</li>
<li><a href="Rubys.html#102">4.3  Constant References</a></li>
<li><a href="Rubys.html#103">4.4  Method Invocations</a></li>
<li><a href="Rubys.html#106">4.5  Assignments</a>
<ul>
<li><a href="Rubys.html#107">4.5.1  Assigning to Variables</a></li>
<li><a href="Rubys.html#108">4.5.2  Assigning to Constants</a></li>
<li><a href="Rubys.html#108">4.5.3  Assigning to Attributes and Array Elements</a></li>
<li><a href="Rubys.html#109">4.5.4  Abbreviated Assignment</a></li>
<li><a href="Rubys.html#111">4.5.5  Parallel Assignment</a>
<ul>
<li><a href="Rubys.html#111">4.5.5.1  Same number of lvalues and rvalues</a></li>
<li><a href="Rubys.html#111">4.5.5.2  One lvalue, multiple rvalues</a></li>
<li><a href="Rubys.html#112">4.5.5.3  Multiple lvalues, single array rvalue</a></li>
<li><a href="Rubys.html#112">4.5.5.4  Different numbers of lvalues and rvalues</a></li>
<li><a href="Rubys.html#112">4.5.5.5  The splat operator</a></li>
<li><a href="Rubys.html#113">4.5.5.6  Parentheses in parallel assignment</a></li>
<li><a href="Rubys.html#114">4.5.5.7  The value of parallel assignment</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="Rubys.html#114">4.6  Operators</a>
<ul>
<li><a href="Rubys.html#117">4.6.1  Unary + and –</a></li>
<li><a href="Rubys.html#117">4.6.2  Exponentiation: **</a></li>
<li><a href="Rubys.html#117">4.6.3  Arithmetic: +, –, *, /, and %</a></li>
<li><a href="Rubys.html#118">4.6.4  Shift and Append: &lt;&lt; and &gt;&gt;</a></li>
<li><a href="Rubys.html#118">4.6.5  Complement, Union, Intersection: ~, &amp;, |, and ^</a></li>
<li><a href="Rubys.html#119">4.6.6  Comparison: &lt;, &lt;=, &gt;, &gt;=, and &lt;=&gt;</a></li>
<li><a href="Rubys.html#120">4.6.7  Equality: ==, !=, =~, !~, and ===</a></li>
<li><a href="Rubys.html#121">4.6.8  Boolean Operators: &amp;&amp;, ||, !, and, or, not</a></li>
<li><a href="Rubys.html#123">4.6.9  Ranges and Flip-Flops: .. and ...</a>
<ul>
<li><a href="Rubys.html#123">4.6.9.1  Boolean flip-flops</a></li>
</ul>
</li>
<li><a href="Rubys.html#125">4.6.10  Conditional: ?:</a></li>
<li><a href="Rubys.html#126">4.6.11  Assignment Operators</a></li>
<li><a href="Rubys.html#127">4.6.12  The defined? Operator</a></li>
<li><a href="Rubys.html#128">4.6.13  Statement Modifiers</a></li>
<li><a href="Rubys.html#128">4.6.14  Nonoperators</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="Rubys.html#131">Chapter 5. Statements and Control Structures</a>
<ul>
<li><a href="Rubys.html#132">5.1  Conditionals</a>
<ul>
<li><a href="Rubys.html#132">5.1.1  if</a>
<ul>
<li><a href="Rubys.html#133">5.1.1.1  else</a></li>
<li><a href="Rubys.html#134">5.1.1.2  elsif</a></li>
<li><a href="Rubys.html#134">5.1.1.3  Return value</a></li>
</ul>
</li>
<li><a href="Rubys.html#135">5.1.2  if As a Modifier</a></li>
<li><a href="Rubys.html#136">5.1.3  unless</a></li>
<li><a href="Rubys.html#137">5.1.4  case</a></li>
<li><a href="Rubys.html#141">5.1.5  The ?: Operator</a></li>
</ul>
</li>
<li><a href="Rubys.html#141">5.2  Loops</a>
<ul>
<li><a href="Rubys.html#141">5.2.1  while and until</a></li>
<li><a href="Rubys.html#142">5.2.2  while and until As Modifiers</a></li>
<li><a href="Rubys.html#143">5.2.3  The for/in Loop</a></li>
</ul>
</li>
<li><a href="Rubys.html#144">5.3  Iterators and Enumerable Objects</a>
<ul>
<li><a href="Rubys.html#145">5.3.1  Numeric Iterators</a></li>
<li><a href="Rubys.html#146">5.3.2  Enumerable Objects</a></li>
<li><a href="Rubys.html#147">5.3.3  Writing Custom Iterators</a></li>
<li><a href="Rubys.html#149">5.3.4  Enumerators</a></li>
<li><a href="Rubys.html#151">5.3.5  External Iterators</a></li>
<li><a href="Rubys.html#154">5.3.6  Iteration and Concurrent Modification</a></li>
</ul>
</li>
<li><a href="Rubys.html#154">5.4  Blocks</a>
<ul>
<li><a href="Rubys.html#155">5.4.1  Block Syntax</a></li>
<li><a href="Rubys.html#155">5.4.2  The Value of a Block</a></li>
<li><a href="Rubys.html#156">5.4.3  Blocks and Variable Scope</a></li>
<li><a href="Rubys.html#157">5.4.4  Passing Arguments to a Block</a></li>
<li><a href="Rubys.html#159">5.4.5  Block Parameters in Ruby 1.9</a></li>
</ul>
</li>
<li><a href="Rubys.html#160">5.5  Altering Control Flow</a>
<ul>
<li><a href="Rubys.html#160">5.5.1  return</a></li>
<li><a href="Rubys.html#162">5.5.2  break</a>
<ul>
<li><a href="Rubys.html#162">5.5.2.1  break with a value</a></li>
</ul>
</li>
<li><a href="Rubys.html#163">5.5.3  next</a>
<ul>
<li><a href="Rubys.html#164">5.5.3.1  next and block value</a></li>
</ul>
</li>
<li><a href="Rubys.html#165">5.5.4  redo</a></li>
<li><a href="Rubys.html#166">5.5.5  retry</a></li>
<li><a href="Rubys.html#167">5.5.6  throw and catch</a></li>
</ul>
</li>
<li><a href="Rubys.html#168">5.6  Exceptions and Exception Handling</a>
<ul>
<li><a href="Rubys.html#169">5.6.1  Exception Classes and Exception Objects</a>
<ul>
<li><a href="Rubys.html#170">5.6.1.1  The methods of exception objects</a></li>
<li><a href="Rubys.html#170">5.6.1.2  Creating exception objects</a></li>
<li><a href="Rubys.html#170">5.6.1.3  Defining new exception classes</a></li>
</ul>
</li>
<li><a href="Rubys.html#170">5.6.2  Raising Exceptions with raise</a></li>
<li><a href="Rubys.html#172">5.6.3  Handling Exceptions with rescue</a>
<ul>
<li><a href="Rubys.html#172">5.6.3.1  Naming the exception object</a></li>
<li><a href="Rubys.html#173">5.6.3.2  Handling exceptions by type</a></li>
<li><a href="Rubys.html#174">5.6.3.3  Propagation of exceptions</a></li>
<li><a href="Rubys.html#175">5.6.3.4  Exceptions during exception handling</a></li>
<li><a href="Rubys.html#175">5.6.3.5  retry in a rescue clause</a></li>
</ul>
</li>
<li><a href="Rubys.html#176">5.6.4  The else Clause</a></li>
<li><a href="Rubys.html#176">5.6.5  The ensure Clause</a></li>
<li><a href="Rubys.html#178">5.6.6  rescue with Method, Class, and Module Definitions</a></li>
<li><a href="Rubys.html#178">5.6.7  rescue As a Statement Modifier</a></li>
</ul>
</li>
<li><a href="Rubys.html#179">5.7  BEGIN and END</a></li>
<li><a href="Rubys.html#180">5.8  Threads, Fibers, and Continuations</a>
<ul>
<li><a href="Rubys.html#180">5.8.1  Threads for Concurrency</a></li>
<li><a href="Rubys.html#181">5.8.2  Fibers for Coroutines</a>
<ul>
<li><a href="Rubys.html#182">5.8.2.1  Fiber arguments and return values</a></li>
<li><a href="Rubys.html#183">5.8.2.2  Implementing generators with fibers</a></li>
<li><a href="Rubys.html#185">5.8.2.3  Advanced fiber features</a></li>
</ul>
</li>
<li><a href="Rubys.html#186">5.8.3  Continuations</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="Rubys.html#189">Chapter 6. Methods, Procs, Lambdas, and Closures</a>
<ul>
<li><a href="Rubys.html#191">6.1  Defining Simple Methods</a>
<ul>
<li><a href="Rubys.html#191">6.1.1  Method Return Value</a></li>
<li><a href="Rubys.html#192">6.1.2  Methods and Exception Handling</a></li>
<li><a href="Rubys.html#192">6.1.3  Invoking a Method on an Object</a></li>
<li><a href="Rubys.html#193">6.1.4  Defining Singleton Methods</a></li>
<li><a href="Rubys.html#193">6.1.5  Undefining Methods</a></li>
</ul>
</li>
<li><a href="Rubys.html#194">6.2  Method Names</a>
<ul>
<li><a href="Rubys.html#195">6.2.1  Operator Methods</a></li>
<li><a href="Rubys.html#195">6.2.2  Method Aliases</a></li>
</ul>
</li>
<li><a href="Rubys.html#197">6.3  Methods and Parentheses</a>
<ul>
<li><a href="Rubys.html#197">6.3.1  Optional Parentheses</a></li>
<li><a href="Rubys.html#198">6.3.2  Required Parentheses</a></li>
</ul>
</li>
<li><a href="Rubys.html#199">6.4  Method Arguments</a>
<ul>
<li><a href="Rubys.html#199">6.4.1  Parameter Defaults</a></li>
<li><a href="Rubys.html#200">6.4.2  Variable-Length Argument Lists and Arrays</a>
<ul>
<li><a href="Rubys.html#201">6.4.2.1  Passing arrays to methods</a></li>
</ul>
</li>
<li><a href="Rubys.html#202">6.4.3  Mapping Arguments to Parameters</a></li>
<li><a href="Rubys.html#202">6.4.4  Hashes for Named Arguments</a></li>
<li><a href="Rubys.html#203">6.4.5  Block Arguments</a>
<ul>
<li><a href="Rubys.html#205">6.4.5.1  Using &amp; in method invocation</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="Rubys.html#206">6.5  Procs and Lambdas</a>
<ul>
<li><a href="Rubys.html#206">6.5.1  Creating Procs</a>
<ul>
<li><a href="Rubys.html#207">6.5.1.1  Proc.new</a></li>
<li><a href="Rubys.html#207">6.5.1.2  Kernel.lambda</a></li>
<li><a href="Rubys.html#208">6.5.1.3  Kernel.proc</a></li>
<li><a href="Rubys.html#208">6.5.1.4  Lambda Literals</a></li>
</ul>
</li>
<li><a href="Rubys.html#209">6.5.2  Invoking Procs and Lambdas</a></li>
<li><a href="Rubys.html#210">6.5.3  The Arity of a Proc</a></li>
<li><a href="Rubys.html#211">6.5.4  Proc Equality</a></li>
<li><a href="Rubys.html#211">6.5.5  How Lambdas Differ from Procs</a>
<ul>
<li><a href="Rubys.html#211">6.5.5.1  Return in blocks, procs, and lambdas</a></li>
<li><a href="Rubys.html#213">6.5.5.2  Break in blocks, procs and lambdas</a></li>
<li><a href="Rubys.html#213">6.5.5.3  Other control-flow statements</a></li>
<li><a href="Rubys.html#214">6.5.5.4  Argument passing to procs and lambdas</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="Rubys.html#214">6.6  Closures</a>
<ul>
<li><a href="Rubys.html#215">6.6.1  Closures and Shared Variables</a></li>
<li><a href="Rubys.html#216">6.6.2  Closures and Bindings</a></li>
</ul>
</li>
<li><a href="Rubys.html#217">6.7  Method Objects</a>
<ul>
<li><a href="Rubys.html#218">6.7.1  Unbound Method Objects</a></li>
</ul>
</li>
<li><a href="Rubys.html#219">6.8  Functional Programming</a>
<ul>
<li><a href="Rubys.html#219">6.8.1  Applying a Function to an Enumerable</a></li>
<li><a href="Rubys.html#221">6.8.2  Composing Functions</a></li>
<li><a href="Rubys.html#221">6.8.3  Partially Applying Functions</a></li>
<li><a href="Rubys.html#222">6.8.4  Memoizing Functions</a></li>
<li><a href="Rubys.html#223">6.8.5  Symbols, Methods, and Procs</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="Rubys.html#227">Chapter 7. Classes and Modules</a>
<ul>
<li><a href="Rubys.html#228">7.1  Defining a Simple Class</a>
<ul>
<li><a href="Rubys.html#229">7.1.1  Creating the Class</a></li>
<li><a href="Rubys.html#229">7.1.2  Instantiating a Point</a></li>
<li><a href="Rubys.html#229">7.1.3  Initializing a Point</a></li>
<li><a href="Rubys.html#231">7.1.4  Defining a to_s Method</a></li>
<li><a href="Rubys.html#231">7.1.5  Accessors and Attributes</a></li>
<li><a href="Rubys.html#233">7.1.6  Defining Operators</a></li>
<li><a href="Rubys.html#235">7.1.7  Array and Hash Access with [ ]</a></li>
<li><a href="Rubys.html#236">7.1.8  Enumerating Coordinates</a></li>
<li><a href="Rubys.html#236">7.1.9  Point Equality</a></li>
<li><a href="Rubys.html#239">7.1.10  Ordering Points</a></li>
<li><a href="Rubys.html#240">7.1.11  A Mutable Point</a></li>
<li><a href="Rubys.html#240">7.1.12  Quick and Easy Mutable Classes</a></li>
<li><a href="Rubys.html#242">7.1.13  A Class Method</a></li>
<li><a href="Rubys.html#243">7.1.14  Constants</a></li>
<li><a href="Rubys.html#244">7.1.15  Class Variables</a></li>
<li><a href="Rubys.html#245">7.1.16  Class Instance Variables</a></li>
</ul>
</li>
<li><a href="Rubys.html#246">7.2  Method Visibility: Public, Protected, Private</a></li>
<li><a href="Rubys.html#248">7.3  Subclassing and Inheritance</a>
<ul>
<li><a href="Rubys.html#249">7.3.1  Inheriting Methods</a></li>
<li><a href="Rubys.html#250">7.3.2  Overriding Methods</a>
<ul>
<li><a href="Rubys.html#252">7.3.2.1  Overriding private methods</a></li>
</ul>
</li>
<li><a href="Rubys.html#252">7.3.3  Augmenting Behavior by Chaining</a></li>
<li><a href="Rubys.html#253">7.3.4  Inheritance of Class Methods</a></li>
<li><a href="Rubys.html#253">7.3.5  Inheritance and Instance Variables</a></li>
<li><a href="Rubys.html#254">7.3.6  Inheritance and Class Variables</a></li>
<li><a href="Rubys.html#255">7.3.7  Inheritance of Constants</a></li>
</ul>
</li>
<li><a href="Rubys.html#255">7.4  Object Creation and Initialization</a>
<ul>
<li><a href="Rubys.html#256">7.4.1  new, allocate, and initialize</a></li>
<li><a href="Rubys.html#256">7.4.2  Factory Methods</a></li>
<li><a href="Rubys.html#257">7.4.3  dup, clone, and initialize_copy</a></li>
<li><a href="Rubys.html#259">7.4.4  marshal_dump and marshal_load</a></li>
<li><a href="Rubys.html#260">7.4.5  The Singleton Pattern</a></li>
</ul>
</li>
<li><a href="Rubys.html#261">7.5  Modules</a>
<ul>
<li><a href="Rubys.html#262">7.5.1  Modules as Namespaces</a>
<ul>
<li><a href="Rubys.html#263">7.5.1.1  Nested namespaces</a></li>
</ul>
</li>
<li><a href="Rubys.html#264">7.5.2  Modules As Mixins</a></li>
<li><a href="Rubys.html#265">7.5.3  Includable Namespace Modules</a></li>
</ul>
</li>
<li><a href="Rubys.html#266">7.6  Loading and Requiring Modules</a>
<ul>
<li><a href="Rubys.html#267">7.6.1  The Load Path</a></li>
<li><a href="Rubys.html#269">7.6.2  Executing Loaded Code</a>
<ul>
<li><a href="Rubys.html#270">7.6.2.1  Wrapped loads</a></li>
</ul>
</li>
<li><a href="Rubys.html#270">7.6.3  Autoloading Modules</a></li>
</ul>
</li>
<li><a href="Rubys.html#271">7.7  Singleton Methods and the Eigenclass</a></li>
<li><a href="Rubys.html#272">7.8  Method Lookup</a>
<ul>
<li><a href="Rubys.html#273">7.8.1  Class Method Lookup</a></li>
</ul>
</li>
<li><a href="Rubys.html#275">7.9  Constant Lookup</a></li>
</ul>
</li>
<li><a href="Rubys.html#279">Chapter 8. Reflection and Metaprogramming</a>
<ul>
<li><a href="Rubys.html#280">8.1  Types, Classes, and Modules</a>
<ul>
<li><a href="Rubys.html#281">8.1.1  Ancestry and Modules</a></li>
<li><a href="Rubys.html#282">8.1.2  Defining Classes and Modules</a></li>
</ul>
</li>
<li><a href="Rubys.html#282">8.2  Evaluating Strings and Blocks</a>
<ul>
<li><a href="Rubys.html#283">8.2.1  Bindings and eval</a></li>
<li><a href="Rubys.html#284">8.2.2  instance_eval and class_eval</a></li>
<li><a href="Rubys.html#284">8.2.3  instance_exec and class_exec</a></li>
</ul>
</li>
<li><a href="Rubys.html#285">8.3  Variables and Constants</a>
<ul>
<li><a href="Rubys.html#285">8.3.1  Querying, Setting, and Testing Variables</a></li>
</ul>
</li>
<li><a href="Rubys.html#286">8.4  Methods</a>
<ul>
<li><a href="Rubys.html#286">8.4.1  Listing and Testing For Methods</a></li>
<li><a href="Rubys.html#287">8.4.2  Obtaining Method Objects</a></li>
<li><a href="Rubys.html#288">8.4.3  Invoking Methods</a></li>
<li><a href="Rubys.html#288">8.4.4  Defining, Undefining, and Aliasing Methods</a></li>
<li><a href="Rubys.html#290">8.4.5  Handling Undefined Methods</a></li>
<li><a href="Rubys.html#291">8.4.6  Setting Method Visibility</a></li>
</ul>
</li>
<li><a href="Rubys.html#291">8.5  Hooks</a></li>
<li><a href="Rubys.html#293">8.6  Tracing</a></li>
<li><a href="Rubys.html#295">8.7  ObjectSpace and GC</a></li>
<li><a href="Rubys.html#295">8.8  Custom Control Structures</a>
<ul>
<li><a href="Rubys.html#296">8.8.1  Delaying and Repeating Execution: after and every</a></li>
<li><a href="Rubys.html#297">8.8.2  Thread Safety with Synchronized Blocks</a></li>
</ul>
</li>
<li><a href="Rubys.html#298">8.9  Missing Methods and Missing Constants</a>
<ul>
<li><a href="Rubys.html#298">8.9.1  Unicode Codepoint Constants with const_missing</a></li>
<li><a href="Rubys.html#299">8.9.2  Tracing Method Invocations with method_missing</a></li>
<li><a href="Rubys.html#301">8.9.3  Synchronized Objects by Delegation</a></li>
</ul>
</li>
<li><a href="Rubys.html#301">8.10  Dynamically Creating Methods</a>
<ul>
<li><a href="Rubys.html#302">8.10.1  Defining Methods with class_eval</a></li>
<li><a href="Rubys.html#302">8.10.2  Defining Methods with define_method</a></li>
</ul>
</li>
<li><a href="Rubys.html#304">8.11  Alias Chaining</a>
<ul>
<li><a href="Rubys.html#305">8.11.1  Tracing Files Loaded and Classes Defined</a></li>
<li><a href="Rubys.html#306">8.11.2  Chaining Methods for Thread Safety</a></li>
<li><a href="Rubys.html#308">8.11.3  Chaining Methods for Tracing</a></li>
</ul>
</li>
<li><a href="Rubys.html#310">8.12  Domain-Specific Languages</a>
<ul>
<li><a href="Rubys.html#310">8.12.1  Simple XML Output with method_missing</a></li>
<li><a href="Rubys.html#312">8.12.2  Validated XML Output with Method Generation</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="Rubys.html#317">Chapter 9. The Ruby Platform</a>
<ul>
<li><a href="Rubys.html#318">9.1  Strings</a>
<ul>
<li><a href="Rubys.html#322">9.1.1  Formatting Text</a></li>
<li><a href="Rubys.html#323">9.1.2  Packing and Unpacking Binary Strings</a></li>
<li><a href="Rubys.html#324">9.1.3  Strings and Encodings</a></li>
</ul>
</li>
<li><a href="Rubys.html#324">9.2  Regular Expressions</a>
<ul>
<li><a href="Rubys.html#324">9.2.1  Regexp Literals</a></li>
<li><a href="Rubys.html#325">9.2.2  Regexp Factory Methods</a></li>
<li><a href="Rubys.html#326">9.2.3  Regular Expression Syntax</a></li>
<li><a href="Rubys.html#329">9.2.4  Pattern Matching with Regular Expressions</a>
<ul>
<li><a href="Rubys.html#331">9.2.4.1  Global variables for match data</a></li>
<li><a href="Rubys.html#332">9.2.4.2  Pattern matching with strings</a></li>
<li><a href="Rubys.html#333">9.2.4.3  Search and replace</a></li>
<li><a href="Rubys.html#334">9.2.4.4  Regular expression encoding</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="Rubys.html#335">9.3  Numbers and Math</a>
<ul>
<li><a href="Rubys.html#335">9.3.1  Numeric Methods</a></li>
<li><a href="Rubys.html#336">9.3.2  The Math Module</a></li>
<li><a href="Rubys.html#337">9.3.3  Decimal Arithmetic</a></li>
<li><a href="Rubys.html#337">9.3.4  Complex Numbers</a></li>
<li><a href="Rubys.html#338">9.3.5  Rational Numbers</a></li>
<li><a href="Rubys.html#338">9.3.6  Vectors and Matrices</a></li>
<li><a href="Rubys.html#339">9.3.7  Random Numbers</a></li>
</ul>
</li>
<li><a href="Rubys.html#339">9.4  Dates and Times</a></li>
<li><a href="Rubys.html#342">9.5  Collections</a>
<ul>
<li><a href="Rubys.html#342">9.5.1  Enumerable Objects</a>
<ul>
<li><a href="Rubys.html#342">9.5.1.1  Iterating and converting collections</a></li>
<li><a href="Rubys.html#344">9.5.1.2  Enumerators and external iterators</a></li>
<li><a href="Rubys.html#344">9.5.1.3  Sorting collections</a></li>
<li><a href="Rubys.html#345">9.5.1.4  Searching collections</a></li>
<li><a href="Rubys.html#346">9.5.1.5  Selecting subcollections</a></li>
<li><a href="Rubys.html#347">9.5.1.6  Reducing collections</a></li>
</ul>
</li>
<li><a href="Rubys.html#348">9.5.2  Arrays</a>
<ul>
<li><a href="Rubys.html#349">9.5.2.1  Creating arrays</a></li>
<li><a href="Rubys.html#349">9.5.2.2  Array size and elements</a></li>
<li><a href="Rubys.html#350">9.5.2.3  Altering array elements</a></li>
<li><a href="Rubys.html#351">9.5.2.4  Iterating, searching, and sorting arrays</a></li>
<li><a href="Rubys.html#352">9.5.2.5  Array comparison</a></li>
<li><a href="Rubys.html#353">9.5.2.6  Arrays as stacks and queues</a></li>
<li><a href="Rubys.html#353">9.5.2.7  Arrays as sets</a></li>
<li><a href="Rubys.html#354">9.5.2.8  Associative array methods</a></li>
<li><a href="Rubys.html#354">9.5.2.9  Miscellaneous array methods</a></li>
</ul>
</li>
<li><a href="Rubys.html#355">9.5.3  Hashes</a>
<ul>
<li><a href="Rubys.html#355">9.5.3.1  Creating hashes</a></li>
<li><a href="Rubys.html#355">9.5.3.2  Indexing hashes and testing membership</a></li>
<li><a href="Rubys.html#356">9.5.3.3  Storing keys and values in a hash</a></li>
<li><a href="Rubys.html#357">9.5.3.4  Removing hash entries</a></li>
<li><a href="Rubys.html#357">9.5.3.5  Arrays from hashes</a></li>
<li><a href="Rubys.html#358">9.5.3.6  Hash iterators</a></li>
<li><a href="Rubys.html#358">9.5.3.7  Default values</a></li>
<li><a href="Rubys.html#359">9.5.3.8  Hashcodes, key equality, and mutable keys</a></li>
<li><a href="Rubys.html#360">9.5.3.9  Miscellaneous hash methods</a></li>
</ul>
</li>
<li><a href="Rubys.html#360">9.5.4  Sets</a>
<ul>
<li><a href="Rubys.html#361">9.5.4.1  Creating sets</a></li>
<li><a href="Rubys.html#361">9.5.4.2  Testing, comparing, and combining Sets</a></li>
<li><a href="Rubys.html#362">9.5.4.3  Adding and deleting set elements</a></li>
<li><a href="Rubys.html#363">9.5.4.4  Set iterators</a></li>
<li><a href="Rubys.html#364">9.5.4.5  Miscellaneous set methods</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="Rubys.html#364">9.6  Files and Directories</a>
<ul>
<li><a href="Rubys.html#365">9.6.1  File and Directory Names</a></li>
<li><a href="Rubys.html#366">9.6.2  Listing Directories</a></li>
<li><a href="Rubys.html#367">9.6.3  Testing Files</a></li>
<li><a href="Rubys.html#369">9.6.4  Creating, Deleting, and Renaming Files and Directories</a></li>
</ul>
</li>
<li><a href="Rubys.html#370">9.7  Input/Output</a>
<ul>
<li><a href="Rubys.html#370">9.7.1  Opening Streams</a>
<ul>
<li><a href="Rubys.html#370">9.7.1.1  Opening files</a></li>
<li><a href="Rubys.html#371">9.7.1.2  Kernel.open</a></li>
<li><a href="Rubys.html#372">9.7.1.3  StringIO</a></li>
<li><a href="Rubys.html#372">9.7.1.4  Predefined streams</a></li>
</ul>
</li>
<li><a href="Rubys.html#373">9.7.2  Streams and Encodings</a></li>
<li><a href="Rubys.html#374">9.7.3  Reading from a Stream</a>
<ul>
<li><a href="Rubys.html#374">9.7.3.1  Reading lines</a></li>
<li><a href="Rubys.html#375">9.7.3.2  Reading entire files</a></li>
<li><a href="Rubys.html#376">9.7.3.3  Reading bytes and characters</a></li>
</ul>
</li>
<li><a href="Rubys.html#378">9.7.4  Writing to a Stream</a></li>
<li><a href="Rubys.html#379">9.7.5  Random Access Methods</a></li>
<li><a href="Rubys.html#379">9.7.6  Closing, Flushing, and Testing Streams</a></li>
</ul>
</li>
<li><a href="Rubys.html#380">9.8  Networking</a>
<ul>
<li><a href="Rubys.html#381">9.8.1  A Very Simple Client</a></li>
<li><a href="Rubys.html#382">9.8.2  A Very Simple Server</a></li>
<li><a href="Rubys.html#382">9.8.3  Datagrams</a></li>
<li><a href="Rubys.html#383">9.8.4  A More Complex Client</a></li>
<li><a href="Rubys.html#384">9.8.5  A Multiplexing Server</a></li>
<li><a href="Rubys.html#386">9.8.6  Fetching Web Pages</a></li>
</ul>
</li>
<li><a href="Rubys.html#387">9.9  Threads and Concurrency</a>
<ul>
<li><a href="Rubys.html#388">9.9.1  Thread Lifecycle</a>
<ul>
<li><a href="Rubys.html#388">9.9.1.1  The main thread</a></li>
<li><a href="Rubys.html#389">9.9.1.2  Threads and unhandled exceptions</a></li>
</ul>
</li>
<li><a href="Rubys.html#389">9.9.2  Threads and Variables</a>
<ul>
<li><a href="Rubys.html#390">9.9.2.1  Thread-private variables</a></li>
<li><a href="Rubys.html#391">9.9.2.2  Thread-local variables</a></li>
</ul>
</li>
<li><a href="Rubys.html#391">9.9.3  Thread Scheduling</a>
<ul>
<li><a href="Rubys.html#391">9.9.3.1  Thread priorities</a></li>
<li><a href="Rubys.html#392">9.9.3.2  Thread preemption and Thread.pass</a></li>
</ul>
</li>
<li><a href="Rubys.html#392">9.9.4  Thread States</a>
<ul>
<li><a href="Rubys.html#392">9.9.4.1  Querying thread state</a></li>
<li><a href="Rubys.html#393">9.9.4.2  Altering state: pausing, waking, and killing threads</a></li>
</ul>
</li>
<li><a href="Rubys.html#394">9.9.5  Listing Threads and Thread Groups</a></li>
<li><a href="Rubys.html#394">9.9.6  Threading Examples</a>
<ul>
<li><a href="Rubys.html#395">9.9.6.1  Reading files concurrently</a></li>
<li><a href="Rubys.html#395">9.9.6.2  A Multithreaded Server</a></li>
<li><a href="Rubys.html#396">9.9.6.3  Concurrent iterators</a></li>
</ul>
</li>
<li><a href="Rubys.html#396">9.9.7  Thread Exclusion and Deadlock</a>
<ul>
<li><a href="Rubys.html#398">9.9.7.1  Deadlock</a></li>
</ul>
</li>
<li><a href="Rubys.html#399">9.9.8  Queue and SizedQueue</a></li>
<li><a href="Rubys.html#400">9.9.9  Condition Variables and Queues</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="Rubys.html#403">Chapter 10. The Ruby Environment</a>
<ul>
<li><a href="Rubys.html#404">10.1  Invoking the Ruby Interpreter</a>
<ul>
<li><a href="Rubys.html#405">10.1.1  Common Options</a></li>
<li><a href="Rubys.html#406">10.1.2  Warnings and Information Options</a></li>
<li><a href="Rubys.html#406">10.1.3  Encoding Options</a></li>
<li><a href="Rubys.html#407">10.1.4  Text Processing Options</a></li>
<li><a href="Rubys.html#408">10.1.5  Miscellaneous Options</a></li>
</ul>
</li>
<li><a href="Rubys.html#409">10.2  The Top-Level Environment</a>
<ul>
<li><a href="Rubys.html#409">10.2.1  Predefined Modules and Classes</a></li>
<li><a href="Rubys.html#410">10.2.2  Top-Level Constants</a></li>
<li><a href="Rubys.html#411">10.2.3  Global Variables</a>
<ul>
<li><a href="Rubys.html#411">10.2.3.1  Global settings</a></li>
<li><a href="Rubys.html#412">10.2.3.2  Exception-handling globals</a></li>
<li><a href="Rubys.html#413">10.2.3.3  Streams and text-processing globals</a></li>
<li><a href="Rubys.html#414">10.2.3.4  Pattern-matching globals</a></li>
<li><a href="Rubys.html#415">10.2.3.5  Command-line option globals</a></li>
</ul>
</li>
<li><a href="Rubys.html#415">10.2.4  Predefined Global Functions</a>
<ul>
<li><a href="Rubys.html#415">10.2.4.1  Keyword functions</a></li>
<li><a href="Rubys.html#415">10.2.4.2  Text input, output, and manipulation functions</a></li>
<li><a href="Rubys.html#416">10.2.4.3  OS methods</a></li>
<li><a href="Rubys.html#416">10.2.4.4  Warnings, failures, and exiting</a></li>
<li><a href="Rubys.html#416">10.2.4.5  Reflection functions</a></li>
<li><a href="Rubys.html#416">10.2.4.6  Conversion functions</a></li>
<li><a href="Rubys.html#416">10.2.4.7  Miscellaneous Kernel functions</a></li>
</ul>
</li>
<li><a href="Rubys.html#417">10.2.5  User-Defined Global Functions</a></li>
</ul>
</li>
<li><a href="Rubys.html#417">10.3  Practical Extraction and Reporting Shortcuts</a>
<ul>
<li><a href="Rubys.html#418">10.3.1  Input Functions</a></li>
<li><a href="Rubys.html#418">10.3.2  Deprecated Extraction Functions</a></li>
<li><a href="Rubys.html#418">10.3.3  Reporting Functions</a></li>
<li><a href="Rubys.html#419">10.3.4  One-Line Script Shortcuts</a></li>
</ul>
</li>
<li><a href="Rubys.html#419">10.4  Calling the OS</a>
<ul>
<li><a href="Rubys.html#419">10.4.1  Invoking OS Commands</a></li>
<li><a href="Rubys.html#420">10.4.2  Forking and Processes</a></li>
<li><a href="Rubys.html#422">10.4.3  Trapping Signals</a></li>
<li><a href="Rubys.html#422">10.4.4  Terminating Programs</a></li>
</ul>
</li>
<li><a href="Rubys.html#423">10.5  Security</a>
<ul>
<li><a href="Rubys.html#423">10.5.1  Tainted Data</a></li>
<li><a href="Rubys.html#424">10.5.2  Restricted Execution and Safe Levels</a>
<ul>
<li><a href="Rubys.html#425">10.5.2.1  Safe level 0</a></li>
<li><a href="Rubys.html#425">10.5.2.2  Safe Level 1</a></li>
<li><a href="Rubys.html#425">10.5.2.3  Safe level 2</a></li>
<li><a href="Rubys.html#426">10.5.2.4  Safe level 3</a></li>
<li><a href="Rubys.html#426">10.5.2.5  Safe level 4</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="Rubys.html#429">Index</a></li>
</ul>
<hr/>
</body>
</html>
