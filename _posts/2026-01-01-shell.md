---
layout: default
---

## **[POSIX sh](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/contents.html)标准语法（可移植性基础）**

POSIX（Portable Operating System Interface）为Unix-like系统定义了一个标准的shell规范，基于**Bourne Shell**。遵守POSIX标准的脚本能在大多数shell中运行（包括bash、zsh、ksh、ash/dash等），但**csh/fish不完全兼容**。

---

### **1. 变量操作**
```sh
# 赋值（等号两边无空格）
name=value

# 引用变量
echo "$name"

# 默认值
${var:-default}      # 如果var未设置或为空，使用default
${var:=default}      # 如果var未设置或为空，设为default
${var:?error_msg}    # 如果var未设置或为空，报错退出
${var:+replacement}  # 如果var已设置且非空，使用replacement
```
好的，这是一个在 Shell 脚本（特别是 Bash、Zsh 等现代 Shell）中非常核心且强大的功能，统称为 **“参数扩展”**。它主要用于处理变量可能为空或未设置的情况，让脚本更健壮、简洁。

下面我将逐一详细讲解你列出的这四种形式，并附上例子。

---

### 核心概念：`:` 的作用
在语法 `${var:...}` 中，冒号 `:` 是关键。它意味着检查不仅限于“变量是否**未设置**”，还包括“变量是否设置为**空值**”。
如果没有冒号，例如 `${var-default}`，则只检查变量是否**未设置**，而变量值为空字符串(`""`)时会被视为**已设置**，从而不会使用默认值。

为了清晰，我们先统一理解：下面讲解的带冒号 `:` 的形式，都是“**未设置或为空**”时触发相应操作。

---

### 1. `${var:-default}` - 使用默认值（临时替换）

*   **含义**：如果变量 `var` **未设置或为空**，那么整个表达式的值就取 `default`；否则，取 `var` 的值。
*   **关键点**：它**不会改变**变量 `var` 本身的值。这只是一种“临时借用”默认值的读取方式。
*   **类比**：相当于一个三目运算符：`(var 不为空) ? var : default`

**示例**：
```bash
#!/bin/bash

name=""
user_name=${name:-"Guest"}  # name为空，所以user_name被赋值为"Guest"
echo "Hello, $user_name"    # 输出：Hello, Guest
echo "name is still: $name" # 输出：name is still: （空行，name未被修改）

unset age
user_age=${age:-30}
echo "Age is $user_age"     # 输出：Age is 30
echo "age variable is set? ${age+yes}" # 输出：空（age仍为未设置状态）
```

---

### 2. `${var:=default}` - 赋值默认值（永久设置）

*   **含义**：如果变量 `var` **未设置或为空**，那么**不仅**整个表达式的值取 `default`，**还会将 `default` 赋值给变量 `var`**。如果 `var` 已有非空值，则直接使用它的值。
*   **关键点**：它**会改变**变量 `var` 本身的值。常用于“确保一个变量一定有值”的场景。
*   **类比**：相当于 `if [ -z "$var" ]; then var=default; fi` 的简写。

**示例**：
```bash
#!/bin/bash

count=""
total=${count:=100} # count为空，所以count被设为100，total也被赋值为100
echo "total is $total"   # 输出：total is 100
echo "count is $count"   # 输出：count is 100 (count被修改了!)

path="/usr/bin"
new_path=${path:="/tmp"} # path非空，所以new_path被赋值为"/usr/bin"，path不变
echo "new_path is $new_path" # 输出：new_path is /usr/bin
echo "path is $path"         # 输出：path is /usr/bin
```

---

### 3. `${var:?error_msg}` - 错误检查并退出

*   **含义**：如果变量 `var` **未设置或为空**，那么脚本会立即退出（在交互式Shell中会打印错误信息并停止当前命令），并显示你定义的 `error_msg` 到标准错误输出。如果 `var` 有非空值，则正常使用它的值。
*   **关键点**：这是一种**严格的验证机制**，用于强制要求某个变量必须被提供，否则视为致命错误。
*   **类比**：相当于 `if [ -z "$var" ]; then echo "error_msg" >&2; exit 1; fi`

**示例**：
```bash
#!/bin/bash

# 模拟从配置读取，如果读取失败则为空
config_file=""
# 如果未设置配置文件，则报错退出
required_file=${config_file:?"Config file must be set!"}
echo "This line will not be executed if the above fails."

# 运行脚本会得到类似以下输出并退出：
# ./script.sh: line 5: config_file: Config file must be set!
```

**更实用的例子**：
```bash
#!/bin/bash
# 要求用户通过环境变量传递API密钥
API_KEY=${API_KEY:?"Please set the API_KEY environment variable."}
curl -H "Authorization: $API_KEY" https://api.example.com
```

---

### 4. `${var:+replacement}` - 非空时替换

*   **含义**：与 `:-` 相反。如果变量 `var` **已设置且不为空**，那么整个表达式的值取 `replacement`；否则（未设置或为空），整个表达式的结果就是一个**空字符串**。
*   **关键点**：它同样**不会改变** `var` 本身的值。常用于“当某个条件（变量存在）满足时，添加一段文本或选项”的场景。
*   **类比**：相当于 `(var 不为空) ? replacement : ""`

**示例**：
```bash
#!/bin/bash

debug_mode="YES"
# 如果debug_mode非空，则添加 --debug 标志
flags="${debug_mode:+--debug}"
echo "Flags are: $flags" # 输出：Flags are: --debug

verbose_mode=""
# 如果verbose_mode为空，则flags2为空
flags2="${verbose_mode:+--verbose}"
echo "Flags2 are: '$flags2'" # 输出：Flags2 are: '' (空字符串)

# 组合使用的典型场景：构建命令行参数
args="--input file.txt"
args="${debug_mode:+$args --debug}"
args="${verbose_mode:+$args --verbose}"
echo "Final command: cmd $args"
# 如果debug_mode="YES", verbose_mode=""，则输出：Final command: cmd --input file.txt --debug
```

---

### 总结与记忆技巧

| 语法 | 符号记忆 | 触发条件 (`var` 的状态) | 主要动作 | 是否修改变量 `var` |
| :--- | :--- | :--- | :--- | :--- |
| **`${var:-word}`** | `-` 像一根**横杆**，临时**垫一下** | 未设置或为空 | **使用**备用值 `word` | **否** |
| **`${var:=word}`** | `=` 是**等号**，表示**赋值** | 未设置或为空 | **赋值并使用** `word` | **是** |
| **`${var:?message}`** | `?` 表示**疑问/错误**，出错了就问 | 未设置或为空 | **报错退出**，显示 `message` | **否** |
| **`${var:+word}`** | `+` 表示**正面的，有就加** | 已设置且非空 | **使用替换值** `word` | **否** |

**简单口诀**：
*   `-` ： **没有就用**（默认值）
*   `=` ： **没有就设**（赋值）
*   `?` ： **没有就错**（检错）
*   `+` ： **有就换**（替换）

掌握这四种参数扩展，能让你写出更加简洁、安全、可读性强的 Shell 脚本。

### **2. 条件测试**
```sh
# test命令或 [ ]（注意空格）
test "$a" = "$b"
[ "$a" = "$b" ]

# 常用测试操作符
[ -f file ]     # 存在且为普通文件
[ -d dir ]      # 存在且为目录
[ -r file ]     # 可读
[ -n "$str" ]   # 字符串非空
[ -z "$str" ]   # 字符串为空
[ "$a" -eq 1 ]  # 数值相等
[ "$a" -ne 1 ]  # 数值不等
[ "$a" -gt 1 ]  # 大于
[ "$a" -lt 1 ]  # 小于

# 组合条件
[ ! -f file ]                 # 非
[ -f file ] && [ -r file ]    # 与
[ -f file ] || [ -d file ]    # 或
```

### **3. 流程控制**
```sh
# if语句
if condition; then
    commands
elif condition; then
    commands
else
    commands
fi

# case语句
case $var in
    pattern1)
        commands ;;
    pattern2|pattern3)
        commands ;;
    *)
        commands ;;
esac

# for循环（遍历列表）
for var in item1 item2 item3; do
    echo "$var"
done

# while循环
while condition; do
    commands
done

# until循环
until condition; do
    commands
done
```

### **4. 函数**
```sh
# 定义函数
func_name() {
    commands
    return  # 可选的返回值（0-255）
}

# 调用函数
func_name arg1 arg2

# 函数内获取参数
func_name() {
    echo "第一个参数: $1"
    echo "参数个数: $#"
    echo "所有参数: $@"
}
```

### **5. 位置参数和特殊变量**
```sh
$0      # 脚本名
$1, $2  # 第1、2个参数
$#      # 参数个数
$@      # 所有参数（每个参数独立）
$*      # 所有参数（作为一个字符串）
$?      # 上条命令的退出状态
$$      # 当前shell的PID
$!      # 最后一个后台进程的PID
```

### **6. 引号和转义**
```sh
# 单引号：完全字面值
echo '$PATH'      # 输出 $PATH

# 双引号：允许变量和命令替换
echo "$PATH"      # 输出PATH的值

# 反斜杠转义
echo "Line 1\nLine 2"  # \n不会解释为换行
echo -e "Line 1\nLine 2"  # 需-e选项（非POSIX）
```

### **7. 命令执行与替换**
```sh
# 命令替换（两种形式，推荐第一种）
$(command)    # POSIX标准
`command`     # 传统形式

# 后台执行
command &

# 顺序执行
command1 ; command2
command1 && command2  # 前一个成功才执行下一个
command1 || command2  # 前一个失败才执行下一个
```

### **8. 输入/输出重定向**
```sh
# 标准重定向
command > file      # 覆盖输出
command >> file     # 追加输出
command < file      # 输入重定向

# 错误重定向
command 2> file     # 标准错误重定向
command 2>&1        # 标准错误合并到标准输出
command > file 2>&1 # 两者都重定向到文件
```

### **9. 算术运算**
```sh
# 使用 $(( )) 进行整数运算
result=$((a + b))
result=$((a * (b + c)))

# 运算符
+ - * / %    # 加减乘除取余
< > <= >= == !=  # 比较
&& || !      # 逻辑
```

### **10. 模式匹配**
```sh
# 通配符
*           # 匹配任意字符
?           # 匹配单个字符
[abc]       # 匹配a、b、c中任意一个
[a-z]       # 匹配a到z中任意一个
[!abc]      # 匹配非a、b、c的任意字符
```

---

### **POSIX与非POSIX主要差异**

| 功能 | POSIX | 非POSIX扩展（避免使用） |
|------|-------|-------------------|
| 数组 | 不支持 | `array=(1 2 3); echo ${array[0]}` |
| 字符串替换 | `${var#pattern}` | `${var//pattern/replace}` |
| 进程替换 | 不支持 | `<(command)` 或 `>(command)` |
| 通配符扩展 | 有限 | `**`（递归匹配） |
| 测试操作符 | `[ ]` | `[[ ]]`（bash/zsh等） |
| 函数定义 | `func() { ... }` | `function func { ... }` |
| 局部变量 | 无 | `local var=value` |

---

### **编写可移植脚本的要点**
1. **脚本首行**：`#!/bin/sh`（而非`#!/bin/bash`）
2. **测试命令**：使用`[ ]`而不是`[[ ]]`
3. **字符串处理**：优先使用外部命令`cut`、`sed`、`awk`而非shell扩展
4. **错误处理**：检查命令退出状态`$?`
5. **变量引用**：始终用双引号引用变量，如`"$var"`
6. **命令替换**：使用`$(command)`而非反引号`` `command` ``
7. **避免使用**：数组、关联数组、进程替换、`let`、`select`等

### **检查脚本兼容性**
```sh
# 使用dash检查（严格POSIX shell）
dash -n script.sh  # 检查语法
dash script.sh     # 实际执行

# 或使用checkbashisms工具（Debian/Ubuntu）
checkbashisms script.sh
```

遵循POSIX标准可以确保脚本在大多数Unix/Linux系统上运行，包括嵌入式系统使用的BusyBox ash。
