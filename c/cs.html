<!DOCTYPE html><html>
<head>
<title></title>
<style type="text/css">
<!--
.xflip {
    -moz-transform: scaleX(-1);
    -webkit-transform: scaleX(-1);
    -o-transform: scaleX(-1);
    transform: scaleX(-1);
    filter: fliph;
}
.yflip {
    -moz-transform: scaleY(-1);
    -webkit-transform: scaleY(-1);
    -o-transform: scaleY(-1);
    transform: scaleY(-1);
    filter: flipv;
}
.xyflip {
    -moz-transform: scaleX(-1) scaleY(-1);
    -webkit-transform: scaleX(-1) scaleY(-1);
    -o-transform: scaleX(-1) scaleY(-1);
    transform: scaleX(-1) scaleY(-1);
    filter: fliph + flipv;
}
-->
</style>
</head>
<body>
<a name=1></a><img src="c-1_1.jpg"/><br/>
1<br/>
<hr/>
<a name=2></a>&#160;&#160;<br/>
2&#160;<br/>
&#160;<br/><a href="cs.html#6">Preface&#160;........................................................................................................................................&#160;6&#160;<br/></a><a href="cs.html#8">Preface to the first edition&#160;..........................................................................................................&#160;8&#160;<br/></a><a href="cs.html#9">Chapter 1 - A Tutorial Introduction&#160;...........................................................................................&#160;9&#160;</a><br/>
<a href="cs.html#9">1.1 Getting Started..................................................................................................................&#160;9&#160;<br/></a><a href="cs.html#11">1.2 Variables and Arithmetic Expressions&#160;...........................................................................&#160;11&#160;<br/></a><a href="cs.html#16">1.3 The for statement............................................................................................................&#160;16&#160;<br/></a><a href="cs.html#17">1.4 Symbolic Constants........................................................................................................&#160;17&#160;<br/></a><a href="cs.html#18">1.5 Character Input and Output&#160;............................................................................................&#160;18&#160;</a><br/>
<a href="cs.html#18">1.5.1 File Copying............................................................................................................&#160;18&#160;<br/></a><a href="cs.html#20">1.5.2 Character Counting&#160;.................................................................................................&#160;20&#160;<br/></a><a href="cs.html#21">1.5.3 Line Counting..........................................................................................................&#160;21&#160;<br/></a><a href="cs.html#22">1.5.4 Word Counting........................................................................................................&#160;22&#160;</a><br/>
<a href="cs.html#23">1.6 Arrays&#160;.............................................................................................................................&#160;23&#160;<br/></a><a href="cs.html#25">1.7 Functions&#160;........................................................................................................................&#160;25&#160;<br/></a><a href="cs.html#28">1.8 Arguments - Call by Value.............................................................................................&#160;28&#160;<br/></a><a href="cs.html#29">1.9 Character Arrays&#160;............................................................................................................&#160;29&#160;<br/></a><a href="cs.html#31">1.10 External Variables and Scope&#160;......................................................................................&#160;31&#160;</a><br/>
<a href="cs.html#35">Chapter 2 - Types, Operators and Expressions&#160;........................................................................&#160;35&#160;</a><br/>
<a href="cs.html#35">2.1 Variable Names&#160;..............................................................................................................&#160;35&#160;<br/>2.2 Data Types and Sizes&#160;.....................................................................................................&#160;35&#160;<br/></a><a href="cs.html#36">2.3 Constants&#160;........................................................................................................................&#160;36&#160;<br/></a><a href="cs.html#39">2.4 Declarations....................................................................................................................&#160;39&#160;<br/></a><a href="cs.html#40">2.5 Arithmetic Operators......................................................................................................&#160;40&#160;<br/>2.6 Relational and Logical Operators...................................................................................&#160;40&#160;<br/></a><a href="cs.html#41">2.7 Type Conversions...........................................................................................................&#160;41&#160;<br/></a><a href="cs.html#44">2.8 Increment and Decrement Operators..............................................................................&#160;44&#160;<br/></a><a href="cs.html#46">2.9 Bitwise Operators...........................................................................................................&#160;46&#160;<br/></a><a href="cs.html#47">2.10 Assignment Operators and Expressions.......................................................................&#160;47&#160;<br/></a><a href="cs.html#49">2.11 Conditional Expressions...............................................................................................&#160;49&#160;<br/>2.12 Precedence and Order of Evaluation&#160;............................................................................&#160;49&#160;</a><br/>
<a href="cs.html#52">Chapter 3 - Control Flow&#160;.........................................................................................................&#160;52&#160;</a><br/>
<a href="cs.html#52">3.1 Statements and Blocks&#160;...................................................................................................&#160;52&#160;<br/>3.2 If-Else&#160;.............................................................................................................................&#160;52&#160;<br/></a><a href="cs.html#53">3.3 Else-If&#160;.............................................................................................................................&#160;53&#160;<br/></a><a href="cs.html#54">3.4 Switch.............................................................................................................................&#160;54&#160;<br/></a><a href="cs.html#56">3.5 Loops - While and For&#160;...................................................................................................&#160;56&#160;<br/></a><a href="cs.html#58">3.6 Loops - Do-While...........................................................................................................&#160;58&#160;<br/></a><a href="cs.html#59">3.7 Break and Continue&#160;........................................................................................................&#160;59&#160;<br/></a><a href="cs.html#60">3.8 Goto and labels...............................................................................................................&#160;60&#160;</a><br/>
<a href="cs.html#62">Chapter 4 - Functions and Program&#160;Structure..........................................................................&#160;62&#160;</a><br/>
<a href="cs.html#62">4.1 Basics of Functions&#160;........................................................................................................&#160;62&#160;<br/></a><a href="cs.html#65">4.2 Functions Returning Non-integers&#160;.................................................................................&#160;65&#160;<br/></a><a href="cs.html#67">4.3 External Variables&#160;..........................................................................................................&#160;67&#160;<br/></a><a href="cs.html#72">4.4 Scope Rules&#160;....................................................................................................................&#160;72&#160;<br/></a><a href="cs.html#73">4.5 Header Files....................................................................................................................&#160;73&#160;<br/></a><a href="cs.html#75">4.6 Static Variables&#160;..............................................................................................................&#160;75&#160;<br/>4.7 Register Variables&#160;..........................................................................................................&#160;75&#160;<br/></a><a href="cs.html#76">4.8 Block Structure...............................................................................................................&#160;76&#160;<br/>4.9 Initialization&#160;...................................................................................................................&#160;76&#160;<br/></a><a href="cs.html#78">4.10 Recursion......................................................................................................................&#160;78&#160;<br/></a><a href="cs.html#79">4.11 The C Preprocessor&#160;......................................................................................................&#160;79&#160;</a><br/>
<hr/>
<a name=3></a>&#160;&#160;<br/>
3&#160;<br/>
<a href="cs.html#79">4.11.1 File Inclusion.........................................................................................................&#160;79&#160;<br/></a><a href="cs.html#80">4.11.2 Macro Substitution&#160;................................................................................................&#160;80&#160;<br/></a><a href="cs.html#82">4.11.3 Conditional Inclusion&#160;............................................................................................&#160;82&#160;</a><br/>
<a href="cs.html#83">Chapter 5 - Pointers and Arrays&#160;...............................................................................................&#160;83&#160;</a><br/>
<a href="cs.html#83">5.1 Pointers and Addresses...................................................................................................&#160;83&#160;<br/></a><a href="cs.html#84">5.2 Pointers and Function Arguments&#160;..................................................................................&#160;84&#160;<br/></a><a href="cs.html#87">5.3 Pointers and Arrays&#160;........................................................................................................&#160;87&#160;<br/></a><a href="cs.html#90">5.4 Address Arithmetic&#160;........................................................................................................&#160;90&#160;<br/></a><a href="cs.html#93">5.5 Character Pointers and Functions...................................................................................&#160;93&#160;<br/></a><a href="cs.html#96">5.6 Pointer Arrays; Pointers to Pointers&#160;...............................................................................&#160;96&#160;<br/></a><a href="cs.html#99">5.7 Multi-dimensional Arrays&#160;..............................................................................................&#160;99&#160;<br/></a><a href="cs.html#101">5.8 Initialization of Pointer Arrays.....................................................................................&#160;101&#160;<br/>5.9 Pointers vs. Multi-dimensional Arrays.........................................................................&#160;101&#160;<br/></a><a href="cs.html#102">5.10 Command-line&#160;Arguments&#160;.........................................................................................&#160;102&#160;<br/></a><a href="cs.html#106">5.11 Pointers to Functions&#160;..................................................................................................&#160;106&#160;<br/></a><a href="cs.html#108">5.12 Complicated Declarations&#160;..........................................................................................&#160;108&#160;</a><br/>
<a href="cs.html#114">Chapter 6 - Structures.............................................................................................................&#160;114&#160;</a><br/>
<a href="cs.html#114">6.1 Basics of Structures......................................................................................................&#160;114&#160;<br/></a><a href="cs.html#116">6.2 Structures and Functions&#160;..............................................................................................&#160;116&#160;<br/></a><a href="cs.html#118">6.3 Arrays of Structures&#160;.....................................................................................................&#160;118&#160;<br/></a><a href="cs.html#122">6.4 Pointers to Structures&#160;...................................................................................................&#160;122&#160;<br/></a><a href="cs.html#124">6.5 Self-referential Structures&#160;............................................................................................&#160;124&#160;<br/></a><a href="cs.html#127">6.6 Table Lookup&#160;...............................................................................................................&#160;127&#160;<br/></a><a href="cs.html#129">6.7 Typedef.........................................................................................................................&#160;129&#160;<br/></a><a href="cs.html#131">6.8 Unions&#160;..........................................................................................................................&#160;131&#160;<br/></a><a href="cs.html#132">6.9 Bit-fields.......................................................................................................................&#160;132&#160;</a><br/>
<a href="cs.html#135">Chapter 7 - Input and Output..................................................................................................&#160;135&#160;</a><br/>
<a href="cs.html#135">7.1 Standard Input and Output&#160;...........................................................................................&#160;135&#160;<br/></a><a href="cs.html#137">7.2 Formatted Output - printf&#160;.............................................................................................&#160;137&#160;<br/></a><a href="cs.html#138">7.3 Variable-length Argument Lists...................................................................................&#160;138&#160;<br/></a><a href="cs.html#140">7.4 Formatted Input - Scanf................................................................................................&#160;140&#160;<br/></a><a href="cs.html#142">7.5 File Access&#160;...................................................................................................................&#160;142&#160;<br/></a><a href="cs.html#145">7.6 Error Handling - Stderr and Exit&#160;..................................................................................&#160;145&#160;<br/></a><a href="cs.html#146">7.7 Line Input and Output&#160;..................................................................................................&#160;146&#160;<br/></a><a href="cs.html#147">7.8 Miscellaneous Functions&#160;..............................................................................................&#160;147&#160;</a><br/>
<a href="cs.html#147">7.8.1 String Operations...................................................................................................&#160;147&#160;<br/></a><a href="cs.html#148">7.8.2 Character Class Testing and Conversion&#160;..............................................................&#160;148&#160;<br/>7.8.3 Ungetc&#160;...................................................................................................................&#160;148&#160;<br/>7.8.4 Command Execution&#160;.............................................................................................&#160;148&#160;<br/>7.8.5 Storage Management.............................................................................................&#160;148&#160;<br/></a><a href="cs.html#149">7.8.6 Mathematical Functions&#160;........................................................................................&#160;149&#160;<br/>7.8.7 Random Number generation&#160;.................................................................................&#160;149&#160;</a><br/>
<a href="cs.html#151">Chapter 8 - The UNIX System&#160;Interface................................................................................&#160;151&#160;</a><br/>
<a href="cs.html#151">8.1 File Descriptors&#160;............................................................................................................&#160;151&#160;<br/></a><a href="cs.html#152">8.2 Low Level I/O - Read and Write..................................................................................&#160;152&#160;<br/></a><a href="cs.html#153">8.3 Open, Creat, Close, Unlink&#160;..........................................................................................&#160;153&#160;<br/></a><a href="cs.html#155">8.4 Random Access - Lseek&#160;...............................................................................................&#160;155&#160;<br/></a><a href="cs.html#156">8.5 Example&#160;- An implementation of Fopen and Getc.......................................................&#160;156&#160;<br/></a><a href="cs.html#159">8.6 Example&#160;- Listing Directories&#160;......................................................................................&#160;159&#160;<br/></a><a href="cs.html#163">8.7 Example&#160;- A Storage Allocator&#160;....................................................................................&#160;163&#160;</a><br/>
<a href="cs.html#168">Appendix A - Reference Manual&#160;...........................................................................................&#160;168&#160;</a><br/>
<a href="cs.html#168">A.1 Introduction&#160;.................................................................................................................&#160;168&#160;</a><br/>
<hr/>
<a name=4></a>&#160;&#160;<br/>
4&#160;<br/>
<a href="cs.html#168">A.2 Lexical Conventions....................................................................................................&#160;168&#160;</a><br/>
<a href="cs.html#168">A.2.1 Tokens&#160;..................................................................................................................&#160;168&#160;<br/>A.2.2 Comments.............................................................................................................&#160;168&#160;<br/>A.2.3 Identifiers..............................................................................................................&#160;168&#160;<br/></a><a href="cs.html#169">A.2.4 Keywords..............................................................................................................&#160;169&#160;<br/>A.2.5 Constants&#160;..............................................................................................................&#160;169&#160;<br/></a><a href="cs.html#171">A.2.6 String Literals&#160;.......................................................................................................&#160;171&#160;</a><br/>
<a href="cs.html#171">A.3 Syntax Notation...........................................................................................................&#160;171&#160;<br/>A.4 Meaning of Identifiers&#160;.................................................................................................&#160;171&#160;</a><br/>
<a href="cs.html#171">A.4.1 Storage Class&#160;........................................................................................................&#160;171&#160;<br/></a><a href="cs.html#172">A.4.2 Basic Types&#160;..........................................................................................................&#160;172&#160;<br/></a><a href="cs.html#173">A.4.3 Derived types........................................................................................................&#160;173&#160;<br/>A.4.4 Type Qualifiers.....................................................................................................&#160;173&#160;</a><br/>
<a href="cs.html#173">A.5 Objects and Lvalues&#160;....................................................................................................&#160;173&#160;<br/>A.6 Conversions&#160;.................................................................................................................&#160;173&#160;</a><br/>
<a href="cs.html#174">A.6.1 Integral Promotion................................................................................................&#160;174&#160;<br/>A.6.2 Integral Conversions.............................................................................................&#160;174&#160;<br/>A.6.3 Integer and Floating..............................................................................................&#160;174&#160;<br/>A.6.4 Floating Types&#160;......................................................................................................&#160;174&#160;<br/>A.6.5 Arithmetic Conversions........................................................................................&#160;174&#160;<br/></a><a href="cs.html#175">A.6.6 Pointers and Integers&#160;............................................................................................&#160;175&#160;<br/></a><a href="cs.html#176">A.6.7 Void&#160;......................................................................................................................&#160;176&#160;<br/>A.6.8 Pointers to Void....................................................................................................&#160;176&#160;</a><br/>
<a href="cs.html#176">A.7 Expressions..................................................................................................................&#160;176&#160;</a><br/>
<a href="cs.html#177">A.7.1 Pointer Conversion&#160;...............................................................................................&#160;177&#160;<br/>A.7.2 Primary Expressions.............................................................................................&#160;177&#160;<br/>A.7.3 Postfix Expressions&#160;..............................................................................................&#160;177&#160;<br/></a><a href="cs.html#179">A.7.4 Unary Operators&#160;...................................................................................................&#160;179&#160;<br/></a><a href="cs.html#181">A.7.5 Casts&#160;.....................................................................................................................&#160;181&#160;<br/>A.7.6 Multiplicative Operators.......................................................................................&#160;181&#160;<br/></a><a href="cs.html#182">A.7.7 Additive Operators&#160;...............................................................................................&#160;182&#160;<br/>A.7.8 Shift Operators&#160;.....................................................................................................&#160;182&#160;<br/></a><a href="cs.html#183">A.7.9 Relational Operators.............................................................................................&#160;183&#160;<br/>A.7.10 Equality Operators..............................................................................................&#160;183&#160;<br/>A.7.11 Bitwise AND Operator&#160;.......................................................................................&#160;183&#160;<br/></a><a href="cs.html#184">A.7.12 Bitwise Exclusive OR Operator&#160;.........................................................................&#160;184&#160;<br/>A.7.13 Bitwise Inclusive OR Operator&#160;..........................................................................&#160;184&#160;<br/>A.7.14 Logical AND Operator&#160;.......................................................................................&#160;184&#160;<br/>A.7.15 Logical OR Operator&#160;..........................................................................................&#160;184&#160;<br/>A.7.16 Conditional Operator..........................................................................................&#160;184&#160;<br/></a><a href="cs.html#185">A.7.17 Assignment Expressions.....................................................................................&#160;185&#160;<br/>A.7.18 Comma Operator&#160;................................................................................................&#160;185&#160;<br/></a><a href="cs.html#186">A.7.19 Constant Expressions&#160;.........................................................................................&#160;186&#160;</a><br/>
<a href="cs.html#186">A.8 Declarations.................................................................................................................&#160;186&#160;</a><br/>
<a href="cs.html#187">A.8.1 Storage Class Specifiers&#160;.......................................................................................&#160;187&#160;<br/></a><a href="cs.html#188">A.8.2 Type Specifiers.....................................................................................................&#160;188&#160;<br/>A.8.3 Structure and Union Declarations&#160;........................................................................&#160;188&#160;<br/></a><a href="cs.html#191">A.8.4 Enumerations........................................................................................................&#160;191&#160;<br/></a><a href="cs.html#192">A.8.5 Declarators............................................................................................................&#160;192&#160;<br/></a><a href="cs.html#193">A.8.6 Meaning of Declarators&#160;........................................................................................&#160;193&#160;<br/></a><a href="cs.html#196">A.8.7 Initialization..........................................................................................................&#160;196&#160;<br/></a><a href="cs.html#198">A.8.8 Type names...........................................................................................................&#160;198&#160;</a><br/>
<hr/>
<a name=5></a>&#160;&#160;<br/>
5&#160;<br/>
<a href="cs.html#199">A.8.9 Typedef.................................................................................................................&#160;199&#160;<br/>A.8.10 Type Equivalence&#160;...............................................................................................&#160;199&#160;</a><br/>
<a href="cs.html#199">A.9 Statements&#160;...................................................................................................................&#160;199&#160;</a><br/>
<a href="cs.html#200">A.9.1 Labeled Statements...............................................................................................&#160;200&#160;<br/>A.9.2 Expression Statement&#160;...........................................................................................&#160;200&#160;<br/>A.9.3 Compound Statement&#160;...........................................................................................&#160;200&#160;<br/></a><a href="cs.html#201">A.9.4 Selection Statements.............................................................................................&#160;201&#160;<br/>A.9.5 Iteration Statements&#160;..............................................................................................&#160;201&#160;<br/></a><a href="cs.html#202">A.9.6 Jump statements&#160;...................................................................................................&#160;202&#160;</a><br/>
<a href="cs.html#203">A.10 External Declarations&#160;................................................................................................&#160;203&#160;</a><br/>
<a href="cs.html#203">A.10.1 Function Definitions...........................................................................................&#160;203&#160;<br/></a><a href="cs.html#204">A.10.2 External Declarations&#160;.........................................................................................&#160;204&#160;</a><br/>
<a href="cs.html#205">A.11 Scope and Linkage&#160;....................................................................................................&#160;205&#160;</a><br/>
<a href="cs.html#205">A.11.1 Lexical Scope&#160;.....................................................................................................&#160;205&#160;<br/></a><a href="cs.html#206">A.11.2 Linkage&#160;...............................................................................................................&#160;206&#160;</a><br/>
<a href="cs.html#206">A.12 Preprocessing.............................................................................................................&#160;206&#160;</a><br/>
<a href="cs.html#207">A.12.1 Trigraph Sequences&#160;............................................................................................&#160;207&#160;<br/>A.12.2 Line Splicing&#160;......................................................................................................&#160;207&#160;<br/>A.12.3 Macro Definition and Expansion&#160;.......................................................................&#160;207&#160;<br/></a><a href="cs.html#209">A.12.4 File Inclusion......................................................................................................&#160;209&#160;<br/></a><a href="cs.html#210">A.12.5 Conditional Compilation&#160;....................................................................................&#160;210&#160;<br/></a><a href="cs.html#211">A.12.6 Line Control&#160;.......................................................................................................&#160;211&#160;<br/>A.12.7 Error Generation.................................................................................................&#160;211&#160;<br/></a><a href="cs.html#212">A.12.8 Pragmas&#160;..............................................................................................................&#160;212&#160;<br/>A.12.9 Null directive......................................................................................................&#160;212&#160;<br/>A.12.10 Predefined names&#160;.............................................................................................&#160;212&#160;</a><br/>
<a href="cs.html#212">A.13 Grammar....................................................................................................................&#160;212&#160;</a><br/>
<a href="cs.html#220">Appendix B - Standard Library..............................................................................................&#160;220&#160;</a><br/>
<a href="cs.html#220">B.1 Input and Output: &lt;stdio.h&gt;&#160;........................................................................................&#160;220&#160;</a><br/>
<a href="cs.html#220">B.1.1 File Operations&#160;.....................................................................................................&#160;220&#160;<br/></a><a href="cs.html#222">B.1.2 Formatted Output..................................................................................................&#160;222&#160;<br/></a><a href="cs.html#223">B.1.3 Formatted Input&#160;....................................................................................................&#160;223&#160;<br/></a><a href="cs.html#225">B.1.4 Character Input and Output Functions..................................................................&#160;225&#160;<br/>B.1.5 Direct Input and Output Functions&#160;.......................................................................&#160;225&#160;<br/></a><a href="cs.html#226">B.1.6 File Positioning Functions&#160;....................................................................................&#160;226&#160;<br/>B.1.7 Error Functions&#160;.....................................................................................................&#160;226&#160;</a><br/>
<a href="cs.html#226">B.2 Character Class Tests: &lt;ctype.h&gt;&#160;................................................................................&#160;226&#160;<br/></a><a href="cs.html#227">B.3 String Functions: &lt;string.h&gt;&#160;........................................................................................&#160;227&#160;<br/></a><a href="cs.html#228">B.4 Mathematical Functions: &lt;math.h&gt;.............................................................................&#160;228&#160;<br/></a><a href="cs.html#229">B.5 Utility Functions: &lt;stdlib.h&gt;&#160;.......................................................................................&#160;229&#160;<br/></a><a href="cs.html#231">B.6 Diagnostics: &lt;assert.h&gt;................................................................................................&#160;231&#160;<br/>B.7 Variable Argument&#160;Lists: &lt;stdarg.h&gt;&#160;..........................................................................&#160;231&#160;<br/></a><a href="cs.html#232">B.8 Non-local Jumps: &lt;setjmp.h&gt;......................................................................................&#160;232&#160;<br/>B.9 Signals: &lt;signal.h&gt;&#160;......................................................................................................&#160;232&#160;<br/></a><a href="cs.html#233">B.10 Date and Time&#160;Functions: &lt;time.h&gt;&#160;..........................................................................&#160;233&#160;<br/></a><a href="cs.html#234">B.11 Implementation-defined Limits: &lt;limits.h&gt; and &lt;float.h&gt;</a><br/>
<a href="cs.html#234">............................................................................................................................................&#160;234&#160;</a><br/>
<a href="cs.html#236">Appendix C - Summary of Changes&#160;......................................................................................&#160;236&#160;</a><br/>
<hr/>
<a name=6></a>&#160;&#160;<br/>
6&#160;<br/>
&#160;<br/>
<b>Preface&#160;</b><br/>
The computing world has undergone a&#160;revolution since the publication of&#160;<i>The C&#160;<br/>Programming Language</i>&#160;in 1978. Big computers are much bigger, and personal computers&#160;<br/>have capabilities that rival mainframes of a decade ago. During this time, C has changed too,&#160;<br/>although only modestly, and it has spread far beyond its origins as the language of the UNIX&#160;<br/>operating system. &#160;<br/>
The growing popularity of C, the changes in the language over the years, and the creation of&#160;<br/>compilers by groups not involved in its design, combined to demonstrate a need for a more&#160;<br/>precise and more contemporary definition of the language than the first edition of this book&#160;<br/>provided. In 1983, the American National Standards Institute (ANSI) established a committee&#160;<br/>whose goal was to produce ``an unambiguous and machine-independent definition of the&#160;<br/>language C'',&#160;while still retaining its spirit. The result is the ANSI standard for C. &#160;<br/>
The standard formalizes constructions that were&#160;hinted but not described in the first edition,&#160;<br/>particularly structure assignment and enumerations. It provides a new form&#160;of function&#160;<br/>declaration that permits cross-checking of definition with use. It specifies a standard library,&#160;<br/>with an extensive set of functions for performing input and output, memory management,&#160;<br/>string manipulation, and similar tasks. It makes precise the behavior of features that were not&#160;<br/>spelled out in the original definition, and at the same time states explicitly which aspects of&#160;<br/>the language remain machine-dependent. &#160;<br/>
This Second Edition of&#160;<i>The C Programming Language</i>&#160;describes C as defined by the ANSI&#160;<br/>standard. Although we have noted the places where the language has evolved, we have chosen&#160;<br/>to write exclusively in the new form. For the most part, this makes no significant difference;&#160;<br/>the most visible change is the new form&#160;of function declaration and definition. Modern&#160;<br/>compilers already support most features of the standard. &#160;<br/>
We have tried to retain the brevity of the first edition. C is not a big language, and it is not&#160;<br/>well served by a big book. We have improved the exposition of critical features, such as&#160;<br/>pointers, that are central to C programming. We&#160;have refined the original examples, and have&#160;<br/>added new examples in several chapters. For instance, the treatment of complicated&#160;<br/>declarations is augmented by programs that convert declarations into words and vice versa.&#160;<br/>As before, all examples have been tested directly from&#160;the text, which is in machine-readable&#160;<br/>form. &#160;<br/>
Appendix A, the reference manual, is not the standard, but our attempt to convey the&#160;<br/>essentials of the standard in a smaller&#160;space. It is meant for easy comprehension by&#160;<br/>programmers, but not as a definition for compiler writers -- that role properly belongs to the&#160;<br/>standard itself.&#160;Appendix B is a summary of&#160;the facilities of&#160;the standard library. It too is&#160;<br/>meant for reference by programmers, not implementers. Appendix C is a concise summary of&#160;<br/>the changes from&#160;the original version. &#160;<br/>
As we said in the preface to the first edition, C ``wears well as one's experience with it&#160;<br/>grows''.&#160;With a decade more experience, we&#160;still feel that way. We hope that this book will&#160;<br/>help you learn C and use it well. &#160;<br/>
<hr/>
<a name=7></a>&#160;&#160;<br/>
7&#160;<br/>
We are deeply indebted to friends who helped us to produce this second edition. Jon Bently,&#160;<br/>Doug Gwyn, Doug McIlroy, Peter Nelson, and Rob Pike gave us perceptive comments on&#160;<br/>almost every page of draft manuscripts. We are grateful for careful&#160;reading by Al Aho, Dennis&#160;<br/>Allison, Joe Campbell, G.R. Emlin, Karen Fortgang, Allen Holub, Andrew Hume, Dave&#160;<br/>Kristol, John Linderman, Dave Prosser, Gene&#160;Spafford, and Chris van&#160;Wyk. We also received&#160;<br/>helpful suggestions from&#160;Bill Cheswick, Mark Kernighan, Andy Koenig, Robin Lake, Tom&#160;<br/>London, Jim&#160;Reeds, Clovis Tondo, and Peter Weinberger. Dave Prosser answered many&#160;<br/>detailed questions about the ANSI standard. We&#160;used Bjarne Stroustrup's C++ translator&#160;<br/>extensively for local testing of our programs,&#160;and Dave Kristol provided us with an ANSI C&#160;<br/>compiler for final testing. Rich Drechsler helped greatly with typesetting. &#160;<br/>
&#160;<br/>
Our sincere thanks to all. &#160;<br/>
Brian W.&#160;Kernighan&#160;<br/>Dennis M. Ritchie &#160;<br/>
<hr/>
<a name=8></a>8<br/>
<b>Preface to the first edition&#160;</b><br/>
C is a general-purpose programming language with features economy of expression, modern&#160;<br/>flow control and data structures, and a rich&#160;set of operators. C is not a ``very high level''&#160;<br/>language, nor a ``big''&#160;one, and is not specialized&#160;to any particular area of application. But its&#160;<br/>absence of restrictions and its generality make it more convenient and effective for many&#160;<br/>tasks than supposedly more powerful languages. &#160;<br/>
C was originally designed for and implemented on the UNIX operating system&#160;on the DEC&#160;<br/>PDP-11, by Dennis Ritchie. The operating system, the C compiler, and essentially all UNIX&#160;<br/>applications programs (including all of the software used to prepare this book) are written in&#160;<br/>C. Production compilers also exist for several other machines, including the IBM System/370,&#160;<br/>the Honeywell 6000, and the Interdata 8/32. C is&#160;not tied to any particular hardware or&#160;<br/>system, however, and it is easy to write programs that will run without change on any&#160;<br/>machine that supports C. &#160;<br/>
This book is meant to help the reader learn how&#160;to program&#160;in C. It contains a tutorial&#160;<br/>introduction to get new users started as soon as possible, separate chapters on each major&#160;<br/>feature, and a reference manual. Most of&#160;the treatment is based on reading, writing and&#160;<br/>revising examples, rather than on mere statements&#160;of rules. For the most part, the examples&#160;<br/>are complete, real programs rather than isolated&#160;fragments. All examples have been tested&#160;<br/>directly from&#160;the text, which is in machine-readable form. Besides showing how to make&#160;<br/>effective use of the language, we have also tried where possible to illustrate useful algorithms&#160;<br/>and principles of good style and sound design. &#160;<br/>
The book is not an introductory programming manual; it assumes some familiarity with basic&#160;<br/>programming concepts like variables, assignment statements, loops, and functions.&#160;<br/>Nonetheless, a novice programmer should be able to read along and pick up the language,&#160;<br/>although access to more knowledgeable colleague will help. &#160;<br/>
In our experience, C has proven to be a pleasant,&#160;expressive and versatile language for a wide&#160;<br/>variety of programs. It is easy to learn, and it&#160;wears well as on's experience with it grows. We&#160;<br/>hope that this book will help you to use it well. &#160;<br/>
The thoughtful criticisms and suggestions of many friends and colleagues have added greatly&#160;<br/>to this book and to our pleasure in writing it.&#160;In particular, Mike Bianchi, Jim&#160;Blue, Stu&#160;<br/>Feldman, Doug McIlroy Bill Roome, Bob Rosin and Larry Rosler all read multiple volumes&#160;<br/>with care. We are also indebted to Al Aho, Steve Bourne, Dan Dvorak, Chuck Haley, Debbie&#160;<br/>Haley, Marion Harris, Rick Holt, Steve Johnson, John Mashey, Bob Mitze, Ralph Muha,&#160;<br/>Peter Nelson, Elliot Pinson, Bill Plauger,&#160;Jerry Spivack, Ken Thompson, and Peter&#160;<br/>Weinberger for helpful comments at various stages, and to Mile Lesk and Joe Ossanna for&#160;<br/>invaluable assistance with typesetting. &#160;<br/>
Brian W.&#160;Kernighan&#160;<br/>Dennis M. Ritchie &#160;<br/>
<hr/>
<a name=9></a>&#160;&#160;<br/>
9&#160;<br/>
&#160;<br/>
<b>Chapter&#160;1 -&#160;A&#160;Tutorial Introduction&#160;</b><br/>
Let us begin with a quick introduction in C. Our&#160;aim&#160;is to show the essential elements of the&#160;<br/>language in real programs, but without getting&#160;bogged down in details, rules, and exceptions.&#160;<br/>At this point, we are not trying to be complete&#160;or even precise (save that the examples are&#160;<br/>meant to be correct). We want to get you as&#160;quickly as possible to the point where you can&#160;<br/>write useful programs, and to do that we have&#160;to concentrate on the basics: variables and&#160;<br/>constants, arithmetic, control flow, functions,&#160;and the rudiments of input and output. We are&#160;<br/>intentionally leaving out of&#160;this chapter features of C that are important for writing bigger&#160;<br/>programs. These include pointers, structures, most&#160;of C's rich set of operators, several control-<br/>flow statements, and the standard library. &#160;<br/>
This approach and its drawbacks. Most notable is that the complete story on any particular&#160;<br/>feature is not found here, and the tutorial,&#160;by being brief, may also be misleading. And&#160;<br/>because the examples do not use the full power of&#160;C, they are not as concise and elegant as&#160;<br/>they might be. We have tried to minimize these&#160;effects, but be warned. Another drawback is&#160;<br/>that later chapters will necessarily repeat some&#160;of this chapter. We hope that the repetition&#160;<br/>will help you more than it annoys. &#160;<br/>
In any case, experienced programmers should be able to extrapolate from&#160;the material in this&#160;<br/>chapter to their own programming needs. Beginners should supplement it by writing small,&#160;<br/>similar programs of their own. Both groups can&#160;use it as a framework on which to hang the&#160;<br/>more detailed descriptions that begin in&#160;<a href="">Chapter 2</a>. &#160;<br/>
<b>1.1 Getting Started&#160;</b><br/>
The only way to learn a new programming language is by writing programs in it. The first&#160;<br/>program&#160;to write is the same for all languages:&#160;<br/>&#160;<i>Print the words</i>&#160;<br/>&#160;hello, world&#160;&#160;<br/>
This is a big hurdle; to leap over it you have to&#160;be able to create the program&#160;text somewhere,&#160;<br/>compile it successfully, load it, run it, and&#160;find out where your output went. With these&#160;<br/>mechanical details mastered, everything else is comparatively easy. &#160;<br/>
In C, the program&#160;to print ``hello, world'' is&#160;&#160;<br/>
&#160;<br/>&#160; &#160;#include &lt;stdio.h&gt;&#160;<br/>&#160;<br/>&#160; &#160;main()&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160;printf(&#34;hello, world\n&#34;);&#160;<br/>&#160; &#160;}&#160;<br/>&#160;<br/>
Just how to run this program&#160;depends on the&#160;system&#160;you are using. As a specific example, on&#160;<br/>the UNIX operating system&#160;you must create the program&#160;in a file whose name ends in ``.c'',&#160;<br/>such as&#160;hello.c, then compile it with the command &#160;<br/>&#160;<br/>&#160; &#160;cc hello.c&#160;<br/>&#160;<br/>
<hr/>
<a name=10></a>&#160;&#160;<br/>
10&#160;<br/>
If you haven't botched anything, such as omitting a character or misspelling something, the&#160;<br/>compilation will proceed silently, and make an executable file called&#160;a.out. If you run&#160;a.out&#160;<br/>by typing the command &#160;<br/>&#160;<br/>&#160; &#160;a.out&#160;<br/>
it will print &#160;<br/>&#160;<br/>&#160; &#160;hello, world&#160;<br/>
On other systems, the rules will be different; check with a local expert. &#160;<br/>
Now, for some explanations about the program&#160;itself. A C program, whatever its size, consists&#160;<br/>of&#160;&#160;<i>functions</i>&#160;and&#160;<i>variables</i>. A function contains&#160;<i>statements</i>&#160;that specify the computing&#160;<br/>operations to be done, and variables store values&#160;used during the computation. C functions are&#160;<br/>like the subroutines and functions in Fortran or&#160;the procedures and functions of Pascal. Our&#160;<br/>example is a function named&#160;main. Normally you are at liberty to give functions whatever&#160;<br/>names you like, but ``main''&#160;is special - your program&#160;begins executing at the beginning of&#160;<br/>main. This means that every program&#160;must have a&#160;main&#160;somewhere. &#160;<br/>
main&#160;will usually call other functions to help perform&#160;its job, some that you wrote, and others&#160;<br/>from&#160;libraries that are provided for you. The first line of the program, &#160;<br/>
&#160;<br/>&#160; &#160;#include &lt;stdio.h&gt;&#160;<br/>
tells the compiler to include information about the standard input/output library; the line&#160;<br/>appears at the beginning of many C source files. The standard library is described in&#160;<a href="">Chapter&#160;<br/>7&#160;and&#160;Appendix B. &#160;</a><br/>
One method of communicating data between functions is for the calling function to provide a&#160;<br/>list of&#160;values, called&#160;<i>arguments</i>, to the function it calls. The&#160;parentheses after the function&#160;<br/>name surround the argument list. In this example,&#160;main&#160;is defined to be a function that expects&#160;<br/>no arguments, which is indicated by the empty list&#160;( ). &#160;<br/>
&#160;<br/>
&#160;<br/>#include &lt;stdio.h&gt; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;<i>include information about standard&#160;<br/>library</i>&#160;<br/>main() &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;<i>define a function called main</i>&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;&#160;<i>that received no argument values</i>&#160;<br/>{ &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;&#160;<i>statements of main are enclosed in braces</i>&#160;<br/>&#160; &#160; printf(&#34;hello, world\n&#34;); &#160; &#160;&#160;<i>main calls library function printf</i>&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;&#160;<i>to print this sequence of characters</i>&#160;<br/>} &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; \n&#160;<i>represents the newline character</i>&#160;<br/>
<b>The first C program</b>&#160;&#160;<br/>
&#160;<br/>
The statements of a function are enclosed in braces&#160;{ }. The function&#160;main&#160;contains only one&#160;<br/>statement, &#160;<br/>
&#160;<br/>&#160; &#160;printf(&#34;hello, world\n&#34;);&#160;<br/>
<hr/>
<a name=11></a>&#160;&#160;<br/>
11&#160;<br/>
A function is called by naming it, followed by a parenthesized list of&#160;arguments, so this calls&#160;<br/>the function&#160;printf&#160;with the argument&#160;&#34;hello, world\n&#34;.&#160;printf&#160;is a library function that&#160;<br/>prints output, in this case the string of characters between the quotes. &#160;<br/>
A sequence of characters in double quotes, like&#160;&#34;hello, world\n&#34;, is called a&#160;<i>character&#160;<br/>string</i>&#160;or&#160;<i>string constant</i>. For the moment our only use of&#160;character strings will be as&#160;<br/>arguments for&#160;printf&#160;and other functions. &#160;<br/>
The sequence&#160;\n&#160;in the string is C notation for the&#160;<i>newline character</i>, which when printed&#160;<br/>advances the output to the left margin&#160;on the next line. If you leave out the&#160;\n&#160;(a worthwhile&#160;<br/>experiment), you will find that there is no line&#160;advance after the output is printed. You must&#160;<br/>use&#160;\n&#160;to include a newline character in the&#160;printf&#160;argument; if you try something like &#160;<br/>
&#160;<br/>&#160; &#160;printf(&#34;hello, world&#160;<br/>&#160; &#160;&#34;);&#160;<br/>
the C compiler will produce an error message. &#160;<br/>
printf&#160;never supplies a newline character automatically, so several calls may be used to&#160;<br/>build up an output line in stages. Our first program&#160;could just as well have been written &#160;<br/>
&#160;<br/>&#160; &#160;#include &lt;stdio.h&gt;&#160;<br/>&#160;<br/>&#160; &#160;main()&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160;printf(&#34;hello, &#34;);&#160;<br/>&#160; &#160; &#160;printf(&#34;world&#34;);&#160;<br/>&#160; &#160; &#160;printf(&#34;\n&#34;);&#160;<br/>&#160; &#160;}&#160;<br/>
to produce identical output. &#160;<br/>
Notice that&#160;\n&#160;represents only a single character. An&#160;<i>escape sequence</i>&#160;like&#160;\n&#160;provides a&#160;<br/>general and extensible mechanism&#160;for representing hard-to-type or invisible characters.&#160;<br/>Among the others that C provides are&#160;\t&#160;for tab,&#160;\b&#160;for backspace,&#160;\&#34;&#160;for the double quote&#160;<br/>and&#160;\\&#160;for the backslash itself.&#160;There is a comp<a href="">lete list in&#160;Section 2.3</a>. &#160;<br/>
<b>Exercise 1-1.</b>&#160;Run the ``hello, world''&#160;program&#160;on your system. Experiment with leaving&#160;<br/>out parts of the program, to see what error messages you get. &#160;<br/>
<b>Exercise 1-2.</b>&#160;Experiment to find out what happens when&#160;prints's argument string contains&#160;<br/><i>\c</i>, where&#160;<i>c</i>&#160;is some character not listed above. &#160;<br/>
<b>1.2 Variables and Arithmetic Expressions&#160;</b><br/>
The next program&#160;uses the formula&#160;oC=(5/9)(oF-32) to print the following table of Fahrenheit&#160;<br/>temperatures and their centigrade or Celsius equivalents: &#160;<br/>
<hr/>
<a name=12></a>&#160;&#160;<br/>
12&#160;<br/>
&#160;<br/>&#160; &#160;1 &#160; &#160;-17&#160;<br/>&#160; &#160;20 &#160; -6&#160;<br/>&#160; &#160;40 &#160; 4&#160;<br/>&#160; &#160;60 &#160; 15&#160;<br/>&#160; &#160;80 &#160; 26&#160;<br/>&#160; &#160;100 &#160;37&#160;<br/>&#160; &#160;120 &#160;48&#160;<br/>&#160; &#160;140 &#160;60&#160;<br/>&#160; &#160;160 &#160;71&#160;<br/>&#160; &#160;180 &#160;82&#160;<br/>&#160; &#160;200 &#160;93&#160;<br/>&#160; &#160;220 &#160;104&#160;<br/>&#160; &#160;240 &#160;115&#160;<br/>&#160; &#160;260 &#160;126&#160;<br/>&#160; &#160;280 &#160;137&#160;<br/>&#160; &#160;300 &#160;148&#160;<br/>
The program&#160;itself&#160;still consists of&#160;the definition of&#160;a single function named&#160;main. It is longer&#160;<br/>than the one that printed ``hello, world'',&#160;but not complicated. It introduces several new&#160;<br/>ideas, including comments, declarations, variables, arithmetic expressions, loops , and&#160;<br/>formatted output. &#160;<br/>&#160;<br/>&#160; &#160;#include &lt;stdio.h&gt;&#160;<br/>&#160;<br/>&#160; &#160;/* print Fahrenheit-Celsius table&#160;<br/>&#160; &#160; &#160; &#160;for fahr = 0, 20, ..., 300 */&#160;<br/>&#160; &#160;main()&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160;int fahr, celsius;&#160;<br/>&#160; &#160; &#160;int lower, upper, step;&#160;<br/>&#160;<br/>&#160; &#160; &#160;lower = 0; &#160; &#160; &#160;/* lower limit of temperature scale */&#160;<br/>&#160; &#160; &#160;upper = 300; &#160; &#160;/* upper limit */&#160;<br/>&#160; &#160; &#160;step = 20; &#160; &#160; &#160;/* step size */&#160;<br/>&#160;<br/>&#160; &#160; &#160;fahr = lower;&#160;<br/>&#160; &#160; &#160;while (fahr &lt;= upper) {&#160;<br/>&#160; &#160; &#160; &#160; &#160;celsius = 5 * (fahr-32) / 9;&#160;<br/>&#160; &#160; &#160; &#160; &#160;printf(&#34;%d\t%d\n&#34;, fahr, celsius);&#160;<br/>&#160; &#160; &#160; &#160; &#160;fahr = fahr + step;&#160;<br/>&#160; &#160; &#160;}&#160;<br/>&#160; &#160;}&#160;<br/>
The two lines &#160;<br/>&#160;<br/>&#160; /* print Fahrenheit-Celsius table&#160;<br/>&#160; &#160; &#160; for fahr = 0, 20, ..., 300 */&#160;<br/>
are a&#160;<i>comment</i>, which in this case explains briefly&#160;what the program&#160;does. Any characters&#160;<br/>between&#160;/*&#160;and&#160;*/&#160;are ignored by the compiler; they may be used freely to make a program&#160;<br/>easier to understand. Comments may appear anywhere where a blank, tab or newline can. &#160;<br/>
In C, all variables must be declared before they are used, usually at the beginning of the&#160;<br/>function before any executable statements. A&#160;<i>declaration</i>&#160;announces the properties of&#160;<br/>variables; it consists of a name and a list of variables, such as &#160;<br/>
&#160;<br/>&#160; &#160; int fahr, celsius;&#160;<br/>&#160; &#160; int lower, upper, step;&#160;<br/>
The type&#160;int&#160;means that the variables listed are integers; by contrast with&#160;float, which&#160;<br/>means floating point, i.e., numbers that may&#160;have a fractional part. The range of both&#160;int&#160;and&#160;<br/>float&#160;depends on the machine you are using; 16-bits&#160;ints, which lie between -32768 and&#160;<br/>
<hr/>
<a name=13></a>&#160;&#160;<br/>
13&#160;<br/>
+32767, are common, as are 32-bit&#160;ints. A&#160;float&#160;number is typically a 32-bit quantity, with&#160;<br/>at least six significant digits and magnitude generally between about 10-38&#160;and 1038. &#160;<br/>
C provides several other data types besides&#160;int&#160;and&#160;float, including: &#160;<br/>
&#160;char&#160; &#160;&#160;&#160;character - a single byte&#160;<br/>
&#160;short&#160; &#160;&#160;&#160;short integer&#160;<br/>
&#160;long&#160; &#160;&#160;&#160;long integer&#160;<br/>
&#160;double&#160;&#160;&#160;&#160;double-precision&#160;floating&#160;point&#160;<br/>
The size of these objects is also machine-dependent. There are also&#160;<i>arrays</i>,&#160;&#160;<i>structures</i>&#160;and&#160;<br/><i>unions</i>&#160;of these basic types,&#160;<i>pointers</i>&#160;to them, and&#160;<i>functions</i>&#160;that return them, all of&#160;which we&#160;<br/>will meet in due course. &#160;<br/>
Computation in the temperature conversion program&#160;begins with the&#160;<i>assignment statements</i>&#160;&#160;<br/>
&#160;<br/>&#160; &#160; lower = 0;&#160;<br/>&#160; &#160; upper = 300;&#160;<br/>&#160; &#160; step = 20;&#160;<br/>
which set the variables to their initial values. Individual statements are terminated by&#160;<br/>semicolons. &#160;<br/>
Each line of the table is computed the same way, so we use a loop that repeats once per output&#160;<br/>line; this is the purpose of&#160;the&#160;while&#160;loop &#160;<br/>
&#160;<br/>&#160;<br/>&#160; &#160; while (fahr &lt;= upper) {&#160;<br/>&#160; &#160; &#160; &#160;...&#160;<br/>&#160; &#160; }&#160;<br/>
The&#160;while&#160;loop operates as follows: The condition in parentheses is tested. If it is true (fahr&#160;<br/>is less than or equal to&#160;upper), the body of the loop (the three&#160;statements enclosed in braces)&#160;<br/>is executed. Then the condition is re-tested, and if true, the body is executed again. When the&#160;<br/>test becomes false (fahr&#160;exceeds&#160;upper) the loop ends, and execution continues at the&#160;<br/>statement that follows the loop. There are no&#160;further statements in this program, so it&#160;<br/>terminates. &#160;<br/>
The body of a&#160;while&#160;can be one or more statements enclosed in braces, as in the temperature&#160;<br/>converter, or a single statement without braces, as in &#160;<br/>
&#160;<br/>&#160; &#160;while (i &lt; j)&#160;<br/>&#160; &#160; &#160; &#160;i = 2 * i;&#160;<br/>
In either case, we will always indent the statements controlled by the&#160;while&#160;by one tab stop&#160;<br/>(which we have shown as four spaces) so you can see at a glance which statements are inside&#160;<br/>the loop. The indentation emphasizes the logical structure of the program. Although C&#160;<br/>compilers do not care about how a program&#160;looks, proper indentation and spacing are critical&#160;<br/>in making programs easy for people to read.&#160;We recommend writing only one statement per&#160;<br/>line, and using blanks around operators to clarify grouping. The position of braces is less&#160;<br/>important, although people hold passionate beliefs. We&#160;have chosen one of several popular&#160;<br/>styles. Pick a style that suits you, then use it consistently. &#160;<br/>
<hr/>
<a name=14></a>&#160;&#160;<br/>
14&#160;<br/>
Most of the work gets done in the body of the&#160;loop. The Celsius temperature is computed and&#160;<br/>assigned to the variable&#160;celsius&#160;by the statement &#160;<br/>
&#160;<br/>&#160; &#160; &#160; &#160; celsius = 5 * (fahr-32) / 9;&#160;<br/>
The reason for multiplying by 5 and dividing by 9 instead of&#160;just multiplying by&#160;5/9&#160;is that in&#160;<br/>C, as in many other languages, integer division&#160;<i>truncates</i>: any fractional part is discarded.&#160;<br/>Since&#160;5&#160;and&#160;9&#160;are integers.&#160;5/9&#160;would be truncated to zero and so all the Celsius temperatures&#160;<br/>would be reported as zero. &#160;<br/>
This example also shows a bit more of how&#160;printf&#160;works.&#160;printf&#160;is a general-purpose&#160;<br/>output formatting function, which we<a href="">&#160;will describe in detail in&#160;Chapter 7</a>. Its first argument is&#160;<br/>a string of characters to&#160;be printed, with each&#160;%&#160;indicating where one of the other (second,&#160;<br/>third, ...) arguments is to be substituted, and in&#160;what form&#160;it is to be printed. For instance,&#160;%d&#160;<br/>specifies an integer argument, so the statement &#160;<br/>
&#160;<br/>&#160; &#160; &#160; &#160; printf(&#34;%d\t%d\n&#34;, fahr, celsius);&#160;<br/>
causes the values of&#160;the two integers&#160;fahr&#160;and&#160;celsius&#160;to be printed, with a tab (\t) between&#160;<br/>them. &#160;<br/>
Each&#160;%&#160;construction in the first argument of&#160;printf&#160;is paired with the corresponding second&#160;<br/>argument, third argument, etc.; they must match up properly by number and type, or you will&#160;<br/>get wrong answers. &#160;<br/>
By the way,&#160;printf&#160;is not part of the C language; there is no input or output defined in C&#160;<br/>itself.&#160;printf&#160;is just a useful function from&#160;the standard library of functions that are normally&#160;<br/>accessible to C programs. The behaviour of&#160;printf&#160;is defined in the ANSI standard, however,&#160;<br/>so its properties should be the same with any compiler and library that conforms to the&#160;<br/>standard. &#160;<br/>
In order to concentrate on C itself, we don't talk much about input and output until&#160;<a href="">chapter 7</a>.&#160;<br/>In particular, we will defer formatted input until then. If you have to input numbers, read the&#160;<br/>discussion of the function&#160;scanf&#160;in&#160;<a href="">Section 7.4</a>.&#160;&#160;scanf&#160;is like&#160;printf, except that it reads&#160;<br/>input instead of writing output. &#160;<br/>
There are a couple of problems with the temperature conversion program. The simpler one is&#160;<br/>that the output isn't very pretty because the numbers are not right-justified. That's easy to fix;&#160;<br/>if we augment each&#160;%d&#160;in the&#160;printf&#160;statement with a width, the numbers printed will be&#160;<br/>right-justified in their fields. For instance, we might say &#160;<br/>
&#160;<br/>&#160; &#160;printf(&#34;%3d %6d\n&#34;, fahr, celsius);&#160;<br/>
to print the first number of each line in a field&#160;three digits wide, and the second in a field six&#160;<br/>digits wide, like this: &#160;<br/>&#160;<br/>&#160; &#160; &#160;0 &#160; &#160; -17&#160;<br/>&#160; &#160; 20 &#160; &#160; &#160;-6&#160;<br/>&#160; &#160; 40 &#160; &#160; &#160; 4&#160;<br/>&#160; &#160; 60 &#160; &#160; &#160;15&#160;<br/>&#160; &#160; 80 &#160; &#160; &#160;26&#160;<br/>&#160; &#160;100 &#160; &#160; &#160;37&#160;<br/>&#160; &#160;...&#160;<br/>
<hr/>
<a name=15></a>15<br/>
The more serious problem&#160;is that because we have used integer arithmetic, the Celsius&#160;<br/>temperatures are not very accurate; for instance, 0oF is actually about -17.8oC, not -17. To get&#160;<br/>more accurate answers, we should use floating-point arithmetic instead of integer. This&#160;<br/>requires some changes in the program. Here is the second version: &#160;<br/>
&#160; &#160;#include &lt;stdio.h&gt;&#160;<br/>
&#160; &#160;/* print Fahrenheit-Celsius table&#160;<br/>
for fahr = 0, 20, ..., 300; floating-point version */&#160;<br/>
&#160; &#160;main()&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160;float fahr, celsius;&#160;<br/>&#160; &#160; &#160;float lower, upper, step;&#160;<br/>
&#160; &#160; &#160;lower = 0;<br/>
/* lower limit of temperatuire scale */&#160;<br/>
&#160; &#160; &#160;upper = 300; &#160; &#160;/* upper limit */&#160;<br/>&#160; &#160; &#160;step = 20;<br/>
/* step size */&#160;<br/>
&#160; &#160; &#160;fahr = lower;&#160;<br/>&#160; &#160; &#160;while (fahr &lt;= upper) {&#160;<br/>
celsius = (5.0/9.0) * (fahr-32.0);&#160;<br/>printf(&#34;%3.0f %6.1f\n&#34;, fahr, celsius);&#160;<br/>fahr = fahr + step;&#160;<br/>
&#160; &#160; &#160;}&#160;<br/>&#160; &#160;}&#160;<br/>
This is much the same as before, except that&#160;fahr&#160;and&#160;celsius&#160;are declared to be&#160;float&#160;and&#160;<br/>the formula for conversion is written in a more natural way. We were unable to use&#160;5/9&#160;in the&#160;<br/>previous version because integer division would truncate it to zero. A decimal point in a&#160;<br/>constant indicates that it is floating point, however, so&#160;5.0/9.0&#160;is not truncated because it is&#160;<br/>the ratio of two floating-point values. &#160;<br/>
If an arithmetic operator has integer operands, an integer operation is performed. If an&#160;<br/>arithmetic operator has one floating-point&#160;operand and one integer operand, however, the&#160;<br/>integer will be converted to floating point before the operation is done. If we had written&#160;<br/>(fahr-32), the&#160;32&#160;would be automatically converted to&#160;floating point. Nevertheless, writing&#160;<br/>floating-point constants with explicit decimal points even when they have integral values&#160;<br/>emphasizes their floating-point nature for human readers. &#160;<br/>
The detailed rules for when integers are converted to floating point are in&#160;<a href="">Chapter 2</a>. For now,&#160;<br/>notice that the assignment &#160;<br/>
&#160; &#160;fahr = lower;&#160;<br/>
and the test &#160;<br/>
&#160; &#160;while (fahr &lt;= upper)&#160;<br/>
also work in the natural way - the&#160;int&#160;is converted to&#160;float&#160;before the operation is done. &#160;<br/>
The&#160;printf&#160;conversion specification&#160;%3.0f&#160;says that a floating-point number (here&#160;fahr) is&#160;<br/>to be printed at least three characters wide, with no decimal point and no fraction digits.&#160;<br/>%6.1f&#160;describes another number (celsius) that is to be printed at&#160;least six characters wide,&#160;<br/>with 1 digit after the decimal point. The output looks like this: &#160;<br/>
&#160; &#160; &#160;0 &#160; -17.8&#160;<br/>&#160; &#160; 20 &#160; &#160;-6.7&#160;<br/>&#160; &#160; 40 &#160; &#160; 4.4&#160;<br/>&#160; &#160;...&#160;<br/>
<hr/>
<a name=16></a>16<br/>
Width and precision may be omitted from&#160;a specification:&#160;%6f&#160;says that the number is to be at&#160;<br/>least six characters wide;&#160;%.2f&#160;specifies two characters after&#160;the decimal point, but the width&#160;<br/>is not constrained; and&#160;%f&#160;merely says to print the number as floating point. &#160;<br/>
%d<br/>
&#160;print as decimal integer&#160;<br/>
%6d<br/>
&#160;print as decimal integer, at least 6 characters wide&#160;<br/>
%f<br/>
&#160;print as floating point&#160;<br/>
%6f<br/>
&#160;print as floating point, at least 6 characters wide&#160;<br/>
%.2f<br/>
&#160;print as floating point, 2 characters after decimal point&#160;<br/>
%6.2f<br/>
&#160;print as floating point, at least&#160;6 wide and 2 after decimal point &#160;<br/>
Among others,&#160;printf&#160;also recognizes&#160;%o&#160;for octal,&#160;%x&#160;for hexadecimal,&#160;%c&#160;for character,&#160;%s&#160;<br/>for character string and&#160;%%&#160;for itself. &#160;<br/>
<b>Exercise 1-3.</b>&#160;Modify the temperature conversion program&#160;to print a heading above the table. &#160;<br/>
<b>Exercise 1-4.</b>&#160;Write a program&#160;to print the corresponding Celsius to Fahrenheit table. &#160;<br/>
<b>1.3 The for statement&#160;</b><br/>
There are plenty of different ways to write a program&#160;for a particular task. Let's try a variation&#160;<br/>on the temperature converter. &#160;<br/>
&#160; &#160;#include &lt;stdio.h&gt;&#160;<br/>
&#160; &#160;/* print Fahrenheit-Celsius table */&#160;<br/>&#160; &#160;main()&#160;<br/>&#160; &#160;{&#160;<br/>
int fahr;&#160;<br/>
for (fahr = 0; fahr &lt;= 300; fahr = fahr + 20)&#160;<br/>
printf(&#34;%3d %6.1f\n&#34;, fahr, (5.0/9.0)*(fahr-32));&#160;<br/>
&#160; &#160;}&#160;<br/>
This produces the same answers, but it certainly looks different. One major change is the&#160;<br/>elimination of most of the variables; only&#160;fahr&#160;remains, and we have made it an&#160;int. The&#160;<br/>lower and upper limits and the step size appear only as constants in the&#160;for&#160;statement, itself a&#160;<br/>new construction, and the expression that computes the Celsius temperature now appears as&#160;<br/>the third argument of&#160;printf&#160;instead of a separate assignment statement. &#160;<br/>
This last change is an instance of a general rule&#160;- in any context where it is permissible to use&#160;<br/>the value of some type, you can use a more complicated expression of that type. Since the&#160;<br/>third argument of&#160;printf&#160;must be a floating-point value to match the&#160;%6.1f, any floating-<br/>point expression can occur here. &#160;<br/>
The&#160;&#160;for&#160;statement is a loop, a generalization of the&#160;while. If you compare it to the earlier&#160;<br/>while, its operation should be clear. Within the parentheses, there are three parts, separated&#160;<br/>by semicolons. The first part, the initialization &#160;<br/>
&#160; &#160;fahr = 0&#160;<br/>
<hr/>
<a name=17></a>&#160;&#160;<br/>
17&#160;<br/>
is done once, before the loop proper is entered. The second part is the&#160;<br/>test or condition that controls the loop: &#160;<br/>&#160;<br/>&#160; &#160;fahr &lt;= 300&#160;<br/>
This condition is evaluated; if it is true, the body of the loop (here a single&#160;ptintf) is&#160;<br/>executed. Then the increment step &#160;<br/>&#160;<br/>&#160; &#160;fahr = fahr + 20&#160;<br/>
is executed, and the condition re-evaluated. The&#160;loop terminates if the condition has become&#160;<br/>false. As with the&#160;while, the body of the loop can be a&#160;single statement or a group of&#160;<br/>statements enclosed in braces. The initialization, condition and increment can be any&#160;<br/>expressions. &#160;<br/>
The choice between&#160;while&#160;and&#160;for&#160;is arbitrary, based on which seems clearer. The&#160;for&#160;is&#160;<br/>usually appropriate for loops in which the initialization and increment are single statements&#160;<br/>and logically related, since it is more compact than&#160;while&#160;and it keeps the loop control&#160;<br/>statements together in one place. &#160;<br/>
<b>Exercise 1-5.</b>&#160;Modify the temperature conversion program&#160;to print the table in reverse order,&#160;<br/>that is, from&#160;300 degrees to 0. &#160;<br/>
<b>1.4 Symbolic Constants&#160;</b><br/>
A final observation before we leave temperature&#160;conversion forever. It's bad practice to bury&#160;<br/>``magic numbers''&#160;like 300 and 20 in a program; they convey little information to someone&#160;<br/>who might have to read the program&#160;later, and&#160;they are hard to change in a systematic way.&#160;<br/>One way to deal with magic numbers is&#160;to give them&#160;meaningful names. A&#160;#define&#160;line&#160;<br/>defines a&#160;<i>symbolic name or symbolic constant</i>&#160;to be a particular string of characters: &#160;<br/>
&#160;&#160;#define&#160;<i>name replacement list</i>&#160;&#160;<br/>
Thereafter, any occurrence of&#160;<i>name</i>&#160;(not in quotes and not part of another name) will be&#160;<br/>replaced by the corresponding&#160;<i>replacement text</i>. The&#160;<i>name</i>&#160;has the same form&#160;as a variable&#160;<br/>name: a sequence of letters and digits&#160;that begins with a letter. The&#160;<i>replacement text</i>&#160;can be&#160;<br/>any sequence of characters; it is not limited to numbers. &#160;<br/>
&#160;<br/>&#160; &#160;#include &lt;stdio.h&gt;&#160;<br/>&#160;<br/>&#160; &#160;#define LOWER &#160;0 &#160; &#160; /* lower limit of table */&#160;<br/>&#160; &#160;#define UPPER &#160;300 &#160; /* upper limit */&#160;<br/>&#160; &#160;#define STEP &#160; 20 &#160; &#160;/* step size */&#160;<br/>&#160;<br/>&#160; &#160;/* print Fahrenheit-Celsius table */&#160;<br/>&#160; &#160;main()&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int fahr;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;for (fahr = LOWER; fahr &lt;= UPPER; fahr = fahr + STEP)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;printf(&#34;%3d %6.1f\n&#34;, fahr, (5.0/9.0)*(fahr-32));&#160;<br/>&#160; &#160;}&#160;<br/>
The quantities&#160;LOWER,&#160;UPPER&#160;and&#160;STEP&#160;are symbolic constants, not variables, so they do not&#160;<br/>appear in declarations. Symbolic constant&#160;names are conventionally written in upper case so&#160;<br/>they can ber readily distinguished from&#160;lower&#160;case variable names. Notice that there is no&#160;<br/>semicolon at the end of a&#160;#define&#160;line. &#160;<br/>
<hr/>
<a name=18></a>&#160;&#160;<br/>
18&#160;<br/>
<b>1.5 Character Input and Output&#160;</b><br/>
We are going to consider a family of&#160;related&#160;programs for processing character data. You will&#160;<br/>find that many programs are just expanded versions of the prototypes that we discuss here. &#160;<br/>
The model of input and output supported by the standard library is very simple. Text input or&#160;<br/>output, regardless of where it originates or where it goes to, is dealt with as streams of&#160;<br/>characters. A&#160;<i>text stream</i>&#160;is a sequence of characters divided into lines; each line consists of&#160;<br/>zero or more characters followed by a newline character. It is the responsibility of the library&#160;<br/>to make each input or output stream&#160;confirm&#160;this model; the C programmer using the library&#160;<br/>need not worry about how lines are represented outside the program. &#160;<br/>
The standard library provides several functions&#160;for reading or writing one character at a time,&#160;<br/>of which&#160;getchar&#160;and&#160;putchar&#160;are the simplest. Each time it is called,&#160;getchar&#160;reads the&#160;<br/><i>next input character</i>&#160;from&#160;a text stream&#160;and returns that as its value. That is, after &#160;<br/>
&#160;<br/>&#160; &#160;c = getchar();&#160;<br/>
the variable&#160;c&#160;contains the next character of input. The characters normally come from&#160;the&#160;<br/>keyboard; input from<a href="">&#160;files is discussed in&#160;Chapter 7. &#160;</a><br/>
The function&#160;putchar&#160;prints a character each time it is called: &#160;<br/>
&#160;<br/>&#160; &#160;putchar(c);&#160;<br/>
prints the contents of&#160;the integer variable&#160;c&#160;as a character, usually on the screen. Calls to&#160;<br/>putchar&#160;and&#160;printf&#160;may be interleaved; the output will appear in the order in which the calls&#160;<br/>are made. &#160;<br/>
<b>1.5.1 File Copying&#160;</b><br/>
Given&#160;&#160;getchar&#160;and&#160;putchar, you can write a surprising amount&#160;of useful code without&#160;<br/>knowing anything more about input and output.&#160;The simplest example is a program&#160;that&#160;<br/>copies its input to its output one character at a time: &#160;<br/>&#160;<br/><i>read a character</i>&#160;<br/>&#160; &#160; while (<i>charater is not end-of-file indicator</i>)&#160;<br/>&#160; &#160; &#160; &#160;&#160;<i>output the character just read&#160;<br/>&#160; &#160; &#160; &#160; read a character</i>&#160;<br/>
Converting this into C gives: &#160;<br/>&#160;<br/>&#160; &#160;#include &lt;stdio.h&gt;&#160;<br/>&#160;<br/>&#160; &#160;/* copy input to output; 1st version &#160;*/&#160;<br/>&#160; &#160;main()&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int c;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;c = getchar();&#160;<br/>&#160; &#160; &#160; &#160;while (c != EOF) {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;putchar(c);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;c = getchar();&#160;<br/>&#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160;}&#160;<br/>
The relational operator&#160;!=&#160;means ``not equal to''.&#160;&#160;<br/>
<hr/>
<a name=19></a>&#160;&#160;<br/>
19&#160;<br/>
What appears to be a character on the keyboard&#160;or screen is of course, like everything else,&#160;<br/>stored internally just as a bit pattern. The type&#160;char&#160;is specifically meant for storing such&#160;<br/>character data, but any integer type can be used. We used&#160;int&#160;for a subtle but important&#160;<br/>reason. &#160;<br/>
The problem&#160;is distinguishing the end of input from&#160;valid data. The solution is that&#160;getchar&#160;<br/>returns a distinctive value when there is no more&#160;input, a value that cannot be confused with&#160;<br/>any real character. This value is called&#160;EOF, for ``end of file''.&#160;We must declare&#160;c&#160;to be a type&#160;<br/>big enough to hold any value that&#160;getchar&#160;returns. We can't&#160;use&#160;char&#160;since&#160;c&#160;must be big&#160;<br/>enough to hold&#160;EOF&#160;in addition to any possible&#160;char. Therefore we use&#160;int. &#160;<br/>
EOF&#160;is an integer defined in &lt;stdio.h&gt;, but the&#160;specific numeric value doesn't&#160;matter as long as&#160;<br/>it is not the same as any&#160;char&#160;value. By using the symbolic constant, we are assured that&#160;<br/>nothing in the program&#160;depends on the specific numeric value. &#160;<br/>
The program&#160;for copying would be written more&#160;concisely by experienced C programmers. In&#160;<br/>C, any assignment, such as &#160;<br/>
&#160;<br/>&#160; &#160;c = getchar();&#160;<br/>
is an expression and has a value, which is the value of the left hand side after the assignment.&#160;<br/>This means that a assignment can appear as part&#160;of a larger expression.&#160;If the assignment of a&#160;<br/>character to&#160;c&#160;is put inside the test part of a&#160;while&#160;loop, the copy program&#160;can be written this&#160;<br/>way: &#160;<br/>&#160;<br/>&#160; &#160;#include &lt;stdio.h&gt;&#160;<br/>&#160;<br/>&#160; &#160;/* copy input to output; 2nd version &#160;*/&#160;<br/>&#160; &#160;main()&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int c;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;while ((c = getchar()) != EOF)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;putchar(c);&#160;<br/>&#160; &#160;}&#160;<br/>
The&#160;while&#160;gets a character, assigns it to&#160;c, and then tests whether the character was the end-<br/>of-file signal. If it&#160;was not, the body of the&#160;while&#160;is executed, printing the character. The&#160;<br/>while&#160;then repeats. When the end of&#160;the input is finally reached, the&#160;while&#160;terminates and so&#160;<br/>does&#160;main. &#160;<br/>
This version centralizes the input - there is now only one reference to&#160;getchar&#160;- and shrinks&#160;<br/>the program. The resulting program&#160;is more compact, and, once the idiom&#160;is mastered, easier&#160;<br/>to read. You'll see this style often. (It's possible to get carried away and create impenetrable&#160;<br/>code, however, a tendency that we will try to curb.) &#160;<br/>
The parentheses around the assignment, within the condition are necessary. The&#160;<i>precedence</i>&#160;<br/>of&#160;&#160;!=&#160;is higher than that of&#160;=, which means that in the absence of parentheses the relational&#160;<br/>test&#160;!=&#160;would be done before the assignment&#160;=. So the statement &#160;<br/>
&#160;<br/>&#160; &#160;c = getchar() != EOF&#160;<br/>
is equivalent to &#160;<br/>&#160;<br/>&#160; &#160;c = (getchar() != EOF)&#160;<br/>
<hr/>
<a name=20></a>&#160;&#160;<br/>
20&#160;<br/>
This has the undesired effect of setting&#160;c&#160;to 0 or 1, depending on whether or not the call of&#160;<br/>getchar&#160;returned end of file. (More on this in&#160;<a href="">Chapter 2</a>.) &#160;<br/>
<b>Exercsise 1-6.</b>&#160;Verify that the expression&#160;getchar() != EOF&#160;is 0 or 1. &#160;<br/>
<b>Exercise 1-7.</b>&#160;Write a program&#160;to print the value of&#160;EOF. &#160;<br/>
<b>1.5.2 Character Counting&#160;</b><br/>
The next program&#160;counts characters; it is similar to the copy program. &#160;<br/>&#160;<br/>&#160; &#160;#include &lt;stdio.h&gt;&#160;<br/>&#160;<br/>&#160; &#160;/* count characters in input; 1st version */&#160;<br/>&#160; &#160;main()&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;long nc;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;nc = 0;&#160;<br/>&#160; &#160; &#160; &#160;while (getchar() != EOF)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;++nc;&#160;<br/>&#160; &#160; &#160; &#160;printf(&#34;%ld\n&#34;, nc);&#160;<br/>&#160; &#160;}&#160;<br/>
The statement &#160;<br/>&#160;<br/>&#160; &#160;++nc;&#160;<br/>
presents a new operator,&#160;++, which means&#160;<i>increment by one</i>. You could instead write&#160;nc = nc&#160;<br/>+ 1&#160;but&#160;++nc&#160;is more concise and often more efficient. There is a corresponding operator&#160;--&#160;<br/>to decrement by 1. The operators&#160;++&#160;and&#160;--&#160;can be either prefix operators (++nc) or postfix&#160;<br/>operators (nc++); these two forms have different values in expressions, as will be shown in&#160;<br/><a href="">Chapter 2, but&#160;</a>++nc&#160;and&#160;nc++&#160;both increment&#160;nc. For the moment we will will stick to the&#160;<br/>prefix form. &#160;<br/>
The character counting program&#160;accumulates its count in a&#160;long&#160;variable instead of&#160;an int.&#160;<br/>long&#160;integers are at least 32 bits. Although on some machines,&#160;int&#160;and&#160;long&#160;are the same&#160;<br/>size, on others an&#160;int&#160;is 16 bits, with a maximum&#160;value&#160;of 32767, and it would take relatively&#160;<br/>little input to overflow an&#160;int&#160;counter. The conversion specification&#160;%ld&#160;tells&#160;printf&#160;that the&#160;<br/>corresponding argument is a&#160;long&#160;integer. &#160;<br/>
It may be possible to cope with even bigger numbers by using a&#160;double&#160;(double precision&#160;<br/>float). We will also use a&#160;for&#160;statement instead of a&#160;while, to illustrate another way to write&#160;<br/>the loop. &#160;<br/>
&#160;<br/>&#160; &#160; #include &lt;stdio.h&gt;&#160;<br/>&#160;<br/>&#160; &#160;/* count characters in input; 2nd version */&#160;<br/>&#160; &#160;main()&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;double nc;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;for (nc = 0; gechar() != EOF; ++nc)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;;&#160;<br/>&#160; &#160; &#160; &#160;printf(&#34;%.0f\n&#34;, nc);&#160;<br/>&#160; &#160;}&#160;<br/>
<hr/>
<a name=21></a>&#160;&#160;<br/>
21&#160;<br/>
printf&#160;uses&#160;%f&#160;for both&#160;float&#160;and&#160;double;&#160;%.0f&#160;suppresses the printing of the decimal point&#160;<br/>and the fraction part, which is zero. &#160;<br/>
The body of this&#160;for&#160;loop is empty, because all the work&#160;is done in the test and increment&#160;<br/>parts. But the grammatical rules of&#160;C require that a&#160;for&#160;statement have a body. The isolated&#160;<br/>semicolon, called a&#160;<i>null statement</i>, is there to satisfy that requirement. We put it on a separate&#160;<br/>line to make it visible. &#160;<br/>
Before we leave the character counting program, observe that if the input contains no&#160;<br/>characters, the&#160;while&#160;or&#160;for&#160;test fails on the very first call to&#160;getchar, and the program&#160;<br/>produces zero, the right answer. This is important. One of the nice things about&#160;while&#160;and&#160;<br/>for&#160;is that they test at the top of the loop, before proceeding with the body. If there is nothing&#160;<br/>to do, nothing is done, even if that means never going through the loop body. Programs&#160;<br/>should act intelligently when given zero-length input. The&#160;while&#160;and&#160;for&#160;statements help&#160;<br/>ensure that programs do reasonable things with boundary conditions. &#160;<br/>
<b>1.5.3 Line Counting&#160;</b><br/>
The next program&#160;counts input lines. As we mentioned above, the standard library ensures&#160;<br/>that an input text stream&#160;appears as a sequence of lines, each terminated by a newline. Hence,&#160;<br/>counting lines is just counting newlines: &#160;<br/>&#160;<br/>&#160; &#160;#include &lt;stdio.h&gt;&#160;<br/>&#160;<br/>&#160; &#160;/* count lines in input */&#160;<br/>&#160; &#160;main()&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int c, nl;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;nl = 0;&#160;<br/>&#160; &#160; &#160; &#160;while ((c = getchar()) != EOF)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;if (c == '\n')&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;++nl;&#160;<br/>&#160; &#160; &#160; &#160;printf(&#34;%d\n&#34;, nl);&#160;<br/>&#160; &#160;}&#160;<br/>
The body of the&#160;while&#160;now consists of an&#160;if, which in turn controls the increment&#160;++nl. The&#160;<br/>if&#160;statement tests the parenthesized condition, and if the condition is true, executes the&#160;<br/>statement (or group of statements in braces) that follows. We have again indented to show&#160;<br/>what is controlled by what. &#160;<br/>
The double equals sign&#160;==&#160;is the C notation for ``is equal to''&#160;(like Pascal's single&#160;=&#160;or&#160;<br/>Fortran's&#160;.EQ.). This symbol is used to distinguish the equality test from&#160;the single&#160;=&#160;that C&#160;<br/>uses for assignment. A word of caution: newcomers to C occasionally write&#160;=&#160;when they&#160;<br/>mean&#160;==<a href="">. As we will see in&#160;Chapter 2</a>, the result is usually a legal expression, so you will get&#160;<br/>no warning. &#160;<br/>
A character written between single quotes represents an integer value equal to the numerical&#160;<br/>value of the character in the machine's character set. This is called a&#160;<i>character constant</i>,&#160;<br/>although it is just another way to write&#160;a small integer. So, for example,&#160;'A'&#160;is a character&#160;<br/>constant; in the ASCII character set its value is&#160;65, the internal representation of the character&#160;<br/>A. Of course,&#160;'A'&#160;is to be preferred over&#160;65: its meaning is obvious, and it is independent of a&#160;<br/>particular character set. &#160;<br/>
<hr/>
<a name=22></a>&#160;&#160;<br/>
22&#160;<br/>
The escape sequences used in string constants are also legal in character constants, so&#160;'\n'&#160;<br/>stands for the value of the newline character,&#160;which is 10 in ASCII.&#160;You should note carefully&#160;<br/>that&#160;'\n'&#160;is a single character, and in expressions is just an integer; on the other hand,&#160;'\n'&#160;is&#160;<br/>a string constant that happens to contain only one character. The topic of strings versus&#160;<br/><a href="">characters is discussed further in&#160;Chapter 2. &#160;</a><br/>
<b>Exercise 1-8.</b>&#160;Write a program&#160;to count blanks, tabs, and newlines. &#160;<br/>
<b>Exercise 1-9.</b>&#160;Write a program&#160;to copy its input to its&#160;output, replacing each&#160;string of one or&#160;<br/>more blanks by a single blank. &#160;<br/>
<b>Exercise 1-10.</b>&#160;Write a program&#160;to copy its input to its output, replacing each tab by&#160;\t, each&#160;<br/>backspace by&#160;\b, and each backslash by&#160;\\. This makes tabs and backspaces visible in an&#160;<br/>unambiguous way. &#160;<br/>
<b>1.5.4 Word Counting&#160;</b><br/>
The fourth in our series of useful programs counts lines, words, and characters, with the loose&#160;<br/>definition that a word is any sequence of characters that does not contain a blank, tab or&#160;<br/>newline. This is a bare-bones version of the UNIX program&#160;wc. &#160;<br/>&#160;<br/>&#160; &#160;#include &lt;stdio.h&gt;&#160;<br/>&#160;<br/>&#160; &#160;#define IN &#160; 1 &#160;/* inside a word */&#160;<br/>&#160; &#160;#define OUT &#160;0 &#160;/* outside a word */&#160;<br/>&#160;<br/>&#160; &#160;/* count lines, words, and characters in input */&#160;<br/>&#160; &#160;main()&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int c, nl, nw, nc, state;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;state = OUT;&#160;<br/>&#160; &#160; &#160; &#160;nl = nw = nc = 0;&#160;<br/>&#160; &#160; &#160; &#160;while ((c = getchar()) != EOF) {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;++nc;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;if (c == '\n')&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;++nl;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;if (c == ' ' || c == '\n' || c = '\t')&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;state = OUT;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;else if (state == OUT) {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;state = IN;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;++nw;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160; &#160; &#160;printf(&#34;%d %d %d\n&#34;, nl, nw, nc);&#160;<br/>&#160; &#160;}&#160;<br/>
Every time the program&#160;encounters the first character of a word, it counts one more word. The&#160;<br/>variable&#160;state&#160;records whether the program&#160;is currently&#160;in a word or not; initially it is ``not in&#160;<br/>a word'',&#160;which is assigned the value&#160;OUT. We prefer the symbolic constants&#160;IN&#160;and&#160;OUT&#160;to the&#160;<br/>literal values 1 and 0 because they make the program&#160;more readable. In a program&#160;as tiny as&#160;<br/>this, it makes little difference, but in larger programs, the increase in clarity is well worth the&#160;<br/>modest extra effort to write it this way from&#160;the beginning. You'll also find that it's easier to&#160;<br/>make extensive changes in programs where&#160;magic numbers appear only as symbolic&#160;<br/>constants. &#160;<br/>
<hr/>
<a name=23></a>&#160;&#160;<br/>
23&#160;<br/>
The line &#160;<br/>
&#160;<br/>&#160; &#160;nl = nw = nc = 0;&#160;<br/>
sets all three variables to zero. This is not a special case, but a consequence of the fact that an&#160;<br/>assignment is an expression with the value and assignments associated from&#160;right to left. It's&#160;<br/>as if&#160;we had written &#160;<br/>&#160;<br/>&#160; &#160;nl = (nw = (nc = 0));&#160;<br/>
The operator&#160;||&#160;means OR, so the line &#160;<br/>&#160;<br/>&#160; &#160;if (c == ' ' || c == '\n' || c = '\t')&#160;<br/>
says ``if&#160;c&#160;is a blank&#160;<i>or</i>&#160;c&#160;is a newline&#160;<i>or</i>&#160;c&#160;is a tab''.&#160;(Recall that the escape sequence&#160;\t&#160;is a&#160;<br/>visible representation of the tab character.) There is a corresponding operator&#160;&amp;&amp;&#160;for AND; its&#160;<br/>precedence is just higher than&#160;||. Expressions connected by&#160;&amp;&amp;&#160;or&#160;||&#160;are evaluated left to&#160;<br/>right, and it is guaranteed that evaluation will&#160;stop as soon as the truth or falsehood is known.&#160;<br/>If&#160;&#160;c&#160;is a blank, there is no need to test whether&#160;it is a newline or tab, so these tests are not&#160;<br/>made. This isn't particularly important here, but&#160;is significant in more complicated situations,&#160;<br/>as we will soon see. &#160;<br/>
The example also shows an&#160;else, which specifies an alternative&#160;action if the condition part of&#160;<br/>an&#160;if&#160;statement is false. The general form&#160;is &#160;<br/>
&#160;<br/>&#160; &#160;if (<i>expression</i>)&#160;<br/>&#160; &#160; &#160; &#160;<i>statement1</i>&#160;<br/>&#160; &#160;else&#160;<br/>&#160; &#160; &#160; &#160;<i>statement2</i>&#160;<br/>One and only one of the two statements associated with an&#160;if-else&#160;is performed. If the&#160;<br/><i>expression</i>&#160;is true,&#160;<i>statement1</i>&#160;is executed; if not,&#160;<i>statement2</i>&#160;is executed. Each&#160;<i>statement</i>&#160;can&#160;<br/>be a single statement or several in braces. In&#160;the word count program, the one after the&#160;else&#160;is&#160;<br/>an&#160;if&#160;that controls two statements in braces. &#160;<br/>
<b>Exercise 1-11.</b>&#160;How would you test the word count program?&#160;What kinds of input are most&#160;<br/>likely to uncover bugs if there are any?&#160;&#160;<br/>
<b>Exercise 1-12.</b>&#160;Write a program&#160;that prints its input one word per line. &#160;<br/>
<b>1.6 Arrays&#160;</b><br/>
Let is write a program&#160;to count the number of&#160;occurrences of each digit, of white space&#160;<br/>characters (blank, tab, newline), and of all other characters. This is artificial, but it permits us&#160;<br/>to illustrate several aspects of&#160;C in one program. &#160;<br/>
There are twelve categories of input, so it is convenient to use an array to hold the number of&#160;<br/>occurrences of each digit, rather than ten individual variables. Here is one version of the&#160;<br/>program: &#160;<br/>
<hr/>
<a name=24></a>&#160;&#160;<br/>
24&#160;<br/>
&#160;<br/>&#160; &#160;#include &lt;stdio.h&gt;&#160;<br/>&#160;<br/>&#160; &#160;/* count digits, white space, others */&#160;<br/>&#160; &#160;main()&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int c, i, nwhite, nother;&#160;<br/>&#160; &#160; &#160; &#160;int ndigit[10];&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;nwhite = nother = 0;&#160;<br/>&#160; &#160; &#160; &#160;for (i = 0; i &lt; 10; ++i)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;ndigit[i] = 0;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;while ((c = getchar()) != EOF)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;if (c &gt;= '0' &amp;&amp; c &lt;= '9')&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;++ndigit[c-'0'];&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;else if (c == ' ' || c == '\n' || c == '\t')&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;++nwhite;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;else&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;++nother;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;printf(&#34;digits =&#34;);&#160;<br/>&#160; &#160; &#160; &#160;for (i = 0; i &lt; 10; ++i)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;printf(&#34; %d&#34;, ndigit[i]);&#160;<br/>&#160; &#160; &#160; &#160;printf(&#34;, white space = %d, other = %d\n&#34;,&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;nwhite, nother);&#160;<br/>&#160; &#160;}&#160;<br/>
The output of this program&#160;on itself is &#160;<br/>&#160;<br/>&#160; &#160;digits = 9 3 0 0 0 0 0 0 0 1, white space = 123, other = 345&#160;<br/>
The declaration &#160;<br/>&#160;<br/>&#160; &#160;int ndigit[10];&#160;<br/>
declares&#160;ndigit&#160;to be an array of 10 integers. Array subscripts always start at zero in C, so&#160;<br/>the elements are&#160;ndigit[0], ndigit[1], ...,&#160;ndigit[9]. This is reflected in the&#160;for&#160;<br/>loops that initialize and print the array. &#160;<br/>
A subscript can be any integer expression, which includes integer variables like&#160;i, and integer&#160;<br/>constants. &#160;<br/>
This particular program&#160;relies on the properties&#160;of the character representation of the digits.&#160;<br/>For example, the test &#160;<br/>
&#160;<br/>&#160; &#160;if (c &gt;= '0' &amp;&amp; c &lt;= '9')&#160;<br/>
determines whether the character in&#160;c&#160;is a digit. If it is, the numeric value of that digit is &#160;<br/>&#160;<br/>&#160; &#160;c - '0'&#160;<br/>
This works only if&#160;'0', '1', ..., '9'&#160;have consecutive increasing values. Fortunately,&#160;<br/>this is true for all character sets. &#160;<br/>
By definition,&#160;chars are just small integers, so&#160;char&#160;variables and constants are identical to&#160;<br/>ints in arithmetic expressions. This is natural and convenient; for example&#160;c-'0'&#160;is an&#160;<br/>integer expression with a value between&#160;0 and 9 corresponding to the character&#160;'0'&#160;to&#160;'9'&#160;<br/>stored in&#160;c, and thus a valid subscript for the array&#160;ndigit. &#160;<br/>
The decision as to whether a character is a digit,&#160;white space, or something else is made with&#160;<br/>the sequence &#160;<br/>
<hr/>
<a name=25></a>&#160;&#160;<br/>
25&#160;<br/>
&#160;<br/>&#160; &#160;if (c &gt;= '0' &amp;&amp; c &lt;= '9')&#160;<br/>&#160; &#160; &#160; &#160;++ndigit[c-'0'];&#160;<br/>&#160; &#160;else if (c == ' ' || c == '\n' || c == '\t')&#160;<br/>&#160; &#160; &#160; &#160;++nwhite;&#160;<br/>&#160; &#160;else&#160;<br/>&#160; &#160; &#160; &#160;++nother;&#160;<br/>
The pattern &#160;<br/>&#160;<br/>&#160; &#160;if (<i>condition1</i>)&#160;<br/>&#160; &#160; &#160; &#160;<i>statement1</i>&#160;<br/>&#160; &#160;else if (<i>condition2</i>)&#160;<br/>&#160; &#160; &#160; &#160;<i>statement2</i>&#160;<br/>&#160; &#160; &#160; &#160;...&#160;<br/>&#160; &#160; &#160; &#160;...&#160;<br/>&#160; &#160;else&#160;<br/>&#160; &#160; &#160; &#160;<i>statementn</i>&#160;<br/>occurs frequently in programs as a way to express a multi-way decision. The&#160;<i>conditions</i>&#160;are&#160;<br/>evaluated in order from&#160;the top until some&#160;<i>condition</i>&#160;is satisfied; at that point the&#160;<br/>corresponding&#160;&#160;<i>statement</i>&#160;part is executed, and the entire construction is finished. (Any&#160;<br/><i>statement</i>&#160;can be several statements enclosed in braces.) If none of the conditions is satisfied,&#160;<br/>the&#160;<i>statement</i>&#160;after the final&#160;else&#160;is executed if&#160;it is present. If&#160;the final&#160;else&#160;and&#160;<i>statement</i>&#160;<br/>are omitted, as in the word count program, no action takes place. There can be any number of &#160;<br/>
else if(<i>condition</i>)&#160;<br/>&#160;&#160;<i>statement</i>&#160;&#160;<br/>
groups between the initial&#160;if&#160;and the final&#160;else. &#160;<br/>
As a matter of&#160;style, it is advisable to format&#160;this construction as we have shown; if each&#160;if&#160;<br/>were indented past the previous&#160;else, a long sequence of decisions would march off the right&#160;<br/>side of the page. &#160;<br/>
The&#160;switch&#160;statement, to be discussed in&#160;<a href="">Chapter 4, provides another way to write a m</a>ulti-<br/>way branch that is particulary suitable when&#160;the condition is whether some integer or&#160;<br/>character expression matches one of&#160;a set of&#160;constants. For contrast, we will present a&#160;switch&#160;<br/>version of this program&#160;in&#160;<a href="">Section 3.4</a>. &#160;<br/>
<b>Exercise 1-13.</b>&#160;Write a program&#160;to print a histogram&#160;of the lengths of words in its input. It is&#160;<br/>easy to draw the histogram&#160;with the bars horizontal; a vertical orientation is more challenging. &#160;<br/>
<b>Exercise 1-14.</b>&#160;Write a program&#160;to print a histogram&#160;of the frequencies of different characters&#160;<br/>in its input. &#160;<br/>
<b>1.7 Functions&#160;</b><br/>
In C, a function is equivalent&#160;to a subroutine or function in Fortran, or a procedure or function&#160;<br/>in Pascal. A function provides a convenient way&#160;to encapsulate some computation, which can&#160;<br/>then be used without worrying about its implementation. With properly designed functions, it&#160;<br/>is possible to ignore&#160;<i>how</i>&#160;a job is done; knowing&#160;<i>what</i>&#160;is done is sufficient. C makes the sue of&#160;<br/>functions easy, convinient and efficient; you will&#160;often see a short function defined and called&#160;<br/>only once, just because it clarifies some piece of code. &#160;<br/>
<hr/>
<a name=26></a>&#160;&#160;<br/>
26&#160;<br/>
So far we have used only functions like&#160;printf,&#160;&#160;getchar&#160;and&#160;putchar&#160;that have been&#160;<br/>provided for us; now it's time to write a few of our own. Since C has no exponentiation&#160;<br/>operator like the&#160;**&#160;of&#160;Fortran, let us illustrate the mechanics of&#160;function definition by writing&#160;<br/>a function&#160;power(m,n)&#160;to raise an integer&#160;m&#160;to a positive integer power&#160;n. That is, the value of&#160;<br/>power(2,5)&#160;is 32. This function is not a practical&#160;exponentiation routine, since it handles&#160;<br/>only positive powers of small integers, but&#160;it's good enough for illustration.(The standard&#160;<br/>library contains a function&#160;pow(x,y)&#160;that computes&#160;<i>xy</i>.) &#160;<br/>
Here is the function&#160;power&#160;and a main program&#160;to exercise it, so you can see the whole&#160;<br/>structure at once. &#160;<br/>
&#160;<br/>&#160; &#160;#include &lt;stdio.h&gt;&#160;<br/>&#160;<br/>&#160; &#160;int power(int m, int n);&#160;<br/>&#160;<br/>&#160; &#160; /* test power function */&#160;<br/>&#160; &#160; main()&#160;<br/>&#160; &#160; {&#160;<br/>&#160; &#160; &#160; &#160; int i;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160; for (i = 0; i &lt; 10; ++i)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; printf(&#34;%d %d %d\n&#34;, i, power(2,i), power(-3,i));&#160;<br/>&#160; &#160; &#160; &#160; return 0;&#160;<br/>&#160; &#160; }&#160;<br/>&#160;<br/>&#160; &#160; /* power: &#160;raise base to n-th power; n &gt;= 0 */&#160;<br/>&#160; &#160; int power(int base, int n)&#160;<br/>&#160; &#160; {&#160;<br/>&#160; &#160; &#160; &#160; int i, &#160;p;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160; p = 1;&#160;<br/>&#160; &#160; &#160; &#160; for (i = 1; i &lt;= n; ++i)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; p = p * base;&#160;<br/>&#160; &#160; &#160; &#160; return p;&#160;<br/>&#160; &#160; }&#160;<br/>
A function definition has this form: &#160;<br/>&#160;<br/>return-type function-name(parameter declarations, if any)&#160;<br/>{&#160;<br/>&#160; &#160;declarations&#160;<br/>&#160; &#160;statements&#160;<br/>}&#160;<br/>
Function definitions can appear in any order,&#160;and in one source file or several, although no&#160;<br/>function can be split between files. If the source program&#160;appears in several files, you may&#160;<br/>have to say more to compile and load it than if&#160;it all appears in one, but that is an operating&#160;<br/>system&#160;matter, not a language attribute. For the moment, we will assume that both functions&#160;<br/>are in the same file, so whatever you have learned about running C programs will still work. &#160;<br/>
The function&#160;power&#160;is called twice by&#160;main, in the line &#160;<br/>
&#160;<br/>&#160; &#160;printf(&#34;%d %d %d\n&#34;, i, power(2,i), power(-3,i));&#160;<br/>
Each call passes two arguments to&#160;power, which each time returns an integer to be formatted&#160;<br/>and printed. In an expression,&#160;power(2,i)&#160;is an integer just as&#160;2&#160;and&#160;i&#160;are. (Not all functions&#160;<br/>produce an integer value; we will take this up in&#160;<a href="">Chapter 4.) &#160;</a><br/>
The first line of&#160;power&#160;itself,&#160;&#160;<br/>
<hr/>
<a name=27></a>&#160;&#160;<br/>
27&#160;<br/>
&#160;<br/>&#160; &#160; int power(int base, int n)&#160;<br/>
declares the parameter types and names, and the&#160;type of&#160;the result that the function returns.&#160;<br/>The names used by&#160;power&#160;for its parameters are local to&#160;power, and are not visible to any&#160;<br/>other function: other routines can use the same names without conflict. This&#160;is also true of the&#160;<br/>variables&#160;i&#160;and&#160;p: the&#160;i&#160;in&#160;power&#160;is unrelated to the&#160;i&#160;in&#160;main. &#160;<br/>
We will generally use&#160;<i>parameter</i>&#160;for a variable named in the&#160;parenthesized list in a function.&#160;<br/>The terms&#160;<i>formal argument</i>&#160;and&#160;<i>actual argument</i>&#160;are sometimes used for the same distinction. &#160;<br/>
The value that&#160;power&#160;computes is returned to&#160;main&#160;by the&#160;return: statement. Any expression&#160;<br/>may follow&#160;return: &#160;<br/>
&#160;<br/>&#160; &#160;return&#160;<i>expression</i>;&#160;<br/>
A function need not return a value; a return statement with no expression causes control, but&#160;<br/>no useful value, to be returned to the caller,&#160;as does ``falling off the end''&#160;of a function by&#160;<br/>reaching the terminating right brace. And the calling function can ignore a value returned by a&#160;<br/>function. &#160;<br/>
You may have noticed that there is a&#160;return&#160;statement at the end of&#160;main. Since&#160;main&#160;is a&#160;<br/>function like any other, it may return a value to its&#160;caller, which is in effect the environment in&#160;<br/>which the program&#160;was executed. Typically,&#160;a return value of&#160;zero implies normal&#160;<br/>termination; non-zero values signal unusual or&#160;erroneous termination conditions. In the&#160;<br/>interests of&#160;simplicity, we have omitted&#160;return&#160;statements from&#160;our&#160;main&#160;functions up to this&#160;<br/>point, but we will include them&#160;hereafter, as a&#160;reminder that programs should return status to&#160;<br/>their environment. &#160;<br/>
The declaration &#160;<br/>
&#160;<br/>&#160; &#160; int power(int base, int n);&#160;<br/>
just before&#160;main&#160;says that&#160;power&#160;is a function that expects two&#160;int&#160;arguments and returns an&#160;<br/>int. This declaration, which is called a&#160;<i>function prototype</i>, has to agree with the definition&#160;<br/>and uses of&#160;power. It is an error if the definition of&#160;a function or any uses of it do not agree&#160;<br/>with its prototype. &#160;<br/>
parameter names need not agree. Indeed,&#160;parameter names are optional in a function&#160;<br/>prototype, so for the prototype we could have written &#160;<br/>
&#160;<br/>&#160; &#160; int power(int, int);&#160;<br/>
Well-chosen names are good documentation however, so we will often use them. &#160;<br/>
A note of history: the biggest change between&#160;ANSI C and earlier versions is how functions&#160;<br/>are declared and defined. In the&#160;original definition of C, the&#160;power&#160;function would have been&#160;<br/>written like this: &#160;<br/>
<hr/>
<a name=28></a>&#160;&#160;<br/>
28&#160;<br/>
&#160;<br/>&#160; &#160;/* power: &#160;raise base to n-th power; n &gt;= 0 */&#160;<br/>&#160; &#160;/* &#160; &#160; &#160; &#160; (old-style version) */&#160;<br/>&#160; &#160;power(base, n)&#160;<br/>&#160; &#160;int base, n;&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int i, p;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;p = 1;&#160;<br/>&#160; &#160; &#160; &#160;for (i = 1; i &lt;= n; ++i)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;p = p * base;&#160;<br/>&#160; &#160; &#160; &#160;return p;&#160;<br/>&#160; &#160;}&#160;<br/>
The parameters are named between the parentheses, and their types are declared before&#160;<br/>opening the left brace; undeclared parameters are taken as&#160;int. (The body of the function is&#160;<br/>the same&#160;as before.) &#160;<br/>
The declaration of&#160;power&#160;at the beginning of the program&#160;would have looked like this: &#160;<br/>
&#160;<br/>&#160; &#160; int power();&#160;<br/>
No parameter list was permitted, so the&#160;compiler could not readily check that&#160;power&#160;was&#160;<br/>being called correctly. Indeed, since by default&#160;power&#160;would have been assumed to return an&#160;<br/>int, the entire declaration might well have been omitted. &#160;<br/>
The new syntax of function prototypes makes it much easier for a compiler to detect errors in&#160;<br/>the number of&#160;arguments or their types. The old style of&#160;declaration and definition still works&#160;<br/>in ANSI C, at least for a transition period,&#160;but we strongly recommend that you use the new&#160;<br/>form&#160;when you have a compiler that supports it. &#160;<br/>
<b>Exercise 1.15.</b>&#160;Rewrite the temperature conversion program&#160;of&#160;<a href="cs.html#11">Section 1.2</a>&#160;to use a function&#160;<br/>for conversion. &#160;<br/>
<b>1.8 Arguments - Call by Value&#160;</b><br/>
One aspect of&#160;C functions may be unfamiliar to&#160;programmers who are used to some other&#160;<br/>languages, particulary Fortran. In C, all function arguments are passed ``by value.''&#160;This&#160;<br/>means that the called function is given the values of its arguments in temporary variables&#160;<br/>rather than the originals. This leads to some&#160;different properties than are seen with ``call by&#160;<br/>reference''&#160;languages like Fortran or with&#160;var&#160;parameters in Pascal, in which the called routine&#160;<br/>has access to the original argument, not a local copy. &#160;<br/>
Call by value is an asset, however, not a liability. It usually leads to more compact programs&#160;<br/>with fewer extraneous variables, because parameters can be treated as conveniently initialized&#160;<br/>local variables in the called routine.&#160;For example, here is a version of&#160;power&#160;that makes use of&#160;<br/>this property. &#160;<br/>
&#160; &#160;/* power: &#160;raise base to n-th power; n &gt;= 0; version 2 */&#160;<br/>&#160; &#160;int power(int base, int n)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int p;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;for (p = 1; n &gt; 0; --n)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;p = p * base;&#160;<br/>&#160; &#160; &#160; &#160;return p;&#160;<br/>&#160; &#160;}&#160;<br/>
<hr/>
<a name=29></a>&#160;&#160;<br/>
29&#160;<br/>
The parameter&#160;n&#160;is used as a temporary variable, and is counted down (a&#160;for&#160;loop that runs&#160;<br/>backwards) until it becomes zero; there&#160;is no longer a need for the variable&#160;i. Whatever is&#160;<br/>done to&#160;n&#160;inside&#160;power&#160;has no effect on the argument that&#160;power&#160;was originally called with. &#160;<br/>
When necessary, it is possible to arrange for&#160;a function to modify a variable in a calling&#160;<br/>routine. The caller must provide the&#160;<i>address</i>&#160;of&#160;the variable to be set (technically a&#160;<i>pointer</i>&#160;to&#160;<br/>the variable), and the called function must declare the parameter to be a pointer and access the&#160;<br/>variable indirectly through it. W<a href="">e will cover pointers in&#160;Chapter 5. &#160;</a><br/>
The story is different for arrays. When the name of an array is used as an argument, the value&#160;<br/>passed to the function is the location or address of the beginning of the array - there is no&#160;<br/>copying of array elements. By subscripting this&#160;value, the function can access and alter any&#160;<br/>argument of the array. This is the topic of the next section. &#160;<br/>
<b>1.9 Character Arrays&#160;</b><br/>
The most common type of&#160;array in C is the array of&#160;characters. To illustrate the use of&#160;<br/>character arrays and functions to manipulate them,&#160;let's write a program&#160;that reads a set of&#160;text&#160;<br/>lines and prints the longest. The outline is simple enough: &#160;<br/>&#160;<br/>&#160; &#160;while (<i>there's another line</i>)&#160;<br/>&#160; &#160; &#160; &#160;if (<i>it's longer than the previous longest</i>)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;(<i>save it</i>)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;(<i>save its length</i>)&#160;<br/>&#160; &#160;<i>print longest line</i>&#160;<br/>
This outline makes it clear that the program&#160;divides naturally into pieces. One piece gets a&#160;<br/>new line, another saves it, and the rest controls the process. &#160;<br/>
Since things divide so nicely, it&#160;would be well to write them&#160;that way too. Accordingly, let us&#160;<br/>first write a separate function&#160;getline&#160;to fetch the next line of input. We will try to make the&#160;<br/>function useful in other contexts. At the minimum,&#160;getline&#160;has to return a signal about&#160;<br/>possible end of file; a more useful design would be to return the length of the line, or zero if&#160;<br/>end of file is encountered. Zero is an acceptable end-of-file return because it is never a valid&#160;<br/>line length. Every text line has at least one character; even a line containing only a newline&#160;<br/>has length 1. &#160;<br/>
When we find a line that is longer than the previous longest line, it must be saved somewhere.&#160;<br/>This suggests a second function,&#160;copy, to copy the new line to a safe place. &#160;<br/>
Finally, we need a main program&#160;to control&#160;getline&#160;and&#160;copy. Here is the result. &#160;<br/>
<hr/>
<a name=30></a>&#160;&#160;<br/>
30&#160;<br/>
&#160; &#160;#include &lt;stdio.h&gt;&#160;<br/>&#160; &#160;#define MAXLINE 1000 &#160; /* maximum input line length */&#160;<br/>&#160;<br/>&#160; &#160;int getline(char line[], int maxline);&#160;<br/>&#160; &#160;void copy(char to[], char from[]);&#160;<br/>&#160;<br/>&#160; &#160;/* print the longest input line */&#160;<br/>&#160; &#160;main()&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int len; &#160; &#160; &#160; &#160; &#160; &#160;/* current line length */&#160;<br/>&#160; &#160; &#160; &#160;int max; &#160; &#160; &#160; &#160; &#160; &#160;/* maximum length seen so far */&#160;<br/>&#160; &#160; &#160; &#160;char line[MAXLINE]; &#160; &#160;/* current input line */&#160;<br/>&#160; &#160; &#160; &#160;char longest[MAXLINE]; /* longest line saved here */&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;max = 0;&#160;<br/>&#160; &#160; &#160; &#160;while ((len = getline(line, MAXLINE)) &gt; 0)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;if (len &gt; max) {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;max = len;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;copy(longest, line);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160; &#160; &#160;if (max &gt; 0) &#160;/* there was a line */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;printf(&#34;%s&#34;, longest);&#160;<br/>&#160; &#160; &#160; &#160;return 0;&#160;<br/>&#160; &#160;}&#160;<br/>&#160;<br/>&#160; &#160;/* getline: &#160;read a line into s, return length &#160;*/&#160;<br/>&#160; &#160;int getline(char s[],int lim)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int c, i;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;for (i=0; i &lt; lim-1 &amp;&amp; (c=getchar())!=EOF &amp;&amp; c!='\n'; ++i)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;s[i] = c;&#160;<br/>&#160; &#160; &#160; &#160;if (c == '\n') {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;s[i] = c;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;++i;&#160;<br/>&#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160; &#160; &#160;s[i] = '\0';&#160;<br/>&#160; &#160; &#160; &#160;return i;&#160;<br/>&#160; &#160;}&#160;<br/>&#160;<br/>&#160; &#160;/* copy: &#160;copy 'from' into 'to'; assume to is big enough */&#160;<br/>&#160; &#160;void copy(char to[], char from[])&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int i;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;i = 0;&#160;<br/>&#160; &#160; &#160; &#160;while ((to[i] = from[i]) != '\0')&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;++i;&#160;<br/>&#160; &#160;}&#160;<br/>
The functions&#160;getline&#160;and&#160;copy&#160;are declared at the beginning of the program, which we&#160;<br/>assume&#160;is contained in one file. &#160;<br/>
main&#160;and&#160;getline&#160;communicate through a pair of arguments and a returned value. In&#160;<br/>
getline, the arguments are declared by the line &#160;<br/>
&#160;<br/>&#160; &#160;int getline(char s[], int lim);&#160;<br/>
which specifies that the first argument,&#160;s, is an array, and the second,&#160;lim, is an integer. The&#160;<br/>purpose of supplying the size of an&#160;array in a declaration is to set aside storage. The length of&#160;<br/>an array&#160;s&#160;is not necessary in&#160;getline&#160;since its size is set in&#160;main.&#160;getline&#160;uses&#160;return&#160;to&#160;<br/>
<hr/>
<a name=31></a><img src="c-31_1.png"/><br/>
&#160;&#160;<br/>
31&#160;<br/>
send a value back to the caller, just as the function&#160;power&#160;did. This line also declares that&#160;<br/>getline&#160;returns an&#160;int; since&#160;int&#160;is the default return type, it could be omitted. &#160;<br/>
Some functions return a useful value; others, like&#160;copy, are used only for their effect and&#160;<br/>return no value. The return type of&#160;copy&#160;is&#160;void, which states explicitly that no value is&#160;<br/>returned. &#160;<br/>
getline&#160;puts the character&#160;'\0'&#160;(the&#160;<i>null character</i>, whose value is zero) at the end of the&#160;<br/>array it is creating, to mark the end of the string&#160;of characters. This conversion is also used by&#160;<br/>the C language: when a string constant like &#160;<br/>
&#160;<br/>&#160; &#160;&#34;hello\n&#34;&#160;<br/>
appears in a C program, it is stored as an array of characters containing the characters in the&#160;<br/>string and terminated with a&#160;'\0'&#160;to mark the end. &#160;<br/>
&#160;<br/>
The&#160;&#160;%s&#160;format specification in&#160;printf&#160;expects the corresponding argument to be a string&#160;<br/>represented in this form.&#160;copy&#160;also relies on the fact that its&#160;input argument is terminated with&#160;<br/>a&#160;'\0', and copies this character into the output. &#160;<br/>
It is worth mentioning in passing that even a program&#160;as small as this one presents some&#160;<br/>sticky design problems. For example, what should&#160;main&#160;do if it encounters a line which is&#160;<br/>bigger than its limit?&#160;getline&#160;works safely, in that it stops collecting when the array is full,&#160;<br/>even if no newline has been seen. By testing the length and the last character returned,&#160;main&#160;<br/>can determine whether the line was too long, and&#160;then cope as it wishes. In the interests of&#160;<br/>brevity, we have ignored this issue. &#160;<br/>
There is no way for a user of&#160;getline&#160;to know in advance how long an input line might be, so&#160;<br/>getline&#160;checks for overflow. On the other hand, the user of&#160;copy&#160;already knows (or can find&#160;<br/>out) how big the strings are, so we have chosen not to add error checking to it. &#160;<br/>
<b>Exercise 1-16.</b>&#160;Revise the main routine of the longest-line program&#160;so it will correctly print&#160;<br/>the length of arbitrary long input lines, and as much as possible of the text. &#160;<br/>
<b>Exercise 1-17.</b>&#160;Write a program&#160;to print all input lines that are longer than 80 characters. &#160;<br/>
<b>Exercise 1-18.</b>&#160;Write a program&#160;to remove trailing blanks and tabs from&#160;each line of input,&#160;<br/>and to delete entirely blank lines. &#160;<br/>
<b>Exercise 1-19.</b>&#160;Write a function&#160;reverse(s)&#160;that reverses the character string&#160;s. Use it to&#160;<br/>write a program&#160;that reverses its input a line at a time. &#160;<br/>
<b>1.10 External Variables and Scope&#160;</b><br/>
The variables in&#160;main, such as&#160;line,&#160;longest, etc., are private or local to&#160;main. Because they&#160;<br/>are declared within&#160;main, no other function can have direct access to them. The same is true&#160;<br/>of the variables in other functions; for example, the variable&#160;i&#160;in&#160;getline&#160;is unrelated to the&#160;i&#160;<br/>
<hr/>
<a name=32></a>&#160;&#160;<br/>
32&#160;<br/>
in copy. Each local variable in a function comes into existence only when the function is&#160;<br/>called, and disappears when the function is exited. This is why such variables are usually&#160;<br/>known as&#160;<i>automatic</i>&#160;variables, following terminology in other languages. We will use the&#160;<br/>term&#160;automatic henceforth to refer to these local variables. (<a href="">Chapter 4</a>&#160;discusses the&#160;static&#160;<br/>storage class, in which local variables do retain their values between calls.) &#160;<br/>
Because automatic variables come and go with&#160;function invocation, they do not retain their&#160;<br/>values from&#160;one call to the next, and must be explicitly set upon each entry. If they are not set,&#160;<br/>they will contain garbage. &#160;<br/>
As an alternative to automatic variables,&#160;it is possible to define variables that are&#160;<i>external</i>&#160;to&#160;<br/>all functions, that is, variables that can be accessed by name by any function. (This&#160;<br/>mechanism&#160;is rather like Fortran COMMON or Pascal variables declared in the outermost&#160;<br/>block.) Because external variables are globally&#160;accessible, they can be used instead of&#160;<br/>argument lists to communicate data between&#160;functions. Furthermore, because external&#160;<br/>variables remain in existence permanently,&#160;rather than appearing and disappearing as&#160;<br/>functions are called and exited, they retain their&#160;values even after the functions that set them&#160;<br/>have returned. &#160;<br/>
An external variable must be&#160;<i>defined</i>, exactly once, outside of any function; this sets aside&#160;<br/>storage for it. The variable must also be&#160;<i>declared</i>&#160;in each function that wants to access it; this&#160;<br/>states the type of the variable.&#160;The declaration may be an explicit&#160;extern&#160;statement or may be&#160;<br/>implicit from&#160;context. To make the discussion concrete, let us rewrite the longest-line&#160;<br/>program&#160;with&#160;line,&#160;longest, and&#160;max&#160;as external variables. This requires changing the calls,&#160;<br/>declarations, and bodies of all three functions. &#160;<br/>
&#160;<br/>&#160; &#160;#include &lt;stdio.h&gt;&#160;<br/>&#160;<br/>&#160; &#160;#define MAXLINE 1000 &#160; &#160;/* maximum input line size */&#160;<br/>&#160;<br/>&#160; &#160;int max; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;/* maximum length seen so far */&#160;<br/>&#160; &#160;char line[MAXLINE]; &#160; &#160; /* current input line */&#160;<br/>&#160; &#160;char longest[MAXLINE]; &#160;/* longest line saved here */&#160;<br/>&#160;<br/>&#160; &#160;int getline(void);&#160;<br/>&#160; &#160;void copy(void);&#160;<br/>&#160;<br/>&#160; &#160;/* print longest input line; specialized version */&#160;<br/>&#160; &#160;main()&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int len;&#160;<br/>&#160; &#160; &#160; &#160;extern int max;&#160;<br/>&#160; &#160; &#160; &#160;extern char longest[];&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;max = 0;&#160;<br/>&#160; &#160; &#160; &#160;while ((len = getline()) &gt; 0)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;if (len &gt; max) {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;max = len;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;copy();&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160; &#160; &#160;if (max &gt; 0) &#160;/* there was a line */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;printf(&#34;%s&#34;, longest);&#160;<br/>&#160; &#160; &#160; &#160;return 0;&#160;<br/>&#160; &#160;}&#160;<br/>
<hr/>
<a name=33></a>&#160;&#160;<br/>
33&#160;<br/>
&#160;<br/>&#160; &#160;/* getline: &#160;specialized version */&#160;<br/>&#160; &#160;int getline(void)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int c, i;&#160;<br/>&#160; &#160; &#160; &#160;extern char line[];&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;for (i = 0; i &lt; MAXLINE - 1&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &amp;&amp; (c=getchar)) != EOF &amp;&amp; c != '\n'; ++i)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; line[i] = c;&#160;<br/>&#160; &#160; &#160; &#160;if (c == '\n') {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;line[i] = c;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;++i;&#160;<br/>&#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160; &#160; &#160;line[i] = '\0';&#160;<br/>&#160; &#160; &#160; &#160;return i;&#160;<br/>&#160; &#160;}&#160;<br/>&#160;<br/>&#160; &#160;/* copy: specialized version */&#160;<br/>&#160; &#160;void copy(void)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int i;&#160;<br/>&#160; &#160; &#160; &#160;extern char line[], longest[];&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;i = 0;&#160;<br/>&#160; &#160; &#160; &#160;while ((longest[i] = line[i]) != '\0')&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;++i;&#160;<br/>&#160; &#160;}&#160;<br/>
The external variables in&#160;main,&#160;getline&#160;and&#160;copy&#160;are defined by the first lines of the example&#160;<br/>above, which state their type and cause storage to be allocated for them. Syntactically,&#160;<br/>external definitions are just like definitions of&#160;local variables, but since they occur outside of&#160;<br/>functions, the variables are external. Before a function can use an external variable, the name&#160;<br/>of the variable must be made&#160;known to the function; the declaration is the same as before&#160;<br/>except for the added keyword&#160;extern. &#160;<br/>
In certain circumstances, the&#160;extern&#160;declaration can be omitted. If&#160;the definition of&#160;the&#160;<br/>external variable occurs in the source file before&#160;its use in a particular function, then there is&#160;<br/>no need for an&#160;extern&#160;declaration in the function. The&#160;extern&#160;declarations in&#160;main,&#160;getline&#160;<br/>and&#160;copy&#160;are thus redundant. In fact, common practice&#160;is to place definitions of all external&#160;<br/>variables at the beginning of the source file, and then omit all extern declarations. &#160;<br/>
If the program&#160;is in several source files, and a variable is defined in&#160;<i>file1</i>&#160;and used in&#160;<i>file2</i>&#160;and&#160;<br/><i>file3</i>, then&#160;extern&#160;declarations are needed in&#160;<i>file2</i>&#160;and&#160;<i>file3</i>&#160;to connect the occurrences of the&#160;<br/>variable. The usual practice is to collect&#160;extern&#160;declarations of variables and functions in a&#160;<br/>separate file, historically called a&#160;<i>header</i>, that is included by&#160;#include&#160;at the front of each&#160;<br/>source file. The suffix&#160;.h&#160;is conventional for header names.&#160;The functions of the standard&#160;<br/>library, for example, are declared in headers like&#160;&lt;stdio.h&gt;. This topic is discussed at length&#160;<br/>in&#160;<a href="">Chapter 4, and the library itself&#160;in&#160;Chapter 7&#160;and&#160;Appendix B</a>. &#160;<br/>
Since the specialized versions of&#160;getline&#160;and&#160;copy&#160;have no arguments, logic would suggest&#160;<br/>that their prototypes at the beginning of the file should be&#160;getline()&#160;and&#160;copy(). But for&#160;<br/>compatibility with older C programs the standard takes an empty list as an old-style&#160;<br/>declaration, and turns off all argument list checking; the word&#160;void&#160;must be used for an&#160;<br/>explicitly empty list. We will discuss this further in&#160;<a href="">Chapter 4</a>. &#160;<br/>
You should note that we are using the words&#160;<i>definition</i>&#160;and&#160;<i>declaration</i>&#160;carefully when we&#160;<br/>refer to external variables in this section.``Definition''&#160;refers to the place where the variable is&#160;<br/>
<hr/>
<a name=34></a>&#160;&#160;<br/>
34&#160;<br/>
created or assigned storage; ``declaration''&#160;refers&#160;to places where the nature of the variable is&#160;<br/>stated but no storage is allocated. &#160;<br/>
By the way, there is a tendency to make everything in sight an&#160;extern&#160;variable because it&#160;<br/>appears to simplify communications - argument lists are short and variables are always there&#160;<br/>when you want them. But external variables are always there even when you don't want them.&#160;<br/>Relying too heavily on external variables is&#160;fraught with peril since it leads to programs&#160;<br/>whose data connections are not all obvious - variables can be changed in unexpected and even&#160;<br/>inadvertent ways, and the program&#160;is hard to modify. The second version of the longest-line&#160;<br/>program&#160;is inferior to the first, partly for&#160;these reasons, and partly because it destroys the&#160;<br/>generality of&#160;two useful functions by writing into them&#160;the names of&#160;the variables they&#160;<br/>manipulate. &#160;<br/>
At this point we have covered what might be&#160;called the conventional core of C. With this&#160;<br/>handful of building blocks, it's possible to write&#160;useful programs of considerable size, and it&#160;<br/>would probably be a good idea if you paused long enough to do so. These exercises suggest&#160;<br/>programs of somewhat greater complexity than the ones earlier in this chapter. &#160;<br/>
<b>Exercise 1-20.</b>&#160;Write a program&#160;detab&#160;that replaces tabs in the input with the proper number&#160;<br/>of blanks to space to the next tab stop.&#160;Assume&#160;a fixed set of tab stops, say every&#160;<i>n</i>&#160;columns.&#160;<br/>Should&#160;<i>n</i>&#160;be a variable or a symbolic parameter?&#160;&#160;<br/>
<b>Exercise 1-21.</b>&#160;Write a program&#160;entab&#160;that replaces strings of blanks by the minimum&#160;<br/>number of tabs and blanks to achieve the same spacing. Use the same tab stops as for&#160;detab.&#160;<br/>When either a tab or a single&#160;blank would suffice to reach a tab stop, which should be given&#160;<br/>preference? &#160;<br/>
<b>Exercise 1-22.</b>&#160;Write a program&#160;to ``fold'' long input lines&#160;into two or more shorter lines after&#160;<br/>the last non-blank character that occurs before the&#160;<i>n</i>-th column&#160;of input. Make sure your&#160;<br/>program&#160;does something intelligent with very long lines, and if there are no blanks or tabs&#160;<br/>before the specified column. &#160;<br/>
<b>Exercise 1-23.</b>&#160;Write a program&#160;to remove all comments from&#160;a C program. Don't forget to&#160;<br/>handle quoted strings and character constants properly. C comments don't nest. &#160;<br/>
<b>Exercise 1-24.</b>&#160;Write a program&#160;to check a C program&#160;for rudimentary syntax errors like&#160;<br/>unmatched parentheses, brackets and braces.&#160;Don't forget about quotes, both single and&#160;<br/>double, escape sequences, and comments. (This program&#160;is hard if you do it in full&#160;<br/>generality.) &#160;<br/>
<hr/>
<a name=35></a>&#160;&#160;<br/>
35&#160;<br/>
&#160;<br/>
<b>Chapter&#160;2 -&#160;Types, Operators and&#160;<br/>Expressions&#160;</b><br/>
Variables and constants are the basic data objects manipulated in a program. Declarations list&#160;<br/>the variables to be used, and state what type&#160;they have and perhaps what their initial values&#160;<br/>are. Operators specify what is to be done&#160;to them. Expressions combine variables and&#160;<br/>constants to produce new values. The type of an object determines the set of values it can&#160;<br/>have and what operations can be performed on it. These building blocks are the topics of this&#160;<br/>chapter. &#160;<br/>
The ANSI standard has made many small changes and additions to basic types and&#160;<br/>expressions. There are now&#160;signed&#160;and&#160;unsigned&#160;forms of all integer types, and notations for&#160;<br/>unsigned constants and hexadecimal character&#160;constants. Floating-point operations may be&#160;<br/>done in single precision; there is also a&#160;long&#160;double type for extended precision. String&#160;<br/>constants may be concatenated at compile time. Enumerations have become part of the&#160;<br/>language, formalizing a feature of long&#160;standing. Objects may be declared&#160;const, which&#160;<br/>prevents them&#160;from&#160;being changed. The rules for automatic coercions among arithmetic types&#160;<br/>have been augmented to handle the richer set of types. &#160;<br/>
<b>2.1 Variable Names&#160;</b><br/>
<a href="">Although we didn't say so in&#160;Chapter 1, there are som</a>e restrictions on the names of variables&#160;<br/>and symbolic constants. Names are made up of letters and digits; the first character must be a&#160;<br/>letter. The underscore ``_'' counts as a letter; it is sometimes useful for improving the&#160;<br/>readability of long variable names. Don't begin variable names with underscore, however,&#160;<br/>since library routines often use such names.&#160;Upper and lower case letters are distinct, so&#160;x&#160;and&#160;<br/>X&#160;are two different names. Traditional C practice&#160;is to use lower case for variable names, and&#160;<br/>all upper case for symbolic constants. &#160;<br/>
At least the first 31 characters of an internal&#160;name are significant. For function names and&#160;<br/>external variables, the number may be less than&#160;31, because external names may be used by&#160;<br/>assemblers and loaders over which the language has no control. For external names, the&#160;<br/>standard guarantees uniqueness only for 6 characters and a single case. Keywords like&#160;if,&#160;<br/>else,&#160;&#160;int,&#160;&#160;float, etc., are reserved: you can't use them&#160;as variable names. They must be in&#160;<br/>lower case. &#160;<br/>
It's wise to choose variable names that are related to the purpose of the variable, and that are&#160;<br/>unlikely to get mixed up typographically. We tend to use short names for local variables,&#160;<br/>especially loop indices, and longer names for external variables. &#160;<br/>
<b>2.2 Data Types and Sizes&#160;</b><br/>
There are only a few basic data types in C: &#160;<br/>
char&#160;<br/>
a single byte, capable of holding one character in the local character set&#160;<br/>
int&#160;<br/>
an integer, typically reflecting the natural size of&#160;integers on the host machine<br/>
float&#160;&#160;single-precision floating point&#160;<br/>
<hr/>
<a name=36></a>&#160;&#160;<br/>
36&#160;<br/>
double&#160;&#160;double-precision floating point&#160;<br/>
In addition, there are a number of qualifiers&#160;that can be applied to these basic types.&#160;short&#160;<br/>and&#160;long&#160;apply to integers: &#160;<br/>
&#160;<br/>&#160; &#160;short int sh;&#160;<br/>&#160; &#160;long int counter;&#160;<br/>
The word&#160;int&#160;can be omitted in such declarations, and typically it is. &#160;<br/>
The intent is that&#160;short&#160;and&#160;long&#160;should provide different lengths of integers where practical;&#160;<br/>int&#160;will normally be the natural size for a particular machine.&#160;short&#160;is often 16 bits long, and&#160;<br/>
int&#160;either 16 or 32 bits. Each compiler is free to choose appropriate sizes for its own&#160;<br/>hardware, subject only to the the restriction that&#160;shorts and ints are at least 16 bits,&#160;longs are&#160;<br/>at least 32 bits, and&#160;short&#160;is no longer than&#160;int, which is no longer than&#160;long. &#160;<br/>
The qualifier&#160;signed&#160;or&#160;unsigned&#160;may be applied to&#160;char&#160;or any integer.&#160;unsigned&#160;numbers&#160;<br/>are always positive or zero, and obey the laws of arithmetic modulo&#160;<i>2n</i>, where&#160;<i>n</i>&#160;is the number&#160;<br/>of&#160;bits in the type. So, for instance, if&#160;chars are 8 bits,&#160;unsigned char&#160;variables have values&#160;<br/>between 0 and 255, while&#160;signed chars have values between -128 and 127 (in a two's&#160;<br/>complement machine.) Whether plain&#160;chars are signed or unsigned is machine-dependent,&#160;<br/>but printable characters are always positive. &#160;<br/>
The type&#160;long double&#160;specifies extended-precision floating&#160;point. As with integers, the sizes&#160;<br/>of floating-point objects are implementation-defined;&#160;float,&#160;double&#160;and&#160;long double&#160;could&#160;<br/>represent one, two or three distinct sizes. &#160;<br/>
The standard headers&#160;&lt;limits.h&gt;&#160;and&#160;&lt;float.h&gt;&#160;contain symbolic constants for all of these&#160;<br/>sizes, along with other properties of the machine and compiler. These are discussed in&#160;<br/><a href="">Appendix B. &#160;</a><br/>
<b>Exercise 2-1.</b>&#160;Write a program&#160;to determine the ranges of&#160;char,&#160;&#160;short,&#160;&#160;int, and&#160;long&#160;<br/>variables, both&#160;signed&#160;and&#160;unsigned, by printing appropriate values from&#160;standard headers&#160;<br/>and by direct computation. Harder if you compute them: determine the ranges of the various&#160;<br/>floating-point types. &#160;<br/>
<b>2.3 Constants&#160;</b><br/>
An integer constant like&#160;1234&#160;is an&#160;int. A&#160;long&#160;constant is written with a terminal&#160;l&#160;(ell) or&#160;<br/>L, as in&#160;123456789L; an integer constant too big to fit into an&#160;int&#160;will also be taken as a long.&#160;<br/>Unsigned constants are written with a terminal&#160;u&#160;or&#160;U, and the suffix&#160;ul&#160;or&#160;UL&#160;indicates&#160;<br/>unsigned long. &#160;<br/>
Floating-point constants contain a decimal point (123.4) or an exponent (1e-2) or both; their&#160;<br/>type is&#160;double, unless suffixed. The suffixes&#160;f&#160;or&#160;F&#160;indicate a&#160;float&#160;constant;&#160;l&#160;or&#160;L&#160;indicate&#160;<br/>a&#160;long double. &#160;<br/>
The value of an integer can be&#160;specified in octal or hexadecimal instead of decimal. A leading&#160;<br/>0&#160;(zero) on an integer constant means octal; a leading&#160;0x&#160;or&#160;0X&#160;means hexadecimal. For&#160;<br/>example, decimal 31 can be written as&#160;037&#160;in octal and&#160;0x1f&#160;or&#160;0x1F&#160;in hex. Octal and&#160;<br/>
<hr/>
<a name=37></a>&#160;&#160;<br/>
37&#160;<br/>
hexadecimal constants may also be followed by&#160;L&#160;to make them&#160;long&#160;and&#160;U&#160;to make them&#160;<br/>unsigned:&#160;0XFUL&#160;is an&#160;<i>unsigned long</i>&#160;constant with value 15 decimal. &#160;<br/>
A&#160;character constant&#160;is an integer, written as one character within single quotes, such as&#160;<br/>'x'. The value of a character constant is the numeric value of the character in the machine's&#160;<br/>character set. For example, in the ASCII character set the character constant&#160;'0'&#160;has the value&#160;<br/>48, which is unrelated to the numeric value 0. If we write&#160;'0'&#160;instead of a numeric value like&#160;<br/>48 that depends on the character set, the program&#160;is independent of the particular value and&#160;<br/>easier to read. Character constants participate in&#160;numeric operations just as any other integers,&#160;<br/>although they are most often used in comparisons with other characters. &#160;<br/>
Certain characters can be represented in character and string constants by escape sequences&#160;<br/>like&#160;&#160;\n&#160;(newline); these sequences look like two&#160;characters, but represent only one. In&#160;<br/>addition, an arbitrary byte-sized bit pattern can be specified by &#160;<br/>
&#160;<br/>&#160; &#160;'\<i>ooo</i>'&#160;<br/>
where&#160;<i>ooo</i>&#160;is one to three octal digits (0...7) or by &#160;<br/>&#160;<br/>&#160; &#160;'\x<i>hh</i>'&#160;<br/>
where&#160;<i>hh</i>&#160;is one or more hexadecimal digits (0...9, a...f, A...F). So we might write &#160;<br/>&#160;<br/>&#160; &#160;#define VTAB '\013' &#160; /* ASCII vertical tab */&#160;<br/>&#160; &#160;#define BELL '\007' &#160; /* ASCII bell character */&#160;<br/>
or, in hexadecimal, &#160;<br/>&#160;<br/>&#160; &#160;#define VTAB '\xb' &#160; /* ASCII vertical tab */&#160;<br/>&#160; &#160;#define BELL '\x7' &#160; /* ASCII bell character */&#160;<br/>
The complete set of escape sequences is &#160;<br/>
&#160;\a&#160;&#160;&#160;alert&#160;(bell)&#160;character&#160;&#160;&#160;\\&#160;<br/>
&#160; backslash&#160;<br/>
&#160;\b&#160;&#160;&#160;backspace&#160;<br/>
&#160;\?&#160;<br/>
&#160;question mark&#160;<br/>
&#160;\f&#160;&#160;&#160;formfeed&#160;<br/>
&#160;&#160;\'&#160;<br/>
&#160;single quote&#160;<br/>
&#160;\n&#160;&#160;&#160;newline&#160;<br/>
&#160;\&#34;&#160;&#160;<br/>
&#160;double quote&#160;<br/>
&#160;\r&#160;&#160;&#160;carriage return&#160;<br/>
&#160;\<i>ooo</i>&#160;&#160;&#160;octal number&#160;<br/>
&#160;\t&#160;&#160;&#160;horizontal tab&#160;<br/>
&#160;\x<i>hh</i>&#160;&#160;&#160;hexadecimal number &#160;<br/>
&#160;\v&#160;&#160;&#160;vertical tab&#160;<br/>
&#160;<br/>
&#160;<br/>
The character constant&#160;'\0'&#160;represents the character with&#160;value zero, the null character.&#160;'\0'&#160;<br/>is often written instead of&#160;0&#160;to emphasize the character nature&#160;of some&#160;expression, but the&#160;<br/>numeric value is just 0. &#160;<br/>
A&#160;<i>constant expression</i>&#160;is an expression that involves only&#160;constants. Such expressions may be&#160;<br/>evaluated at during compilation rather than run-time, and accordingly may be used in any&#160;<br/>place that a constant can occur, as in &#160;<br/>
&#160;<br/>&#160; &#160;#define MAXLINE 1000&#160;<br/>&#160; &#160;char line[MAXLINE+1];&#160;<br/>
or &#160;<br/>&#160;<br/>&#160; &#160;#define LEAP 1 /* in leap years */&#160;<br/>&#160; &#160;int days[31+28+LEAP+31+30+31+30+31+31+30+31+30+31];&#160;<br/>
<hr/>
<a name=38></a>&#160;&#160;<br/>
38&#160;<br/>
A&#160;&#160;<i>string constant</i>, or&#160;<i>string literal</i>, is a sequence of zero or more characters surrounded by&#160;<br/>double quotes, as in &#160;<br/>&#160;<br/>&#160; &#160;&#34;I am a string&#34;&#160;<br/>
or &#160;<br/>&#160;<br/>&#160; &#160;&#34;&#34; /* the empty string */&#160;<br/>
The quotes are not part of the&#160;string, but serve only to delimit it. The same escape sequences&#160;<br/>used in character constants apply in strings;&#160;\&#34;&#160;represents the double-quote character. String&#160;<br/>constants can be concatenated at compile time: &#160;<br/>&#160;<br/>&#160; &#160;&#34;hello, &#34; &#34;world&#34;&#160;<br/>
is equivalent to &#160;<br/>&#160;<br/>&#160; &#160;&#34;hello, world&#34;&#160;<br/>
This is useful for splitting up long strings across several source lines. &#160;<br/>
Technically, a string constant is an array of characters. The internal representation of a string&#160;<br/>has a null character&#160;'\0'&#160;at the end, so the physical storage required is one more than the&#160;<br/>number of characters written between the quotes.&#160;This representation means that there is no&#160;<br/>limit to how long a string can be, but programs must&#160;scan a string completely to determine its&#160;<br/>length. The standard library function&#160;strlen(s)&#160;returns the length of its character string&#160;<br/>argument&#160;s, excluding the terminal&#160;'\0'. Here is our version: &#160;<br/>
&#160;<br/>&#160; &#160;/* strlen: &#160;return length of s */&#160;<br/>&#160; &#160;int strlen(char s[])&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int i;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;while (s[i] != '\0')&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;++i;&#160;<br/>&#160; &#160; &#160; &#160;return i;&#160;<br/>&#160; &#160;}&#160;<br/>
strlen&#160;and other string functions are declared in the standard header&#160;&lt;string.h&gt;. &#160;<br/>
Be careful to distinguish between a character&#160;constant and a string that contains a single&#160;<br/>character:&#160;'x'&#160;is not the same as&#160;&#34;x&#34;. The former is an integer, used to produce the numeric&#160;<br/>value of&#160;the letter&#160;<i>x</i>&#160;in the machine's character set. The&#160;latter is an array of characters that&#160;<br/>contains one character (the letter&#160;<i>x</i>) and a&#160;'\0'. &#160;<br/>
There is one other kind of constant, the&#160;<i>enumeration constant</i>. An enumeration is a list of&#160;<br/>constant integer values, as in &#160;<br/>
&#160;<br/>&#160; &#160;enum boolean { NO, YES };&#160;<br/>
The first name in an&#160;enum&#160;has value 0, the next 1, and&#160;so on, unless explicit values are&#160;<br/>specified. If not all values are specified, unspecified values continue the progression from&#160;the&#160;<br/>last specified value, as the second of these examples: &#160;<br/>&#160;<br/>&#160; &#160;enum escapes { BELL = '\a', BACKSPACE = '\b', TAB = '\t',&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; NEWLINE = '\n', VTAB = '\v', RETURN = '\r' };&#160;<br/>&#160;<br/>&#160; &#160;enum months { JAN = 1, FEB, MAR, APR, MAY, JUN,&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;JUL, AUG, SEP, OCT, NOV, DEC };&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;/* FEB = 2, MAR = 3, etc. */&#160;<br/>
<hr/>
<a name=39></a>&#160;&#160;<br/>
39&#160;<br/>
Names in different enumerations must be distinct. Values need not be distinct in the same&#160;<br/>enumeration. &#160;<br/>
Enumerations provide a convenient way to associate constant values with names, an&#160;<br/>alternative to&#160;#define&#160;with the advantage that the values can be generated for you. Although&#160;<br/>variables of&#160;enum&#160;types may be declared, compilers need not check that what you store in&#160;<br/>such a variable is a valid value for the enumeration. Nevertheless, enumeration variables offer&#160;<br/>the chance of checking and so are often better than&#160;#defines. In addition, a debugger may be&#160;<br/>able to print values of&#160;enumeration variables in their symbolic form. &#160;<br/>
<b>2.4 Declarations&#160;</b><br/>
All variables must be declared before use, although certain declarations can be made&#160;<br/>implicitly by content. A declaration specifies a type, and contains a list of&#160;one or more&#160;<br/>variables of that type, as in &#160;<br/>&#160;<br/>&#160; &#160;int &#160;lower, upper, step;&#160;<br/>&#160; &#160;char c, line[1000];&#160;<br/>
Variables can be distributed among declarations&#160;in any fashion; the lists above could well be&#160;<br/>written as &#160;<br/>&#160;<br/>&#160; &#160;int &#160;lower;&#160;<br/>&#160; &#160;int &#160;upper;&#160;<br/>&#160; &#160;int &#160;step;&#160;<br/>&#160; &#160;char c;&#160;<br/>&#160; &#160;char line[1000];&#160;<br/>
The latter form&#160;takes more space, but is convenient for adding a comment to each declaration&#160;<br/>for subsequent modifications. &#160;<br/>
A variable may also be initialized in its declaration. If&#160;the name is followed by an equals sign&#160;<br/>and an expression, the expression serves as an initializer, as in &#160;<br/>
&#160;<br/>&#160; &#160;char &#160;esc = '\\';&#160;<br/>&#160; &#160;int &#160; i = 0;&#160;<br/>&#160; &#160;int &#160; limit = MAXLINE+1;&#160;<br/>&#160; &#160;float eps = 1.0e-5;&#160;<br/>
If the variable in question is not automatic,&#160;the initialization is done once only, conceptionally&#160;<br/>before the program&#160;starts executing, and the initializer must be a constant expression. An&#160;<br/>explicitly initialized automatic variable is initialized each time the function or block it is in is&#160;<br/>entered; the initializer may be any expression. External and static variables are initialized to&#160;<br/>zero by default. Automatic variables for which is no explicit initializer have undefined (i.e.,&#160;<br/>garbage) values. &#160;<br/>
The qualifier&#160;const&#160;can be applied to the declaration of any variable to specify that its value&#160;<br/>will not be changed. For an array, the&#160;const&#160;qualifier says that the elements will not be&#160;<br/>altered. &#160;<br/>
&#160;<br/>&#160; &#160;const double e = 2.71828182845905;&#160;<br/>&#160; &#160;const char msg[] = &#34;warning: &#34;;&#160;<br/>
The&#160;&#160;const&#160;declaration can also be used with array arguments, to indicate that the function&#160;<br/>does not change that array: &#160;<br/>&#160;<br/>&#160; &#160;int strlen(const char[]);&#160;<br/>
<hr/>
<a name=40></a>&#160;&#160;<br/>
40&#160;<br/>
The result is implementation-defined if&#160;an attempt is made to change a&#160;const. &#160;<br/>
<b>2.5 Arithmetic Operators&#160;</b><br/>
The binary arithmetic operators are&#160;+,&#160;&#160;-,&#160;&#160;*,&#160;&#160;/, and the modulus operator&#160;%. Integer division&#160;<br/>truncates any fractional part. The expression &#160;<br/>&#160;<br/>&#160; &#160;x % y&#160;<br/>
produces the remainder when&#160;x&#160;is divided by&#160;y, and thus is zero when&#160;y&#160;divides&#160;x&#160;exactly. For&#160;<br/>example, a year is a leap year if it is divisible by 4 but not by 100, except that years divisible&#160;<br/>by 400&#160;<i>are</i>&#160;leap years. Therefore &#160;<br/>&#160;<br/>&#160; &#160;if ((year % 4 == 0 &amp;&amp; year % 100 != 0) || year % 400 == 0)&#160;<br/>&#160; &#160; &#160; &#160;printf(&#34;%d is a leap year\n&#34;, year);&#160;<br/>&#160; &#160;else&#160;<br/>&#160; &#160; &#160; &#160;printf(&#34;%d is not a leap year\n&#34;, year);&#160;<br/>
The&#160;%&#160;operator cannot be applied to a&#160;float&#160;or&#160;double. The direction of truncation for&#160;/&#160;and&#160;<br/>the sign of&#160;the result for&#160;%&#160;are machine-dependent for negative operands, as is the action taken&#160;<br/>on overflow or underflow. &#160;<br/>
The binary&#160;+&#160;and&#160;-&#160;operators have the same precedence, which is lower than the precedence&#160;<br/>of&#160;*,&#160;/&#160;and&#160;%, which is in turn lower than unary&#160;+&#160;and&#160;-. Arithmetic operators associate left&#160;to&#160;<br/>right. &#160;<br/>
Table 2.1 at the end of this chapter summarizes precedence and associativity for all operators. &#160;<br/>
<b>2.6 Relational and Logical Operators&#160;</b><br/>
The relational operators are &#160;<br/>&#160;<br/>&#160; &#160;&gt; &#160; &gt;= &#160; &lt; &#160; &lt;=&#160;<br/>
They all have the same precedence. Just below them&#160;in precedence are the equality operators: &#160;<br/>&#160;<br/>&#160; &#160;== &#160; !=&#160;<br/>
Relational operators have lower precedence than&#160;arithmetic operators, so an expression like&#160;i&#160;<br/>&lt; lim-1&#160;is taken as&#160;i &lt; (lim-1), as would be expected. &#160;<br/>
More interesting are the logical operators&#160;&amp;&amp;&#160;and&#160;||. Expressions connected by&#160;&amp;&amp;&#160;or&#160;||&#160;are&#160;<br/>evaluated left to right, and evaluation stops as&#160;soon as the truth or falsehood of the result is&#160;<br/>known. Most C programs rely on these properties.&#160;For example, here is a loop from&#160;the input&#160;<br/>function&#160;getline&#160;that we wrote in&#160;<a href="">Chapter 1</a>: &#160;<br/>
&#160;<br/>&#160; &#160;for (i=0; i &lt; lim-1 &amp;&amp; (c=getchar()) != '\n' &amp;&amp; c != EOF; ++i)&#160;<br/>&#160; &#160; &#160; &#160;s[i] = c;&#160;<br/>
Before reading a new character it is necessary to&#160;check that there is room&#160;to store it in the&#160;<br/>array&#160;s, so the test&#160;i &lt; lim-1&#160;<i>must</i>&#160;be made first. Moreover, if&#160;this test fails, we must not go&#160;<br/>on and read another character. &#160;<br/>
Similarly, it would be unfortunate if&#160;c&#160;were tested against&#160;EOF&#160;before&#160;getchar&#160;is called;&#160;<br/>therefore the call and assignment must occur before the character in&#160;c&#160;is tested. &#160;<br/>
<hr/>
<a name=41></a>&#160;&#160;<br/>
41&#160;<br/>
The precedence of&#160;&amp;&amp;&#160;is higher than that of&#160;||, and both are lower than relational and equality&#160;<br/>operators, so expressions like &#160;<br/>
&#160;<br/>&#160; &#160;i &lt; lim-1 &amp;&amp; (c=getchar()) != '\n' &amp;&amp; c != EOF&#160;<br/>
need no extra parentheses. But since the precedence of&#160;!=&#160;is higher than assignment,&#160;<br/>parentheses are needed in &#160;<br/>&#160;<br/>&#160; &#160;(c=getchar()) != '\n'&#160;<br/>
to achieve the desired result of&#160;assignment to&#160;c&#160;and then comparison with&#160;'\n'. &#160;<br/>
By definition, the numeric value of a relational or&#160;logical expression is 1 if the relation is true,&#160;<br/>and 0 if&#160;the relation is false. &#160;<br/>
The unary negation operator&#160;!&#160;converts a non-zero operand into&#160;0, and a zero operand in 1. A&#160;<br/>common use of&#160;!&#160;is in constructions like &#160;<br/>
&#160;<br/>&#160; &#160;if (!valid)&#160;<br/>
rather than &#160;<br/>&#160;<br/>&#160; &#160;if (valid == 0)&#160;<br/>
It's hard to generalize about which form&#160;is better. Constructions like&#160;!valid&#160;read nicely (``if&#160;<br/>not valid''), but more complicated ones can be hard to understand. &#160;<br/>
<b>Exercise 2-2.</b>&#160;Write a loop equivalent to the&#160;for&#160;loop above without using&#160;&amp;&amp;&#160;or&#160;||. &#160;<br/>
<b>2.7 Type Conversions&#160;</b><br/>
When an operator has operands of different types, they are converted to a common type&#160;<br/>according to a small number of rules. In general, the only automatic conversions are those that&#160;<br/>convert a ``narrower'' operand into a ``wider''&#160;one without losing information, such as&#160;<br/>converting an integer into floating point in an expression like&#160;f + i. Expressions that don't&#160;<br/>make sense, like using a&#160;float&#160;as a subscript, are disallowed. Expressions that might lose&#160;<br/>information, like assigning a longer integer type to&#160;a shorter, or a floating-point type to an&#160;<br/>integer, may draw a warning, but they are not illegal. &#160;<br/>
A&#160;&#160;char&#160;is just a small integer, so&#160;chars may be freely used in arithmetic expressions. This&#160;<br/>permits considerable flexibility in certain&#160;kinds of&#160;character transformations. One is&#160;<br/>exemplified by this naive implementation of&#160;the function&#160;atoi, which converts a string of&#160;<br/>digits into its numeric equivalent. &#160;<br/>
&#160;<br/>&#160; &#160;/* atoi: &#160;convert s to integer */&#160;<br/>&#160; &#160;int atoi(char s[])&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int i, n;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;n = 0;&#160;<br/>&#160; &#160; &#160; &#160;for (i = 0; s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9'; ++i)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;n = 10 * n + (s[i] - '0');&#160;<br/>&#160; &#160; &#160; &#160;return n;&#160;<br/>&#160; &#160;}&#160;<br/>
<a href="">As we discussed in&#160;Chapter 1</a>, the expression &#160;<br/>&#160;<br/>
<hr/>
<a name=42></a>42<br/>
&#160; &#160; s[i] - '0'&#160;<br/>
gives the numeric value of the character stored in&#160;s[i], because the values of&#160;'0',&#160;'1', etc.,&#160;<br/>form&#160;a contiguous increasing sequence. &#160;<br/>
Another example of&#160;char&#160;to&#160;int&#160;conversion is the function&#160;lower, which maps a single&#160;<br/>character to lower case&#160;<i>for the ASCII character set</i>. If the character is not an upper case letter,&#160;<br/>lower&#160;returns it unchanged. &#160;<br/>
&#160; &#160;/* lower: &#160;convert c to lower case; ASCII only */&#160;<br/>&#160; &#160;int lower(int c)&#160;<br/>&#160; &#160;{&#160;<br/>
if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z')&#160;<br/>
return c + 'a' - 'A';&#160;<br/>
else&#160;<br/>
return c;&#160;<br/>
&#160; &#160;}&#160;<br/>
This works for ASCII because corresponding upper case and lower case letters are a fixed&#160;<br/>distance apart as numeric values and each alphabet is contiguous -- there is nothing but letters&#160;<br/>between&#160;A&#160;and&#160;Z. This latter observation is not true of&#160;the EBCDIC character set, however, so&#160;<br/>this code would convert more than just letters in EBCDIC. &#160;<br/>
The standard header&#160;&lt;ctype.h&gt;<a href="">, described in&#160;Appendix B, defines a fam</a>ily of functions that&#160;<br/>provide tests and conversions that are independent&#160;of character set. For example, the function&#160;<br/>tolower&#160;is a portable replacement for the function&#160;lower&#160;shown above. Similarly, the test &#160;<br/>
&#160; &#160;c &gt;= '0' &amp;&amp; c &lt;= '9'&#160;<br/>
can be replaced by &#160;<br/>
&#160; &#160;isdigit(c)&#160;<br/>
We will use the&#160;&lt;ctype.h&gt;&#160;functions from&#160;now on. &#160;<br/>
There is one subtle point about the conversion of characters to integers. The language does&#160;<br/>not specify whether variables of type&#160;char&#160;are signed or unsigned quantities. When a&#160;char&#160;is&#160;<br/>converted to an&#160;int, can it ever produce a negative integer? The answer varies from&#160;machine&#160;<br/>to machine, reflecting differences in architecture. On some machines a&#160;char&#160;whose leftmost&#160;<br/>bit is 1 will be converted to a negative&#160;integer (``sign extension''). On others, a&#160;char&#160;is&#160;<br/>promoted to an int by adding zeros at the left&#160;end, and thus is always positive. &#160;<br/>
The definition of C guarantees that any character&#160;in the machine's standard printing character&#160;<br/>set will never be negative, so these characters will always be positive quantities in&#160;<br/>expressions. But arbitrary bit patterns stored in character variables may appear to be negative&#160;<br/>on some machines, yet positive on others. For portability, specify&#160;signed&#160;or&#160;unsigned&#160;if non-<br/>character data is to be stored in&#160;char&#160;variables. &#160;<br/>
Relational expressions like&#160;i &gt; j&#160;and logical expressions connected by&#160;&amp;&amp;&#160;and&#160;||&#160;are defined&#160;<br/>to have value 1 if true, and 0 if false. Thus the assignment &#160;<br/>
&#160; &#160;d = c &gt;= '0' &amp;&amp; c &lt;= '9'&#160;<br/>
sets&#160;d&#160;to 1 if&#160;c&#160;is a digit, and 0 if not. However, functions like&#160;isdigit&#160;may return any non-<br/>zero value for true. In the test part of&#160;if,&#160;while,&#160;for, etc., ``true'' just means ``non-zero'', so&#160;<br/>this makes no difference. &#160;<br/>
<hr/>
<a name=43></a>&#160;&#160;<br/>
43&#160;<br/>
Implicit arithmetic conversions work much as&#160;expected. In general, if an operator like&#160;+&#160;or&#160;*&#160;<br/>that takes two operands (a binary operator) has&#160;operands of different types, the ``lower'' type&#160;<br/>is&#160;&#160;<i>promoted</i>&#160;to the ``higher''&#160;type before the operation proceeds. The result is of the integer&#160;<br/>type.&#160;<a href="http://www.buginword.com">Section 6 of&#160;</a><a href="">Appendix A&#160;states the conversion rule</a>s precisely. If there are no&#160;unsigned&#160;<br/>operands, however, the following informal set of&#160;rules will suffice: &#160;<br/>
•&#160;&#160;If either operand is&#160;long double, convert the other to&#160;long double. &#160;<br/>•&#160;&#160;Otherwise, if&#160;either operand is&#160;double, convert the other to&#160;double. &#160;<br/>•&#160;&#160;Otherwise, if&#160;either operand is&#160;float, convert the other to&#160;float. &#160;<br/>•&#160;&#160;Otherwise, convert&#160;char&#160;and&#160;short&#160;to&#160;int. &#160;<br/>•&#160;&#160;Then, if&#160;either operand is&#160;long, convert the other to&#160;long. &#160;<br/>
Notice that&#160;floats in an expression are not automatically converted to&#160;double; this is a&#160;<br/>change from&#160;the original definition. In general, mathematical functions like those in&#160;&lt;math.h&gt;&#160;<br/>will use double precision. The main reason for using&#160;float&#160;is to save storage in large arrays,&#160;<br/>or, less often, to save time on machines where double-precision arithmetic is particularly&#160;<br/>expensive. &#160;<br/>
Conversion rules are more complicated when&#160;unsigned&#160;operands are involved. The problem&#160;<br/>is that comparisons between signed and unsigned values are machine-dependent, because they&#160;<br/>depend on the sizes of the various integer types. For example, suppose that&#160;int&#160;is 16 bits and&#160;<br/>long&#160;is 32 bits. Then&#160;-1L &lt; 1U, because&#160;1U, which is an&#160;unsigned int, is promoted to a&#160;<br/>
signed long. But&#160;-1L &gt; 1UL&#160;because&#160;-1L&#160;is promoted to&#160;unsigned long&#160;and thus appears&#160;<br/>to be a large positive number. &#160;<br/>
Conversions take place across assignments; the value&#160;of the right side is converted to the type&#160;<br/>of&#160;the left, which is the type of&#160;the result. &#160;<br/>
A character is converted to an integer, either by sign extension or not, as described above. &#160;<br/>
Longer integers are converted to shorter ones or to&#160;chars by dropping the excess high-order&#160;<br/>bits. Thus in &#160;<br/>
&#160;<br/>&#160; &#160;int &#160;i;&#160;<br/>&#160; &#160;char c;&#160;<br/>&#160;<br/>&#160; &#160;i = c;&#160;<br/>&#160; &#160;c = i;&#160;<br/>
the value of&#160;c&#160;is unchanged. This is true whether or&#160;not sign extension is involved. Reversing&#160;<br/>the order of assignments might lose information, however. &#160;<br/>
If&#160;&#160;x&#160;is&#160;float&#160;and&#160;i&#160;is&#160;int, then&#160;x = i&#160;and&#160;i = x&#160;both cause conversions;&#160;float&#160;to&#160;int&#160;<br/>causes truncation of any fractional part. When a&#160;double&#160;is converted to&#160;float, whether the&#160;<br/>value is rounded or truncated is implementation dependent. &#160;<br/>
Since an argument of a function call is an expression, type conversion also takes place when&#160;<br/>arguments are passed to functions. In the absence of a function prototype,&#160;char&#160;and&#160;short&#160;<br/>become int, and&#160;float&#160;becomes&#160;double. This is why we have declared function arguments to&#160;<br/>be&#160;int&#160;and&#160;double&#160;even when the function is called with&#160;char&#160;and&#160;float. &#160;<br/>
Finally, explicit type conversions can be forced (``coerced'')&#160;in any expression, with a unary&#160;<br/>operator called a&#160;cast. In the construction &#160;<br/>
<hr/>
<a name=44></a>&#160;&#160;<br/>
44&#160;<br/>
&#160; (<i>type name</i>)&#160;<i>expression</i>&#160;&#160;<br/>
the&#160;&#160;<i>expression</i>&#160;is converted to the named type by the conversion rules above. The precise&#160;<br/>meaning of a cast is as if the&#160;<i>expression</i>&#160;were assigned to a variable of the specified type,&#160;<br/>which is then used in place of&#160;the whole construction. For example, the library routine&#160;sqrt&#160;<br/>expects a&#160;double&#160;argument, and will produce nonsense if inadvertently handled something&#160;<br/>else. (sqrt&#160;is declared in&#160;&lt;math.h&gt;.) So if&#160;n&#160;is an integer, we can use &#160;<br/>
&#160;<br/>&#160; &#160;sqrt((double) n)&#160;<br/>
to convert the value of&#160;n&#160;to&#160;double&#160;before passing it to&#160;sqrt. Note that the cast produces the&#160;<br/><i>value</i>&#160;of&#160;n&#160;in the proper type;&#160;n&#160;itself is not altered. The cast operator has the same high&#160;<br/>precedence as other unary operators, as summarized in the table at the end of this chapter. &#160;<br/>
If arguments are declared by a function prototype, as the normally should be, the declaration&#160;<br/>causes automatic coercion of any arguments when the function is called. Thus, given a&#160;<br/>function prototype for&#160;sqrt: &#160;<br/>
&#160;<br/>&#160; &#160;double sqrt(double)&#160;<br/>
the call &#160;<br/>&#160;<br/>&#160; &#160;root2 = sqrt(2)&#160;<br/>
coerces the integer&#160;2&#160;into the&#160;double&#160;value&#160;2.0&#160;without any need for a cast. &#160;<br/>
The standard library includes a portable&#160;implementation of a pseudo-random&#160;number&#160;<br/>generator and a function for initializing the seed; the former illustrates a cast: &#160;<br/>
&#160;<br/>&#160; &#160;unsigned long int next = 1;&#160;<br/>&#160;<br/>&#160; &#160;/* rand: &#160;return pseudo-random integer on 0..32767 */&#160;<br/>&#160; &#160;int rand(void)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;next = next * 1103515245 + 12345;&#160;<br/>&#160; &#160; &#160; &#160;return (unsigned int)(next/65536) % 32768;&#160;<br/>&#160; &#160;}&#160;<br/>&#160;<br/>&#160; &#160;/* srand: &#160;set seed for rand() */&#160;<br/>&#160; &#160;void srand(unsigned int seed)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;next = seed;&#160;<br/>&#160; &#160;}&#160;<br/>
<b>Exercise 2-3.</b>&#160;Write a function&#160;htoi(s), which converts a string of hexadecimal digits&#160;<br/>(including an optional&#160;0x&#160;or&#160;0X) into its equivalent integer value. The allowable digits are&#160;0&#160;<br/>through&#160;9,&#160;a&#160;through&#160;f, and&#160;A&#160;through&#160;F. &#160;<br/>
<b>2.8 Increment and Decrement Operators&#160;</b><br/>
C provides two unusual operators for incrementing and decrementing variables. The&#160;<br/>increment operator&#160;++&#160;adds 1 to its operand, while the decrement operator&#160;--&#160;subtracts 1. We&#160;<br/>have frequently used&#160;++&#160;to increment variables, as in &#160;<br/>&#160;<br/>&#160; &#160;if (c == '\n')&#160;<br/>&#160; &#160; &#160; &#160;++nl;&#160;<br/>
<hr/>
<a name=45></a>&#160;&#160;<br/>
45&#160;<br/>
The unusual aspect is that&#160;++&#160;and&#160;--&#160;may be used either as prefix operators (before the&#160;<br/>variable, as in&#160;++n), or postfix operators (after the variable:&#160;n++). In both cases, the effect is to&#160;<br/>increment&#160;&#160;n. But the expression&#160;++n&#160;increments&#160;n&#160;&#160;<i>before</i>&#160;its value is used, while&#160;n++&#160;<br/>increments&#160;&#160;n&#160;&#160;<i>after</i>&#160;its value has been used. This means that in a context where the value is&#160;<br/>being used, not just the effect,&#160;++n&#160;and&#160;n++&#160;are different. If&#160;n&#160;is 5, then &#160;<br/>&#160;<br/>&#160; &#160;x = n++;&#160;<br/>
sets&#160;x&#160;to 5, but &#160;<br/>&#160;<br/>&#160; &#160;x = ++n;&#160;<br/>
sets&#160;x&#160;to 6. In both cases,&#160;n&#160;becomes 6. The increment and decrement operators can only be&#160;<br/>applied to variables; an expression like&#160;(i+j)++&#160;is illegal. &#160;<br/>
In a context where no value is wanted, just the incrementing effect, as in &#160;<br/>
&#160;<br/>&#160; &#160;if (c == '\n')&#160;<br/>&#160; &#160; &#160; &#160;nl++;&#160;<br/>
prefix and postfix are the same. But there are situations where one or the other is specifically&#160;<br/>called for. For instance, consider the function&#160;squeeze(s,c), which removes all occurrences&#160;<br/>of the character&#160;c&#160;from&#160;the string&#160;s. &#160;<br/>&#160;<br/>&#160; &#160;/* squeeze: &#160;delete all c from s */&#160;<br/>&#160; &#160;void squeeze(char s[], int c)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; int i, j;&#160;<br/>&#160;<br/>&#160; &#160; &#160; for (i = j = 0; s[i] != '\0'; i++)&#160;<br/>&#160; &#160; &#160; &#160; &#160; if (s[i] != c)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; s[j++] = s[i];&#160;<br/>&#160; &#160; &#160; s[j] = '\0';&#160;<br/>&#160; &#160;}&#160;<br/>
Each time a non-c&#160;occurs, it is copied into the current&#160;j&#160;position, and only then is&#160;j&#160;<br/>incremented to be ready for the next character. This is exactly equivalent to &#160;<br/>&#160;<br/>&#160; &#160;if (s[i] != c) {&#160;<br/>&#160; &#160; &#160; &#160;s[j] = s[i];&#160;<br/>&#160; &#160; &#160; &#160;j++;&#160;<br/>&#160; &#160;}&#160;<br/>
Another example of a similar construction comes from&#160;the&#160;getline&#160;function that we wrote in&#160;<br/><a href="">Chapter 1, where we can replace &#160;<br/></a>&#160;<br/>&#160; &#160;if (c == '\n') {&#160;<br/>&#160; &#160; &#160; &#160;s[i] = c;&#160;<br/>&#160; &#160; &#160; &#160;++i;&#160;<br/>&#160; &#160;}&#160;<br/>
by the more compact &#160;<br/>&#160;<br/>&#160; &#160;if (c == '\n')&#160;<br/>&#160; &#160; &#160; s[i++] = c;&#160;<br/>
As a third example, consider the standard function&#160;strcat(s,t), which concatenates the&#160;<br/>string&#160;&#160;t&#160;to the end of string&#160;s.&#160;&#160;strcat&#160;assumes that there is enough space in&#160;s&#160;to hold the&#160;<br/>combination. As we have written it,&#160;strcat&#160;returns no value; the standard library version&#160;<br/>returns a pointer to the resulting string. &#160;<br/>&#160;<br/>&#160; &#160;/* strcat: &#160;concatenate t to end of s; s must be big enough */&#160;<br/>&#160; &#160;void strcat(char s[], char t[])&#160;<br/>&#160; &#160;{&#160;<br/>
<hr/>
<a name=46></a>&#160;&#160;<br/>
46&#160;<br/>
&#160; &#160; &#160; &#160;int i, j;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;i = j = 0;&#160;<br/>&#160; &#160; &#160; &#160;while (s[i] != '\0') /* find end of s */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;i++;&#160;<br/>&#160; &#160; &#160; &#160;while ((s[i++] = t[j++]) != '\0') /* copy t */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;;&#160;<br/>&#160; &#160;}&#160;<br/>
As each member is copied from&#160;t&#160;to&#160;s, the postfix&#160;++&#160;is applied to both&#160;i&#160;and&#160;j&#160;to&#160;make&#160;sure&#160;<br/>that they are in position for the next pass through the loop. &#160;<br/>
<b>Exercise 2-4.</b>&#160;Write an alternative version of&#160;squeeze(s1,s2)&#160;that deletes each character in&#160;<br/>s1&#160;that matches any character in the&#160;<i>string</i>&#160;s2. &#160;<br/>
<b>Exercise 2-5.</b>&#160;Write the function&#160;any(s1,s2), which returns the first location in a string&#160;s1&#160;<br/>where any character from&#160;the string&#160;s2&#160;occurs, or&#160;-1&#160;if&#160;s1&#160;contains no characters from&#160;s2.&#160;<br/>(The standard library function&#160;strpbrk&#160;does the same job but returns a pointer to the&#160;<br/>location.) &#160;<br/>
<b>2.9 Bitwise Operators&#160;</b><br/>
C provides six operators for bit manipulation; these may only be applied to integral operands,&#160;<br/>that is,&#160;char,&#160;short,&#160;int, and&#160;long, whether signed or unsigned. &#160;<br/>
&amp;&#160;<br/>
bitwise AND&#160;<br/>
|&#160;<br/>
bitwise inclusive OR&#160;<br/>
^&#160;<br/>
bitwise exclusive OR&#160;<br/>
&lt;&lt;&#160; &#160;&#160;left&#160;shift&#160;<br/>
&gt;&gt;&#160;&#160;right shift&#160;<br/>
~&#160;<br/>
one's complement (unary)<br/>
The bitwise AND operator&#160;&amp;&#160;is often used to mask off some&#160;set of bits, for example &#160;<br/>
&#160;<br/>&#160; &#160;n = n &amp; 0177;&#160;<br/>
sets to zero all but the low-order 7 bits of&#160;n. &#160;<br/>
The bitwise OR operator&#160;|&#160;is used to turn bits on: &#160;<br/>
&#160;<br/>&#160; &#160;x = x | SET_ON;&#160;<br/>
sets to one in&#160;x&#160;the bits that are set to one in&#160;SET_ON. &#160;<br/>
The bitwise exclusive OR operator&#160;^&#160;sets a one in each bit position where its operands have&#160;<br/>different bits, and zero where they are the same. &#160;<br/>
One must distinguish the bitwise operators&#160;&amp;&#160;and&#160;|&#160;from&#160;the logical operators&#160;&amp;&amp;&#160;and&#160;||,&#160;<br/>which imply left-to-right evaluation of a truth value. For example, if&#160;x&#160;is 1 and&#160;y&#160;is 2, then&#160;x&#160;<br/>&amp; y&#160;is zero while&#160;x &amp;&amp; y&#160;is one. &#160;<br/>
The shift operators&#160;&lt;&lt;&#160;and&#160;&gt;&gt;&#160;perform&#160;left and right shifts&#160;of their left operand by the number&#160;<br/>of bit positions given by the right operand, which must be non-negative. Thus&#160;x &lt;&lt; 2&#160;shifts&#160;<br/>
<hr/>
<a name=47></a>&#160;&#160;<br/>
47&#160;<br/>
the value of&#160;x&#160;by two positions, filling vacated bits with zero; this is equivalent to&#160;<br/>multiplication by 4. Right shifting an&#160;unsigned&#160;quantity always fits the vacated bits with&#160;<br/>zero. Right shifting a signed quantity will fill with bit signs (``arithmetic shift'')&#160;on some&#160;<br/>machines and with 0-bits (``logical shift'')&#160;on others. &#160;<br/>
The unary operator&#160;~&#160;yields the one's complement of an&#160;integer; that is, it converts each 1-bit&#160;<br/>into a 0-bit and vice versa. For example &#160;<br/>
&#160;<br/>&#160; &#160;x = x &amp; ~077&#160;<br/>
sets the last six bits of&#160;x&#160;to zero. Note that&#160;x &amp; ~077&#160;is independent of word length, and is&#160;<br/>thus preferable to, for example,&#160;x &amp; 0177700, which assumes that&#160;x&#160;is a 16-bit quantity. The&#160;<br/>portable form&#160;involves no extra cost, since&#160;~077&#160;is a constant expression that can be evaluated&#160;<br/>at compile time. &#160;<br/>
As an illustration of&#160;some of&#160;the bit operators, consider the function&#160;getbits(x,p,n)&#160;that&#160;<br/>returns the (right adjusted)&#160;n-bit field of&#160;x&#160;that begins at position&#160;p. We assume that bit&#160;<br/>position 0 is at the right end and that&#160;n&#160;and&#160;p&#160;are sensible positive values. For example,&#160;<br/>getbits(x,4,3)&#160;returns the three bits in positions 4, 3 and 2, right-adjusted. &#160;<br/>
&#160;<br/>&#160; &#160;/* getbits: &#160;get n bits from position p */&#160;<br/>&#160; &#160;unsigned getbits(unsigned x, int p, int n)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;return (x &gt;&gt; (p+1-n)) &amp; ~(~0 &lt;&lt; n);&#160;<br/>&#160; &#160;}&#160;<br/>
The expression&#160;x &gt;&gt; (p+1-n)&#160;moves the desired field to the right end of the word.&#160;~0&#160;is all&#160;<br/>1-bits; shifting it left&#160;n&#160;positions with&#160;~0&lt;&lt;n&#160;places zeros in the rightmost&#160;n&#160;bits;&#160;<br/>complementing that with&#160;~&#160;makes a mask with ones in the rightmost&#160;n&#160;bits. &#160;<br/>
<b>Exercise 2-6.</b>&#160;Write a function&#160;setbits(x,p,n,y)&#160;that returns&#160;x&#160;with the&#160;n&#160;bits that begin at&#160;<br/>position&#160;p&#160;set to the rightmost&#160;n&#160;bits of&#160;y, leaving the other bits unchanged. &#160;<br/>
<b>Exercise 2-7.</b>&#160;Write a function&#160;invert(x,p,n)&#160;that returns&#160;x&#160;with the&#160;n&#160;bits that begin at&#160;<br/>position&#160;p&#160;inverted (i.e., 1 changed into 0 and vice versa), leaving the others unchanged. &#160;<br/>
<b>Exercise 2-8.</b>&#160;Write a function&#160;rightrot(x,n)&#160;that returns the value of&#160;the integer&#160;x&#160;rotated&#160;<br/>to the right by&#160;n&#160;positions. &#160;<br/>
<b>2.10 Assignment Operators and Expressions&#160;</b><br/>
An expression such as &#160;<br/>&#160;<br/>&#160; &#160;i = i + 2&#160;<br/>
in which the variable on the left&#160;side is repeated immediately on the right, can be written in&#160;<br/>the compressed form&#160;&#160;<br/>&#160;<br/>&#160; &#160;i += 2&#160;<br/>
The operator&#160;+=&#160;is called an&#160;<i>assignment operator</i>. &#160;<br/>
Most binary operators (operators like&#160;+&#160;that have a left and right operand) have a&#160;<br/>corresponding assignment operator&#160;<i>op</i>=, where&#160;<i>op</i>&#160;is one of &#160;<br/>
<hr/>
<a name=48></a>&#160;&#160;<br/>
48&#160;<br/>
&#160;<br/>&#160; &#160;+ &#160; - &#160; * &#160; / &#160; % &#160; &lt;&lt; &#160; &gt;&gt; &#160; &amp; &#160; ^ &#160; |&#160;<br/>
If&#160;<i>expr1</i>&#160;and&#160;<i>expr2</i>&#160;are expressions, then &#160;<br/>&#160;<br/>&#160; &#160;<i>expr1&#160;op= expr2</i>&#160;<br/>is equivalent to &#160;<br/>&#160;<br/>&#160; &#160;<i>expr1</i>&#160;= (<i>expr1</i>)&#160;<i>op</i>&#160;(<i>expr2</i>)&#160;<br/>except that&#160;<i>expr1</i>&#160;is computed only once. Notice the parentheses around&#160;<i>expr2</i>: &#160;<br/>&#160;<br/>&#160; &#160;x *= y + 1&#160;<br/>
means &#160;<br/>&#160;<br/>&#160; &#160;x = x * (y + 1)&#160;<br/>
rather than &#160;<br/>&#160;<br/>&#160; &#160;x = x * y + 1&#160;<br/>
As an example, the function&#160;bitcount&#160;counts the number of 1-bits in its integer argument. &#160;<br/>&#160;<br/>&#160; &#160;/* bitcount: &#160;count 1 bits in x */&#160;<br/>&#160; &#160;int bitcount(unsigned x)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int b;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;for (b = 0; x != 0; x &gt;&gt;= 1)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;if (x &amp; 01)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;b++;&#160;<br/>&#160; &#160; &#160; &#160;return b;&#160;<br/>&#160; &#160;}&#160;<br/>
Declaring the argument&#160;x&#160;to&#160;be&#160;an&#160;unsigned&#160;ensures that when it is right-shifted, vacated bits&#160;<br/>will be filled with zeros, not sign bits, regardless of&#160;the machine the program&#160;is run on. &#160;<br/>
Quite apart from&#160;conciseness, assignment operators have the advantage that they correspond&#160;<br/>better to the way people think. We say ``add 2 to&#160;i'' or ``increment&#160;i&#160;by 2'', not ``take&#160;i, add&#160;<br/>2, then put the result back in&#160;i''. Thus the expression&#160;i += 2&#160;is preferable to&#160;i = i+2. In&#160;<br/>addition, for a complicated expression like &#160;<br/>
&#160;<br/>&#160; &#160;yyval[yypv[p3+p4] + yypv[p1]] += 2&#160;<br/>
the assignment operator makes the code easier to&#160;understand, since the reader doesn't have to&#160;<br/>check painstakingly that two long expressions are indeed the same, or to wonder why they're&#160;<br/>not. And an assignment operator may even help a compiler to produce efficient code. &#160;<br/>
We have already seen that the assignment statement has a value and can occur in expressions;&#160;<br/>the most common example is &#160;<br/>
&#160;<br/>&#160; &#160;while ((c = getchar()) != EOF)&#160;<br/>&#160; &#160; &#160; &#160;...&#160;<br/>
The other assignment operators (+=,&#160;&#160;-=, etc.) can also occur in expressions, although this is&#160;<br/>less frequent. &#160;<br/>
In all such expressions, the type of an assignment expression is the type of its left operand,&#160;<br/>and the value is the value after the assignment. &#160;<br/>
<b>Exercise 2-9.</b>&#160;In a two's complement number system,&#160;x &amp;= (x-1)&#160;deletes the rightmost 1-bit&#160;<br/>in&#160;x. Explain why. Use this observation to write a faster version of&#160;bitcount. &#160;<br/>
<hr/>
<a name=49></a>&#160;&#160;<br/>
49&#160;<br/>
<b>2.11 Conditional Expressions&#160;</b><br/>
The statements &#160;<br/>&#160;<br/>&#160; &#160;if (a &gt; b)&#160;<br/>&#160; &#160; &#160; &#160;z = a;&#160;<br/>&#160; &#160;else&#160;<br/>&#160; &#160; &#160; &#160;z = b;&#160;<br/>
compute in&#160;z&#160;the&#160;maximum of&#160;a&#160;and&#160;b. The&#160;<i>conditional expression</i>, written with the ternary&#160;<br/>operator ``?:'',&#160;provides an alternate way to write this and similar constructions. In the&#160;<br/>expression &#160;<br/>&#160;<br/>&#160; &#160;<i>expr1</i>&#160;?&#160;<i>expr2</i>&#160;:&#160;<i>expr3</i>&#160;<br/>the expression&#160;<i>expr1</i>&#160;is evaluated first. If it is non-zero (true), then the expression&#160;<i>expr2</i>&#160;is&#160;<br/>evaluated, and that is the value of the conditional expression. Otherwise&#160;<i>expr3</i>&#160;is evaluated,&#160;<br/>and that is the value. Only one of&#160;<i>expr2</i>&#160;and&#160;<i>expr3</i>&#160;is evaluated. Thus to set&#160;z&#160;to&#160;the&#160;maximum&#160;<br/>of&#160;a&#160;and&#160;b, &#160;<br/>&#160;<br/>&#160; &#160;z = (a &gt; b) ? a : b; &#160; &#160;/* z = max(a, b) */&#160;<br/>
It should be noted that the conditional expression&#160;is indeed an expression, and it can be used&#160;<br/>wherever any other expression can be. If&#160;<i>expr2</i>&#160;and&#160;<i>expr3</i>&#160;are of different types, the type of the&#160;<br/>result is determined by the conversion rules discussed earlier in this chapter. For example, if&#160;f&#160;<br/>is a&#160;float&#160;and&#160;n&#160;an&#160;int, then the expression &#160;<br/>&#160;<br/>&#160; &#160;(n &gt; 0) ? f : n&#160;<br/>
is of type&#160;float&#160;regardless of whether&#160;n&#160;is positive. &#160;<br/>
Parentheses are not necessary around the first&#160;expression of a conditional expression, since&#160;<br/>the precedence of&#160;?:&#160;is very low, just above assignment. They are advisable anyway,&#160;<br/>however, since they make the condition part of the expression easier to see. &#160;<br/>
The conditional expression often leads to succinct code. For example, this loop prints&#160;n&#160;<br/>elements of an array, 10 per line, with each column&#160;separated by one blank, and with each line&#160;<br/>(including the last) terminated by a newline. &#160;<br/>
&#160;<br/>&#160; &#160;for (i = 0; i &lt; n; i++)&#160;<br/>&#160; &#160; &#160; &#160;printf(&#34;%6d%c&#34;, a[i], (i%10==9 || i==n-1) ? '\n' : ' ');&#160;<br/>
A newline is printed after every tenth element, and after the&#160;n-th. All other elements are&#160;<br/>followed by one blank. This might look tricky,&#160;but it's more compact than the equivalent&#160;if-<br/>else. Another good example is &#160;<br/>&#160;<br/>&#160; &#160;printf(&#34;You have %d items%s.\n&#34;, n, n==1 ? &#34;&#34; : &#34;s&#34;);&#160;<br/>
<b>Exercise 2-10.</b>&#160;Rewrite the function&#160;lower, which converts upper case letters to lower case,&#160;<br/>with a conditional expression instead of&#160;if-else. &#160;<br/>
<b>2.12 Precedence and Order of Evaluation&#160;</b><br/>
Table 2.1 summarizes the rules for precedence and associativity of all operators, including&#160;<br/>those that we have not yet discussed. Operators on the same line have the same precedence;&#160;<br/>rows are in order of decreasing precedence, so, for example,&#160;*,&#160;&#160;/, and&#160;%&#160;all have the same&#160;<br/>precedence, which is higher than that of binary&#160;+&#160;and&#160;-. The ``operator''&#160;()&#160;refers to function&#160;<br/>call. The operators&#160;-&gt;&#160;and&#160;.&#160;are used to access members of structures; they will be covered in&#160;<br/>
<hr/>
<a name=50></a>&#160;&#160;<br/>
50&#160;<br/>
<a href="">Chapter 6</a>, along with&#160;sizeof<a href="">&#160;(size of an object).&#160;Chapter 5</a>&#160;discusses&#160;*&#160;(indirection through a&#160;<br/>pointer) and&#160;&amp;<a href="">&#160;(address of an object), and&#160;Chapter 3&#160;discusses the com</a>ma operator. &#160;<br/>
<b>Operators &#160;</b><br/>
<b>Associativity&#160;</b><br/>
() [] -&gt; .&#160;<br/>
&#160;left&#160;to right&#160;<br/>
! ~ ++ -- + - *&#160;(<i>type</i>)&#160;sizeof&#160;<br/>
&#160;right to left&#160;<br/>
* / %&#160;&#160;<br/>
&#160;left&#160;to right&#160;<br/>
+ -&#160;&#160;<br/>
&#160;left&#160;to right&#160;<br/>
&lt;&lt; &#160;&gt;&gt;&#160;&#160;<br/>
&#160;left&#160;to right&#160;<br/>
&lt; &lt;= &gt; &gt;=&#160;&#160;<br/>
&#160;left&#160;to right&#160;<br/>
== !=&#160;&#160;<br/>
&#160;left&#160;to right&#160;<br/>
&amp;&#160;&#160;<br/>
&#160;left&#160;to right&#160;<br/>
^&#160;&#160;<br/>
&#160;left&#160;to right&#160;<br/>
|&#160;&#160;<br/>
&#160;left&#160;to right&#160;<br/>
&amp;&amp;&#160;<br/>
&#160;left&#160;to right&#160;<br/>
||&#160;&#160;<br/>
&#160;left&#160;to right&#160;<br/>
?:&#160;&#160;<br/>
&#160;right to left&#160;<br/>
= += -= *= /= %= &amp;= ^= |= &lt;&lt;= &gt;&gt;=&#160;&#160;right to left&#160;<br/>
,&#160;&#160;<br/>
&#160;left&#160;to right&#160;<br/>
Unary &amp; +, -, and * have higher precedence than the binary forms. &#160;<br/>
<i><b>Table 2.1:</b>&#160;Precedence and Associativity of Operators</i>&#160;&#160;<br/>
Note that the precedence of the bitwise operators&#160;&amp;,&#160;&#160;^, and&#160;|&#160;falls below&#160;==&#160;and&#160;!=. This&#160;<br/>implies that bit-testing expressions like &#160;<br/>
&#160;<br/>&#160; &#160;if ((x &amp; MASK) == 0) ...&#160;<br/>
must be fully parenthesized to give proper results. &#160;<br/>
C, like most languages, does not specify the order in which the operands of an operator are&#160;<br/>evaluated. (The exceptions are&#160;&amp;&amp;,&#160;||,&#160;?:, and `,'.) For example, in a statement like &#160;<br/>
&#160;<br/>&#160; &#160;x = f() + g();&#160;<br/>
f&#160;may be evaluated before&#160;g&#160;or vice versa; thus if either&#160;f&#160;or&#160;g&#160;alters a variable on which the&#160;<br/>other depends,&#160;x&#160;can depend on the order of evaluation. Intermediate results can be stored in&#160;<br/>temporary variables to ensure a particular sequence. &#160;<br/>
Similarly, the order in which function arguments are evaluated is not specified, so the&#160;<br/>statement &#160;<br/>
&#160;<br/>&#160; &#160;printf(&#34;%d %d\n&#34;, ++n, power(2, n)); &#160; /* WRONG */&#160;<br/>
can produce different results with different compilers, depending on whether&#160;n&#160;is incremented&#160;<br/>before&#160;power&#160;is called. The solution, of&#160;course, is to write &#160;<br/>&#160;<br/>&#160; &#160;++n;&#160;<br/>
<hr/>
<a name=51></a>&#160;&#160;<br/>
51&#160;<br/>
&#160; &#160;printf(&#34;%d %d\n&#34;, n, power(2, n));&#160;<br/>
Function calls, nested assignment statements, and increment and decrement operators cause&#160;<br/>``side effects'' - some&#160;variable is changed as&#160;a by-product of the evaluation of an expression.&#160;<br/>In any expression involving side effects, there can be subtle dependencies on the order in&#160;<br/>which variables taking part in the expression&#160;are updated. One unhappy situation is typified&#160;<br/>by the statement &#160;<br/>&#160;<br/>&#160; &#160;a[i] = i++;&#160;<br/>
The question is whether the subscript is the old value of&#160;i&#160;or the new. Compilers can interpret&#160;<br/>this in different ways, and generate different&#160;answers depending on their interpretation. The&#160;<br/>standard intentionally leaves most such matters&#160;unspecified. When side effects (assignment to&#160;<br/>variables) take place within an expression is left to the discretion of the compiler, since the&#160;<br/>best order depends strongly on machine architecture. (The standard does specify that all side&#160;<br/>effects on arguments take effect before a function&#160;is called, but that would not help in the call&#160;<br/>to&#160;printf&#160;above.) &#160;<br/>
The moral is that writing code that depends&#160;on order of evaluation is a bad programming&#160;<br/>practice in any language. Naturally, it is necessary&#160;to know what things to avoid, but if you&#160;<br/>don't know&#160;<i>how</i>&#160;they are done on various machines, you won't be tempted to take advantage&#160;<br/>of a particular implementation. &#160;<br/>
<hr/>
<a name=52></a>&#160;&#160;<br/>
52&#160;<br/>
&#160;<br/>
<b>Chapter&#160;3 - Control Flow&#160;</b><br/>
The control-flow of a language specify the order in which computations are performed. We&#160;<br/>have already met the most common control-flow&#160;constructions in earlier examples; here we&#160;<br/>will complete the set, and be more precise about the ones discussed before. &#160;<br/>
<b>3.1 Statements and Blocks&#160;</b><br/>
An expression such as&#160;x = 0&#160;or&#160;i++&#160;or&#160;printf(...)&#160;becomes a&#160;<i>statement</i>&#160;when it is&#160;<br/>followed by a semicolon, as in &#160;<br/>&#160;<br/>&#160; &#160;x = 0;&#160;<br/>&#160; &#160;i++;&#160;<br/>&#160; &#160;printf(...);&#160;<br/>
In C, the semicolon is a statement terminator, rather than a separator as it is in languages like&#160;<br/>Pascal. &#160;<br/>
Braces&#160;&#160;{&#160;and&#160;}&#160;are used to group declarations&#160;and statements together into a&#160;<i>compound&#160;<br/>statement</i>, or&#160;<i>block</i>, so that they are syntactically equivalent to a single statement. The braces&#160;<br/>that surround the statements of a function are one obvious example; braces around multiple&#160;<br/>statements after an&#160;if,&#160;else,&#160;while, or&#160;for&#160;are another. (Variables can be declared inside&#160;<i>any</i>&#160;<br/><a href="">block; we will talk about this in&#160;Chapter 4</a>.) There is no semicolon after the right brace that&#160;<br/>ends a block. &#160;<br/>
<b>3.2 If-Else&#160;</b><br/>
The&#160;if-else&#160;statement is used to express decisions. Formally the syntax is &#160;<br/>&#160;<br/>&#160; &#160;if (<i>expression</i>)&#160;<br/>&#160; &#160; &#160; &#160;<i>statement1</i>&#160;<br/>&#160; &#160;else&#160;<br/>&#160; &#160; &#160; &#160;<i>statement2</i>&#160;<br/>where the&#160;else&#160;part is optional. The&#160;<i>expression</i>&#160;is evaluated; if&#160;it is true (that is, if&#160;<i>expression</i>&#160;<br/>has a non-zero value),&#160;<i>statement1</i>&#160;is executed. If&#160;it is false (<i>expression</i>&#160;is zero) and if there is&#160;<br/>an&#160;else&#160;part,&#160;<i>statement2</i>&#160;is executed instead. &#160;<br/>
Since an&#160;if&#160;tests the numeric value of an expression, certain coding shortcuts are possible.&#160;<br/>The most obvious is writing &#160;<br/>
&#160;<br/>&#160; &#160;if (<i>expression</i>)&#160;<br/>
instead of &#160;<br/>&#160;<br/>&#160; &#160;if (<i>expression</i>&#160;!= 0)&#160;<br/>
Sometimes this is natural and clear; at other times it can be cryptic. &#160;<br/>
Because the&#160;else&#160;part of an&#160;if-else&#160;is optional,there is an ambiguity when an else if&#160;omitted&#160;<br/>from&#160;a nested&#160;if&#160;sequence. This is resolved by associating the&#160;else&#160;with the closest previous&#160;<br/>else-less&#160;if. For example, in &#160;<br/>
<hr/>
<a name=53></a>&#160;&#160;<br/>
53&#160;<br/>
&#160;<br/>&#160; &#160;if (n &gt; 0)&#160;<br/>&#160; &#160; &#160; &#160;if (a &gt; b)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;z = a;&#160;<br/>&#160; &#160; &#160; &#160;else&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;z = b;&#160;<br/>
the&#160;else&#160;goes to the inner&#160;if, as we have shown by indentation. If that isn't what you want,&#160;<br/>braces must be used to force the proper association: &#160;<br/>&#160;<br/>&#160; &#160;if (n &gt; 0) {&#160;<br/>&#160; &#160; &#160; &#160;if (a &gt; b)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; z = a;&#160;<br/>&#160; &#160;}&#160;<br/>&#160; &#160;else&#160;<br/>&#160; &#160; &#160; &#160;z = b;&#160;<br/>
The ambiguity is especially pernicious in situations like this: &#160;<br/>&#160;<br/>&#160; &#160;if (n &gt; 0)&#160;<br/>&#160; &#160; &#160; &#160;for (i = 0; i &lt; n; i++)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;if (s[i] &gt; 0) {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;printf(&#34;...&#34;);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;return i;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160;else &#160; &#160; &#160; &#160;/* WRONG */&#160;<br/>&#160; &#160; &#160; &#160;printf(&#34;error -- n is negative\n&#34;);&#160;<br/>
The indentation shows unequivocally what&#160;you want, but the compiler doesn't get the&#160;<br/>message, and associates the&#160;else&#160;with the inner&#160;if. This kind of bug can be&#160;hard to find; it's a&#160;<br/>good idea to use braces when there are nested&#160;ifs. &#160;<br/>
By the way, notice that there is a semicolon after&#160;z = a&#160;in &#160;<br/>
&#160;<br/>&#160; &#160;if (a &gt; b)&#160;<br/>&#160; &#160; &#160; &#160;z = a;&#160;<br/>&#160; &#160;else&#160;<br/>&#160; &#160; &#160; &#160;z = b;&#160;<br/>
This is because grammatically, a&#160;<i>statement</i>&#160;follows the&#160;if, and an expression statement like&#160;<br/>``z = a;''&#160;is always terminated by a semicolon. &#160;<br/>
<b>3.3 Else-If&#160;</b><br/>
The construction &#160;<br/>&#160;<br/>&#160; &#160;if (<i>expression</i>)&#160;<br/>&#160; &#160; &#160; &#160;<i>statement</i>&#160;<br/>&#160; &#160;else if (<i>expression</i>)&#160;<br/>&#160; &#160; &#160; &#160;<i>statement</i>&#160;<br/>&#160; &#160;else if (<i>expression</i>)&#160;<br/>&#160; &#160; &#160; &#160;<i>statement</i>&#160;<br/>&#160; &#160;else if (<i>expression</i>)&#160;<br/>&#160; &#160; &#160; &#160;<i>statement</i>&#160;<br/>&#160; &#160;else&#160;<br/>&#160; &#160; &#160; &#160;<i>statement</i>&#160;<br/>
occurs so often that it is worth a brief separate discussion. This sequence of&#160;if&#160;statements is&#160;<br/>the most general way of&#160;writing a multi-way decision. The&#160;<i>expressions</i>&#160;are evaluated in order;&#160;<br/>if&#160;an&#160;<i>expression</i>&#160;is true, the&#160;<i>statement</i>&#160;associated with it is executed, and this terminates the&#160;<br/>whole chain. As always, the code for each&#160;<i>statement</i>&#160;is either a single statement, or a group of&#160;<br/>them&#160;in braces. &#160;<br/>
<hr/>
<a name=54></a>&#160;&#160;<br/>
54&#160;<br/>
The last&#160;else&#160;part handles the ``none of the above''&#160;or default case where none of the other&#160;<br/>conditions is satisfied. Sometimes there is no explicit action for the default; in that case the&#160;<br/>trailing &#160;<br/>
&#160;<br/>&#160; &#160;else&#160;<br/>&#160; &#160; &#160; &#160;<i>statement</i>&#160;<br/>
can be omitted, or it may be used for error checking to catch an ``impossible''&#160;condition. &#160;<br/>
To illustrate a three-way decision, here is a binary search function that decides if&#160;a particular&#160;<br/>value&#160;&#160;x&#160;occurs in the sorted array&#160;v. The elements of&#160;v&#160;must be in increasing order. The&#160;<br/>function returns the position (a number between 0 and&#160;n-1) if&#160;x&#160;occurs in&#160;v, and -1 if not. &#160;<br/>
Binary search first compares the input value&#160;x&#160;to the middle element of the array&#160;v. If&#160;x&#160;is less&#160;<br/>than the middle value, searching focuses on the&#160;lower half of the table, otherwise on the upper&#160;<br/>half. In either case, the next step is to compare&#160;x&#160;to the middle element of the selected half.&#160;<br/>This process of dividing the range in two continues until the value is found or the range is&#160;<br/>empty. &#160;<br/>
&#160;<br/>&#160; &#160;/* binsearch: &#160;find x in v[0] &lt;= v[1] &lt;= ... &lt;= v[n-1] */&#160;<br/>&#160; &#160;int binsearch(int x, int v[], int n)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int low, high, mid;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;low = 0;&#160;<br/>&#160; &#160; &#160; &#160;high = n - 1;&#160;<br/>&#160; &#160; &#160; &#160;while (low &lt;= high) {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;mid = (low+high)/2;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;if (x &lt; v[mid])&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;high = mid + 1;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;else if (x &#160;&gt; v[mid])&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;low = mid + 1;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;else &#160; &#160;/* found match */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;return mid;&#160;<br/>&#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160; &#160; &#160;return -1; &#160; /* no match */&#160;<br/>&#160; &#160;}&#160;<br/>
The fundamental decision is whether&#160;x&#160;is less than, greater than, or equal to the middle&#160;<br/>element&#160;v[mid]&#160;at each step; this is a natural for&#160;else-if. &#160;<br/>
<b>Exercise 3-1.</b>&#160;Our binary search makes two tests inside the loop, when one would suffice (at&#160;<br/>the price of more tests outside.) Write a version with only one test inside the loop and&#160;<br/>measure the difference in run-time. &#160;<br/>
<b>3.4 Switch&#160;</b><br/>
The&#160;switch&#160;statement is a multi-way decision that tests whether an expression matches one of&#160;<br/>a number of&#160;<i>constant</i>&#160;integer values, and branches accordingly. &#160;<br/>&#160;<br/>&#160; &#160;switch (<i>expression</i>) {&#160;<br/>&#160; &#160; &#160; &#160;case&#160;<i>const-expr</i>:&#160;<i>statements</i>&#160;<br/>&#160; &#160; &#160; &#160;case&#160;<i>const-expr</i>:&#160;<i>statements</i>&#160;<br/>&#160; &#160; &#160; &#160;default:&#160;<i>statements</i>&#160;<br/>&#160; &#160;}&#160;<br/>
<hr/>
<a name=55></a>&#160;&#160;<br/>
55&#160;<br/>
Each case is labeled by one or more integer-valued constants or constant expressions. If a case&#160;<br/>matches the expression value, execution starts&#160;at that case. All case expressions must be&#160;<br/>different. The case labeled&#160;default&#160;is executed if none of the other cases are satisfied. A&#160;<br/>default&#160;is optional; if it isn't there&#160;and if none of the cases match, no action at all takes place.&#160;<br/>Cases and the default clause can occur in any order. &#160;<br/>
In&#160;<a href="">Chapter 1</a>&#160;we wrote a program&#160;to count the occurrences of each digit, white space, and all&#160;<br/>other characters, using a sequence of&#160;if ... else if&#160;...&#160;else. Here is the same program&#160;<br/>with a&#160;switch: &#160;<br/>
&#160;<br/>&#160; &#160;#include &lt;stdio.h&gt;&#160;<br/>&#160;<br/>&#160; &#160;main() &#160;/* count digits, white space, others */&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int c, i, nwhite, nother, ndigit[10];&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;nwhite = nother = 0;&#160;<br/>&#160; &#160; &#160; &#160;for (i = 0; i &lt; 10; i++)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;ndigit[i] = 0;&#160;<br/>&#160; &#160; &#160; &#160;while ((c = getchar()) != EOF) {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;switch (c) {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;case '0': case '1': case '2': case '3': case '4':&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;case '5': case '6': case '7': case '8': case '9':&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;ndigit[c-'0']++;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;break;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;case ' ':&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;case '\n':&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;case '\t':&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;nwhite++;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;break;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;default:&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;nother++;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;break;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160; &#160; &#160;printf(&#34;digits =&#34;);&#160;<br/>&#160; &#160; &#160; &#160;for (i = 0; i &lt; 10; i++)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;printf(&#34; %d&#34;, ndigit[i]);&#160;<br/>&#160; &#160; &#160; &#160;printf(&#34;, white space = %d, other = %d\n&#34;,&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;nwhite, nother);&#160;<br/>&#160; &#160; &#160; &#160;return 0;&#160;<br/>&#160; &#160;}&#160;<br/>
The&#160;break&#160;statement causes an immediate exit from&#160;the&#160;switch. Because cases serve just as&#160;<br/>labels, after the code for one case is done, execution&#160;<i>falls through</i>&#160;to the next unless you take&#160;<br/>explicit action to escape.&#160;break&#160;and&#160;return&#160;are the most common ways to leave a&#160;switch. A&#160;<br/>break&#160;statement can also be used to force an immediate exit from&#160;while,&#160;for, and&#160;do&#160;loops,&#160;<br/>as will be discussed later in this chapter. &#160;<br/>
Falling through cases is a mixed blessing. On the positive side, it allows several cases to be&#160;<br/>attached to a single action, as with the digits in this example. But it also implies that normally&#160;<br/>each case must end with a&#160;break&#160;to prevent falling through to the next. Falling through from&#160;<br/>one case to another is not robust, being prone to&#160;disintegration when the program&#160;is modified.&#160;<br/>With the exception of multiple labels for a single computation, fall-throughs should be used&#160;<br/>sparingly, and commented. &#160;<br/>
<hr/>
<a name=56></a>&#160;&#160;<br/>
56&#160;<br/>
As a matter of good form, put a&#160;break&#160;after the last case (the&#160;default&#160;here) even though it's&#160;<br/>logically unnecessary. Some day when another&#160;case gets added at the end, this bit of&#160;<br/>defensive programming will save you. &#160;<br/>
<b>Exercise 3-2.</b>&#160;Write a function&#160;escape(s,t)&#160;that converts characters like newline and tab&#160;<br/>into visible escape sequences like&#160;\n&#160;and&#160;\t&#160;as it copies the string&#160;t&#160;to&#160;s. Use a&#160;switch. Write&#160;<br/>a function for the other direction as well, converting escape sequences into the real characters. &#160;<br/>
<b>3.5 Loops - While and For&#160;</b><br/>
We have already encountered the&#160;while&#160;and&#160;for&#160;loops. In &#160;<br/>&#160;<br/>&#160; &#160;while (<i>expression</i>)&#160;<br/>&#160; &#160; &#160; &#160;<i>statement</i>&#160;<br/>
the&#160;&#160;<i>expression</i>&#160;is evaluated. If it is non-zero,&#160;<i>statement</i>&#160;is executed and&#160;<i>expression</i>&#160;is re-<br/>evaluated. This cycle continues until&#160;<i>expression</i>&#160;becomes zero, at which point execution&#160;<br/>resumes after&#160;<i>statement</i>. &#160;<br/>
The&#160;for&#160;statement &#160;<br/>
&#160;<br/>&#160; &#160;for (<i>expr1</i>;&#160;<i>expr2</i>;&#160;<i>expr3</i>)&#160;<br/>&#160; &#160; &#160; &#160;<i>statement</i>&#160;<br/>
is equivalent to &#160;<br/>&#160;<br/>&#160; &#160;<i>expr1</i>;&#160;<br/>&#160; &#160;while (<i>expr2</i>) {&#160;<br/>&#160; &#160; &#160; &#160;<i>statement</i>&#160;<br/>&#160; &#160; &#160; &#160;<i>expr3</i>;&#160;<br/>&#160; &#160;}&#160;<br/>
except for the behaviour of&#160;continue<a href="cs.html#59">, which is described in&#160;Section 3.7</a>. &#160;<br/>
Grammatically, the three components of a&#160;for&#160;loop are expressions. Most commonly,&#160;<i>expr1</i>&#160;<br/>and&#160;&#160;<i>expr3</i>&#160;are assignments or function calls and&#160;<i>expr2</i>&#160;is a relational expression. Any of the&#160;<br/>three parts can be omitted, although&#160;the semicolons must remain. If&#160;<i>expr1</i>&#160;or&#160;<i>expr3</i>&#160;is omitted,&#160;<br/>it is simply dropped from&#160;the expansion. If the test,&#160;<i>expr2</i>, is not present, it is taken as&#160;<br/>permanently true, so &#160;<br/>
&#160;<br/>&#160; &#160;for (;;) {&#160;<br/>&#160; &#160; &#160; &#160;...&#160;<br/>&#160; &#160;}&#160;<br/>
is an ``infinite'' loop, presumably to be broken by other means, such as a&#160;break&#160;or&#160;return. &#160;<br/>
Whether to use&#160;while&#160;or&#160;for&#160;is largely a matter of personal preference. For example, in &#160;<br/>
&#160;<br/>&#160; &#160;while ((c = getchar()) == ' ' || c == '\n' || c = '\t')&#160;<br/>&#160; &#160; &#160; &#160;; &#160; /* skip white space characters */&#160;<br/>
there is no initialization or re-initialization, so the&#160;while&#160;is most natural. &#160;<br/>
The&#160;&#160;for&#160;is preferable when there is a simple initialization and increment since it keeps the&#160;<br/>loop control statements close together and visible at the top of the loop. This is most obvious&#160;<br/>in &#160;<br/>
<hr/>
<a name=57></a>&#160;&#160;<br/>
57&#160;<br/>
&#160;<br/>&#160; &#160;for (i = 0; i &lt; n; i++)&#160;<br/>&#160; &#160; &#160; &#160;...&#160;<br/>
which is the C idiom&#160;for processing the first&#160;n&#160;elements of an array, the analog of the Fortran&#160;<br/>DO loop or the Pascal&#160;for. The analogy is not perfect, however, since the index variable&#160;i&#160;<br/>retains its value when the loop terminates for any reason. Because the components of the&#160;for&#160;<br/>are arbitrary expressions,&#160;for&#160;loops are not restricted to arithmetic progressions. Nonetheless,&#160;<br/>it is bad style to force unrelated computations into the initialization and increment of&#160;a&#160;for,&#160;<br/>which are better reserved for loop control operations. &#160;<br/>
As a larger example, here is another version of&#160;atoi&#160;for converting a string to its numeric&#160;<br/>equivalent. This one is slightly mo<a href="">re general than the one in&#160;Chapter 2; it copes with optional&#160;<br/></a>leading white space and an optional&#160;+&#160;or&#160;-&#160;sign. (<a href="">Chapter 4&#160;shows&#160;</a>atof, which does the same&#160;<br/>conversion for floating-point numbers.) &#160;<br/>
The structure of the program&#160;reflects the form&#160;of the input: &#160;<br/>
<i>&#160; skip white space, if any&#160;<br/>&#160; get sign, if any&#160;<br/>&#160; get integer part and convert it&#160;</i>&#160;<br/>
Each step does its part, and leaves things in a clean state for the next. The whole process&#160;<br/>terminates on the first character that could not be part of a number. &#160;<br/>
&#160;<br/>&#160; &#160;#include &lt;ctype.h&gt;&#160;<br/>&#160;<br/>&#160; &#160;/* atoi: &#160;convert s to integer; version 2 */&#160;<br/>&#160; &#160;int atoi(char s[])&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int i, n, sign;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;for (i = 0; isspace(s[i]); i++) &#160;/* skip white space */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;;&#160;<br/>&#160; &#160; &#160; &#160;sign = (s[i] == '-') ? -1 : 1;&#160;<br/>&#160; &#160; &#160; &#160;if (s[i] == '+' || s[i] == '-') &#160;/* skip sign */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;i++;&#160;<br/>&#160; &#160; &#160; &#160;for (n = 0; isdigit(s[i]); i++)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;n = 10 * n + (s[i] - '0');&#160;<br/>&#160; &#160; &#160; &#160;return sign * n;&#160;<br/>&#160; &#160;}&#160;<br/>
The standard library provides a more elaborate function&#160;strtol&#160;for conversion of strings to&#160;<br/><a href="">long integers; see&#160;Section 5 of Appendix B</a>. &#160;<br/>
The advantages of keeping loop control centralized are even more obvious when there are&#160;<br/>several nested loops. The following function is a&#160;Shell sort for sorting an array of integers.&#160;<br/>The basic idea of this sorting algorithm,&#160;which was invented in 1959 by D. L. Shell, is that in&#160;<br/>early stages, far-apart elements are compared, rather than adjacent ones as in simpler&#160;<br/>interchange sorts. This tends to eliminate large amounts of disorder quickly, so later stages&#160;<br/>have less work to do. The interval between compared elements is gradually decreased to one,&#160;<br/>at which point the sort effectively becomes an adjacent interchange method. &#160;<br/>
&#160;<br/>&#160; &#160;/* shellsort: &#160;sort v[0]...v[n-1] into increasing order */&#160;<br/>&#160; &#160;void shellsort(int v[], int n)&#160;<br/>&#160; &#160;{&#160;<br/>
<hr/>
<a name=58></a>&#160;&#160;<br/>
58&#160;<br/>
&#160; &#160; &#160; &#160;int gap, i, j, temp;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;for (gap = n/2; gap &gt; 0; gap /= 2)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;for (i = gap; i &lt; n; i++)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;for (j=i-gap; j&gt;=0 &amp;&amp; v[j]&gt;v[j+gap]; j-=gap) {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;temp = v[j];&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;v[j] = v[j+gap];&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;v[j+gap] = temp;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160;}&#160;<br/>
There are three nested loops. The outermost controls the gap between compared elements,&#160;<br/>shrinking it from&#160;n/2&#160;by a factor of two each pass until it becomes zero. The middle loop&#160;<br/>steps along the elements. The innermost loop compares each pair of elements that is separated&#160;<br/>by&#160;&#160;gap&#160;and reverses any that are out of order. Since&#160;gap&#160;is eventually reduced to one, all&#160;<br/>elements are eventually ordered correctly. Notice how the generality of&#160;the&#160;for&#160;makes&#160;the&#160;<br/>outer loop fit in the same form&#160;as the others, even though it is not an arithmetic progression. &#160;<br/>
One final C operator is the comma ``,'', which most often finds use in the&#160;for&#160;statement. A&#160;<br/>pair of expressions separated by a comma is evaluated left to right, and the type and value of&#160;<br/>the result are the type and value&#160;of the right operand. Thus in a for statement, it is possible to&#160;<br/>place multiple expressions in the various parts, for example to process two indices in parallel.&#160;<br/>This is illustrated in the function&#160;reverse(s), which reverses the string&#160;s&#160;in place. &#160;<br/>
&#160;<br/>&#160; &#160;#include &lt;string.h&gt;&#160;<br/>&#160;<br/>&#160; &#160;/* reverse: &#160;reverse string s in place */&#160;<br/>&#160; &#160;void reverse(char s[])&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int c, i, j;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;for (i = 0, j = strlen(s)-1; i &lt; j; i++, j--) {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;c = s[i];&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;s[i] = s[j];&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;s[j] = c;&#160;<br/>&#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160;}&#160;<br/>
The commas that separate function arguments, variables in declarations, etc., are&#160;<i>not</i>&#160;comma&#160;<br/>operators, and do not guarantee left to right evaluation. &#160;<br/>
Comma&#160;operators should be used sparingly. The&#160;most suitable uses are for constructs strongly&#160;<br/>related to each other, as in the&#160;for&#160;loop in&#160;reverse, and in macros where a multistep&#160;<br/>computation has to be a single&#160;expression. A comma expression might also be appropriate for&#160;<br/>the exchange of elements in&#160;reverse, where the exchange can be thought of a single&#160;<br/>operation: &#160;<br/>
&#160;<br/>&#160; &#160; for (i = 0, j = strlen(s)-1; i &lt; j; i++, j--)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;c = s[i], s[i] = s[j], s[j] = c;&#160;<br/>
<b>Exercise 3-3.</b>&#160;Write a function&#160;expand(s1,s2)&#160;that expands shorthand notations like&#160;a-z&#160;in&#160;<br/>the string&#160;s1&#160;into the equivalent complete list&#160;abc...xyz&#160;in&#160;s2. Allow for letters of&#160;either&#160;<br/>case and digits, and be prepared to handle cases like&#160;a-b-c&#160;and&#160;a-z0-9&#160;and&#160;-a-z. Arrange&#160;<br/>that a leading or trailing&#160;-&#160;is taken literally. &#160;<br/>
<b>3.6 Loops - Do-While&#160;</b><br/>
<hr/>
<a name=59></a>&#160;&#160;<br/>
59&#160;<br/>
As we discussed in&#160;<a href="">Chapter 1, the&#160;</a>while&#160;and&#160;for&#160;loops test the termination condition at the&#160;<br/>top. By contrast, the third loop in C, the&#160;do-while, tests at the bottom&#160;<i>after</i>&#160;making each pass&#160;<br/>through the loop body; the body is always executed at least once. &#160;<br/>
The syntax of the&#160;do&#160;is &#160;<br/>
&#160;<br/>&#160; &#160;do&#160;<br/>&#160; &#160; &#160; &#160;<i>statement</i>&#160;<br/>&#160; &#160;while (<i>expression</i>);&#160;<br/>
The&#160;&#160;<i>statement</i>&#160;is executed, then&#160;<i>expression</i>&#160;is evaluated. If&#160;it is true,&#160;<i>statement</i>&#160;is evaluated&#160;<br/>again, and so on. When the expression becomes false, the loop terminates. Except for the&#160;<br/>sense of the test,&#160;do-while&#160;is equivalent to the Pascal&#160;repeat-until&#160;statement. &#160;<br/>
Experience shows that&#160;do-while&#160;is much less used than&#160;while&#160;and&#160;for. Nonetheless, from&#160;<br/>time to time it is valuable, as in the following function&#160;itoa, which converts a number to a&#160;<br/>character string (the inverse of&#160;atoi). The job is slightly more complicated than might be&#160;<br/>thought at first, because the easy methods of generating the digits generate them&#160;in the wrong&#160;<br/>order. We have chosen to generate the string backwards, then reverse it. &#160;<br/>
&#160;<br/>&#160; &#160;/* itoa: &#160;convert n to characters in s */&#160;<br/>&#160; &#160;void itoa(int n, char s[])&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int i, sign;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;if ((sign = n) &lt; 0) &#160;/* record sign */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;n = -n; &#160; &#160; &#160; &#160; &#160;/* make n positive */&#160;<br/>&#160; &#160; &#160; &#160;i = 0;&#160;<br/>&#160; &#160; &#160; &#160;do { &#160; &#160; &#160;/* generate digits in reverse order */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;s[i++] = n % 10 + '0'; &#160;/* get next digit */&#160;<br/>&#160; &#160; &#160; &#160;} while ((n /= 10) &gt; 0); &#160; &#160;/* delete it */&#160;<br/>&#160; &#160; &#160; &#160;if (sign &lt; 0)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;s[i++] = '-';&#160;<br/>&#160; &#160; &#160; &#160;s[i] = '\0';&#160;<br/>&#160; &#160; &#160; &#160;reverse(s);&#160;<br/>&#160; &#160;}&#160;<br/>
The&#160;&#160;do-while&#160;is necessary, or at least convenient,&#160;since at least one character must be&#160;<br/>installed in the array&#160;s, even if&#160;n&#160;is zero. We also used braces around the single statement that&#160;<br/>makes up the body of the&#160;do-while, even though they are unnecessary, so the hasty reader&#160;<br/>will not mistake the&#160;while&#160;part for the&#160;<i>beginning</i>&#160;of a&#160;while&#160;loop. &#160;<br/>
<b>Exercise 3-4.</b>&#160;In a two's complement number&#160;representation, our version of&#160;itoa&#160;does not&#160;<br/>handle the largest negative number, that is, the value of&#160;n&#160;equal to -(2wordsize-1). Explain why&#160;<br/>not. Modify&#160;it to print that value correctly, regardless of&#160;the machine on which it runs. &#160;<br/>
<b>Exercise 3-5.</b>&#160;Write the function&#160;itob(n,s,b)&#160;that converts the integer&#160;n&#160;into a base&#160;b&#160;<br/>character representation in the string&#160;s. In particular,&#160;itob(n,s,16)&#160;formats&#160;s&#160;as a&#160;<br/>hexadecimal integer in&#160;s. &#160;<br/>
<b>Exercise 3-6.</b>&#160;Write a version of&#160;itoa&#160;that accepts three arguments instead of two. The third&#160;<br/>argument is a minimum&#160;field width; the converted number must be padded with blanks on the&#160;<br/>left if necessary to make it wide enough. &#160;<br/>
<b>3.7 Break and Continue&#160;</b><br/>
<hr/>
<a name=60></a>&#160;&#160;<br/>
60&#160;<br/>
It is sometimes convenient to be able to exit&#160;from&#160;a loop other than by testing at the top or&#160;<br/>bottom.&#160;The&#160;break&#160;statement provides an early exit from&#160;for,&#160;&#160;while, and&#160;do, just as from&#160;<br/>switch. A&#160;break&#160;causes the innermost enclosing loop or&#160;switch&#160;to be exited immediately. &#160;<br/>
The following function,&#160;trim, removes trailing blanks, tabs and newlines from&#160;the end of a&#160;<br/>string, using a&#160;break&#160;to exit from&#160;a loop when the rightmost non-blank, non-tab, non-newline&#160;<br/>is found. &#160;<br/>
&#160;<br/>&#160; &#160;/* trim: &#160;remove trailing blanks, tabs, newlines */&#160;<br/>&#160; &#160;int trim(char s[])&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int n;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;for (n = strlen(s)-1; n &gt;= 0; n--)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;if (s[n] != ' ' &amp;&amp; s[n] != '\t' &amp;&amp; s[n] != '\n')&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;break;&#160;<br/>&#160; &#160; &#160; &#160;s[n+1] = '\0';&#160;<br/>&#160; &#160; &#160; &#160;return n;&#160;<br/>&#160; &#160;}&#160;<br/>
strlen&#160;returns the length of the string. The&#160;for&#160;loop starts at the end and scans backwards&#160;<br/>looking for the first character that is not a blank or tab or newline. The loop is broken when&#160;<br/>one is found, or when&#160;n&#160;becomes negative (that is, when the entire string has been scanned).&#160;<br/>You should verify that this is correct behavior&#160;even when the string is empty or contains only&#160;<br/>white space characters. &#160;<br/>
The&#160;continue&#160;statement is related to&#160;break, but less often used; it causes the next iteration of&#160;<br/>the enclosing&#160;for,&#160;while, or&#160;do&#160;loop to begin. In the&#160;while&#160;and&#160;do, this means that the test&#160;<br/>part is executed immediately; in the&#160;for, control passes to the increment step. The&#160;continue&#160;<br/>statement applies only to loops, not to&#160;switch. A&#160;continue&#160;inside a&#160;switch&#160;inside a loop&#160;<br/>causes the next loop iteration. &#160;<br/>
As an example, this fragment processes only the non-negative elements in the array&#160;a;&#160;<br/>negative values are skipped. &#160;<br/>
&#160;<br/>&#160; &#160;for (i = 0; i &lt; n; i++)&#160;<br/>&#160; &#160; &#160; &#160;if (a[i] &lt; 0) &#160; /* skip negative elements */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;continue;&#160;<br/>&#160; &#160; &#160; &#160;... /* do positive elements */&#160;<br/>
The&#160;continue&#160;statement is often used when the part&#160;of the loop that follows is complicated,&#160;<br/>so that reversing a test and indenting another level would nest the program&#160;too deeply. &#160;<br/>
<b>3.8 Goto and labels&#160;</b><br/>
C provides the infinitely-abusable&#160;goto&#160;statement, and labels to branch to. Formally, the&#160;goto&#160;<br/>statement is never necessary, and in practice it is&#160;almost always easy to write code without it.&#160;<br/>We&#160;have not used&#160;goto&#160;in this book. &#160;<br/>
Nevertheless, there are a few situations where&#160;gotos may find a place. The most common is&#160;<br/>to abandon processing in some deeply nested structure, such as breaking out of two or more&#160;<br/>loops at once. The&#160;break&#160;statement cannot be used directly since it only exits from&#160;the&#160;<br/>innermost loop. Thus: &#160;<br/>
<hr/>
<a name=61></a>&#160;&#160;<br/>
61&#160;<br/>
&#160;<br/>&#160; &#160; &#160; &#160;for ( ... )&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;for ( ... ) {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;...&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;if (disaster)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;goto error;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160; &#160; &#160;...&#160;<br/>&#160; &#160;error:&#160;<br/>&#160; &#160; &#160; &#160;/* clean up the mess */&#160;<br/>
This organization is handy if the error-handling code is non-trivial, and if errors can occur in&#160;<br/>several places. &#160;<br/>
A label has the same form&#160;as a variable name, and is followed by a colon. It can be attached to&#160;<br/>any statement in the same function as the&#160;goto. The scope of&#160;a label is the entire function. &#160;<br/>
As another example, consider the problem&#160;of determining whether two arrays&#160;a&#160;and&#160;b&#160;have an&#160;<br/>element in common. One possibility is &#160;<br/>
&#160;<br/>&#160; &#160; &#160; &#160;for (i = 0; i &lt; n; i++)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;for (j = 0; j &lt; m; j++)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;if (a[i] == b[j])&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;goto found;&#160;<br/>&#160; &#160; &#160; &#160;/* didn't find any common element */&#160;<br/>&#160; &#160; &#160; &#160;...&#160;<br/>&#160; &#160;found:&#160;<br/>&#160; &#160; &#160; &#160;/* got one: a[i] == b[j] */&#160;<br/>&#160; &#160; &#160; &#160;...&#160;<br/>
Code involving a&#160;goto&#160;can always be written without one, though perhaps at the price of&#160;<br/>some repeated tests or an extra variable. For example, the array search becomes &#160;<br/>&#160;<br/>&#160; &#160;found = 0;&#160;<br/>&#160; &#160;for (i = 0; i &lt; n &amp;&amp; !found; i++)&#160;<br/>&#160; &#160; &#160; &#160;for (j = 0; j &lt; m &amp;&amp; !found; j++)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;if (a[i] == b[j])&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;found = 1;&#160;<br/>&#160; &#160;if (found)&#160;<br/>&#160; &#160; &#160; &#160;/* got one: a[i-1] == b[j-1] */&#160;<br/>&#160; &#160; &#160; &#160;...&#160;<br/>&#160; &#160;else&#160;<br/>&#160; &#160; &#160; &#160;/* didn't find any common element */&#160;<br/>&#160; &#160; &#160; &#160;...&#160;<br/>
With a few exceptions like those&#160;cited here, code that relies on&#160;goto&#160;statements is generally&#160;<br/>harder to understand and to maintain than code without&#160;gotos. Although we are not dogmatic&#160;<br/>about the matter, it does seem&#160;that&#160;goto&#160;statements should be used rarely, if at all. &#160;<br/>
<hr/>
<a name=62></a>&#160;&#160;<br/>
62&#160;<br/>
&#160;<br/>
<b>Chapter&#160;4 - Functions and Program&#160;<br/>Structure&#160;</b><br/>
Functions break large computing tasks into smaller ones, and enable people to build on what&#160;<br/>others have done instead of starting over from&#160;scratch. Appropriate functions hide details of&#160;<br/>operation from&#160;parts of the program&#160;that don't&#160;need to know about them, thus clarifying the&#160;<br/>whole, and easing the pain of making changes. &#160;<br/>
C has been designed to make functions efficient and easy to use; C programs generally consist&#160;<br/>of many small functions rather than a few big&#160;ones. A program&#160;may reside in one or more&#160;<br/>source files. Source files may be compiled separately and loaded together, along with&#160;<br/>previously compiled functions from&#160;libraries. We&#160;will not go into that process here, however,&#160;<br/>since the details vary from&#160;system&#160;to system. &#160;<br/>
Function declaration and definition is the area&#160;where the ANSI standard has made the most&#160;<br/><a href="">changes to C. As we saw first in&#160;Chapter 1, it is now possible to declare the type of argum</a>ents&#160;<br/>when a function is declared. The syntax of&#160;function declaration also changes, so that&#160;<br/>declarations and definitions match. This makes it possible for a compiler to detect many more&#160;<br/>errors than it could before. Furthermore, when&#160;arguments are properly declared, appropriate&#160;<br/>type coercions are performed automatically. &#160;<br/>
The standard clarifies the rules on the scope of&#160;names; in particular, it requires that there be&#160;<br/>only one definition of each external object. Initialization is more general: automatic arrays&#160;<br/>and structures may now be initialized. &#160;<br/>
The C preprocessor has also been enhanced. New preprocessor facilities include a more&#160;<br/>complete set of conditional compilation directives, a way to create quoted strings from&#160;macro&#160;<br/>arguments, and better control over the macro expansion process. &#160;<br/>
<b>4.1 Basics of Functions&#160;</b><br/>
To begin with, let us design and&#160;write a program&#160;to print each line of its input that contains a&#160;<br/>particular ``pattern''&#160;or string of characters.&#160;(This is a special case of the UNIX program&#160;<br/>grep.) For example, searching for the pattern of letters ``ould''&#160;in the set of&#160;lines &#160;<br/>&#160;<br/>&#160; &#160;Ah Love! could you and I with Fate conspire&#160;<br/>&#160; &#160;To grasp this sorry Scheme of Things entire,&#160;<br/>&#160; &#160;Would not we shatter it to bits -- and then&#160;<br/>&#160; &#160;Re-mould it nearer to the Heart's Desire!&#160;<br/>
will produce the output &#160;<br/>&#160;<br/>&#160; &#160;Ah Love! could you and I with Fate conspire&#160;<br/>&#160; &#160;Would not we shatter it to bits -- and then&#160;<br/>&#160; &#160;Re-mould it nearer to the Heart's Desire!&#160;<br/>
The job falls neatly into three pieces: &#160;<br/>&#160;<br/>while (<i>there's another line</i>)&#160;<br/>&#160; &#160; if (<i>the line contains the pattern</i>)&#160;<br/>&#160; &#160; &#160; &#160;&#160;<i>print it</i>&#160;<br/>
<hr/>
<a name=63></a>&#160;&#160;<br/>
63&#160;<br/>
Although it's certainly possible to put&#160;the code for all of this in&#160;main, a better way is to use the&#160;<br/>structure to advantage by making each part a separate function. Three small pieces are better&#160;<br/>to deal with than one big one, because irrelevant&#160;details can be buried in the functions, and the&#160;<br/>chance of unwanted interactions is minimized.&#160;And the pieces may even be useful in other&#160;<br/>programs. &#160;<br/>
``While there's another line''&#160;is&#160;getline<a href="">, a function that we wrote in&#160;Chapter 1</a>, and ``print it''&#160;<br/>is&#160;&#160;printf, which someone has already provided for&#160;us. This means we need only write a&#160;<br/>routine to decide whether the line contains an occurrence of the pattern. &#160;<br/>
We can solve that problem&#160;by writing a function&#160;strindex(s,t)&#160;that returns the position or&#160;<br/>index in the string&#160;s&#160;where the string&#160;t&#160;begins, or&#160;-1&#160;if&#160;s&#160;does not contain&#160;t. Because C arrays&#160;<br/>begin at position zero, indexes will be zero&#160;or positive, and so a negative value like&#160;-1&#160;is&#160;<br/>convenient for signaling failure. When we later need more sophisticated pattern matching, we&#160;<br/>only have to replace&#160;strindex; the rest of the code can remain the same. (The standard&#160;<br/>library provides a function&#160;strstr&#160;that is similar to&#160;strindex, except that it returns a pointer&#160;<br/>instead of an index.) &#160;<br/>
Given this much design, filling in the details of&#160;the program&#160;is straightforward. Here is the&#160;<br/>whole thing, so you can see how the pieces fit together. For now, the pattern to be searched&#160;<br/>for is a literal string, which is not the most general of&#160;mechanisms. We will return shortly to a&#160;<br/>discussion of&#160;how to initialize character arrays, and in&#160;<a href="">Chapter 5</a>&#160;will show how to make the&#160;<br/>pattern a parameter that is set when the program&#160;is run. There is also a slightly different&#160;<br/>version of&#160;getline; you might find it instructive to comp<a href="">are it to the one in&#160;Chapter 1. &#160;</a><br/>
&#160;<br/>&#160; &#160;#include &lt;stdio.h&gt;&#160;<br/>&#160; &#160;#define MAXLINE 1000 /* maximum input line length */&#160;<br/>&#160;<br/>&#160; &#160;int getline(char line[], int max)&#160;<br/>&#160; &#160;int strindex(char source[], char searchfor[]);&#160;<br/>&#160;<br/>&#160; &#160;char pattern[] = &#34;ould&#34;; &#160; /* pattern to search for */&#160;<br/>&#160;<br/>&#160; &#160;/* find all lines matching pattern */&#160;<br/>&#160; &#160;main()&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;char line[MAXLINE];&#160;<br/>&#160; &#160; &#160; &#160;int found = 0;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;while (getline(line, MAXLINE) &gt; 0)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;if (strindex(line, pattern) &gt;= 0) {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;printf(&#34;%s&#34;, line);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;found++;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160; &#160; &#160;return found;&#160;<br/>&#160; &#160;}&#160;<br/>&#160;<br/>&#160; &#160;/* getline: &#160;get line into s, return length */&#160;<br/>&#160; &#160;int getline(char s[], int lim)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int c, i;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;i = 0;&#160;<br/>&#160; &#160; &#160; &#160;while (--lim &gt; 0 &amp;&amp; (c=getchar()) != EOF &amp;&amp; c != '\n')&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;s[i++] = c;&#160;<br/>&#160; &#160; &#160; &#160;if (c == '\n')&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;s[i++] = c;&#160;<br/>
<hr/>
<a name=64></a>&#160;&#160;<br/>
64&#160;<br/>
&#160; &#160; &#160; &#160;s[i] = '\0';&#160;<br/>&#160; &#160; &#160; &#160;return i;&#160;<br/>&#160; &#160;}&#160;<br/>&#160;<br/>&#160; &#160;/* strindex: &#160;return index of t in s, -1 if none */&#160;<br/>&#160; &#160;int strindex(char s[], char t[])&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int i, j, k;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;for (i = 0; s[i] != '\0'; i++) {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;for (j=i, k=0; t[k]!='\0' &amp;&amp; s[j]==t[k]; j++, k++)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;if (k &gt; 0 &amp;&amp; t[k] == '\0')&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;return i;&#160;<br/>&#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160; &#160; &#160;return -1;&#160;<br/>&#160; &#160;}&#160;<br/>
Each function definition has the form&#160;&#160;<br/>&#160;<br/><i>return-type function-name</i>(<i>argument declarations</i>)&#160;<br/>{&#160;<br/>&#160; &#160;&#160;<i>declarations and statements</i>&#160;<br/>}&#160;<br/>
Various parts may be absent; a minimal function is &#160;<br/>&#160;<br/>&#160; &#160;dummy() {}&#160;<br/>
which does nothing and returns nothing. A do-nothing function like this is sometimes useful&#160;<br/>as a place holder during program&#160;development. If the return type is omitted,&#160;int&#160;is assumed. &#160;<br/>
A program&#160;is just a set of definitions of variables and functions. Communication between the&#160;<br/>functions is by arguments and values returned by the functions, and through external&#160;<br/>variables. The functions can occur in any order in the source file, and the source program&#160;can&#160;<br/>be split into multiple files, so long as no function is split. &#160;<br/>
The&#160;return&#160;statement is the mechanism&#160;for returning a value from&#160;the called function to its&#160;<br/>caller. Any expression can follow&#160;return: &#160;<br/>
&#160;<br/>&#160; &#160;return&#160;<i>expression</i>;&#160;<br/>
The&#160;<i>expression</i>&#160;will be converted to the return type&#160;of the function if necessary. Parentheses&#160;<br/>are often used around the&#160;<i>expression</i>, but they are optional. &#160;<br/>
The calling function is free to ignore the returned&#160;value. Furthermore, there need to be no&#160;<br/>expression after&#160;return; in that case, no value is returned to&#160;the caller. Control also returns to&#160;<br/>the caller with no value when execution ``falls&#160;off the end''&#160;of the function by reaching the&#160;<br/>closing right brace. It is not illegal, but probably a sign of trouble, if a function returns a value&#160;<br/>from&#160;one place and no value from&#160;another. In any case, if a function fails to return a value, its&#160;<br/>``value''&#160;is certain to be garbage. &#160;<br/>
The pattern-searching program&#160;returns a status from&#160;main, the number of matches found. This&#160;<br/>value is available for use by the environment that called the program&#160;&#160;<br/>
The mechanics of&#160;how to compile and load a&#160;C program&#160;that resides on multiple source files&#160;<br/>vary from&#160;one system&#160;to the next.&#160;On the UNIX system, for example, the&#160;cc&#160;command&#160;<br/>mentioned in&#160;<a href="">Chapter 1&#160;does the job. Suppose that the three functions are stored in three files&#160;<br/></a>called&#160;main.c,&#160;getline.c, and&#160;strindex.c. Then the command &#160;<br/>
<hr/>
<a name=65></a>&#160;&#160;<br/>
65&#160;<br/>
&#160;<br/>&#160; &#160;cc main.c getline.c strindex.c&#160;<br/>
compiles the three files, placing the resulting object code in files&#160;main.o,&#160;&#160;getline.o, and&#160;<br/>strindex.o, then loads them&#160;all into an executable file called&#160;a.out. If there is an error, say&#160;<br/>in&#160;main.c, the file can be recompiled by itself&#160;and the result loaded with the previous object&#160;<br/>files, with the command &#160;<br/>&#160;<br/>&#160; &#160;cc main.c getline.o strindex.o&#160;<br/>
The&#160;&#160;cc&#160;command uses the ``.c'' versus ``.o'' naming convention to distinguish source files&#160;<br/>from&#160;object files. &#160;<br/>
<b>Exercise 4-1.</b>&#160;Write the function&#160;strindex(s,t)&#160;which returns the position of&#160;the&#160;<i>rightmost</i>&#160;<br/>occurrence of&#160;t&#160;in&#160;s, or&#160;-1&#160;if there is none. &#160;<br/>
<b>4.2 Functions Returning Non-integers&#160;</b><br/>
So far our examples of functions have returned either no value (void) or an&#160;int. What if a&#160;<br/>function must return some other type?&#160;many numerical functions like&#160;sqrt,&#160;&#160;sin, and&#160;cos&#160;<br/>return&#160;&#160;double; other specialized functions return other&#160;types. To illustrate how to deal with&#160;<br/>this, let us write and use the function&#160;atof(s), which converts the string&#160;s&#160;to its double-<br/>precision floating-point equivalent.&#160;atof&#160;if an extension of&#160;atoi, which we showed versions&#160;<br/><a href="">of in&#160;Chapters 2&#160;and&#160;3. It handles an optional sign and&#160;</a>decimal point, and the presence or&#160;<br/>absence of either part or fractional part. Our version is&#160;<i>not</i>&#160;a high-quality input conversion&#160;<br/>routine; that would take more space than we&#160;care to use. The standard library includes an&#160;<br/>atof; the header&#160;&lt;stdlib.h&gt;&#160;declares it. &#160;<br/>
First,&#160;atof&#160;itself&#160;must declare the type of&#160;value it returns, since it is not&#160;int. The type name&#160;<br/>precedes the function name: &#160;<br/>
&#160;<br/>&#160; &#160;#include &lt;ctype.h&gt;&#160;<br/>&#160;<br/>&#160; &#160;/* atof: &#160;convert string s to double */&#160;<br/>&#160; &#160;double atof(char s[])&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;double val, power;&#160;<br/>&#160; &#160; &#160; &#160;int i, sign;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;for (i = 0; isspace(s[i]); i++) &#160;/* skip white space */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;;&#160;<br/>&#160; &#160; &#160; &#160;sign = (s[i] == '-') ? -1 : 1;&#160;<br/>&#160; &#160; &#160; &#160;if (s[i] == '+' || s[i] == '-')&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;i++;&#160;<br/>&#160; &#160; &#160; &#160;for (val = 0.0; isdigit(s[i]); i++)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;val = 10.0 * val + (s[i] - '0');&#160;<br/>&#160; &#160; &#160; &#160;if (s[i] == '.')&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;i++;&#160;<br/>&#160; &#160; &#160; &#160;for (power = 1.0; isdigit(s[i]); i++) {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;val = 10.0 * val + (s[i] - '0');&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;power *= 10;&#160;<br/>&#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160; &#160; &#160;return sign * val / power;&#160;<br/>&#160; &#160;}&#160;<br/>
Second, and just as important, the calling routine must know that&#160;atof&#160;returns a non-int value.&#160;<br/>One way to ensure this is to declare&#160;atof&#160;explicitly in the calling routine. The declaration is&#160;<br/>shown in this primitive calculator (barely adequate for check-book balancing), which reads&#160;<br/>
<hr/>
<a name=66></a>&#160;&#160;<br/>
66&#160;<br/>
one number per line, optionally preceded with a&#160;sign, and adds them&#160;up, printing the running&#160;<br/>sum&#160;after each input: &#160;<br/>&#160;<br/>&#160; &#160;#include &lt;stdio.h&gt;&#160;<br/>&#160;<br/>&#160; &#160;#define MAXLINE 100&#160;<br/>&#160;<br/>&#160; &#160;/* rudimentary calculator */&#160;<br/>&#160; &#160;main()&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;double sum, atof(char []);&#160;<br/>&#160; &#160; &#160; &#160;char line[MAXLINE];&#160;<br/>&#160; &#160; &#160; &#160;int getline(char line[], int max);&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;sum = 0;&#160;<br/>&#160; &#160; &#160; &#160;while (getline(line, MAXLINE) &gt; 0)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;printf(&#34;\t%g\n&#34;, sum += atof(line));&#160;<br/>&#160; &#160; &#160; &#160;return 0;&#160;<br/>&#160; &#160;}&#160;<br/>
The declaration &#160;<br/>&#160;<br/>&#160; &#160;double sum, atof(char []);&#160;<br/>
says that&#160;sum&#160;is a&#160;double&#160;variable, and that&#160;atof&#160;is a function that takes one&#160;char[]&#160;argument&#160;<br/>and returns a&#160;double. &#160;<br/>
The function&#160;atof&#160;must be declared and defined consistently. If&#160;atof&#160;itself&#160;and the call to it in&#160;<br/>main&#160;have inconsistent types in the same source file, the error will be detected by the&#160;<br/>compiler. But if&#160;(as is more likely)&#160;atof&#160;were compiled separately, the mismatch would not&#160;<br/>be detected,&#160;atof&#160;would return a&#160;double&#160;that&#160;main&#160;would treat as an&#160;int, and meaningless&#160;<br/>answers would result. &#160;<br/>
In the light of what we have said about how&#160;declarations must match definitions, this might&#160;<br/>seem&#160;surprising. The reason a mismatch can happen is that if&#160;there is&#160;no function prototype, a&#160;<br/>function is implicitly declared by its first appearance in an expression, such as &#160;<br/>
&#160;<br/>&#160; &#160;sum += atof(line)&#160;<br/>
If a name that has not been previously declared occurs in an expression and is followed by a&#160;<br/>left parentheses, it is declared by context to&#160;be a function name, the function is assumed to&#160;<br/>return an&#160;int, and nothing is assumed about its arguments. Furthermore, if a function&#160;<br/>declaration does not include arguments, as in &#160;<br/>&#160;<br/>&#160; &#160;double atof();&#160;<br/>
that too is taken to mean that nothing is&#160;to be assumed about the arguments of&#160;atof; all&#160;<br/>parameter checking is turned off.&#160;This special meaning of&#160;the empty argument list is intended&#160;<br/>to permit older C programs to compile with new compilers. But it's a bad idea to use it with&#160;<br/>new C programs. If the function takes arguments, declare them; if it takes no arguments, use&#160;<br/>void. &#160;<br/>
Given&#160;atof, properly declared, we could write&#160;atoi&#160;(convert a string to&#160;int) in terms of&#160;it: &#160;<br/>
&#160;<br/>&#160; &#160;/* atoi: &#160;convert string s to integer using atof */&#160;<br/>&#160; &#160;int atoi(char s[])&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;double atof(char s[]);&#160;<br/>&#160;<br/>
<hr/>
<a name=67></a>&#160;&#160;<br/>
67&#160;<br/>
&#160; &#160; &#160; &#160;return (int) atof(s);&#160;<br/>&#160; &#160;}&#160;<br/>
Notice the structure of the declarations and the return statement. The value of the expression&#160;<br/>in &#160;<br/>&#160;<br/>&#160; &#160;return&#160;<i>expression</i>;&#160;<br/>
is converted to the type of the function before&#160;the return is taken. Therefore, the value of&#160;<br/>atof, a&#160;double, is converted automatically to&#160;int&#160;when it appears in this&#160;return, since the&#160;<br/>function&#160;atoi&#160;returns an&#160;int. This operation does potentionally&#160;discard information, however,&#160;<br/>so some compilers warn of&#160;it. The cast states&#160;explicitly that the operation is intended, and&#160;<br/>suppresses any warning. &#160;<br/>
<b>Exercise 4-2.</b>&#160;Extend&#160;atof&#160;to handle scientific notation of the form&#160;&#160;<br/>
&#160;<br/>&#160; &#160;123.45e-6&#160;<br/>
where a floating-point number may be followed by&#160;e&#160;or&#160;E&#160;and an optionally signed exponent. &#160;<br/>
<b>4.3 External Variables&#160;</b><br/>
A C program&#160;consists of a set of external objects, which are either variables or functions. The&#160;<br/>adjective ``external''&#160;is used in contrast to&#160;``internal'', which describes the arguments and&#160;<br/>variables defined inside functions. External variables are defined outside of any function, and&#160;<br/>are thus potentionally available to many functions. Functions themselves are always external,&#160;<br/>because C does not allow functions to be defined&#160;inside other functions. By default, external&#160;<br/>variables and functions have the property that all references to them&#160;by the same name, even&#160;<br/>from&#160;functions compiled separately, are references&#160;to the same thing. (The standard calls this&#160;<br/>property&#160;&#160;<i>external linkage</i>.) In this sense, external variables are analogous to Fortran&#160;<br/>COMMON blocks or variables in the outermost&#160;block in Pascal. We will see later how to&#160;<br/>define external variables and functions that&#160;are visible only within a single source file.&#160;<br/>Because external variables are globally accessible, they provide an alternative to function&#160;<br/>arguments and return values for communicating data between functions. Any function may&#160;<br/>access an external variable by referring to it by name, if the name has been declared&#160;<br/>somehow. &#160;<br/>
If a large number of variables must be shared&#160;among functions, external variables are more&#160;<br/>convenient and efficient than long&#160;argum<a href="">ent lists. As pointed out in&#160;Chapter 1, however, this&#160;<br/></a>reasoning should be applied with some caution,&#160;for it can have a bad effect on program&#160;<br/>structure, and lead to programs with too many data connections between functions. &#160;<br/>
External variables are also useful because of&#160;their greater scope and lifetime. Automatic&#160;<br/>variables are internal to a function; they come&#160;into existence when the function is entered, and&#160;<br/>disappear when it is left. External variables,&#160;on the other hand, are permanent, so they can&#160;<br/>retain values from&#160;one function invocation to the next. Thus if two functions must share some&#160;<br/>data, yet neither calls the other, it is often most convenient if the shared data is kept in&#160;<br/>external variables rather than being passed in and out via arguments. &#160;<br/>
Let us examine this issue with a larger example. The problem&#160;is to write a calculator program&#160;<br/>that provides the operators&#160;+,&#160;-,&#160;*&#160;and&#160;/. Because it is easier to implement, the calculator will&#160;<br/>use reverse Polish notation instead of infix. (Reverse Polish notation is used by some pocket&#160;<br/>calculators, and in languages like Forth and Postscript.) &#160;<br/>
In reverse Polish notation, each operator follows its operands; an infix expression like &#160;<br/>
<hr/>
<a name=68></a>&#160;&#160;<br/>
68&#160;<br/>
&#160;<br/>&#160; &#160;(1 - 2) * (4 + 5)&#160;<br/>
is entered as &#160;<br/>&#160;<br/>&#160; &#160;1 2 - 4 5 + *&#160;<br/>
Parentheses are not needed; the notation is&#160;unambiguous as long as we know how many&#160;<br/>operands each operator expects. &#160;<br/>
The implementation is simple. Each operand is pushed onto a stack; when an operator arrives,&#160;<br/>the proper number of operands (two for binary operators) is popped, the operator is applied to&#160;<br/>them, and the result is pushed back onto the stack. In the example above, for instance, 1 and 2&#160;<br/>are pushed, then replaced by their difference,&#160;-1. Next, 4 and 5 are pushed and then replaced&#160;<br/>by their sum,&#160;9. The product of -1 and 9, which is -9, replaces them&#160;on the stack. The value on&#160;<br/>the top of the stack is popped and printed when the end of the input line is encountered. &#160;<br/>
The structure of the program&#160;is thus a loop that performs the proper operation on each&#160;<br/>operator and operand as it appears: &#160;<br/>
&#160;<br/>&#160; &#160;while (<i>next operator or operand is not end-of-file indicator</i>)&#160;<br/>&#160; &#160; &#160; &#160;if (<i>number</i>)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;<i>push it</i>&#160;<br/>&#160; &#160; &#160; &#160;else if (<i>operator</i>)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;<i>pop operands</i>&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;<i>do operation</i>&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;<i>push result</i>&#160;<br/>&#160; &#160; &#160; &#160;else if (<i>newline</i>)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;<i>pop and print top of stack</i>&#160;<br/>&#160; &#160; &#160; &#160;else&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;<i>error</i>&#160;<br/>
The operation of pushing and popping a stack are trivial, but by the time error detection and&#160;<br/>recovery are added, they are long enough that it&#160;is better to put each in a separate function&#160;<br/>than to repeat the code throughout the whole program. And there should be a separate&#160;<br/>function for fetching the next input operator or operand. &#160;<br/>
The main design decision that has not yet been discussed is where the stack is, that is, which&#160;<br/>routines access it directly. On&#160;possibility is to keep it in&#160;main, and pass the stack and the&#160;<br/>current stack position to the routines that push and pop it. But&#160;main&#160;doesn't need to know&#160;<br/>about the variables that control the stack;&#160;it only does push and pop operations. So we have&#160;<br/>decided to store the stack and its associated information in external variables accessible to the&#160;<br/>push&#160;and&#160;pop&#160;functions but not to&#160;main. &#160;<br/>
Translating this outline into code is easy enough. If for now we think of the program&#160;as&#160;<br/>existing in one source file, it will look like this: &#160;<br/>
&#160; &#160;&#160;#include<i>s</i>&#160;<br/>&#160; &#160;&#160;#define<i>s</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>function declarations for</i>&#160;main&#160;&#160;<br/>
&#160; &#160;&#160;main() { ... }&#160;&#160;<br/>
&#160; &#160;&#160;<i>external variables for</i>&#160;push&#160;<i>and</i>&#160;pop&#160;&#160;<br/>
&#160;<br/>
<hr/>
<a name=69></a>&#160;&#160;<br/>
69&#160;<br/>
&#160; &#160;void push( double f) { ... }&#160;<br/>&#160; &#160;double pop(void) { ... }&#160;<br/>&#160;<br/>&#160; &#160;int getop(char s[]) { ... }&#160;<br/>
&#160; &#160;&#160;<i>routines called by</i>&#160;getop&#160;&#160;<br/>
<a href="">Later we will discuss how this might be split into two or more source files. &#160;</a><br/>
The function&#160;main&#160;is a loop containing a big&#160;switch&#160;on the type of operator or operand; this is&#160;<br/>a more typical use of&#160;switch&#160;than the one shown in&#160;Section 3.4. &#160;<br/>
&#160;<br/>&#160; &#160;#include &lt;stdio.h&gt;&#160;<br/>&#160; &#160;#include &lt;stdlib.h&gt; &#160;/* for &#160;atof() */&#160;<br/>&#160;<br/>&#160; &#160;#define MAXOP &#160; 100 &#160;/* max size of operand or operator */&#160;<br/>&#160; &#160;#define NUMBER &#160;'0' &#160;/* signal that a number was found */&#160;<br/>&#160;<br/>&#160; &#160;int getop(char []);&#160;<br/>&#160; &#160;void push(double);&#160;<br/>&#160; &#160;double pop(void);&#160;<br/>&#160;<br/>&#160; &#160;/* reverse Polish calculator */&#160;<br/>&#160; &#160;main()&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int type;&#160;<br/>&#160; &#160; &#160; &#160;double op2;&#160;<br/>&#160; &#160; &#160; &#160;char s[MAXOP];&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;while ((type = getop(s)) != EOF) {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;switch (type) {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;case NUMBER:&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;push(atof(s));&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;break;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;case '+':&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;push(pop() + pop());&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;break;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;case '*':&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;push(pop() * pop());&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;break;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;case '-':&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;op2 = pop();&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;push(pop() - op2);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;break;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;case '/':&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;op2 = pop();&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;if (op2 != 0.0)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;push(pop() / op2);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;else&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;printf(&#34;error: zero divisor\n&#34;);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;break;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;case '\n':&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;printf(&#34;\t%.8g\n&#34;, pop());&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;break;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;default:&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;printf(&#34;error: unknown command %s\n&#34;, s);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;break;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160; &#160; &#160;return 0;&#160;<br/>&#160; &#160;}&#160;<br/>
<hr/>
<a name=70></a>&#160;&#160;<br/>
70&#160;<br/>
Because&#160;&#160;+&#160;and&#160;*&#160;are commutative operators, the order in which the popped operands are&#160;<br/>combined is irrelevant, but for&#160;-&#160;and&#160;/&#160;the left and right operand must be distinguished. In &#160;<br/>&#160;<br/>&#160; &#160;push(pop() - pop()); &#160; /* WRONG */&#160;<br/>
the order in which the two calls of&#160;pop&#160;are evaluated is not defined. To guarantee the right&#160;<br/>order, it is necessary to pop the first value into a temporary variable as we did in&#160;main. &#160;<br/>&#160;<br/>&#160; &#160;#define MAXVAL &#160;100 &#160;/* maximum depth of val stack */&#160;<br/>&#160;<br/>&#160; &#160;int sp = 0; &#160; &#160; &#160; &#160; &#160;/* next free stack position */&#160;<br/>&#160; &#160;double val[MAXVAL]; &#160;/* value stack */&#160;<br/>&#160;<br/>&#160; &#160;/* push: &#160;push f onto value stack */&#160;<br/>&#160; &#160;void push(double f)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;if (sp &lt; MAXVAL)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;val[sp++] = f;&#160;<br/>&#160; &#160; &#160; &#160;else&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;printf(&#34;error: stack full, can't push %g\n&#34;, f);&#160;<br/>&#160; &#160;}&#160;<br/>&#160;<br/>&#160; &#160;/* pop: &#160;pop and return top value from stack */&#160;<br/>&#160; &#160;double pop(void)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;if (sp &gt; 0)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;return val[--sp];&#160;<br/>&#160; &#160; &#160; &#160;else {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;printf(&#34;error: stack empty\n&#34;);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;return 0.0;&#160;<br/>&#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160;}&#160;<br/>
A variable is external if&#160;it is defined outside&#160;of any function. Thus the stack and stack index&#160;<br/>that must be shared by&#160;push&#160;and&#160;pop&#160;are defined outside these functions. But&#160;main&#160;itself&#160;does&#160;<br/>not refer to the stack or stack position - the representation can be hidden. &#160;<br/>
Let us now turn to the implementation of&#160;getop, the function that fetches the next operator or&#160;<br/>operand. The task is easy. Skip blanks and tabs. If the next character is not a digit or a&#160;<br/>hexadecimal point, return it. Otherwise, collect&#160;a string of digits (which might include a&#160;<br/>decimal point), and return&#160;NUMBER, the signal that a number has been collected. &#160;<br/>
&#160;<br/>&#160; &#160;#include &lt;ctype.h&gt;&#160;<br/>&#160;<br/>&#160; &#160;int getch(void);&#160;<br/>&#160; &#160;void ungetch(int);&#160;<br/>&#160;<br/>&#160; &#160;/* getop: &#160;get next character or numeric operand */&#160;<br/>&#160; &#160;int getop(char s[])&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int i, c;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;while ((s[0] = c = getch()) == ' ' || c == '\t')&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;;&#160;<br/>&#160; &#160; &#160; &#160;s[1] = '\0';&#160;<br/>&#160; &#160; &#160; &#160;if (!isdigit(c) &amp;&amp; c != '.')&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;return c; &#160; &#160; &#160;/* not a number */&#160;<br/>&#160; &#160; &#160; &#160;i = 0;&#160;<br/>&#160; &#160; &#160; &#160;if (isdigit(c)) &#160; &#160;/* collect integer part */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;while (isdigit(s[++i] = c = getch()))&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; ;&#160;<br/>&#160; &#160; &#160; &#160;if (c == '.') &#160; &#160; &#160;/* collect fraction part */&#160;<br/>
<hr/>
<a name=71></a>&#160;&#160;<br/>
71&#160;<br/>
&#160; &#160; &#160; &#160; &#160; &#160;while (isdigit(s[++i] = c = getch()))&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; ;&#160;<br/>&#160; &#160; &#160; &#160;s[i] = '\0';&#160;<br/>&#160; &#160; &#160; &#160;if (c != EOF)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;ungetch(c);&#160;<br/>&#160; &#160; &#160; &#160;return NUMBER;&#160;<br/>&#160; &#160;}&#160;<br/>
What are&#160;getch&#160;and&#160;ungetch?&#160;It is often the case that a program&#160;cannot determine that it has&#160;<br/>read enough input until it has read too much. One&#160;instance is collecting characters that make&#160;<br/>up a number: until the first non-digit is seen,&#160;the number is not complete. But then the&#160;<br/>program&#160;has read one character too far, a character that it is not prepared for. &#160;<br/>
The problem&#160;would be solved if it were possible to ``un-read''&#160;the unwanted character. Then,&#160;<br/>every time the program&#160;reads one character too many, it could push it back on the input, so&#160;<br/>the rest of the code could behave as if it had&#160;never been read. Fortunately, it's easy to simulate&#160;<br/>un-getting a character, by writing a&#160;pair of cooperating functions.&#160;getch&#160;delivers the next&#160;<br/>input character to be considered;&#160;ungetch&#160;will return them&#160;before reading new input. &#160;<br/>
How they work together is simple.&#160;ungetch&#160;puts the pushed-back characters into a shared&#160;<br/>buffer -- a character array.&#160;getch&#160;reads from&#160;the buffer if there is anything else, and calls&#160;<br/>getchar&#160;if the buffer is empty. There must also be&#160;an index variable that records the position&#160;<br/>of the current character in the buffer. &#160;<br/>
Since the buffer and the index are shared by&#160;getch&#160;and&#160;ungetch&#160;and must retain their values&#160;<br/>between calls, they must be external&#160;to both routines. Thus we can write&#160;getch,&#160;ungetch, and&#160;<br/>their shared variables as: &#160;<br/>
&#160;<br/>&#160; &#160;#define BUFSIZE 100&#160;<br/>&#160;<br/>&#160; &#160;char buf[BUFSIZE]; &#160; &#160;/* buffer for ungetch */&#160;<br/>&#160; &#160;int bufp = 0; &#160; &#160; &#160; &#160; /* next free position in buf */&#160;<br/>&#160;<br/>&#160; &#160;int getch(void) &#160;/* get a (possibly pushed-back) character */&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;return (bufp &gt; 0) ? buf[--bufp] : getchar();&#160;<br/>&#160; &#160;}&#160;<br/>&#160;<br/>&#160; &#160;void ungetch(int c) &#160; /* push character back on input */&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;if (bufp &gt;= BUFSIZE)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;printf(&#34;ungetch: too many characters\n&#34;);&#160;<br/>&#160; &#160; &#160; &#160;else&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;buf[bufp++] = c;&#160;<br/>&#160; &#160;}&#160;<br/>
The standard library includes a function&#160;ungetch&#160;that provides one character of pushback; we&#160;<br/><a href="">will discuss it in&#160;Chapter 7</a>. We have used an array for the pushback, rather than a single&#160;<br/>character, to illustrate a more general approach. &#160;<br/>
<b>Exercise 4-3.</b>&#160;Given the basic framework, it's straightforward to extend the calculator. Add&#160;<br/>the modulus (%) operator and provisions for negative numbers. &#160;<br/>
<b>Exercise 4-4.</b>&#160;Add the commands to print the top elements of the stack without popping, to&#160;<br/>duplicate it, and to swap the top two elements. Add a command to clear the stack. &#160;<br/>
<hr/>
<a name=72></a>&#160;&#160;<br/>
72&#160;<br/>
<b>Exercise 4-5.</b>&#160;Add access to library functions like&#160;sin,&#160;&#160;exp, and&#160;pow. See &lt;math.h&gt; in&#160;<br/><a href="">Appendix B, Section 4</a>. &#160;<br/>
<b>Exercise 4-6.</b>&#160;Add commands for handling variables. (It's&#160;easy to provide twenty-six variables&#160;<br/>with single-letter names.) Add a variable for the most recently printed value. &#160;<br/>
<b>Exercise 4-7.</b>&#160;Write a routine&#160;ungets(s)&#160;that will push back an&#160;entire string onto the input.&#160;<br/>Should&#160;ungets&#160;know about&#160;buf&#160;and&#160;bufp, or should it just use&#160;ungetch? &#160;<br/>
<b>Exercise 4-8.</b>&#160;Suppose that there will never be more than one character of pushback. Modify&#160;<br/>getch&#160;and&#160;ungetch&#160;accordingly. &#160;<br/>
<b>Exercise 4-9.</b>&#160;Our&#160;getch&#160;and&#160;ungetch&#160;do not handle a pushed-back&#160;EOF&#160;correctly. Decide&#160;<br/>what their properties ought to be if an&#160;EOF&#160;is pushed back, then implement your design. &#160;<br/>
<b>Exercise 4-10.</b>&#160;An alternate organization uses&#160;getline&#160;to read an entire input line; this makes&#160;<br/>getch&#160;and&#160;ungetch&#160;unnecessary. Revise the calculator to use this approach. &#160;<br/>
<b>4.4 Scope Rules&#160;</b><br/>
The functions and external variables that make&#160;up a C program&#160;need not all be compiled at the&#160;<br/>same time; the source text of the program&#160;may&#160;be kept in several files, and previously&#160;<br/>compiled routines may be loaded from&#160;libraries. Among the questions of interest are &#160;<br/>
•&#160;&#160;How are declarations written so that&#160;variables are properly declared during&#160;<br/>
compilation? &#160;<br/>
•&#160;&#160;How are declarations arranged so that all&#160;the pieces will be properly connected when&#160;<br/>
the program&#160;is loaded? &#160;<br/>
•&#160;&#160;How are declarations organized so there is only one copy?&#160;&#160;<br/>•&#160;&#160;How are external variables initialized? &#160;<br/>
Let us discuss these topics by reorganizing the&#160;calculator program&#160;into several files. As a&#160;<br/>practical matter, the calculator is too small to&#160;be worth splitting, but it is a fine illustration of&#160;<br/>the issues that arise in larger programs. &#160;<br/>
The&#160;&#160;<i>scope</i>&#160;of a name is the part of the program&#160;within which the name can be used. For an&#160;<br/>automatic variable declared at the beginning of&#160;a function, the scope is the function in which&#160;<br/>the name is declared. Local variables of the same name in different functions are unrelated.&#160;<br/>The same is true of&#160;the parameters of&#160;the function, which are in effect local variables. &#160;<br/>
The scope of an external variable or a function&#160;lasts from&#160;the point at which it is declared to&#160;<br/>the end of the file being compiled. For example, if&#160;main,&#160;sp,&#160;val,&#160;push, and&#160;pop&#160;are defined&#160;<br/>in one file, in the order shown above, that is, &#160;<br/>
&#160;<br/>&#160; &#160;main() { ... }&#160;<br/>&#160;<br/>&#160; &#160;int sp = 0;&#160;<br/>&#160; &#160;double val[MAXVAL];&#160;<br/>&#160;<br/>&#160; &#160;void push(double f) { ... }&#160;<br/>&#160;<br/>&#160; &#160;double pop(void) { ... }&#160;<br/>
<hr/>
<a name=73></a>&#160;&#160;<br/>
73&#160;<br/>
then the variables&#160;sp&#160;and&#160;val&#160;may be used in&#160;push&#160;and&#160;pop&#160;simply by naming them; no&#160;<br/>further declarations are needed. But these names are not visible in&#160;main, nor are&#160;push&#160;and&#160;pop&#160;<br/>themselves. &#160;<br/>
On the other hand, if&#160;an external variable is to&#160;be referred to before it is defined, or if it is&#160;<br/>defined in a different source file from&#160;the one where it is being used, then an&#160;extern&#160;<br/>declaration is mandatory. &#160;<br/>
It is important to distinguish between the&#160;<i>declaration</i>&#160;of an external variable and its&#160;<i>definition</i>.&#160;<br/>A declaration announces the properties of a variable (primarily its type); a definition also&#160;<br/>causes storage to be set aside. If the lines &#160;<br/>
&#160;<br/>&#160; &#160;int sp;&#160;<br/>&#160; &#160;double val[MAXVAL];&#160;<br/>
appear outside of any function, they&#160;<i>define</i>&#160;the external variables&#160;sp&#160;and&#160;val, cause storage to&#160;<br/>be set aside, and also serve as the declarations&#160;for the rest of&#160;that source file. On the other&#160;<br/>hand, the lines &#160;<br/>&#160;<br/>&#160; &#160;extern int sp;&#160;<br/>&#160; &#160;extern double val[];&#160;<br/>
<i>declare</i>&#160;for the rest of&#160;the source file that&#160;sp&#160;is an&#160;int&#160;and that&#160;val&#160;is a&#160;double&#160;array (whose&#160;<br/>size is determined elsewhere), but they do not create the variables or reserve storage for them. &#160;<br/>
There must be only one&#160;<i>definition</i>&#160;of an external variable among all the files that make up the&#160;<br/>source program; other files may contain&#160;extern&#160;declarations to access it. (There may also be&#160;<br/>extern&#160;declarations in the file containing the definition.) Array sizes must be specified with&#160;<br/>the definition, but are optional with an&#160;extern&#160;declaration. &#160;<br/>
Initialization of&#160;an external variable goes only with the definition. &#160;<br/>
Although it is not a likely organization for this program, the functions&#160;push&#160;and&#160;pop&#160;could be&#160;<br/>defined in one file, and the variables&#160;val&#160;and&#160;sp&#160;defined and initialized in another. Then these&#160;<br/>definitions and declarations would be necessary to tie them&#160;together: &#160;<br/>
&#160;&#160;<i>in file1</i>: &#160;<br/>
&#160;<br/>&#160; &#160; &#160; extern int sp;&#160;<br/>&#160; &#160; &#160; extern double val[];&#160;<br/>&#160;<br/>&#160; &#160; &#160; void push(double f) { ... }&#160;<br/>&#160;<br/>&#160; &#160; &#160; double pop(void) { ... }&#160;<br/>
&#160;&#160;<i>in file2</i>: &#160;<br/>&#160;<br/>&#160; &#160; &#160; int sp = 0;&#160;<br/>&#160; &#160; &#160; double val[MAXVAL];&#160;<br/>
Because the&#160;extern&#160;declarations in&#160;<i>file1</i>&#160;lie ahead of and outside the function definitions, they&#160;<br/>apply to all functions; one set of declarations suffices for all of&#160;<i>file1</i>. This same organization&#160;<br/>would also bee needed if the definition of&#160;sp&#160;and&#160;val&#160;followed their use in one file. &#160;<br/>
<b>4.5 Header Files&#160;</b><br/>
<hr/>
<a name=74></a><img src="c-74_1.png"/><br/>
74<br/>
Let is now consider dividing the calculator program&#160;into several source files, as it might be is&#160;<br/>each of the components were substantially bigger. The&#160;main&#160;function would go in one file,&#160;<br/>which we will call&#160;main.c;&#160;&#160;push,&#160;&#160;pop, and their variables go into a second file,&#160;stack.c;&#160;<br/>getop&#160;goes into a third,&#160;getop.c. Finally,&#160;getch&#160;and&#160;ungetch&#160;go into a fourth file,&#160;getch.c;&#160;<br/>we separate them&#160;from&#160;the others because&#160;they would come from&#160;a separately-compiled&#160;<br/>library in a realistic program. &#160;<br/>
There is one more thing to worry about - the definitions and declarations shared among files.&#160;<br/>As much as possible, we want to centralize this, so that there is only one copy to get and keep&#160;<br/>right as the program&#160;evolves. Accordingly, we will place this common material in a&#160;<i>header&#160;<br/>file</i>,&#160;calc.h, which will be included as necessary. (The&#160;#include&#160;line is described in&#160;<a href="cs.html#79">Section&#160;<br/>4.11.) The resulting program</a>&#160;then looks like this: &#160;<br/>
There is a tradeoff between the desire that&#160;each file have access only to the information it&#160;<br/>needs for its job and the practical reality that it is&#160;harder to maintain more header files. Up to&#160;<br/>some moderate program&#160;size, it is probably best&#160;to have one header file that contains&#160;<br/>
<hr/>
<a name=75></a>&#160;&#160;<br/>
75&#160;<br/>
everything that is to be shared between any two parts of the program; that is the decision we&#160;<br/>made here. For a much larger program, more organization and more headers would be needed. &#160;<br/>
<b>4.6 Static Variables&#160;</b><br/>
The variables&#160;sp&#160;and&#160;val&#160;in&#160;stack.c, and&#160;buf&#160;and&#160;bufp&#160;in&#160;getch.c, are for the private use of&#160;<br/>the functions in their respective source files,&#160;and are not meant to be accessed by anything&#160;<br/>else. The&#160;static&#160;declaration, applied to an external variable or function, limits the scope of&#160;<br/>that object to the rest of&#160;the source file being compiled. External&#160;static&#160;thus provides a way&#160;<br/>to hide names like&#160;buf&#160;and&#160;bufp&#160;in the&#160;getch-ungetch&#160;combination, which must be external&#160;<br/>so they can be shared, yet which should not be visible to users of&#160;getch&#160;and&#160;ungetch. &#160;<br/>
Static storage is specified by prefixing the normal declaration with the word&#160;static. If the&#160;<br/>two routines and the two variables are compiled in one file, as in &#160;<br/>
&#160;<br/>&#160; &#160;static char buf[BUFSIZE]; &#160;/* buffer for ungetch */&#160;<br/>&#160; &#160;static int bufp = 0; &#160; &#160; &#160; /* next free position in buf */&#160;<br/>&#160;<br/>&#160; &#160;int getch(void) { ... }&#160;<br/>&#160;<br/>&#160; &#160;void ungetch(int c) { ... }&#160;<br/>
then no other routine will be able to access&#160;buf&#160;and&#160;bufp, and those names will not conflict&#160;<br/>with the same names in other files of&#160;the same&#160;program. In the same way, the variables that&#160;<br/>push&#160;and&#160;pop&#160;use for stack manipulation can be hidden, by declaring&#160;sp&#160;and&#160;val&#160;to be&#160;<br/>
static. &#160;<br/>
The external&#160;static&#160;declaration is most often used for&#160;variables, but it can be applied to&#160;<br/>functions as well. Normally, function names are global, visible to any part of the entire&#160;<br/>program. If a function is declared&#160;static, however, its name is invisible outside of the file in&#160;<br/>which it is declared. &#160;<br/>
The&#160;static&#160;declaration can also be applied to internal variables. Internal&#160;static&#160;variables are&#160;<br/>local to a particular function just as automatic variables are, but unlike automatics, they&#160;<br/>remain in existence rather than coming and&#160;going each time the function is activated. This&#160;<br/>means that internal&#160;static&#160;variables provide private, permanent storage within a single&#160;<br/>function. &#160;<br/>
<b>Exercise 4-11.</b>&#160;Modify&#160;getop&#160;so that it doesn't&#160;need to use&#160;ungetch. Hint: use an internal&#160;<br/>static&#160;variable. &#160;<br/>
<b>4.7 Register Variables&#160;</b><br/>
A&#160;&#160;register&#160;declaration advises the compiler that the variable in question will be heavily&#160;<br/>used. The idea is that&#160;register&#160;variables are to be placed in&#160;machine registers, which may&#160;<br/>result in smaller and faster programs. But compilers are free to ignore the advice. &#160;<br/>
The&#160;register&#160;declaration looks like &#160;<br/>
&#160;<br/>&#160; &#160;register int &#160;x;&#160;<br/>&#160; &#160;register char c;&#160;<br/>
<hr/>
<a name=76></a>&#160;&#160;<br/>
76&#160;<br/>
and so on. The&#160;register&#160;declaration can only be applied to automatic variables and to the&#160;<br/>formal parameters of a function. In this later case, it looks like &#160;<br/>&#160;<br/>&#160; &#160;f(register unsigned m, register long n)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;register int i;&#160;<br/>&#160; &#160; &#160; &#160;...&#160;<br/>&#160; &#160;}&#160;<br/>
In practice, there are restrictions on register&#160;variables, reflecting the realities of underlying&#160;<br/>hardware. Only a few variables in each function&#160;may be kept in registers, and only certain&#160;<br/>types are allowed. Excess register declarations are harmless, however, since the word&#160;<br/>register&#160;is ignored for excess or disallowed declarations. And it is not possible to take the&#160;<br/><a href="">address of a register variable (a topic covered in&#160;Chapter 5), regardless of whether the variable&#160;<br/></a>is actually placed in a register. The specific&#160;restrictions on number and types of register&#160;<br/>variables vary from&#160;machine to machine. &#160;<br/>
<b>4.8 Block Structure&#160;</b><br/>
C is not a block-structured language in the sense of Pascal or similar languages, because&#160;<br/>functions may not be defined within other functions. On the other hand, variables can be&#160;<br/>defined in a block-structured fashion within a&#160;function. Declarations of variables (including&#160;<br/>initializations) may follow the left brace that introduces&#160;<i>any</i>&#160;compound statement, not just the&#160;<br/>one that begins a function. Variables declared in this way hide any identically named&#160;<br/>variables in outer blocks, and remain in existence until the matching right brace. For example,&#160;<br/>in &#160;<br/>&#160;<br/>&#160; &#160;if (n &gt; 0) {&#160;<br/>&#160; &#160; &#160; &#160;int i; &#160;/* declare a new i */&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;for (i = 0; i &lt; n; i++)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;...&#160;<br/>&#160; &#160;}&#160;<br/>
the scope of the variable&#160;i&#160;is the ``true''&#160;branch of the&#160;if; this&#160;i&#160;is unrelated to any&#160;i&#160;outside&#160;<br/>the block. An automatic variable declared and&#160;initialized in a block is&#160;initialized each time the&#160;<br/>block is entered. &#160;<br/>
Automatic variables, including formal parameters, also hide external variables and functions&#160;<br/>of the same name. Given the declarations &#160;<br/>
&#160;<br/>&#160; &#160;int x;&#160;<br/>&#160; &#160;int y;&#160;<br/>&#160;<br/>&#160; &#160;f(double x)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;double y;&#160;<br/>&#160; &#160;}&#160;<br/>
then within the function&#160;f, occurrences of&#160;x&#160;refer to the parameter, which is a&#160;double; outside&#160;<br/>f, they refer to the external&#160;int. The same is true of&#160;the variable&#160;y. &#160;<br/>
As a matter of style, it's best to avoid variable names that conceal names in an outer scope; the&#160;<br/>potential for confusion and error is too great. &#160;<br/>
<b>4.9 Initialization&#160;</b><br/>
<hr/>
<a name=77></a>&#160;&#160;<br/>
77&#160;<br/>
Initialization has been mentioned in passing many&#160;times so far, but always peripherally to&#160;<br/>some other topic. This section summarizes some of the rules, now that we have discussed the&#160;<br/>various storage classes. &#160;<br/>
In the absence of&#160;explicit initialization, external and static variables are guaranteed to be&#160;<br/>initialized to zero; automatic and register variables have undefined (i.e., garbage) initial&#160;<br/>values. &#160;<br/>
Scalar variables may be initialized when they&#160;are defined, by following the name with an&#160;<br/>equals sign and an expression: &#160;<br/>
&#160;<br/>&#160; &#160;int x = 1;&#160;<br/>&#160; &#160;char squota = '\'';&#160;<br/>&#160; &#160;long day = 1000L * 60L * 60L * 24L; /* milliseconds/day */&#160;<br/>
For external and static variables, the initializer must be a constant expression; the&#160;<br/>initialization is done once, conceptionally before&#160;the program&#160;begins execution. For automatic&#160;<br/>and register variables, the initializer is not restricted to being a constant: it may be any&#160;<br/>expression involving previously&#160;defined values, even function calls. For example, the&#160;<br/>initialization of&#160;the binary search program<a href="">&#160;in&#160;Section 3.3</a>&#160;could be written as &#160;<br/>&#160;<br/>&#160; &#160;int binsearch(int x, int v[], int n)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int low = 0;&#160;<br/>&#160; &#160; &#160; &#160;int high = n - 1;&#160;<br/>&#160; &#160; &#160; &#160;int mid;&#160;<br/>&#160; &#160; &#160; &#160;...&#160;<br/>&#160; &#160;}&#160;<br/>
instead of &#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;int low, high, mid;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;low = 0;&#160;<br/>&#160; &#160; &#160; &#160;high = n - 1;&#160;<br/>
In effect, initialization of&#160;automatic variables&#160;are just shorthand for assignment statements.&#160;<br/>Which form&#160;to prefer is largely a matter of&#160;taste. We have generally used explicit&#160;<br/>assignments, because initializers in declarations&#160;are harder to see and further away from&#160;the&#160;<br/>point of use. &#160;<br/>
An array may be initialized by following its declaration with a list of&#160;initializers enclosed in&#160;<br/>braces and separated by commas. For example, to initialize an array&#160;days&#160;with the number of&#160;<br/>days in each month: &#160;<br/>
&#160;<br/>&#160; &#160;int days[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }&#160;<br/>
When the size of the array is omitted, the&#160;compiler will compute the length by counting the&#160;<br/>initializers, of&#160;which there are 12 in this case. &#160;<br/>
If&#160;there are fewer initializers for an array than&#160;the specified size, the others will be zero for&#160;<br/>external, static and automatic variables. It is&#160;an error to have too many initializers. There is no&#160;<br/>way to specify&#160;repetition of&#160;an initializer, nor to&#160;initialize an element in the middle of&#160;an array&#160;<br/>without supplying all the preceding values as well. &#160;<br/>
Character arrays are a special case of initialization; a string may be used instead of the braces&#160;<br/>and commas notation: &#160;<br/>
<hr/>
<a name=78></a>&#160;&#160;<br/>
78&#160;<br/>
&#160;<br/>&#160; &#160;char pattern = &#34;ould&#34;;&#160;<br/>
is a shorthand for the longer but equivalent &#160;<br/>&#160;<br/>&#160; &#160;char pattern[] = { 'o', 'u', 'l', 'd', '\0' };&#160;<br/>
In this case, the array size is five (four characters plus the terminating&#160;'\0'). &#160;<br/>
<b>4.10 Recursion&#160;</b><br/>
C functions may be used recursively; that is, a function may call itself&#160;either directly or&#160;<br/>indirectly. Consider printing a number as a character string. As we mentioned before, the&#160;<br/>digits are generated in the wrong order: low-order digits are available before high-order digits,&#160;<br/>but they have to be printed the other way around. &#160;<br/>
There are two solutions to this problem. On is&#160;to store the digits in an array as they are&#160;<br/>generated, then print them&#160;in the reverse order, as we did with&#160;itoa&#160;in&#160;<a href="">section 3.6</a>. The&#160;<br/>alternative is a recursive solution, in which&#160;printd&#160;first calls itself&#160;to cope with any leading&#160;<br/>digits, then prints the trailing digit. Again,&#160;this version can fail on the largest negative&#160;<br/>number. &#160;<br/>
&#160;<br/>&#160; &#160;#include &lt;stdio.h&gt;&#160;<br/>&#160;<br/>&#160; &#160;/* printd: &#160;print n in decimal */&#160;<br/>&#160; &#160;void printd(int n)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;if (n &lt; 0) {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;putchar('-');&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;n = -n;&#160;<br/>&#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160; &#160; &#160;if (n / 10)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;printd(n / 10);&#160;<br/>&#160; &#160; &#160; &#160;putchar(n % 10 + '0');&#160;<br/>&#160; &#160;}&#160;<br/>
When a function calls itself recursively, each invocation gets a fresh set of all the automatic&#160;<br/>variables, independent of the previous set. This in&#160;printd(123)&#160;the first&#160;printd&#160;receives the&#160;<br/>argument&#160;&#160;n = 123. It passes&#160;12&#160;to a second&#160;printd, which in turn passes&#160;1&#160;to a third. The&#160;<br/>third-level&#160;printd&#160;prints&#160;1, then returns to the second level. That&#160;printd&#160;prints&#160;2, then returns&#160;<br/>to the first level. That one prints&#160;3&#160;and terminates. &#160;<br/>
Another good example of recursion is quicksort, a sorting algorithm&#160;developed by C.A.R.&#160;<br/>Hoare in 1962. Given an array, one element is&#160;chosen and the others partitioned in two&#160;<br/>subsets - those less than the partition element and&#160;those greater than or equal to it. The same&#160;<br/>process is then applied recursively to the two subsets. When a subset has fewer than two&#160;<br/>elements, it doesn't need any sorting; this stops the recursion. &#160;<br/>
Our version of quicksort is not the fastest possible, but it's one of the simplest. We use the&#160;<br/>middle element of each subarray for partitioning. &#160;<br/>
&#160;<br/>&#160; &#160;/* qsort: &#160;sort v[left]...v[right] into increasing order */&#160;<br/>&#160; &#160;void qsort(int v[], int left, int right)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int i, last;&#160;<br/>&#160; &#160; &#160; &#160;void swap(int v[], int i, int j);&#160;<br/>&#160;<br/>
<hr/>
<a name=79></a>&#160;&#160;<br/>
79&#160;<br/>
&#160; &#160; &#160; &#160;if (left &gt;= right) /* do nothing if array contains */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;return; &#160; &#160; &#160; &#160;/* fewer than two elements */&#160;<br/>&#160; &#160; &#160; &#160;swap(v, left, (left + right)/2); /* move partition elem */&#160;<br/>&#160; &#160; &#160; &#160;last = left; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; /* to v[0] */&#160;<br/>&#160; &#160; &#160; &#160;for (i = left + 1; i &lt;= right; i++) &#160;/* partition */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;if (v[i] &lt; v[left])&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;swap(v, ++last, i);&#160;<br/>&#160; &#160; &#160; &#160;swap(v, left, last); &#160; &#160; &#160; &#160; &#160; &#160;/* restore partition &#160;elem */&#160;<br/>&#160; &#160; &#160; &#160;qsort(v, left, last-1);&#160;<br/>&#160; &#160; &#160; &#160;qsort(v, last+1, right);&#160;<br/>&#160; &#160;}&#160;<br/>
We moved the swapping operation into a separate function&#160;swap&#160;because it occurs three times&#160;<br/>in&#160;qsort. &#160;<br/>&#160;<br/>&#160; &#160;/* swap: &#160;interchange v[i] and v[j] */&#160;<br/>&#160; &#160;void swap(int v[], int i, int j)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int temp;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;temp = v[i];&#160;<br/>&#160; &#160; &#160; &#160;v[i] = v[j];&#160;<br/>&#160; &#160; &#160; &#160;v[j] = temp;&#160;<br/>&#160; &#160;}&#160;<br/>
The standard library includes a version of&#160;qsort&#160;that can sort objects of any type. &#160;<br/>
Recursion may provide no saving in storage, since somewhere a stack of the values being&#160;<br/>processed must be maintained. Nor will it be faster. But recursive code is more compact, and&#160;<br/>often much easier to write and understand than&#160;the non-recursive equivalent. Recursion is&#160;<br/>especially convenient for recursively defined&#160;data structures like trees, we will see a nice&#160;<br/>exam<a href="">ple in&#160;Section 6.6</a>. &#160;<br/>
<b>Exercise 4-12.</b>&#160;Adapt the ideas of&#160;printd&#160;to write a recursive version of&#160;itoa; that is, convert&#160;<br/>an integer into a string by calling a recursive routine. &#160;<br/>
<b>Exercise 4-13.</b>&#160;Write a recursive version of the function&#160;reverse(s), which reverses the&#160;<br/>string&#160;s&#160;in place. &#160;<br/>
<b>4.11 The C Preprocessor&#160;</b><br/>
C provides certain language facilities by means of a preprocessor, which is conceptionally a&#160;<br/>separate first step in compilation. The&#160;two most frequently used features are&#160;#include, to&#160;<br/>include the contents of a file during compilation, and&#160;#define, to replace a token by an&#160;<br/>arbitrary sequence of characters. Other features&#160;described in this section include conditional&#160;<br/>compilation and macros with arguments. &#160;<br/>
<b>4.11.1 File Inclusion&#160;</b><br/>
File inclusion makes it easy to handle collections of&#160;#defines and declarations (among other&#160;<br/>things). Any source line of the form&#160;&#160;<br/>&#160;<br/>&#160; &#160;#include &#34;<i>filename</i>&#34;&#160;<br/>
or &#160;<br/>&#160;<br/>&#160; &#160;#include &lt;<i>filename</i>&gt;&#160;<br/>
is replaced by the contents of the file&#160;<i>filename</i>. If the&#160;<i>filename</i>&#160;is quoted, searching for the file&#160;<br/>typically begins where the source program&#160;was found;&#160;if it is not found there, or if the name is&#160;<br/>
<hr/>
<a name=80></a>&#160;&#160;<br/>
80&#160;<br/>
enclosed in &lt; and &gt;, searching follows an implementation-defined rule to find the file. An&#160;<br/>included file may itself contain&#160;#include&#160;lines. &#160;<br/>
There are often several&#160;#include&#160;lines at the beginning of a source file, to include common&#160;<br/>#define&#160;statements and&#160;extern&#160;declarations, or to access the&#160;function prototype declarations&#160;<br/>for library functions from&#160;headers like&#160;&lt;stdio.h&gt;. (Strictly speaking, these need not be files;&#160;<br/>the details of how headers are accessed are implementation-dependent.) &#160;<br/>
#include&#160;is the preferred way to tie the declarations together for a large program. It&#160;<br/>guarantees that all the source files will be supplied with the same definitions and variable&#160;<br/>declarations, and thus eliminates a particularly&#160;nasty kind of bug. Naturally, when an included&#160;<br/>file is changed, all files that depend on it must be recompiled. &#160;<br/>
<b>4.11.2 Macro Substitution&#160;</b><br/>
A definition has the form&#160;&#160;<br/>&#160;<br/>&#160; &#160;#define&#160;<i>name replacement text</i>&#160;<br/>
It calls for a macro substitution of&#160;the simplest&#160;kind - subsequent occurrences of&#160;the token&#160;<br/>name&#160;will be replaced by the&#160;<i>replacement text</i>. The name&#160;in a&#160;#define&#160;has the same form&#160;as a&#160;<br/>variable name; the replacement text is arbitrary.&#160;Normally the replacement text is the rest of&#160;<br/>the line, but a long definition may be&#160;continued onto several lines by placing a&#160;\&#160;at the end of&#160;<br/>each line to be continued. The scope of a name&#160;defined with&#160;#define&#160;is from&#160;its point of&#160;<br/>definition to the end of the source file being compiled. A definition may use previous&#160;<br/>definitions. Substitutions are made only for&#160;tokens, and do not take place within quoted&#160;<br/>strings. For example, if&#160;YES&#160;is a defined name, there would be no substitution in&#160;<br/>printf(&#34;YES&#34;)&#160;or in&#160;YESMAN. &#160;<br/>
Any name may be defined with any replacement text. For example &#160;<br/>
&#160;<br/>&#160; &#160;#define &#160;forever &#160;for (;;) &#160; &#160;/* infinite loop */&#160;<br/>
defines a new word,&#160;forever, for an infinite loop. &#160;<br/>
It is also possible to define macros with arguments, so the replacement text can be different&#160;<br/>for different calls of the macro. As an example, define a macro called&#160;max: &#160;<br/>
&#160;<br/>&#160; &#160;#define &#160;max(A, B) &#160;((A) &gt; (B) ? (A) : (B))&#160;<br/>
Although it looks like a function call, a use of&#160;max&#160;expands into in-line code. Each occurrence&#160;<br/>of a formal parameter (here&#160;A&#160;or&#160;B) will be replaced by the corresponding actual argument.&#160;<br/>Thus the line &#160;<br/>&#160;<br/>&#160; &#160;x = max(p+q, r+s);&#160;<br/>
will be replaced by the line &#160;<br/>&#160;<br/>&#160; &#160;x = ((p+q) &gt; (r+s) ? (p+q) : (r+s));&#160;<br/>
So long as the arguments are treated consistently, this macro will serve for any data type;&#160;<br/>there is no need for different kinds of&#160;max&#160;for different data types, as there would be with&#160;<br/>functions. &#160;<br/>
<hr/>
<a name=81></a>&#160;&#160;<br/>
81&#160;<br/>
If you examine the expansion of&#160;max, you will notice some pitfalls. The expressions are&#160;<br/>evaluated twice; this is bad if they involve side effects like increment operators or input and&#160;<br/>output. For instance &#160;<br/>
&#160;<br/>&#160; &#160;max(i++, j++) &#160;/* WRONG */&#160;<br/>
will increment the larger twice. Some care also has to be taken with parentheses to make sure&#160;<br/>the order of evaluation is preserved; consider what happens when the macro &#160;<br/>&#160;<br/>&#160; &#160;#define square(x) &#160;x * x &#160;/* WRONG */&#160;<br/>
is invoked as&#160;square(z+1). &#160;<br/>
Nonetheless, macros are valuable.&#160;One practical example comes from&#160;&lt;stdio.h&gt;, in which&#160;<br/>getchar&#160;and&#160;putchar&#160;are often defined as macros to avoid the run-time overhead of a&#160;<br/>function call per character processed. The functions in&#160;&lt;ctype.h&gt;&#160;are also usually&#160;<br/>implemented as macros. &#160;<br/>
Names may be undefined with&#160;#undef, usually to ensure that a routine is really a function, not&#160;<br/>a macro: &#160;<br/>
&#160;<br/>&#160; &#160;#undef getchar&#160;<br/>&#160;<br/>&#160; &#160;int getchar(void) { ... }&#160;<br/>
Formal parameters are not replaced within quoted strings. If, however, a parameter name is&#160;<br/>preceded by a&#160;#&#160;in the replacement text, the combination will be expanded into a quoted string&#160;<br/>with the parameter replaced by the actual argument. This can be combined with string&#160;<br/>concatenation to make, for example, a debugging print macro: &#160;<br/>&#160;<br/>&#160; &#160;#define &#160;dprint(expr) &#160; printf(#expr &#34; = %g\n&#34;, expr)&#160;<br/>
When this is invoked, as in &#160;<br/>&#160;<br/>&#160; &#160;dprint(x/y)&#160;<br/>
the macro is expanded into &#160;<br/>&#160;<br/>&#160; &#160;printf(&#34;x/y&#34; &#34; = &amp;g\n&#34;, x/y);&#160;<br/>
and the strings are concatenated, so the effect is &#160;<br/>&#160;<br/>&#160; &#160;printf(&#34;x/y = &amp;g\n&#34;, x/y);&#160;<br/>
Within the actual argument, each&#160;&#34;&#160;is replaced by&#160;\&#34;&#160;and each&#160;\&#160;by&#160;\\, so the result is a legal&#160;<br/>string constant. &#160;<br/>
The preprocessor operator&#160;##&#160;provides a way to concatenate actual arguments during macro&#160;<br/>expansion. If a parameter in the&#160;replacement text is adjacent to a&#160;##, the parameter is replaced&#160;<br/>by the actual argument, the&#160;##&#160;and surrounding white space are removed, and the result is re-<br/>scanned. For example, the macro&#160;paste&#160;concatenates its two arguments: &#160;<br/>
&#160;<br/>&#160; &#160;#define &#160;paste(front, back) &#160;front ## back&#160;<br/>
so&#160;paste(name, 1)&#160;creates the token&#160;name1. &#160;<br/>
The rules for nested uses of&#160;##&#160;are arcane; further details m<a href="">ay be found in&#160;Appendix A. &#160;</a><br/>
<b>Exercise 4-14.</b>&#160;Define a macro&#160;swap(t,x,y)&#160;that interchanges two arguments of type&#160;t.&#160;<br/>(Block structure will help.) &#160;<br/>
<hr/>
<a name=82></a>&#160;&#160;<br/>
82&#160;<br/>
<b>4.11.3 Conditional Inclusion&#160;</b><br/>
It is possible to control preprocessing itself with conditional statements that are evaluated&#160;<br/>during preprocessing. This provides a way to include code selectively, depending on the value&#160;<br/>of conditions evaluated during compilation. &#160;<br/>
The&#160;#if&#160;line evaluates a constant integer expression (which may not include&#160;sizeof, casts, or&#160;<br/>enum&#160;constants). If the expression is non-zero, subsequent lines until an&#160;#endif&#160;or&#160;#elif&#160;or&#160;<br/>
#else&#160;are included. (The preprocessor statement&#160;#elif&#160;is like&#160;else-if.) The expression&#160;<br/>
defined(<i>name</i>) in a&#160;#if&#160;is 1 if&#160;the&#160;<i>name</i>&#160;has been defined, and 0 otherwise. &#160;<br/>
For example, to make sure that the contents of a file&#160;hdr.h&#160;are included only once, the&#160;<br/>contents of the file are surrounded with a conditional like this: &#160;<br/>
&#160;<br/>&#160; &#160;#if !defined(HDR)&#160;<br/>&#160; &#160;#define HDR&#160;<br/>&#160;<br/>&#160; &#160;/* contents of hdr.h go here */&#160;<br/>&#160;<br/>&#160; &#160;#endif&#160;<br/>
The first inclusion of&#160;hdr.h&#160;defines the name&#160;HDR; subsequent inclusions will find the name&#160;<br/>defined and skip down to the&#160;#endif. A similar style can be used to avoid including files&#160;<br/>multiple times. If this style is used consistently, then each header can itself include any other&#160;<br/>headers on which it depends, without the user&#160;of the header having to deal with the&#160;<br/>interdependence. &#160;<br/>
This sequence tests the name&#160;SYSTEM&#160;to decide which version of a header to include: &#160;<br/>
&#160;<br/>&#160; &#160;#if SYSTEM == SYSV&#160;<br/>&#160; &#160; &#160; &#160;#define HDR &#34;sysv.h&#34;&#160;<br/>&#160; &#160;#elif SYSTEM == BSD&#160;<br/>&#160; &#160; &#160; &#160;#define HDR &#34;bsd.h&#34;&#160;<br/>&#160; &#160;#elif SYSTEM == MSDOS&#160;<br/>&#160; &#160; &#160; &#160;#define HDR &#34;msdos.h&#34;&#160;<br/>&#160; &#160;#else&#160;<br/>&#160; &#160; &#160; &#160;#define HDR &#34;default.h&#34;&#160;<br/>&#160; &#160;#endif&#160;<br/>&#160; &#160;#include HDR&#160;<br/>
The&#160;#ifdef&#160;and&#160;#ifndef&#160;lines are specialized forms that test whether a name is defined. The&#160;<br/>first example of&#160;#if&#160;above could have been written &#160;<br/>&#160;<br/>&#160; &#160;#ifndef HDR&#160;<br/>&#160; &#160;#define HDR&#160;<br/>&#160;<br/>&#160; &#160;/* contents of hdr.h go here */&#160;<br/>&#160;<br/>&#160; &#160;#endif&#160;<br/>
<hr/>
<a name=83></a><img src="c-83_1.png"/><br/>
&#160;&#160;<br/>
83&#160;<br/>
&#160;<br/>
<b>Chapter&#160;5 - Pointers and&#160;Arrays&#160;</b><br/>
A pointer is a variable that contains the address of a variable. Pointers are much used in C,&#160;<br/>partly because they are sometimes the only way&#160;to express a computation, and partly because&#160;<br/>they usually lead to more compact and efficient code than can be obtained in other ways.&#160;<br/>Pointers and arrays are closely related; this chapter also explores this relationship and shows&#160;<br/>how to exploit it. &#160;<br/>
Pointers have been lumped with the&#160;goto&#160;statement as a marvelous way to create impossible-<br/>to-understand programs. This is certainly true when they are used carelessly, and it is easy to&#160;<br/>create pointers that point somewhere unexpected.&#160;With discipline, however, pointers can also&#160;<br/>be used to achieve clarity and simplicity. This is the aspect that we will try to illustrate. &#160;<br/>
The main change in ANSI C is to make explicit the rules about how pointers can be&#160;<br/>manipulated, in effect mandating what&#160;good programmers already practice and good&#160;<br/>compilers already enforce. In addition, the type&#160;void *&#160;(pointer to&#160;void) replaces&#160;char *&#160;as&#160;<br/>the proper type for a generic pointer. &#160;<br/>
<b>5.1 Pointers and Addresses&#160;</b><br/>
Let us begin with a simplified&#160;picture of how memory is organized. A typical machine has an&#160;<br/>array of consecutively numbered or addressed memory cells that may be manipulated&#160;<br/>individually or in contiguous groups. One common situation is that any byte can be a&#160;char, a&#160;<br/>pair of one-byte cells can be treated as a&#160;short&#160;integer, and four adjacent bytes form&#160;a&#160;long.&#160;<br/>A pointer is a group of cells (often two or&#160;four) that can hold&#160;an address. So if&#160;c&#160;is a&#160;char&#160;and&#160;<br/>p&#160;is a pointer that points to it, we could represent the situation this way: &#160;<br/>
&#160;<br/>
The unary operator&#160;&amp;&#160;gives the address of an object, so the statement &#160;<br/>
&#160;<br/>&#160; &#160;p = &amp;c;&#160;<br/>
assigns the address of&#160;c&#160;to the variable&#160;p, and&#160;p&#160;is said to ``point to''&#160;c. The&#160;&amp;&#160;operator only&#160;<br/>applies to objects in memory: variables and array elements. It cannot be applied to&#160;<br/>expressions, constants, or&#160;register&#160;variables. &#160;<br/>
The unary operator&#160;*&#160;is the&#160;<i>indirection</i>&#160;or&#160;<i>dereferencing</i>&#160;operator; when applied to a pointer, it&#160;<br/>accesses the object the pointer points to. Suppose that&#160;x&#160;and&#160;y&#160;are integers and&#160;ip&#160;is a pointer&#160;<br/>to&#160;int. This artificial sequence shows how to declare a pointer and how to use&#160;&amp;&#160;and&#160;*: &#160;<br/>
&#160;<br/>&#160; &#160;int x = 1, y = 2, z[10];&#160;<br/>&#160; &#160;int *ip; &#160; &#160; &#160; &#160; &#160;/* ip is a pointer to int */&#160;<br/>&#160;<br/>
<hr/>
<a name=84></a>&#160;&#160;<br/>
84&#160;<br/>
&#160; &#160;ip = &amp;x; &#160; &#160; &#160; &#160; &#160;/* ip now points to x */&#160;<br/>&#160; &#160;y = *ip; &#160; &#160; &#160; &#160; &#160;/* y is now 1 */&#160;<br/>&#160; &#160;*ip = 0; &#160; &#160; &#160; &#160; &#160;/* x is now 0 */&#160;<br/>&#160; &#160;ip = &amp;z[0]; &#160; &#160; &#160; /* ip now points to z[0] */&#160;<br/>
The declaration of&#160;x,&#160;y, and&#160;z&#160;are what we've seen all along. The declaration of the pointer&#160;ip, &#160;<br/>&#160;<br/>&#160; &#160;int *ip;&#160;<br/>
is intended as a mnemonic; it says that the expression&#160;*ip&#160;is an&#160;int. The syntax of the&#160;<br/>declaration for a variable mimics the syntax&#160;of expressions in which the variable might&#160;<br/>appear. This reasoning applies to function declarations as well. For example, &#160;<br/>&#160;<br/>&#160; &#160;double *dp, atof(char *);&#160;<br/>
says that in an expression&#160;*dp&#160;and&#160;atof(s)&#160;have values of&#160;double, and that the argument of&#160;<br/>atof&#160;is a pointer to&#160;char. &#160;<br/>
You should also note the implication that a pointer is constrained to point to a particular kind&#160;<br/>of object: every pointer points to a specific data&#160;type. (There is one exception: a ``pointer to&#160;<br/>void'' is used to hold any type of&#160;pointer but cannot be dereferenced itself. We'll come back to&#160;<br/>it in&#160;<a href="cs.html#106">Section 5.11.) &#160;</a><br/>
If&#160;ip&#160;points to the integer&#160;x, then&#160;*ip&#160;can occur in any context where&#160;x&#160;could, so &#160;<br/>
&#160;<br/>&#160; &#160;*ip = *ip + 10;&#160;<br/>
increments&#160;*ip&#160;by 10. &#160;<br/>
The unary operators&#160;*&#160;and&#160;&amp;&#160;bind more tightly than arithmetic operators, so the assignment &#160;<br/>
&#160;<br/>&#160; &#160;y = *ip + 1&#160;<br/>
takes whatever&#160;ip&#160;points at, adds 1, and assigns the result to&#160;y, while &#160;<br/>&#160;<br/>&#160; &#160;*ip += 1&#160;<br/>
increments what&#160;ip&#160;points to, as do &#160;<br/>&#160;<br/>&#160; &#160;++*ip&#160;<br/>
and &#160;<br/>&#160;<br/>&#160; &#160;(*ip)++&#160;<br/>
The parentheses are necessary in this last&#160;example; without them, the expression would&#160;<br/>increment&#160;ip&#160;instead of what it points to, because unary operators like&#160;*&#160;and&#160;++&#160;associate right&#160;<br/>to left. &#160;<br/>
Finally, since pointers are variables, they can be&#160;used without dereferencing. For example, if&#160;<br/>iq&#160;is another pointer to&#160;int, &#160;<br/>
&#160;<br/>&#160; &#160;iq = ip&#160;<br/>
copies the contents of&#160;ip&#160;into&#160;iq, thus making&#160;iq&#160;point to whatever&#160;ip&#160;pointed to. &#160;<br/>
<b>5.2 Pointers and Function Arguments&#160;</b><br/>
Since C passes arguments to functions by value,&#160;there is no direct way for the called function&#160;<br/>to alter a variable in the calling function. For&#160;instance, a sorting routine might exchange two&#160;<br/>out-of-order arguments with a function called&#160;swap. It is not enough to write &#160;<br/>
<hr/>
<a name=85></a>&#160;&#160;<br/>
85&#160;<br/>
&#160;<br/>&#160; &#160;swap(a, b);&#160;<br/>
where the&#160;swap&#160;function is defined as &#160;<br/>&#160;<br/>&#160; &#160;void swap(int x, int y) &#160;/* WRONG */&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int temp;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;temp = x;&#160;<br/>&#160; &#160; &#160; &#160;x = y;&#160;<br/>&#160; &#160; &#160; &#160;y = temp;&#160;<br/>&#160; &#160;}&#160;<br/>
Because of call by value,&#160;swap&#160;can't&#160;affect the arguments&#160;a&#160;and&#160;b&#160;in the routine that called it.&#160;<br/>The function above swaps&#160;<i>copies</i>&#160;of&#160;a&#160;and&#160;b. &#160;<br/>
The way to obtain the desired effect is for the calling program&#160;to pass&#160;<i>pointers</i>&#160;to the values to&#160;<br/>be changed: &#160;<br/>
&#160;<br/>&#160; &#160;swap(&amp;a, &amp;b);&#160;<br/>
Since the operator&#160;&amp;&#160;produces the address of a variable,&#160;&amp;a&#160;is a pointer to&#160;a. In&#160;swap&#160;itself,&#160;the&#160;<br/>parameters are declared as pointers, and the operands are accessed indirectly through them. &#160;<br/>&#160;<br/>&#160; &#160;void swap(int *px, int *py) &#160;/* interchange *px and *py */&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int temp;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;temp = *px;&#160;<br/>&#160; &#160; &#160; &#160;*px = *py;&#160;<br/>&#160; &#160; &#160; &#160;*py = temp;&#160;<br/>&#160; &#160;}&#160;<br/>
Pictorially: &#160;<br/>
<hr/>
<a name=86></a><img src="c-86_1.png"/><br/>
&#160;&#160;<br/>
86&#160;<br/>
&#160;<br/>
Pointer arguments enable a function to access and&#160;change objects in the function that called it.&#160;<br/>As an example, consider a function&#160;getint&#160;that performs free-format input conversion by&#160;<br/>breaking a stream&#160;of characters into integer values, one integer per call.&#160;getint&#160;has to return&#160;<br/>the value it found and also signal end of file when there is no more input. These values have&#160;<br/>to be passed back by separate paths,&#160;for no matter what value is used for&#160;EOF, that could also&#160;<br/>be the value of an input integer. &#160;<br/>
One solution is to have&#160;getint&#160;return the end of&#160;file status as&#160;its function value, while using a&#160;<br/>pointer argument to store the converted integer back in the calling function. This is the&#160;<br/>scheme&#160;used by&#160;scanf&#160;as well; see&#160;<a href="">Section 7.4</a>. &#160;<br/>
The following loop fills an array with integers by calls to&#160;getint: &#160;<br/>
&#160;<br/>&#160; &#160;int n, array[SIZE], getint(int *);&#160;<br/>&#160;<br/>&#160; &#160;for (n = 0; n &lt; SIZE &amp;&amp; getint(&amp;array[n]) != EOF; n++)&#160;<br/>&#160; &#160; &#160; &#160;;&#160;<br/>
Each call sets&#160;array[n]&#160;to the next integer found in the input and increments&#160;n. Notice that it&#160;<br/>is essential to pass the address of&#160;array[n]&#160;to&#160;getint. Otherwise there is no way for&#160;getint&#160;<br/>to communicate the converted integer back to the caller. &#160;<br/>
Our version of&#160;getint&#160;returns&#160;EOF&#160;for end of file, zero if the next input is not a number, and a&#160;<br/>positive value if the input contains a valid number. &#160;<br/>
&#160;<br/>&#160; &#160;#include &lt;ctype.h&gt;&#160;<br/>
<hr/>
<a name=87></a><img src="c-87_1.png"/><br/>
&#160;&#160;<br/>
87&#160;<br/>
&#160;<br/>&#160; &#160;int getch(void);&#160;<br/>&#160; &#160;void ungetch(int);&#160;<br/>&#160;<br/>&#160; &#160;/* getint: &#160;get next integer from input into *pn */&#160;<br/>&#160; &#160;int getint(int *pn)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int c, sign;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;while (isspace(c = getch())) &#160; /* skip white space */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;;&#160;<br/>&#160; &#160; &#160; &#160;if (!isdigit(c) &amp;&amp; c != EOF &amp;&amp; c != '+' &amp;&amp; c != '-') {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;ungetch(c); &#160;/* it is not a number */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;return 0;&#160;<br/>&#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160; &#160; &#160;sign = (c == '-') ? -1 : 1;&#160;<br/>&#160; &#160; &#160; &#160;if (c == '+' || c == '-')&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;c = getch();&#160;<br/>&#160; &#160; &#160; &#160;for (*pn = 0; isdigit(c), c = getch())&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;*pn = 10 * *pn + (c - '0');&#160;<br/>&#160; &#160; &#160; &#160;*pn *= sign;&#160;<br/>&#160; &#160; &#160; &#160;if (c != EOF)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;ungetch(c);&#160;<br/>&#160; &#160; &#160; &#160;return c;&#160;<br/>&#160; &#160;}&#160;<br/>
Throughout&#160;getint,&#160;*pn&#160;is used as an ordinary&#160;int&#160;variable. We have also used&#160;getch&#160;and&#160;<br/>ungetch&#160;(described in&#160;<a href="">Section 4.3</a>) so the one extra character that&#160;must be read can be pushed&#160;<br/>back onto the input. &#160;<br/>
<b>Exercise 5-1.</b>&#160;As written,&#160;getint&#160;treats a&#160;+&#160;or&#160;-&#160;not followed by a digit as a valid&#160;<br/>representation of zero. Fix it to push such a character back on the input. &#160;<br/>
<b>Exercise 5-2.</b>&#160;Write&#160;getfloat, the floating-point analog of&#160;getint. What type does&#160;<br/>getfloat&#160;return as its function value? &#160;<br/>
<b>5.3 Pointers and Arrays&#160;</b><br/>
In C, there is a strong relationship between&#160;pointers and arrays, strong enough that pointers&#160;<br/>and arrays should be discussed simultaneously. Any operation that can be achieved by array&#160;<br/>subscripting can also be done with pointers. The&#160;pointer version will in general be faster but,&#160;<br/>at least to the uninitiated, somewhat harder to understand. &#160;<br/>
The declaration &#160;<br/>
&#160;<br/>&#160; &#160;int a[10];&#160;<br/>
defines an array of size 10, that is, a block of 10 consecutive objects named&#160;a[0],&#160;&#160;a[1],&#160;<br/>...,a[9]. &#160;<br/>
&#160;<br/>
<hr/>
<a name=88></a><img src="c-88_1.png"/><br/>
<img src="c-88_2.png"/><br/>
&#160;&#160;<br/>
88&#160;<br/>
The notation&#160;a[i]&#160;refers to the&#160;i-th element of the array. If&#160;pa&#160;is a pointer to an integer,&#160;<br/>declared as &#160;<br/>
&#160;<br/>&#160; &#160;int *pa;&#160;<br/>
then the assignment &#160;<br/>&#160;<br/>&#160; &#160;pa = &amp;a[0];&#160;<br/>
sets&#160;pa&#160;to point to element zero of&#160;a; that is,&#160;pa&#160;contains the address of&#160;a[0]. &#160;<br/>
&#160;<br/>
Now the assignment &#160;<br/>
&#160;<br/>&#160; &#160;x = *pa;&#160;<br/>
will copy the contents of&#160;a[0]&#160;into&#160;x. &#160;<br/>
If&#160;&#160;pa&#160;points to a particular element of an array, then by definition&#160;pa+1&#160;points to the next&#160;<br/>element,&#160;&#160;pa+i&#160;points&#160;i&#160;elements after&#160;pa, and&#160;pa-i&#160;points&#160;i&#160;elements before. Thus, if&#160;pa&#160;<br/>points to&#160;a[0], &#160;<br/>
&#160;<br/>&#160; &#160;*(pa+1)&#160;<br/>
refers to the contents of&#160;a[1],&#160;&#160;pa+i&#160;is the address of&#160;a[i], and&#160;*(pa+i)&#160;is the contents of&#160;<br/>a[i]. &#160;<br/>
&#160;<br/>
These remarks are true regardless of the type or size of the variables in the array&#160;a. The&#160;<br/>meaning of ``adding 1 to a pointer,'' and by extension, all pointer arithmetic, is that&#160;pa+1&#160;<br/>points to the next object, and&#160;pa+i&#160;points to the&#160;i-th object beyond&#160;pa. &#160;<br/>
<hr/>
<a name=89></a>&#160;&#160;<br/>
89&#160;<br/>
The correspondence between indexing and pointer arithmetic is very close. By definition, the&#160;<br/>value of a variable or expression of type array is the address of element zero of the array.&#160;<br/>Thus after the assignment &#160;<br/>
&#160;<br/>&#160; &#160;pa = &amp;a[0];&#160;<br/>
pa&#160;and&#160;a&#160;have identical values. Since the name of&#160;an array is a synonym&#160;for the location of the&#160;<br/>initial element, the assignment&#160;pa=&amp;a[0]&#160;can also be written as &#160;<br/>&#160;<br/>&#160; &#160;pa = a;&#160;<br/>
Rather more surprising, at first sight, is the fact that a reference to&#160;a[i]&#160;can also be written as&#160;<br/>*(a+i). In evaluating&#160;a[i], C converts it to&#160;*(a+i)&#160;immediately; the two forms are&#160;<br/>equivalent. Applying the operator&#160;&amp;&#160;to both parts of&#160;this equivalence, it follows that&#160;&amp;a[i]&#160;<br/>and&#160;a+i&#160;are also identical:&#160;a+i&#160;is the address of&#160;the&#160;i-th element beyond&#160;a. As the other side&#160;<br/>of&#160;this coin, if&#160;pa&#160;is a pointer, expressions might use it with a subscript;&#160;pa[i]&#160;is identical to&#160;<br/>*(pa+i). In short, an array-and-index expression is&#160;equivalent to one written as a pointer and&#160;<br/>offset. &#160;<br/>
There is one difference between an array name&#160;and a pointer that must be kept in mind. A&#160;<br/>pointer is a variable, so&#160;pa=a&#160;and&#160;pa++&#160;are legal. But an array name is not a variable;&#160;<br/>constructions like&#160;a=pa&#160;and&#160;a++&#160;are illegal. &#160;<br/>
When an array name is passed to a function,&#160;what is passed is the location of&#160;the initial&#160;<br/>element. Within the called function, this argument is a local variable, and so an array name&#160;<br/>parameter is a pointer, that is, a variable containing an address. We can use this fact to write&#160;<br/>another version of&#160;strlen, which computes the length of a string. &#160;<br/>
&#160;<br/>&#160; &#160;/* strlen: &#160;return length of string s */&#160;<br/>&#160; &#160;int strlen(char *s)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int n;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;for (n = 0; *s != '\0', s++)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;n++;&#160;<br/>&#160; &#160; &#160; &#160;return n;&#160;<br/>&#160; &#160;}&#160;<br/>
Since&#160;s&#160;is a pointer, incrementing it is perfectly legal;&#160;s++&#160;has no effect on the character string&#160;<br/>in the function that called&#160;strlen, but merely increments&#160;strlen's private copy of the&#160;<br/>pointer. That means that calls like &#160;<br/>&#160;<br/>&#160; &#160;strlen(&#34;hello, world&#34;); &#160; /* string constant */&#160;<br/>&#160; &#160;strlen(array); &#160; &#160; &#160; &#160; &#160; &#160;/* char array[100]; */&#160;<br/>&#160; &#160;strlen(ptr); &#160; &#160; &#160; &#160; &#160; &#160; &#160;/* char *ptr; */&#160;<br/>
all work. &#160;<br/>
As formal parameters in a function definition, &#160;<br/>
&#160;<br/>&#160; &#160;char s[];&#160;<br/>
and &#160;<br/>&#160;<br/>&#160; &#160;char *s;&#160;<br/>
are equivalent; we prefer the latter because it&#160;says more explicitly that the variable is a&#160;<br/>pointer. When an array name is passed to a function, the function can at its convenience&#160;<br/>
<hr/>
<a name=90></a>&#160;&#160;<br/>
90&#160;<br/>
believe that it has been handed either an array or a pointer, and manipulate it accordingly. It&#160;<br/>can even use both notations if it seems appropriate and clear. &#160;<br/>
It is possible to pass part of an array to a function, by passing a pointer to the beginning of the&#160;<br/>subarray. For example, if&#160;a&#160;is an array, &#160;<br/>
&#160;<br/>&#160; &#160;f(&amp;a[2])&#160;<br/>
and &#160;<br/>&#160;<br/>&#160; &#160;f(a+2)&#160;<br/>
both pass to the function&#160;f&#160;the address of the subarray that starts at&#160;a[2]. Within&#160;f, the&#160;<br/>parameter declaration can read &#160;<br/>&#160;<br/>&#160; &#160;f(int arr[]) { ... }&#160;<br/>
or &#160;<br/>&#160;<br/>&#160; &#160;f(int *arr) { ... }&#160;<br/>
So as far as&#160;f&#160;is concerned, the fact that the parameter&#160;refers to part of a larger array is of no&#160;<br/>consequence. &#160;<br/>
If&#160;one is sure that the elements exist, it is also possible to index backwards in an array;&#160;p[-1],&#160;<br/>p[-2], and so on are syntactically legal, and refer to the elements that immediately precede&#160;<br/>
p[0]. Of course, it is illegal to refer to objects that are not within the array bounds. &#160;<br/>
<b>5.4 Address Arithmetic&#160;</b><br/>
If&#160;&#160;p&#160;is a pointer to some element of an array, then&#160;p++&#160;increments&#160;p&#160;to point to the next&#160;<br/>element, and&#160;p+=i&#160;increments it to point&#160;i&#160;elements beyond where it currently does. These&#160;<br/>and similar constructions are the simples forms of pointer or address arithmetic. &#160;<br/>
C is consistent and regular in its approach to&#160;address arithmetic; its integration of&#160;pointers,&#160;<br/>arrays, and address arithmetic is one of the&#160;strengths of the language. Let us illustrate by&#160;<br/>writing a rudimentary storage allocator.&#160;There are two routines. The first,&#160;alloc(n), returns a&#160;<br/>pointer to&#160;n&#160;consecutive character positions, which can be used by the caller of&#160;alloc&#160;for&#160;<br/>storing characters. The second,&#160;afree(p), releases the storage thus acquired so it can be re-<br/>used later. The routines are ``rudimentary''&#160;because the calls to&#160;afree&#160;&#160;must&#160;&#160;be&#160;&#160;made&#160;&#160;in&#160;&#160;the&#160;<br/>opposite order to the calls made on&#160;alloc. That is, the storage managed by&#160;alloc&#160;and&#160;afree&#160;<br/>is a stack, or last-in, first-out. The standard library provides analogous functions called&#160;<br/>malloc&#160;and&#160;free<a href="">&#160;that have no such restrictions; in&#160;Section 8.7&#160;we will show how they can be&#160;<br/></a>implemented. &#160;<br/>
The easiest implementation is to have&#160;alloc&#160;hand out pieces of a large character array that we&#160;<br/>will call&#160;allocbuf. This array is private to&#160;alloc&#160;and&#160;afree. Since they deal in pointers, not&#160;<br/>array indices, no other routine need know the name of the array, which can be declared&#160;<br/>static&#160;in the source file containing&#160;alloc&#160;and&#160;afree, and thus be invisible outside it. In&#160;<br/>practical implementations, the array may well&#160;not even have a name; it might instead be&#160;<br/>obtained by calling&#160;malloc&#160;or by asking the operating system&#160;for a pointer to some unnamed&#160;<br/>block of storage. &#160;<br/>
The other information needed is how much of&#160;allocbuf&#160;has been used. We use a pointer,&#160;<br/>called&#160;allocp, that points to the next free element. When&#160;alloc&#160;is asked for&#160;n&#160;characters, it&#160;<br/>
<hr/>
<a name=91></a><img src="c-91_1.png"/><br/>
&#160;&#160;<br/>
91&#160;<br/>
checks to see if there is enough room&#160;left in&#160;allocbuf. If so,&#160;alloc&#160;returns the current value&#160;<br/>of&#160;allocp&#160;(i.e., the beginning of the free block), then increments it by&#160;n&#160;to point to the next&#160;<br/>free area. If there is no room,&#160;alloc&#160;returns zero.&#160;afree(p)&#160;merely sets&#160;allocp&#160;to&#160;p&#160;if&#160;p&#160;is&#160;<br/>inside&#160;allocbuf. &#160;<br/>
&#160;<br/>
&#160;<br/>&#160; &#160;#define ALLOCSIZE 10000 /* size of available space */&#160;<br/>&#160;<br/>&#160; &#160;static char allocbuf[ALLOCSIZE]; /* storage for alloc */&#160;<br/>&#160; &#160;static char *allocp = allocbuf; &#160;/* next free position */&#160;<br/>&#160;<br/>&#160; &#160;char *alloc(int n) &#160; &#160;/* return pointer to n characters */&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;if (allocbuf + ALLOCSIZE - allocp &gt;= n) { &#160;/* it fits */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;allocp += n;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;return allocp - n; /* old p */&#160;<br/>&#160; &#160; &#160; &#160;} else &#160; &#160; &#160;/* not enough room */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;return 0;&#160;<br/>&#160; &#160;}&#160;<br/>&#160;<br/>&#160; &#160;void afree(char *p) &#160;/* free storage pointed to by p */&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;if (p &gt;= allocbuf &amp;&amp; p &lt; allocbuf + ALLOCSIZE)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;allocp = p;&#160;<br/>&#160; &#160;}&#160;<br/>
In general a pointer can be initialized just as&#160;any other variable can, though normally the only&#160;<br/>meaningful values are zero or an expression involving the address of previously defined data&#160;<br/>of appropriate type. The declaration &#160;<br/>&#160;<br/>&#160; &#160;static char *allocp = allocbuf;&#160;<br/>
defines&#160;&#160;allocp&#160;to be a character pointer and initializes it to point to the beginning of&#160;<br/>allocbuf, which is the next free position when the program&#160;starts. This could also have been&#160;<br/>written &#160;<br/>&#160;<br/>&#160; &#160;static char *allocp = &amp;allocbuf[0];&#160;<br/>
since the array name&#160;<i>is</i>&#160;the address of the zeroth element. &#160;<br/>
The test &#160;<br/>
&#160;<br/>&#160; &#160; &#160; &#160;if (allocbuf + ALLOCSIZE - allocp &gt;= n) { &#160;/* it fits */&#160;<br/>
<hr/>
<a name=92></a>&#160;&#160;<br/>
92&#160;<br/>
checks if there's enough room&#160;to satisfy a request for&#160;n&#160;characters. If there is, the new value of&#160;<br/>allocp&#160;would be at most one beyond the end of&#160;allocbuf. If the request can be satisfied,&#160;<br/>
alloc&#160;returns a pointer to the beginning of a block&#160;of characters (notice the declaration of the&#160;<br/>function itself). If not,&#160;alloc&#160;must return some signal that there is no space left. C guarantees&#160;<br/>that zero is never a valid address for data, so a&#160;return value of zero can&#160;be used to signal an&#160;<br/>abnormal event, in this case no space. &#160;<br/>
Pointers and integers are not interchangeable.&#160;Zero is the sole exception: the constant zero&#160;<br/>may be assigned to a pointer, and a pointer may be compared with the constant zero. The&#160;<br/>symbolic constant&#160;NULL&#160;is often used in place of zero, as&#160;a mnemonic to indicate more clearly&#160;<br/>that this is a special value for a pointer.&#160;NULL&#160;is defined in&#160;&lt;stdio.h&gt;. We will use&#160;NULL&#160;<br/>henceforth. &#160;<br/>
Tests like &#160;<br/>
&#160;<br/>&#160; &#160; &#160; &#160;if (allocbuf + ALLOCSIZE - allocp &gt;= n) { &#160;/* it fits */&#160;<br/>
and &#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;if (p &gt;= allocbuf &amp;&amp; p &lt; allocbuf + ALLOCSIZE)&#160;<br/>
show several important facets of pointer arithmetic. First, pointers may be compared under&#160;<br/>certain circumstances. If&#160;p&#160;and&#160;q&#160;point to members of&#160;the same array, then relations like&#160;==,&#160;<br/>!=,&#160;&lt;,&#160;&gt;=, etc., work properly. For example, &#160;<br/>&#160;<br/>&#160; &#160;p &lt; q&#160;<br/>
is true if&#160;p&#160;points to an earlier element of the array than&#160;q&#160;does. Any pointer can be&#160;<br/>meaningfully compared for equality or inequality&#160;with zero. But the behavior is undefined for&#160;<br/>arithmetic or comparisons with pointers that&#160;do not point to members of the same array.&#160;<br/>(There is one exception: the address of the first element past the end of an array can be used in&#160;<br/>pointer arithmetic.) &#160;<br/>
Second, we have already observed that a pointer&#160;and an integer may be added or subtracted.&#160;<br/>The construction &#160;<br/>
&#160;<br/>&#160; &#160;p + n&#160;<br/>
means the address of the&#160;n-th object beyond the one&#160;p&#160;currently points to. This is true&#160;<br/>regardless of the kind of object&#160;p&#160;points to;&#160;n&#160;is scaled according to the size of the objects&#160;p&#160;<br/>points to, which is determined by the declaration of&#160;p. If an&#160;int&#160;is four bytes, for example, the&#160;<br/>int&#160;will be scaled by four. &#160;<br/>
Pointer subtraction is also valid: if&#160;p&#160;and&#160;q&#160;point to elements of the same array, and&#160;p&lt;q, then&#160;<br/>q-p+1&#160;is the number of elements from&#160;p&#160;to&#160;q&#160;inclusive. This fact can be used to write yet&#160;<br/>another version of&#160;strlen: &#160;<br/>
&#160;<br/>&#160; &#160;/* strlen: &#160;return length of string s */&#160;<br/>&#160; &#160;int strlen(char *s)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;char *p = s;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;while (*p != '\0')&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;p++;&#160;<br/>&#160; &#160; &#160; &#160;return p - s;&#160;<br/>&#160; &#160;}&#160;<br/>
<hr/>
<a name=93></a>&#160;&#160;<br/>
93&#160;<br/>
In its declaration,&#160;p&#160;is initialized to&#160;s, that is, to point to the first&#160;character of the string. In the&#160;<br/>while&#160;loop, each character in turn is examined until the&#160;'\0'&#160;at the end is seen. Because&#160;p&#160;<br/>points to characters,&#160;p++&#160;advances&#160;p&#160;to the next character each time, and&#160;p-s&#160;gives the number&#160;<br/>of characters advanced over, that is, the string&#160;length. (The number of characters in the string&#160;<br/>could be too large to store in an&#160;int. The header&#160;&lt;stddef.h&gt;&#160;defines a type&#160;ptrdiff_t&#160;that&#160;<br/>is large enough to hold the signed difference of two pointer values. If we&#160;were being cautious,&#160;<br/>however, we would use&#160;size_t&#160;for the return value of&#160;strlen, to match the standard library&#160;<br/>version.&#160;size_t&#160;is the unsigned integer type returned by the&#160;sizeof&#160;operator. &#160;<br/>
Pointer arithmetic is consistent: if&#160;we had been dealing with&#160;floats, which occupy more&#160;<br/>storage that&#160;chars, and if&#160;p&#160;were a pointer to&#160;float,&#160;p++&#160;would advance to the next&#160;float.&#160;<br/>Thus we could write another version of&#160;alloc&#160;that maintains&#160;floats instead of&#160;chars, merely&#160;<br/>by changing&#160;char&#160;to&#160;float&#160;throughout&#160;alloc&#160;and&#160;afree. All the pointer manipulations&#160;<br/>automatically take into account the size of the objects pointed to. &#160;<br/>
The valid pointer operations are assignment&#160;of pointers of the same&#160;type, adding or&#160;<br/>subtracting a pointer and an integer, subtracting or comparing two pointers to members of the&#160;<br/>same array, and assigning or comparing to zero. All other pointer arithmetic is illegal. It is not&#160;<br/>legal to add two pointers, or to multiply or&#160;divide or shift or mask them, or to add&#160;float&#160;or&#160;<br/>double&#160;to them, or even, except for&#160;void *, to assign a pointer of one&#160;type to a pointer of&#160;<br/>another type without a cast. &#160;<br/>
<b>5.5 Character Pointers and Functions&#160;</b><br/>
A&#160;<i>string constant</i>, written as &#160;<br/>&#160;<br/>&#160; &#160;&#34;I am a string&#34;&#160;<br/>
is an array of characters. In the internal representation, the array is terminated with the null&#160;<br/>character&#160;'\0'&#160;so that programs can find the end. The length in storage is thus one more than&#160;<br/>the number of characters between the double quotes. &#160;<br/>
Perhaps the most common occurrence of string constants is as arguments to functions, as in &#160;<br/>
&#160;<br/>&#160; &#160;printf(&#34;hello, world\n&#34;);&#160;<br/>
When a character string like this appears in a program, access to it is through a character&#160;<br/>pointer;&#160;&#160;printf&#160;receives a pointer to the beginning of&#160;the character array. That is, a string&#160;<br/>constant is accessed by a pointer to its first element. &#160;<br/>
String constants need not be function arguments. If&#160;pmessage&#160;is declared as &#160;<br/>
&#160;<br/>&#160; &#160;char *pmessage;&#160;<br/>
then the statement &#160;<br/>&#160;<br/>&#160; &#160;pmessage = &#34;now is the time&#34;;&#160;<br/>
assigns to&#160;pmessage&#160;a pointer to the character array. This is&#160;<i>not</i>&#160;a string copy; only pointers&#160;<br/>are involved. C does not provide any operators for processing an entire string of characters as&#160;<br/>a unit. &#160;<br/>
There is an important difference between these definitions: &#160;<br/>
&#160;<br/>
<hr/>
<a name=94></a><img src="c-94_1.png"/><br/>
&#160;&#160;<br/>
94&#160;<br/>
&#160; &#160;char amessage[] = &#34;now is the time&#34;; /* an array */&#160;<br/>&#160; &#160;char *pmessage = &#34;now is the time&#34;; /* a pointer */&#160;<br/>
amessage&#160;is an array, just big enough to hold the sequence of characters and&#160;'\0'&#160;that&#160;<br/>initializes it. Individual characters within the array may be changed but&#160;amessage&#160;will always&#160;<br/>refer to the same storage. On the other hand,&#160;pmessage&#160;is a pointer, initialized to point to a&#160;<br/>string constant; the pointer may subsequently be&#160;modified to point elsewhere, but the result is&#160;<br/>undefined if you try to modify the string contents. &#160;<br/>
&#160;<br/>
We will illustrate more aspects of pointers and arrays by studying versions of two useful&#160;<br/>functions adapted from&#160;the standard library. The first function is&#160;strcpy(s,t), which copies&#160;<br/>the string&#160;t&#160;to the string&#160;s. It would be nice just to say&#160;s=t&#160;but this copies the pointer, not the&#160;<br/>characters. To copy the characters, we need a loop. The array version first: &#160;<br/>
&#160;<br/>&#160; &#160;/* strcpy: &#160;copy t to s; array subscript version */&#160;<br/>&#160; &#160;void strcpy(char *s, char *t)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int i;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;i = 0;&#160;<br/>&#160; &#160; &#160; &#160;while ((s[i] = t[i]) != '\0')&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;i++;&#160;<br/>&#160; &#160;}&#160;<br/>
For contrast, here is a version of&#160;strcpy&#160;with pointers: &#160;<br/>&#160;<br/>&#160; &#160;/* strcpy: &#160;copy t to s; pointer version */&#160;<br/>&#160; &#160;void strcpy(char *s, char *t)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int i;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;i = 0;&#160;<br/>&#160; &#160; &#160; &#160;while ((*s = *t) != '\0') {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;s++;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;t++;&#160;<br/>&#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160;}&#160;<br/>
Because arguments are passed by value,&#160;strcpy&#160;can use the parameters&#160;s&#160;and&#160;t&#160;in any way it&#160;<br/>pleases. Here they are conveniently initialized&#160;pointers, which are marched along the arrays a&#160;<br/>character at a time, until the&#160;'\0'&#160;that terminates&#160;t&#160;has been copied into&#160;s. &#160;<br/>
In practice,&#160;strcpy&#160;would not be written as we showed it above. Experienced C programmers&#160;<br/>would prefer &#160;<br/>
&#160;<br/>&#160; &#160;/* strcpy: &#160;copy t to s; pointer version 2 */&#160;<br/>&#160; &#160;void strcpy(char *s, char *t)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;while ((*s++ = *t++) != '\0')&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;;&#160;<br/>
<hr/>
<a name=95></a>&#160;&#160;<br/>
95&#160;<br/>
&#160; &#160;}&#160;<br/>
This moves the increment of&#160;s&#160;and&#160;t&#160;into the test part of the loop. The value of&#160;*t++&#160;is the&#160;<br/>character that&#160;t&#160;pointed to before&#160;t&#160;was incremented; the postfix&#160;++&#160;doesn't change&#160;t&#160;until&#160;<br/>after this character has been fetched. In the same way, the character is stored into the old&#160;s&#160;<br/>position before&#160;s&#160;is incremented. This character is also the value that is compared against&#160;<br/>'\0'&#160;to control the loop. The net effect&#160;is that characters are copied from&#160;t&#160;to&#160;s, up and&#160;<br/>including the terminating&#160;'\0'. &#160;<br/>
As the final abbreviation, observe that a comparison against&#160;'\0'&#160;is redundant, since the&#160;<br/>question is merely whether the expression is zero. So the function would likely be written as &#160;<br/>
&#160;<br/>&#160; &#160;/* strcpy: &#160;copy t to s; pointer version 3 */&#160;<br/>&#160; &#160;void strcpy(char *s, char *t)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;while (*s++ = *t++)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;;&#160;<br/>&#160; &#160;}&#160;<br/>
Although this may seem&#160;cryptic at first sight,&#160;the notational convenience is considerable, and&#160;<br/>the idiom&#160;should be mastered, because you will see it frequently in C programs. &#160;<br/>
The&#160;&#160;strcpy&#160;in the standard library (&lt;string.h&gt;) returns the target string as its function&#160;<br/>value. &#160;<br/>
The second routine that we will examine is&#160;strcmp(s,t), which compares the character&#160;<br/>strings&#160;s&#160;and&#160;t, and returns negative, zero or positive if&#160;s&#160;is lexicographically less than, equal&#160;<br/>to, or greater than&#160;t. The value is obtained by subtracting the characters at the first position&#160;<br/>where&#160;s&#160;and&#160;t&#160;disagree. &#160;<br/>
&#160;<br/>&#160; &#160;/* strcmp: &#160;return &lt;0 if s&lt;t, 0 if s==t, &gt;0 if s&gt;t */&#160;<br/>&#160; &#160;int strcmp(char *s, char *t)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int i;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;for (i = 0; s[i] == t[i]; i++)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;if (s[i] == '\0')&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;return 0;&#160;<br/>&#160; &#160; &#160; &#160;return s[i] - t[i];&#160;<br/>&#160; &#160;}&#160;<br/>
The pointer version of&#160;strcmp: &#160;<br/>&#160;<br/>&#160; &#160;/* strcmp: &#160;return &lt;0 if s&lt;t, 0 if s==t, &gt;0 if s&gt;t */&#160;<br/>&#160; &#160;int strcmp(char *s, char *t)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;for ( ; *s == *t; s++, t++)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;if (*s == '\0')&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;return 0;&#160;<br/>&#160; &#160; &#160; &#160;return *s - *t;&#160;<br/>&#160; &#160;}&#160;<br/>
Since&#160;++&#160;and&#160;--&#160;are either prefix or postfix&#160;operators, other combinations of&#160;*&#160;and&#160;++&#160;and&#160;--&#160;<br/>occur, although less frequently. For example, &#160;<br/>&#160;<br/>&#160; &#160;*--p&#160;<br/>
decrements&#160;p&#160;before fetching the character that&#160;p&#160;points to. In fact, the pair of expressions &#160;<br/>&#160;<br/>&#160; &#160;*p++ = val; &#160;/* push val onto stack */&#160;<br/>&#160; &#160;val = *--p; &#160;/* pop top of stack into val */&#160;<br/>
<hr/>
<a name=96></a><img src="c-96_1.png"/><br/>
&#160;&#160;<br/>
96&#160;<br/>
are the standard idiom<a href="">&#160;for pushing and popping a stack; see&#160;Section 4.3</a>. &#160;<br/>
The header&#160;&lt;string.h&gt;&#160;contains declarations for the functions mentioned in this section, plus&#160;<br/>a variety of other string-handling functions from&#160;the standard library. &#160;<br/>
<b>Exercise 5-3.</b>&#160;Write a pointer version of the function&#160;strcat<a href="">&#160;that we showed in&#160;Chapter 2:&#160;<br/></a>strcat(s,t)&#160;copies the string&#160;t&#160;to the end of&#160;s. &#160;<br/>
<b>Exercise 5-4.</b>&#160;Write the function&#160;strend(s,t), which returns 1 if&#160;the string&#160;t&#160;occurs at the&#160;<br/>end of the string&#160;s, and zero otherwise. &#160;<br/>
<b>Exercise 5-5.</b>&#160;Write versions of the library functions&#160;strncpy,&#160;strncat, and&#160;strncmp, which&#160;<br/>operate on at most the first&#160;n&#160;characters of their argument strings. For example,&#160;<br/>strncpy(s,t,n)&#160;copies at most&#160;n&#160;characters of&#160;t&#160;to&#160;s<a href="">. Full descriptions are in&#160;Appendix B. &#160;</a><br/>
<b>Exercise 5-6.</b>&#160;Rewrite appropriate programs from&#160;earlier chapters and exercises with pointers&#160;<br/>instead of array indexing. Good possibilities include&#160;getline&#160;(<a href="">Chapters 1</a>&#160;and&#160;<a href="">4),&#160;</a>atoi,&#160;itoa,&#160;<br/>and their variants (<a href="">Chapters 2</a>,&#160;&#160;<a href="">3, and&#160;4</a>),&#160;&#160;reverse&#160;&#160;<a href="">(Chapter 3), and&#160;</a>strindex&#160;and&#160;getop&#160;<br/><a href="">(Chapter 4). &#160;</a><br/>
<b>5.6 Pointer Arrays; Pointers to Pointers&#160;</b><br/>
Since pointers are variables themselves, they can&#160;be stored in arrays just as other variables&#160;<br/>can. Let us illustrate by writing a program&#160;that will sort a set of&#160;text lines into alphabetic&#160;<br/>order, a stripped-down version of the UNIX program&#160;sort. &#160;<br/>
In&#160;<a href="">Chapter 3, we presented a Shell sort function that&#160;</a>would sort an array of integers, and in&#160;<br/><a href="">Chapter 4</a>&#160;we improved on it with a quicksort. The&#160;same algorithms will work, except that&#160;<br/>now we have to deal with lines of text, which are of different lengths, and which, unlike&#160;<br/>integers, can't be compared or moved in a single operation. We need a data representation that&#160;<br/>will cope efficiently and conveniently with variable-length text lines. &#160;<br/>
This is where the array of pointers enters. If the lines to be sorted are stored end-to-end in one&#160;<br/>long character array, then each line can be accessed by a pointer to its first character. The&#160;<br/>pointers themselves can bee stored in an array. Two lines can be compared by passing their&#160;<br/>pointers to&#160;strcmp. When two out-of-order lines have to be exchanged, the pointers in the&#160;<br/>pointer array are exchanged, not the text lines themselves. &#160;<br/>
&#160;<br/>
This eliminates the twin problems of&#160;complicated storage management and high overhead that&#160;<br/>would go with moving the lines themselves. &#160;<br/>
The sorting process has three steps: &#160;<br/>
<hr/>
<a name=97></a>&#160;&#160;<br/>
97&#160;<br/>
<i>&#160; read all the lines of input&#160;<br/>&#160; sort them&#160;<br/>&#160; print them in order&#160;</i>&#160;<br/>
As usual, it's best to divide the program&#160;into&#160;functions that match this natural division, with&#160;<br/>the main routine controlling the other functions.&#160;Let us defer the sorting step for a moment,&#160;<br/>and concentrate on the data structure and the input and output. &#160;<br/>
The input routine has to collect and save the&#160;characters of each line,&#160;and build an array of&#160;<br/>pointers to the lines. It will also have to&#160;count the number of input lines, since that&#160;<br/>information is needed for sorting and printing.&#160;Since the input function can only cope with a&#160;<br/>finite number of input lines, it can return some illegal count like&#160;-1&#160;if too much input is&#160;<br/>presented. &#160;<br/>
The output routine only has to print the lines in the order in which they appear in the array of&#160;<br/>pointers. &#160;<br/>
&#160;<br/>&#160; &#160;#include &lt;stdio.h&gt;&#160;<br/>&#160; &#160;#include &lt;string.h&gt;&#160;<br/>&#160;<br/>&#160; &#160;#define MAXLINES 5000 &#160; &#160; /* max #lines to be sorted */&#160;<br/>&#160;<br/>&#160; &#160;char *lineptr[MAXLINES]; &#160;/* pointers to text lines */&#160;<br/>&#160;<br/>&#160; &#160;int readlines(char *lineptr[], int nlines);&#160;<br/>&#160; &#160;void writelines(char *lineptr[], int nlines);&#160;<br/>&#160;<br/>&#160; &#160;void qsort(char *lineptr[], int left, int right);&#160;<br/>&#160;<br/>&#160; &#160;/* sort input lines */&#160;<br/>&#160; &#160;main()&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int nlines; &#160; &#160; /* number of input lines read */&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;if ((nlines = readlines(lineptr, MAXLINES)) &gt;= 0) {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;qsort(lineptr, 0, nlines-1);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;writelines(lineptr, nlines);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;return 0;&#160;<br/>&#160; &#160; &#160; &#160;} else {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;printf(&#34;error: input too big to sort\n&#34;);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;return 1;&#160;<br/>&#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160;}&#160;<br/>&#160;<br/>&#160; &#160;#define MAXLEN 1000 &#160;/* max length of any input line */&#160;<br/>&#160; &#160;int getline(char *, int);&#160;<br/>&#160; &#160;char *alloc(int);&#160;<br/>&#160;<br/>&#160; &#160;/* readlines: &#160;read input lines */&#160;<br/>&#160; &#160;int readlines(char *lineptr[], int maxlines)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int len, nlines;&#160;<br/>&#160; &#160; &#160; &#160;char *p, line[MAXLEN];&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;nlines = 0;&#160;<br/>&#160; &#160; &#160; &#160;while ((len = getline(line, MAXLEN)) &gt; 0)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;if (nlines &gt;= maxlines || p = alloc(len) == NULL)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;return -1;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;else {&#160;<br/>
<hr/>
<a name=98></a>&#160;&#160;<br/>
98&#160;<br/>
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;line[len-1] = '\0'; &#160;/* delete newline */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;strcpy(p, line);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;lineptr[nlines++] = p;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160; &#160; &#160;return nlines;&#160;<br/>&#160; &#160;}&#160;<br/>&#160;<br/>&#160; &#160;/* writelines: &#160;write output lines */&#160;<br/>&#160; &#160;void writelines(char *lineptr[], int nlines)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int i;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;for (i = 0; i &lt; nlines; i++)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;printf(&#34;%s\n&#34;, lineptr[i]);&#160;<br/>&#160; &#160;}&#160;<br/>
The function&#160;getline&#160;is from&#160;<a href="">Section 1.9. &#160;</a><br/>
The main new thing is the declaration for&#160;lineptr: &#160;<br/>
&#160;<br/>&#160; &#160;char *lineptr[MAXLINES]&#160;<br/>
says that&#160;lineptr&#160;is an array of&#160;MAXLINES&#160;elements, each element of which is a pointer to a&#160;<br/>char. That is,&#160;lineptr[i]&#160;is a character pointer, and&#160;*lineptr[i]&#160;is the character it points&#160;<br/>to, the first character of the&#160;i-th saved text line. &#160;<br/>
Since&#160;lineptr&#160;is itself the name of an array, it can be treated as a pointer in the same manner&#160;<br/>as in our earlier examples, and&#160;writelines&#160;can be written instead as &#160;<br/>
&#160;<br/>&#160; &#160;/* writelines: &#160;write output lines */&#160;<br/>&#160; &#160;void writelines(char *lineptr[], int nlines)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;while (nlines-- &gt; 0)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;printf(&#34;%s\n&#34;, *lineptr++);&#160;<br/>&#160; &#160;}&#160;<br/>
Initially,&#160;&#160;*lineptr&#160;points to the first line; each element&#160;advances it to the next line pointer&#160;<br/>while&#160;nlines&#160;is counted down. &#160;<br/>
With input and output under control, we can&#160;proceed to sorting. The quicksort from&#160;<a href="">Chapter 4&#160;<br/></a>needs minor changes: the declarations have&#160;to be modified, and the comparison operation&#160;<br/>must be done by calling&#160;strcmp. The algorithm&#160;remains the same, which gives us some&#160;<br/>confidence that it will still work. &#160;<br/>
&#160;<br/>&#160; &#160;/* qsort: &#160;sort v[left]...v[right] into increasing order */&#160;<br/>&#160; &#160;void qsort(char *v[], int left, int right)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int i, last;&#160;<br/>&#160; &#160; &#160; &#160;void swap(char *v[], int i, int j);&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;if (left &gt;= right) &#160;/* do nothing if array contains */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;return; &#160; &#160; &#160; &#160; /* fewer than two elements */&#160;<br/>&#160; &#160; &#160; &#160;swap(v, left, (left + right)/2);&#160;<br/>&#160; &#160; &#160; &#160;last = left;&#160;<br/>&#160; &#160; &#160; &#160;for (i = left+1; i &lt;= right; i++)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;if (strcmp(v[i], v[left]) &lt; 0)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;swap(v, ++last, i);&#160;<br/>&#160; &#160; &#160; &#160;swap(v, left, last);&#160;<br/>&#160; &#160; &#160; &#160;qsort(v, left, last-1);&#160;<br/>
<hr/>
<a name=99></a>&#160;&#160;<br/>
99&#160;<br/>
&#160; &#160; &#160; &#160;qsort(v, last+1, right);&#160;<br/>&#160; &#160;}&#160;<br/>
Similarly, the swap routine needs only trivial changes: &#160;<br/>&#160;<br/>&#160; &#160;/* swap: &#160;interchange v[i] and v[j] */&#160;<br/>&#160; &#160;void swap(char *v[], int i, int j)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;char *temp;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;temp = v[i];&#160;<br/>&#160; &#160; &#160; &#160;v[i] = v[j];&#160;<br/>&#160; &#160; &#160; &#160;v[j] = temp;&#160;<br/>&#160; &#160;}&#160;<br/>
Since any individual element of&#160;v&#160;(alias&#160;lineptr) is a character pointer,&#160;temp&#160;must be also, so&#160;<br/>one can be copied to the other. &#160;<br/>
<b>Exercise 5-7.</b>&#160;Rewrite&#160;readlines&#160;to store lines in an array supplied by&#160;main, rather than&#160;<br/>calling&#160;alloc&#160;to maintain storage. How much faster is the program? &#160;<br/>
<b>5.7 Multi-dimensional Arrays&#160;</b><br/>
C provides rectangular multi-dimensional arrays,&#160;although in practice they are much less used&#160;<br/>than arrays of&#160;pointers. In this section, we will show some of&#160;their properties. &#160;<br/>
Consider the problem&#160;of date conversion, from&#160;day of the month to day of the year and vice&#160;<br/>versa. For example, March 1 is the 60th day of&#160;a non-leap year, and the 61st day of a leap&#160;<br/>year. Let us define two functions to do the conversions:&#160;day_of_year&#160;converts the month and&#160;<br/>day into the day of the year, and&#160;month_day&#160;converts the day of the year into the month and&#160;<br/>day. Since this latter function computes two&#160;values, the month and day arguments will be&#160;<br/>pointers: &#160;<br/>
&#160;<br/>&#160; &#160;month_day(1988, 60, &amp;m, &amp;d)&#160;<br/>
sets&#160;m&#160;to 2 and&#160;d&#160;to 29 (February 29th). &#160;<br/>
These functions both need the same information,&#160;a table of the number of days in each month&#160;<br/>(``thirty days hath September ...''). Since the number of days per month differs for leap years&#160;<br/>and non-leap years, it's easier to separate them&#160;into two rows of a two-dimensional array than&#160;<br/>to keep track of what happens to February&#160;during computation. The array and the functions&#160;<br/>for performing the transformations are as follows: &#160;<br/>
&#160;<br/>&#160; &#160;static char daytab[2][13] = {&#160;<br/>&#160; &#160; &#160; &#160;{0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},&#160;<br/>&#160; &#160; &#160; &#160;{0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}&#160;<br/>&#160; &#160;};&#160;<br/>&#160;<br/>&#160; &#160;/* day_of_year: &#160;set day of year from month &amp; day */&#160;<br/>&#160; &#160;int day_of_year(int year, int month, int day)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int i, leap;&#160;<br/>&#160; &#160; &#160; &#160;leap = year%4 == 0 &amp;&amp; year%100 != 0 || year%400 == 0;&#160;<br/>&#160; &#160; &#160; &#160;for (i = 1; i &lt; month; i++)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;day += daytab[leap][i];&#160;<br/>&#160; &#160; &#160; &#160;return day;&#160;<br/>&#160; &#160;}&#160;<br/>&#160;<br/>
<hr/>
<a name=100></a>&#160;&#160;<br/>
100&#160;<br/>
&#160; &#160;/* month_day: &#160;set month, day from day of year */&#160;<br/>&#160; &#160;void month_day(int year, int yearday, int *pmonth, int *pday)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int i, leap;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;leap = year%4 == 0 &amp;&amp; year%100 != 0 || year%400 == 0;&#160;<br/>&#160; &#160; &#160; &#160;for (i = 1; yearday &gt; daytab[leap][i]; i++)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;yearday -= daytab[leap][i];&#160;<br/>&#160; &#160; &#160; &#160;*pmonth = i;&#160;<br/>&#160; &#160; &#160; &#160;*pday = yearday;&#160;<br/>&#160; &#160;}&#160;<br/>
Recall that the arithmetic value of&#160;a logical expression, such as the one for&#160;leap, is either zero&#160;<br/>(false) or one (true), so it can be used as a subscript of the array&#160;daytab. &#160;<br/>
The array&#160;daytab&#160;has to be external to both&#160;day_of_year&#160;and&#160;month_day, so they can both&#160;<br/>use it. We made it&#160;char&#160;to illustrate a legitimate use of&#160;char&#160;for storing small non-character&#160;<br/>integers. &#160;<br/>
daytab&#160;is the first two-dimensional array we have&#160;dealt with. In C, a two-dimensional array is&#160;<br/>really a one-dimensional array, each of whose elements is an array. Hence subscripts are&#160;<br/>written as &#160;<br/>
&#160;<br/>&#160; &#160;daytab[i][j] &#160; &#160;/* [row][col] */&#160;<br/>
rather than &#160;<br/>&#160;<br/>&#160; &#160;daytab[i,j] &#160; &#160;/* WRONG */&#160;<br/>
Other than this notational distinction, a two-dimensional array can be treated in much the&#160;<br/>same way as in other languages. Elements are stored by rows, so the rightmost subscript, or&#160;<br/>column, varies fastest as elements are accessed in storage order. &#160;<br/>
An array is initialized by a list of initializers in&#160;braces; each row of a two-dimensional array is&#160;<br/>initialized by a corresponding sub-list. We started the array&#160;daytab&#160;with a column&#160;of zero so&#160;<br/>that month numbers can run from&#160;the natural 1 to&#160;12 instead of 0 to 11. Since space is not at a&#160;<br/>premium&#160;here, this is clearer than adjusting the indices. &#160;<br/>
If a two-dimensional array is to be passed to&#160;a function, the parameter declaration in the&#160;<br/>function must include the number of columns; the&#160;number of rows is irrelevant, since what is&#160;<br/>passed is, as before, a pointer to an array&#160;of rows, where each row is an array of 13&#160;ints. In&#160;<br/>this particular case, it is a pointer&#160;to objects that are arrays of 13&#160;ints. Thus if the array&#160;<br/>daytab&#160;is to be passed to a function&#160;f, the declaration of&#160;f&#160;would be: &#160;<br/>
&#160;<br/>&#160; &#160;f(int daytab[2][13]) { ... }&#160;<br/>
It could also be &#160;<br/>&#160;<br/>&#160; &#160;f(int daytab[][13]) { ... }&#160;<br/>
since the number of rows is irrelevant, or it could be &#160;<br/>&#160;<br/>&#160; &#160;f(int (*daytab)[13]) { ... }&#160;<br/>
which says that the parameter is a pointer to&#160;an array of 13 integers. The parentheses are&#160;<br/>necessary since brackets&#160;[]&#160;have higher precedence than&#160;*. Without parentheses, the&#160;<br/>declaration &#160;<br/>&#160;<br/>&#160; &#160;int *daytab[13]&#160;<br/>
<hr/>
<a name=101></a>&#160;&#160;<br/>
101&#160;<br/>
is an array of 13 pointers to integers. More generally, only the first dimension (subscript) of&#160;<br/>an array is free; all the others have to be specified. &#160;<br/>
<a href="">Section 5.12</a>&#160;has a further discussion of complicated declarations. &#160;<br/>
<b>Exercise 5-8.</b>&#160;There is no error checking in&#160;day_of_year&#160;or&#160;month_day. Remedy this defect. &#160;<br/>
<b>5.8 Initialization of Pointer Arrays&#160;</b><br/>
Consider the problem&#160;of writing a function&#160;month_name(n), which returns a pointer to a&#160;<br/>character string containing the name of the&#160;n-th month. This is an ideal application for an&#160;<br/>internal&#160;static&#160;array.&#160;month_name&#160;contains a private array of&#160;character strings, and returns a&#160;<br/>pointer to the proper one when called. This&#160;section shows how that array of names is&#160;<br/>initialized. &#160;<br/>
The syntax is similar to previous initializations: &#160;<br/>
&#160;<br/>&#160; &#160;/* month_name: &#160;return name of n-th month */&#160;<br/>&#160; &#160;char *month_name(int n)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;static char *name[] = {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;&#34;Illegal month&#34;,&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;&#34;January&#34;, &#34;February&#34;, &#34;March&#34;,&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;&#34;April&#34;, &#34;May&#34;, &#34;June&#34;,&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;&#34;July&#34;, &#34;August&#34;, &#34;September&#34;,&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;&#34;October&#34;, &#34;November&#34;, &#34;December&#34;&#160;<br/>&#160; &#160; &#160; &#160;};&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;return (n &lt; 1 || n &gt; 12) ? name[0] : name[n];&#160;<br/>&#160; &#160;}&#160;<br/>
The declaration of&#160;name, which is an array of character pointers, is the same as&#160;lineptr&#160;in the&#160;<br/>sorting example. The initializer is a list of&#160;character strings; each is assigned to the&#160;<br/>corresponding position in the array. The characters of the&#160;i-th string are placed somewhere,&#160;<br/>and a pointer to them&#160;is stored in&#160;name[i]. Since the size of the array&#160;name&#160;is not specified,&#160;<br/>the compiler counts the initializers and fills in the correct number. &#160;<br/>
<b>5.9 Pointers vs. Multi-dimensional Arrays&#160;</b><br/>
Newcomers to C are sometimes confused about&#160;the difference between a two-dimensional&#160;<br/>array and an array of pointers, such as&#160;name&#160;in the example above. Given the definitions &#160;<br/>&#160;<br/>&#160; &#160;int a[10][20];&#160;<br/>&#160; &#160;int *b[10];&#160;<br/>
then&#160;a[3][4]&#160;and&#160;b[3][4]&#160;are both syntactically legal references to a single&#160;int. But&#160;a&#160;is a&#160;<br/>true two-dimensional array: 200&#160;int-sized locations have been set aside, and the conventional&#160;<br/>rectangular subscript calculation 20 *&#160;<i>row</i>&#160;+<i>col</i>&#160;is used to find the element&#160;a[row,col]. For&#160;b,&#160;<br/>however, the definition only allocates 10 pointers and does not initialize them; initialization&#160;<br/>must be done explicitly, either statically or&#160;with code. Assuming that each element of&#160;b&#160;does&#160;<br/>point to a twenty-element array, then there will be 200&#160;ints set aside, plus ten cells for the&#160;<br/>pointers. The important advantage of the pointer array is that the rows of&#160;the array may be of&#160;<br/>different lengths. That is, each element of&#160;b&#160;need not point to a twenty-element vector; some&#160;<br/>may point to two elements, some&#160;to fifty, and some&#160;to none at all. &#160;<br/>
<hr/>
<a name=102></a><img src="c-102_1.png"/><br/>
<img src="c-102_2.png"/><br/>
102<br/>
Although we have phrased this discussion in terms&#160;of integers, by far the most frequent use of&#160;<br/>arrays of pointers is to store character strings of diverse lengths, as in the function&#160;<br/>month_name. Compare the declaration and picture for an array of pointers: &#160;<br/>
&#160; &#160;char *name[] = { &#34;Illegal month&#34;, &#34;Jan&#34;, &#34;Feb&#34;, &#34;Mar&#34; };&#160;<br/>
with those for a two-dimensional array: &#160;<br/>
&#160; &#160;char aname[][15] = { &#34;Illegal month&#34;, &#34;Jan&#34;, &#34;Feb&#34;, &#34;Mar&#34; };&#160;<br/>
<b>Exercise 5-9.</b>&#160;Rewrite the routines&#160;day_of_year&#160;and&#160;month_day&#160;with pointers instead of&#160;<br/>indexing. &#160;<br/>
<b>5.10 Command-line Arguments&#160;</b><br/>
In environments that support C, there is a way to pass command-line arguments or parameters&#160;<br/>to a program&#160;when it begins executing. When&#160;main&#160;is called, it is called with two arguments.&#160;<br/>The first (conventionally called&#160;argc, for argument count) is the number of command-line&#160;<br/>arguments the program&#160;was invoked with; the second (argv, for argument vector) is a pointer&#160;<br/>to an array of character strings that contain&#160;the arguments, one per string. We customarily use&#160;<br/>multiple levels of&#160;pointers to manipulate these character strings. &#160;<br/>
The simplest illustration is the program&#160;echo, which echoes its command-line arguments on a&#160;<br/>single line, separated by blanks. That is, the command &#160;<br/>
&#160; &#160;echo hello, world&#160;<br/>
prints the output &#160;<br/>
&#160; &#160;hello, world&#160;<br/>
By convention,&#160;argv[0]&#160;is the name&#160;by which the program&#160;was invoked, so&#160;argc&#160;is at least 1.&#160;<br/>If&#160;&#160;argc&#160;is 1, there are no command-line arguments&#160;after the program&#160;name. In the example&#160;<br/>above,&#160;argc&#160;is 3, and&#160;argv[0],&#160;argv[1], and&#160;argv[2]&#160;are&#160;&#34;echo&#34;,&#160;&#34;hello,&#34;, and&#160;&#34;world&#34;&#160;<br/>respectively. The first optional argument is&#160;argv[1]&#160;and the last is&#160;argv[argc-1];&#160;<br/>additionally, the standard requires that&#160;argv[argc]&#160;be a null pointer. &#160;<br/>
<hr/>
<a name=103></a><img src="c-103_1.png"/><br/>
&#160;&#160;<br/>
103&#160;<br/>
&#160;<br/>
The first version of&#160;echo&#160;treats&#160;argv&#160;as an array of character pointers: &#160;<br/>
&#160;<br/>&#160; &#160;#include &lt;stdio.h&gt;&#160;<br/>&#160;<br/>&#160; &#160;/* echo command-line arguments; 1st version */&#160;<br/>&#160; &#160;main(int argc, char *argv[])&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int i;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;for (i = 1; i &lt; argc; i++)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;printf(&#34;%s%s&#34;, argv[i], (i &lt; argc-1) ? &#34; &#34; : &#34;&#34;);&#160;<br/>&#160; &#160; &#160; &#160;printf(&#34;\n&#34;);&#160;<br/>&#160; &#160; &#160; &#160;return 0;&#160;<br/>&#160; &#160;}&#160;<br/>
Since&#160;&#160;argv&#160;is a pointer to an array of pointers,&#160;we can manipulate the pointer rather than&#160;<br/>index the array. This next variant is based on incrementing&#160;argv, which is a pointer to pointer&#160;<br/>to&#160;char, while&#160;argc&#160;is counted down: &#160;<br/>&#160;<br/>&#160; &#160;#include &lt;stdio.h&gt;&#160;<br/>&#160;<br/>&#160; &#160;/* echo command-line arguments; 2nd version */&#160;<br/>&#160; &#160;main(int argc, char *argv[])&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;while (--argc &gt; 0)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;printf(&#34;%s%s&#34;, *++argv, (argc &gt; 1) ? &#34; &#34; : &#34;&#34;);&#160;<br/>&#160; &#160; &#160; &#160;printf(&#34;\n&#34;);&#160;<br/>&#160; &#160; &#160; &#160;return 0;&#160;<br/>&#160; &#160;}&#160;<br/>
Since&#160;argv&#160;is a pointer to the beginning of the array of argument strings, incrementing it by 1&#160;<br/>(++argv) makes it point at the original&#160;argv[1]&#160;instead of&#160;argv[0]. Each successive&#160;<br/>increment moves it along to the next argument;&#160;*argv&#160;is then the pointer to that argument. At&#160;<br/>the same time,&#160;argc&#160;is decremented; when it becomes zero, there are no arguments left to&#160;<br/>print. &#160;<br/>
Alternatively, we could write the&#160;printf&#160;statement as &#160;<br/>
&#160;<br/>&#160; &#160;printf((argc &gt; 1) ? &#34;%s &#34; : &#34;%s&#34;, *++argv);&#160;<br/>
This shows that the format argument of&#160;printf&#160;can be an expression too. &#160;<br/>
As a second example, let us make some enhancements to the pattern-finding program&#160;from&#160;<br/><a href="">Section 4.1. If you recall, we wired the search patte</a>rn deep into the program, an obviously&#160;<br/>unsatisfactory arrangement. Following the lead of the UNIX program&#160;grep, let us enhance the&#160;<br/>program&#160;so the pattern to be matched is specified by the first argument on the command line. &#160;<br/>
<hr/>
<a name=104></a>&#160;&#160;<br/>
104&#160;<br/>
&#160;<br/>&#160; &#160;#include &lt;stdio.h&gt;&#160;<br/>&#160; &#160;#include &lt;string.h&gt;&#160;<br/>&#160; &#160;#define MAXLINE 1000&#160;<br/>&#160;<br/>&#160; &#160;int getline(char *line, int max);&#160;<br/>&#160;<br/>&#160; &#160;/* find: &#160;print lines that match pattern from 1st arg */&#160;<br/>&#160; &#160;main(int argc, char *argv[])&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;char line[MAXLINE];&#160;<br/>&#160; &#160; &#160; &#160;int found = 0;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;if (argc != 2)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;printf(&#34;Usage: find pattern\n&#34;);&#160;<br/>&#160; &#160; &#160; &#160;else&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;while (getline(line, MAXLINE) &gt; 0)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;if (strstr(line, argv[1]) != NULL) {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;printf(&#34;%s&#34;, line);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;found++;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160; &#160; &#160;return found;&#160;<br/>&#160; &#160;}&#160;<br/>
The standard library function&#160;strstr(s,t)&#160;returns a pointer to the first occurrence of the&#160;<br/>string&#160;t&#160;in the string&#160;s, or&#160;NULL&#160;if there is none. It is declared in&#160;&lt;string.h&gt;. &#160;<br/>
The model can now be elaborated to illustrate&#160;further pointer constructions. Suppose we want&#160;<br/>to allow two optional arguments.&#160;One says ``print all the lines&#160;<i>except</i>&#160;those that match the&#160;<br/>pattern;''&#160;the second says ``precede each printed line by its line number.''&#160;&#160;<br/>
A common convention for C programs on UNIX systems is that an argument that begins with&#160;<br/>a minus sign introduces an optional flag or parameter. If we choose&#160;-x&#160;(for ``except'')&#160;to&#160;<br/>signal the inversion, and&#160;-n&#160;(``number'') to request line numbering, then the command &#160;<br/>
&#160;<br/>&#160; &#160;find -x -n<i>pattern</i>&#160;<br/>
will print each line that doesn't&#160;match the pattern, preceded by its line number. &#160;<br/>
Optional arguments should be permitted in any order, and the rest of the program&#160;should be&#160;<br/>independent of the number of arguments that we present. Furthermore, it is convenient for&#160;<br/>users if option arguments can be combined, as in &#160;<br/>
&#160;<br/>&#160; &#160;find -nx&#160;<i>pattern</i>&#160;<br/>
Here is the program: &#160;<br/>&#160;<br/>&#160; &#160;#include &lt;stdio.h&gt;&#160;<br/>&#160; &#160;#include &lt;string.h&gt;&#160;<br/>&#160; &#160;#define MAXLINE 1000&#160;<br/>&#160;<br/>&#160; &#160;int getline(char *line, int max);&#160;<br/>&#160;<br/>&#160; &#160;/* find: print lines that match pattern from 1st arg */&#160;<br/>&#160; &#160;main(int argc, char *argv[])&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;char line[MAXLINE];&#160;<br/>&#160; &#160; &#160; &#160;long lineno = 0;&#160;<br/>&#160; &#160; &#160; &#160;int c, except = 0, number = 0, found = 0;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;while (--argc &gt; 0 &amp;&amp; (*++argv)[0] == '-')&#160;<br/>
<hr/>
<a name=105></a>&#160;&#160;<br/>
105&#160;<br/>
&#160; &#160; &#160; &#160; &#160; &#160;while (c = *++argv[0])&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;switch (c) {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;case 'x':&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;except = 1;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;break;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;case 'n':&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;number = 1;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;break;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;default:&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;printf(&#34;find: illegal option %c\n&#34;, c);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;argc = 0;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;found = -1;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;break;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160; &#160; &#160;if (argc != 1)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;printf(&#34;Usage: find -x -n pattern\n&#34;);&#160;<br/>&#160; &#160; &#160; &#160;else&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;while (getline(line, MAXLINE) &gt; 0) {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;lineno++;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;if ((strstr(line, *argv) != NULL) != except) {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;if (number)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;printf(&#34;%ld:&#34;, lineno);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;printf(&#34;%s&#34;, line);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;found++;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160; &#160; &#160;return found;&#160;<br/>&#160; &#160;}&#160;<br/>
argc&#160;is decremented and&#160;argv&#160;is incremented before each optional argument. At the end of&#160;<br/>the loop, if there are no errors,&#160;argc&#160;tells how many arguments remain unprocessed and&#160;argv&#160;<br/>points to the first of these. Thus&#160;argc&#160;should be 1 and&#160;*argv&#160;should point at the pattern.&#160;<br/>Notice that&#160;*++argv&#160;is a pointer to an argument string, so&#160;(*++argv)[0]&#160;is its first character.&#160;<br/>(An alternate valid form&#160;would be&#160;**++argv.) Because&#160;[]&#160;binds tighter than&#160;*&#160;and&#160;++, the&#160;<br/>parentheses are necessary; without them&#160;the expression would be taken as&#160;*++(argv[0]). In&#160;<br/>fact, that is what we have used in the inner&#160;loop, where the task is to walk along a specific&#160;<br/>argument string. In the inner loop, the expression&#160;*++argv[0]&#160;increments the pointer&#160;<br/>argv[0]! &#160;<br/>
It is rare that one uses pointer expressions&#160;more complicated than these; in such cases,&#160;<br/>breaking them&#160;into two or three steps will be more intuitive. &#160;<br/>
<b>Exercise 5-10.</b>&#160;Write the program&#160;expr, which evaluates a reverse Polish expression from&#160;the&#160;<br/>command line, where each operator or operand is a separate argument. For example, &#160;<br/>
&#160;<br/>&#160; &#160;expr 2 3 4 + *&#160;<br/>
evaluates 2 * (3+4). &#160;<br/>
<b>Exercise 5-11.</b>&#160;Modify the program&#160;entab&#160;and&#160;detab<a href="">&#160;(written as exercises in&#160;Chapter 1</a>) to&#160;<br/>accept a list of tab stops as arguments. Use the default tab settings if there are no arguments. &#160;<br/>
<b>Exercise 5-12.</b>&#160;Extend&#160;entab&#160;and&#160;detab&#160;to accept the shorthand &#160;<br/>
&#160;<br/>&#160; &#160;entab&#160;<i>-m +n</i>&#160;<br/>
to mean tab stops every&#160;<i>n</i>&#160;columns, starting at column&#160;<i>m</i>. Choose convenient (for the user)&#160;<br/>default behavior. &#160;<br/>
<hr/>
<a name=106></a>&#160;&#160;<br/>
106&#160;<br/>
<b>Exercise 5-13.</b>&#160;Write the program&#160;tail, which prints the last&#160;<i>n</i>&#160;lines of its input. By default,&#160;<i>n</i>&#160;<br/>is set to 10, let us say, but it can be changed by an optional argument so that &#160;<br/>
&#160;<br/>&#160; &#160;tail&#160;<i>-n</i>&#160;<br/>
prints the last&#160;<i>n</i>&#160;lines. The program&#160;should behave rationally no matter how unreasonable the&#160;<br/>input or the value of&#160;<i>n</i>. Write the program&#160;so it makes the best use of available storage; lines&#160;<br/>should be stored as in the sorting program<a href="">&#160;of&#160;Section 5.6, not in a two-dim</a>ensional array of&#160;<br/>fixed size. &#160;<br/>
<b>5.11 Pointers to Functions&#160;</b><br/>
In C, a function itself is not a variable, but it is&#160;possible to define pointers to functions, which&#160;<br/>can be assigned, placed in arrays, passed to functions, returned by functions, and so on. We&#160;<br/>will illustrate this by modifying the sorting procedure written earlier in this chapter so that if&#160;<br/>the optional argument&#160;-n&#160;is given, it will sort the input&#160;lines numerically instead of&#160;<br/>lexicographically. &#160;<br/>
A sort often consists of three parts - a comparison that determines the ordering of any pair of&#160;<br/>objects, an exchange that reverses their order,&#160;and a sorting algorithm&#160;that makes comparisons&#160;<br/>and exchanges until the objects are in order.&#160;The sorting algorithm&#160;is independent of&#160;the&#160;<br/>comparison and exchange operations, so by&#160;passing different comparison and exchange&#160;<br/>functions to it, we can arrange to sort by different criteria. This is the approach taken in our&#160;<br/>new sort. &#160;<br/>
Lexicographic comparison of two lines is done by&#160;strcmp, as before; we will also need a&#160;<br/>routine&#160;&#160;numcmp&#160;that compares two lines on the basis&#160;of numeric value and returns the same&#160;<br/>kind of condition indication as&#160;strcmp&#160;does. These functions are declared ahead of&#160;main&#160;and&#160;<br/>a pointer to the appropriate one is passed to&#160;qsort. We have skimped on error processing for&#160;<br/>arguments, so as to concentrate on the main issues. &#160;<br/>
&#160;<br/>&#160; &#160;#include &lt;stdio.h&gt;&#160;<br/>&#160; &#160;#include &lt;string.h&gt;&#160;<br/>&#160;<br/>&#160; &#160;#define MAXLINES 5000 &#160; &#160; /* max #lines to be sorted */&#160;<br/>&#160; &#160;char *lineptr[MAXLINES]; &#160;/* pointers to text lines */&#160;<br/>&#160;<br/>&#160; &#160;int readlines(char *lineptr[], int nlines);&#160;<br/>&#160; &#160;void writelines(char *lineptr[], int nlines);&#160;<br/>&#160;<br/>&#160; &#160;void qsort(void *lineptr[], int left, int right,&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; int (*comp)(void *, void *));&#160;<br/>&#160; &#160;int numcmp(char *, char *);&#160;<br/>&#160;<br/>&#160; &#160;/* sort input lines */&#160;<br/>&#160; &#160;main(int argc, char *argv[])&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int nlines; &#160; &#160; &#160; &#160;/* number of input lines read */&#160;<br/>&#160; &#160; &#160; &#160;int numeric = 0; &#160; /* 1 if numeric sort */&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;if (argc &gt; 1 &amp;&amp; strcmp(argv[1], &#34;-n&#34;) == 0)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;numeric = 1;&#160;<br/>&#160; &#160; &#160; &#160;if ((nlines = readlines(lineptr, MAXLINES)) &gt;= 0) {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;qsort((void**) lineptr, 0, nlines-1,&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160;(int (*)(void*,void*))(numeric ? numcmp : strcmp));&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;writelines(lineptr, nlines);&#160;<br/>
<hr/>
<a name=107></a>&#160;&#160;<br/>
107&#160;<br/>
&#160; &#160; &#160; &#160; &#160; &#160;return 0;&#160;<br/>&#160; &#160; &#160; &#160;} else {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;printf(&#34;input too big to sort\n&#34;);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;return 1;&#160;<br/>&#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160;}&#160;<br/>
In the call to&#160;qsort,&#160;strcmp&#160;and&#160;numcmp&#160;are addresses of functions. Since they are known to&#160;<br/>be functions, the&#160;&amp;&#160;is not necessary, in the same way that it is not needed before an array&#160;<br/>name. &#160;<br/>
We have written&#160;qsort&#160;so it can process any data type, not&#160;just character strings. As indicated&#160;<br/>by the function prototype,&#160;qsort&#160;expects an array of pointers,&#160;two integers, and a function&#160;<br/>with two pointer arguments. The generic pointer type&#160;void *&#160;is used for the pointer&#160;<br/>arguments. Any pointer can be cast to&#160;void *&#160;and back again without loss of information, so&#160;<br/>we can call&#160;qsort&#160;by casting arguments to&#160;void *. The elaborate cast of the function&#160;<br/>argument casts the arguments of&#160;the comparison&#160;function. These will generally have no effect&#160;<br/>on actual representation, but assure the compiler that all is well. &#160;<br/>
&#160;<br/>&#160; &#160;/* qsort: &#160;sort v[left]...v[right] into increasing order */&#160;<br/>&#160; &#160;void qsort(void *v[], int left, int right,&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; int (*comp)(void *, void *))&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int i, last;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;void swap(void *v[], int, int);&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;if (left &gt;= right) &#160; &#160;/* do &#160;nothing if array contains */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;return; &#160; &#160; &#160; &#160; &#160; /* fewer than two elements */&#160;<br/>&#160; &#160; &#160; &#160;swap(v, left, (left + right)/2);&#160;<br/>&#160; &#160; &#160; &#160;last = left;&#160;<br/>&#160; &#160; &#160; &#160;for (i = left+1; i &lt;= right; &#160;i++)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;if ((*comp)(v[i], v[left]) &lt; 0)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;swap(v, ++last, i);&#160;<br/>&#160; &#160; &#160; &#160;swap(v, left, last);&#160;<br/>&#160; &#160; &#160; &#160;qsort(v, left, last-1, comp);&#160;<br/>&#160; &#160; &#160; &#160;qsort(v, last+1, right, comp);&#160;<br/>&#160; &#160;}&#160;<br/>
The declarations should be studied with some care. The fourth parameter of&#160;qsort&#160;is &#160;<br/>&#160;<br/>&#160; &#160;int (*comp)(void *, void *)&#160;<br/>
which says that&#160;comp&#160;is a pointer to a function that has two&#160;void *&#160;arguments and returns an&#160;<br/>int. &#160;<br/>
The use of&#160;comp&#160;in the line &#160;<br/>
&#160;<br/>&#160; &#160;if ((*comp)(v[i], v[left]) &lt; 0)&#160;<br/>
is consistent with the declaration:&#160;comp&#160;is a pointer to a function,&#160;*comp&#160;is the function, and &#160;<br/>&#160;<br/>&#160; &#160;(*comp)(v[i], v[left])&#160;<br/>
is the call to it. The parentheses are needed&#160;so the components are correctly associated;&#160;<br/>without them, &#160;<br/>&#160;<br/>&#160; &#160;int *comp(void *, void *) &#160; &#160;/* WRONG */&#160;<br/>
says that&#160;comp&#160;is a function returning a pointer to an&#160;int, which is very different. &#160;<br/>
<hr/>
<a name=108></a>&#160;&#160;<br/>
108&#160;<br/>
We&#160;have already shown&#160;strcmp, which compares two strings. Here is&#160;numcmp, which&#160;<br/>compares two strings on a leading numeric value, computed by calling&#160;atof: &#160;<br/>
&#160;<br/>&#160; &#160;#include &lt;stdlib.h&gt;&#160;<br/>&#160;<br/>&#160; &#160;/* numcmp: &#160;compare s1 and s2 numerically */&#160;<br/>&#160; &#160;int numcmp(char *s1, char *s2)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;double v1, v2;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;v1 = atof(s1);&#160;<br/>&#160; &#160; &#160; &#160;v2 = atof(s2);&#160;<br/>&#160; &#160; &#160; &#160;if (v1 &lt; v2)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;return -1;&#160;<br/>&#160; &#160; &#160; &#160;else if (v1 &gt; v2)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;return 1;&#160;<br/>&#160; &#160; &#160; &#160;else&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;return 0;&#160;<br/>&#160; &#160;}&#160;<br/>
The&#160;swap&#160;function, which exchanges two pointers, is identical to what we presented earlier in&#160;<br/>the chapter, except that the declarations are changed to&#160;void *. &#160;<br/>&#160;<br/>&#160; &#160;void swap(void *v[], &#160;int i, int j;)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;void *temp;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;temp = v[i];&#160;<br/>&#160; &#160; &#160; &#160;v[i] = v[j];&#160;<br/>&#160; &#160; &#160; &#160;v[j] = temp;&#160;<br/>&#160; &#160;}&#160;<br/>
A variety of other options can be added to&#160;the sorting program; some make challenging&#160;<br/>exercises. &#160;<br/>
<b>Exercise 5-14.</b>&#160;Modify the sort program&#160;to handle a&#160;-r&#160;flag, which indicates sorting in reverse&#160;<br/>(decreasing) order. Be sure that&#160;-r&#160;works with&#160;-n. &#160;<br/>
<b>Exercise 5-15.</b>&#160;Add the option&#160;-f&#160;to fold upper and lower case together, so that case&#160;<br/>distinctions are not made during sorting; for example,&#160;a&#160;and&#160;A&#160;compare equal. &#160;<br/>
<b>Exercise 5-16.</b>&#160;Add the&#160;-d&#160;(``directory order'')&#160;option,&#160;which makes comparisons only on&#160;<br/>letters, numbers and blanks. Make sure it works in conjunction with&#160;-f. &#160;<br/>
<b>Exercise 5-17.</b>&#160;Add a field-searching capability, so sorting may bee done on fields within&#160;<br/>lines, each field sorted according to an independent set of options. (The index for this book&#160;<br/>was sorted with&#160;-df&#160;for the index category and&#160;-n&#160;for the page numbers.) &#160;<br/>
<b>5.12 Complicated Declarations&#160;</b><br/>
C is sometimes castigated for the syntax of its declarations, particularly ones that involve&#160;<br/>pointers to functions. The syntax is an attempt&#160;to make the declaration and the use agree; it&#160;<br/>works well for simple cases, but it can be confusing for the harder ones, because declarations&#160;<br/>cannot be read left to right, and because parentheses are over-used. The difference between &#160;<br/>&#160;<br/>&#160; &#160;int *f(); &#160; &#160; &#160; /* f: function returning pointer to int */&#160;<br/>
and &#160;<br/>&#160;<br/>
<hr/>
<a name=109></a>&#160;&#160;<br/>
109&#160;<br/>
&#160; &#160;int (*pf)(); &#160; &#160;/* pf: pointer to function returning int */ &#160;<br/>
illustrates the problem:&#160;*&#160;is a prefix operator and it has lower precedence than&#160;(), so&#160;<br/>parentheses are necessary to force the proper association. &#160;<br/>
Although truly complicated declarations rarely arise in practice, it is important to know how&#160;<br/>to understand them, and, if necessary, how&#160;to create them. One good way to synthesize&#160;<br/>declarations is in small steps with&#160;typedef, which is discussed in&#160;<a href="">Section 6.7. As an&#160;<br/></a>alternative, in this section we will present a pair of programs that convert from&#160;valid C to a&#160;<br/>word description and back again. The word description reads left to right. &#160;<br/>
The first,&#160;dcl, is the more complex. It converts a C declaration into a word description, as in&#160;<br/>these examples: &#160;<br/>
&#160;<br/>char **argv&#160;<br/>&#160; &#160; argv: &#160;pointer to char&#160;<br/>int (*daytab)[13]&#160;<br/>&#160; &#160; daytab: &#160;pointer to array[13] of int&#160;<br/>int *daytab[13]&#160;<br/>&#160; &#160; daytab: &#160;array[13] of pointer to int&#160;<br/>void *comp()&#160;<br/>&#160; &#160; comp: function returning pointer to void&#160;<br/>void (*comp)()&#160;<br/>&#160; &#160; comp: pointer to function returning void&#160;<br/>char (*(*x())[])()&#160;<br/>&#160; &#160; x: function returning pointer to array[] of&#160;<br/>&#160; &#160; pointer to function returning char&#160;<br/>char (*(*x[3])())[5]&#160;<br/>&#160; &#160; x: array[3] of pointer to function returning&#160;<br/>&#160; &#160; pointer to array[5] of char&#160;<br/>
dcl&#160;is based on the grammar that specifies a declarator, which is spelled out precisely in&#160;<br/><a href="">Appendix A, Section 8.5; this is a sim</a>plified form: &#160;<br/>&#160;<br/><i>&#160;<br/>dcl: &#160; &#160; &#160; optional *'s direct-dcl&#160;<br/>direct-dcl name&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;(dcl)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;direct-dcl()&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;direct-dcl[optional size]&#160;<br/></i>&#160;<br/>
In words, a&#160;<i>dcl</i>&#160;is a&#160;<i>direct-dcl</i>, perhaps preceded by *'s. A&#160;<i>direct-dcl</i>&#160;is a name, or a&#160;<br/>parenthesized&#160;&#160;<i>dcl</i>, or a&#160;<i>direct-dcl</i>&#160;followed by parentheses, or a&#160;<i>direct-dcl</i>&#160;followed by&#160;<br/>brackets with an optional size. &#160;<br/>
This grammar can be used to parse functions. For instance, consider this declarator: &#160;<br/>
&#160;<br/>&#160; &#160;(*pfa[])()&#160;<br/>
pfa&#160;will be identified as a&#160;<i>name</i>&#160;and thus as a&#160;<i>direct-dcl</i>. Then&#160;pfa[]&#160;is also a&#160;<i>direct-dcl</i>. Then&#160;<br/>
*pfa[]&#160;is recognized as a&#160;<i>dcl</i>, so&#160;(*pfa[])&#160;is a&#160;<i>direct-dcl</i>. Then&#160;(*pfa[])()&#160;is a&#160;<i>direct-dcl</i>&#160;<br/>and thus a&#160;<i>dcl</i>. We can also illustrate the parse with a tree like this (where&#160;<i>direct-dcl</i>&#160;has been&#160;<br/>abbreviated to&#160;<i>dir-dcl</i>): &#160;<br/>
<hr/>
<a name=110></a><img src="c-110_1.png"/><br/>
&#160;&#160;<br/>
110&#160;<br/>
&#160;<br/>
The heart of the&#160;dcl&#160;program&#160;is a pair of functions,&#160;dcl&#160;and&#160;dirdcl, that parse a declaration&#160;<br/>according to this grammar. Because the grammar is recursively defined, the functions call&#160;<br/>each other recursively as they recognize pieces&#160;of a declaration; the program&#160;is called a&#160;<br/>recursive-descent parser. &#160;<br/>
&#160;<br/>&#160; &#160;/* dcl: &#160;parse a declarator */&#160;<br/>&#160; &#160;void dcl(void)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int ns;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;for (ns = 0; gettoken() == '*'; ) /* count *'s */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;ns++;&#160;<br/>&#160; &#160; &#160; &#160;dirdcl();&#160;<br/>&#160; &#160; &#160; &#160;while (ns-- &gt; 0)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;strcat(out, &#34; pointer to&#34;);&#160;<br/>&#160; &#160;}&#160;<br/>&#160;<br/>&#160; &#160;/* dirdcl: &#160;parse a direct declarator */&#160;<br/>&#160; &#160;void dirdcl(void)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int type;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;if (tokentype == '(') { &#160; &#160; &#160; &#160; /* ( dcl ) */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;dcl();&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;if (tokentype != ')')&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;printf(&#34;error: missing )\n&#34;);&#160;<br/>&#160; &#160; &#160; &#160;} else if (tokentype == NAME) &#160;/* variable name */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;strcpy(name, token);&#160;<br/>
<hr/>
<a name=111></a>&#160;&#160;<br/>
111&#160;<br/>
&#160; &#160; &#160; &#160;else&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;printf(&#34;error: expected name or (dcl)\n&#34;);&#160;<br/>&#160; &#160; &#160; &#160;while ((type=gettoken()) == PARENS || type == BRACKETS)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;if (type == PARENS)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;strcat(out, &#34; function returning&#34;);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;else {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;strcat(out, &#34; array&#34;);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;strcat(out, token);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;strcat(out, &#34; of&#34;);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160;}&#160;<br/>
Since the programs are intended to be illustrative, not bullet-proof, there are significant&#160;<br/>restrictions on&#160;dcl. It can only handle a simple data type line&#160;char&#160;or&#160;int. It does not handle&#160;<br/>argument types in functions, or qualifiers like&#160;const. Spurious blanks confuse it. It doesn't do&#160;<br/>much error recovery, so invalid declarations will also confuse it. These improvements are left&#160;<br/>as exercises. &#160;<br/>
Here are the global variables and the main routine: &#160;<br/>
&#160;<br/>&#160; &#160;#include &lt;stdio.h&gt;&#160;<br/>&#160; &#160;#include &lt;string.h&gt;&#160;<br/>&#160; &#160;#include &lt;ctype.h&gt;&#160;<br/>&#160;<br/>&#160; &#160;#define MAXTOKEN &#160;100&#160;<br/>&#160;<br/>&#160; &#160;enum { NAME, PARENS, BRACKETS };&#160;<br/>&#160;<br/>&#160; &#160;void dcl(void);&#160;<br/>&#160; &#160;void dirdcl(void);&#160;<br/>&#160;<br/>&#160; &#160;int gettoken(void);&#160;<br/>&#160; &#160;int tokentype; &#160; &#160; &#160; &#160; &#160; /* type of last token */&#160;<br/>&#160; &#160;char token[MAXTOKEN]; &#160; &#160;/* last token string */&#160;<br/>&#160; &#160;char name[MAXTOKEN]; &#160; &#160; /* identifier name */&#160;<br/>&#160; &#160;char datatype[MAXTOKEN]; /* data type = char, int, etc. */&#160;<br/>&#160; &#160;char out[1000];&#160;<br/>&#160;<br/>&#160; &#160;main() &#160;/* convert declaration to words */&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;while (gettoken() != EOF) { &#160; /* 1st token on line */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;strcpy(datatype, token); &#160;/* is the datatype */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;out[0] = '\0';&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;dcl(); &#160; &#160; &#160; /* parse rest of line */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;if (tokentype != '\n')&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;printf(&#34;syntax error\n&#34;);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;printf(&#34;%s: %s %s\n&#34;, name, out, datatype);&#160;<br/>&#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160; &#160; &#160;return 0;&#160;<br/>&#160; &#160;}&#160;<br/>
The function&#160;gettoken&#160;skips blanks and tabs, then finds the next token in the input; a ``token''&#160;<br/>is a name, a pair of parentheses, a pair of&#160;brackets perhaps including a number, or any other&#160;<br/>single character. &#160;<br/>&#160;<br/>&#160; &#160;int gettoken(void) &#160;/* return next token */&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int c, getch(void);&#160;<br/>&#160; &#160; &#160; &#160;void ungetch(int);&#160;<br/>&#160; &#160; &#160; &#160;char *p = token;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;while ((c = getch()) == ' ' || c == '\t')&#160;<br/>
<hr/>
<a name=112></a>&#160;&#160;<br/>
112&#160;<br/>
&#160; &#160; &#160; &#160; &#160; &#160;;&#160;<br/>&#160; &#160; &#160; &#160;if (c == '(') {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;if ((c = getch()) == ')') {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;strcpy(token, &#34;()&#34;);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;return tokentype = PARENS;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;} else {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;ungetch(c);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;return tokentype = '(';&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160; &#160; &#160;} else if (c == '[') {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;for (*p++ = c; (*p++ = getch()) != ']'; )&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;*p = '\0';&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;return tokentype = BRACKETS;&#160;<br/>&#160; &#160; &#160; &#160;} else if (isalpha(c)) {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;for (*p++ = c; isalnum(c = getch()); )&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;*p++ = c;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;*p = '\0';&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;ungetch(c);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;return tokentype = NAME;&#160;<br/>&#160; &#160; &#160; &#160;} else&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;return tokentype = c;&#160;<br/>&#160;<br/>&#160; &#160;}&#160;<br/>
getch&#160;and&#160;ungetch&#160;are discussed in&#160;<a href="">Chapter 4</a>. &#160;<br/>
Going in the other direction is easier, especially if we do not worry about generating&#160;<br/>redundant parentheses. The program&#160;undcl&#160;converts a word description like ``x&#160;is a function&#160;<br/>returning a pointer to an array of pointers to functions returning&#160;char,''&#160;which we will express&#160;<br/>as &#160;<br/>
&#160;<br/>&#160; &#160; x () * [] * () char&#160;<br/>
to &#160;<br/>&#160;<br/>&#160; &#160;char (*(*x())[])()&#160;<br/>
The abbreviated input syntax lets us reuse the&#160;gettoken&#160;function.&#160;undcl&#160;also uses the same&#160;<br/>external variables as&#160;dcl&#160;does. &#160;<br/>&#160;<br/>&#160; &#160;/* undcl: &#160;convert word descriptions to declarations */&#160;<br/>&#160; &#160;main()&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int type;&#160;<br/>&#160; &#160; &#160; &#160;char temp[MAXTOKEN];&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;while (gettoken() != EOF) {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;strcpy(out, token);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;while ((type = gettoken()) != '\n')&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;if (type == PARENS || type == BRACKETS)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;strcat(out, token);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;else if (type == '*') {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;sprintf(temp, &#34;(*%s)&#34;, out);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;strcpy(out, temp);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;} else if (type == NAME) {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;sprintf(temp, &#34;%s %s&#34;, token, out);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;strcpy(out, temp);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;} else&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;printf(&#34;invalid input at %s\n&#34;, token);&#160;<br/>&#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160; &#160; &#160;return 0;&#160;<br/>&#160; &#160;}&#160;<br/>
<hr/>
<a name=113></a>&#160;&#160;<br/>
113&#160;<br/>
<b>Exercise 5-18.</b>&#160;Make&#160;dcl&#160;recover from&#160;input errors. &#160;<br/>
<b>Exercise 5-19.</b>&#160;Modify&#160;undcl&#160;so that it does not add redundant parentheses to declarations. &#160;<br/>
<b>Exercise 5-20.</b>&#160;Expand&#160;dcl&#160;to handle declarations with function argument types, qualifiers&#160;<br/>like&#160;const, and so on. &#160;<br/>
<hr/>
<a name=114></a><img src="c-114_1.png"/><br/>
&#160;&#160;<br/>
114&#160;<br/>
&#160;<br/>
<b>Chapter&#160;6 - Structures&#160;</b><br/>
A structure is a collection of one or more variables, possibly of different types, grouped&#160;<br/>together under a single name for convenient handling. (Structures are called ``records''&#160;in&#160;<br/>some languages, notably Pascal.) Structures help&#160;to organize complicated data, particularly in&#160;<br/>large programs, because they permit a group of related variables to be treated as a unit instead&#160;<br/>of&#160;as separate entities. &#160;<br/>
One traditional example of a structure is the payroll record: an employee is described by a set&#160;<br/>of attributes such as name, address, social security number, salary, etc. Some of&#160;these in turn&#160;<br/>could be structures: a name has several components, as does an address and even a salary.&#160;<br/>Another example, more typical for C, comes from&#160;graphics: a point is a pair of coordinate, a&#160;<br/>rectangle is a pair of points, and so on. &#160;<br/>
The main change made by the ANSI standard is&#160;to define structure assignment - structures&#160;<br/>may be copied and assigned to, passed to functions, and returned by functions. This has been&#160;<br/>supported by most compilers for many years, but&#160;the properties are now precisely defined.&#160;<br/>Automatic structures and arrays may now also be initialized. &#160;<br/>
<b>6.1 Basics of Structures&#160;</b><br/>
Let us create a few structures suitable for graphics. The basic object is&#160;a point, which we will&#160;<br/>assume has an&#160;<i>x</i>&#160;coordinate and a&#160;<i>y</i>&#160;coordinate, both integers. &#160;<br/>
&#160;<br/>
The two components can be placed in a structure declared like this: &#160;<br/>
&#160;<br/>&#160; &#160;struct point {&#160;<br/>&#160; &#160; &#160; &#160;int x;&#160;<br/>&#160; &#160; &#160; &#160;int y;&#160;<br/>&#160; &#160;};&#160;<br/>
The keyword&#160;struct&#160;introduces a structure declaration, which is a list of declarations&#160;<br/>enclosed in braces. An optional name called a&#160;<i>structure tag</i>&#160;may follow the word&#160;struct&#160;(as&#160;<br/>with&#160;&#160;point&#160;here). The tag names this kind of structure, and can be used subsequently as a&#160;<br/>shorthand for the part of the declaration in braces. &#160;<br/>
<hr/>
<a name=115></a>&#160;&#160;<br/>
115&#160;<br/>
The variables named in a structure are called&#160;<i>members</i>. A structure member or tag and an&#160;<br/>ordinary (i.e., non-member) variable can have the same name without conflict, since they can&#160;<br/>always be distinguished by context. Furthermore, the same member names may occur in&#160;<br/>different structures, although as a matter of&#160;style one would normally use the same names&#160;<br/>only for closely related objects. &#160;<br/>
A&#160;struct&#160;declaration defines a type. The right brace that terminates the list of members may&#160;<br/>be followed by a list of variables, just as for any basic type. That is, &#160;<br/>
&#160;<br/>&#160; &#160;struct { ... } x, y, z;&#160;<br/>
is syntactically analogous to &#160;<br/>&#160;<br/>&#160; &#160;int x, y, z;&#160;<br/>
in the sense that each statement declares&#160;x,&#160;&#160;y&#160;and&#160;z&#160;to be variables of the named type and&#160;<br/>causes space to be set aside for them. &#160;<br/>
A structure declaration that is&#160;not followed by a list of variables reserves no storage; it merely&#160;<br/>describes a template or shape of a structure. If&#160;the declaration is tagged, however, the tag can&#160;<br/>be used later in definitions of instances of the&#160;structure. For example, given the declaration of&#160;<br/>point&#160;above, &#160;<br/>
&#160;<br/>&#160; &#160;struct point pt;&#160;<br/>
defines a variable&#160;pt&#160;which is a structure of type&#160;struct point. A structure can be initialized&#160;<br/>by following its definition with a list of initializers, each a constant expression, for the&#160;<br/>members:&#160;&#160;<br/>&#160;<br/>&#160; &#160;struct maxpt = { 320, 200 };&#160;<br/>
An automatic structure may also be initialized by assignment or by calling a function that&#160;<br/>returns a structure of the right type. &#160;<br/>
A member of a particular structure is referred to in an expression by a construction of the&#160;<br/>form&#160;&#160;<br/>
&#160;&#160;<i>structure-name.member</i>&#160;&#160;<br/>
The structure member operator ``.''&#160;connects the structure name and the member name. To&#160;<br/>print the coordinates of the point&#160;pt, for instance, &#160;<br/>
&#160;<br/>&#160; &#160;printf(&#34;%d,%d&#34;, pt.x, pt.y);&#160;<br/>
or to compute the distance from&#160;the origin (0,0) to&#160;pt, &#160;<br/>&#160;<br/>&#160; &#160;double dist, sqrt(double);&#160;<br/>&#160;<br/>&#160; &#160;dist = sqrt((double)pt.x * pt.x + (double)pt.y * pt.y);&#160;<br/>
Structures can be nested. One representation of&#160;a rectangle is a pair of points that denote the&#160;<br/>diagonally opposite corners: &#160;<br/>
<hr/>
<a name=116></a><img src="c-116_1.png"/><br/>
&#160;&#160;<br/>
116&#160;<br/>
&#160;<br/>
&#160;<br/>&#160; &#160;struct rect {&#160;<br/>&#160; &#160; &#160; &#160;struct point pt1;&#160;<br/>&#160; &#160; &#160; &#160;struct point pt2;&#160;<br/>&#160; &#160;};&#160;<br/>
The&#160;rect&#160;structure contains two&#160;point&#160;structures. If we declare&#160;screen&#160;as &#160;<br/>&#160;<br/>&#160; &#160;struct rect screen;&#160;<br/>
then &#160;<br/>&#160;<br/>&#160; &#160;screen.pt1.x&#160;<br/>
refers to the&#160;<i>x</i>&#160;coordinate of the&#160;pt1&#160;member&#160;of&#160;screen. &#160;<br/>
<b>6.2 Structures and Functions&#160;</b><br/>
The only legal operations on a structure are copying it or assigning to it as a unit, taking its&#160;<br/>address with&#160;&amp;, and accessing its members. Copy and&#160;assignment include passing arguments&#160;<br/>to functions and returning values from&#160;functions&#160;as well. Structures may not be compared. A&#160;<br/>structure may be initialized by a list of&#160;constant member values; an automatic structure may&#160;<br/>also be initialized by an assignment. &#160;<br/>
Let us investigate structures by writing some&#160;functions to manipulate points and rectangles.&#160;<br/>There are at least three possible approaches: pass components separately, pass an entire&#160;<br/>structure, or pass a pointer to it. Each has its good points and bad points. &#160;<br/>
The first function,&#160;makepoint, will take two integers and return a&#160;point&#160;structure: &#160;<br/>
&#160;<br/>&#160; &#160;/* makepoint: &#160;make a point from x and y components */&#160;<br/>&#160; &#160;struct point makepoint(int x, int y)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;struct point temp;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;temp.x = x;&#160;<br/>&#160; &#160; &#160; &#160;temp.y = y;&#160;<br/>&#160; &#160; &#160; &#160;return temp;&#160;<br/>&#160; &#160;}&#160;<br/>
Notice that there is no conflict between the argument name and the member with the same&#160;<br/>name; indeed the re-use of the names stresses the relationship. &#160;<br/>
makepoint&#160;can now be used to initialize any structure dynamically, or to provide structure&#160;<br/>arguments to a function: &#160;<br/>
&#160;<br/>&#160; &#160;struct rect screen;&#160;<br/>
<hr/>
<a name=117></a>&#160;&#160;<br/>
117&#160;<br/>
&#160; &#160;struct point middle;&#160;<br/>&#160; &#160;struct point makepoint(int, int);&#160;<br/>&#160;<br/>&#160; &#160;screen.pt1 = makepoint(0,0);&#160;<br/>&#160; &#160;screen.pt2 = makepoint(XMAX, YMAX);&#160;<br/>&#160; &#160;middle = makepoint((screen.pt1.x + screen.pt2.x)/2,&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; (screen.pt1.y + screen.pt2.y)/2);&#160;<br/>
The next step is a set of functions to do arithmetic on points. For instance, &#160;<br/>&#160;<br/>&#160; &#160;/* addpoints: &#160;add two points */&#160;<br/>&#160; &#160;struct addpoint(struct point p1, struct point p2)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;p1.x += p2.x;&#160;<br/>&#160; &#160; &#160; &#160;p1.y += p2.y;&#160;<br/>&#160; &#160; &#160; &#160;return p1;&#160;<br/>&#160; &#160;}&#160;<br/>
Here both the arguments and the return value&#160;are structures. We incremented the components&#160;<br/>in&#160;p1&#160;rather than using an explicit temporary variable to emphasize that structure parameters&#160;<br/>are passed by value like any others. &#160;<br/>
As another example, the function&#160;ptinrect&#160;tests whether a point is inside a rectangle, where&#160;<br/>we have adopted the convention that a rectangle includes its left and bottom&#160;sides but not its&#160;<br/>top and right sides: &#160;<br/>
&#160;<br/>&#160; &#160;/* ptinrect: &#160;return 1 if p in r, 0 if not */&#160;<br/>&#160; &#160;int ptinrect(struct point p, struct rect r)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;return p.x &gt;= r.pt1.x &amp;&amp; p.x &lt; r.pt2.x&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;&amp;&amp; p.y &gt;= r.pt1.y &amp;&amp; p.y &lt; r.pt2.y;&#160;<br/>&#160; &#160;}&#160;<br/>
This assumes that the rectangle is presented in a standard form&#160;where the&#160;pt1&#160;coordinates are&#160;<br/>less than the&#160;pt2&#160;coordinates. The following function returns a rectangle guaranteed to be in&#160;<br/>canonical form: &#160;<br/>&#160;<br/>&#160; &#160;#define min(a, b) ((a) &lt; (b) ? (a) : (b))&#160;<br/>&#160; &#160;#define max(a, b) ((a) &gt; (b) ? (a) : (b))&#160;<br/>&#160;<br/>&#160; &#160;/* canonrect: canonicalize coordinates of rectangle */&#160;<br/>&#160; &#160;struct rect canonrect(struct rect r)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;struct rect temp;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;temp.pt1.x = min(r.pt1.x, r.pt2.x);&#160;<br/>&#160; &#160; &#160; &#160;temp.pt1.y = min(r.pt1.y, r.pt2.y);&#160;<br/>&#160; &#160; &#160; &#160;temp.pt2.x = max(r.pt1.x, r.pt2.x);&#160;<br/>&#160; &#160; &#160; &#160;temp.pt2.y = max(r.pt1.y, r.pt2.y);&#160;<br/>&#160; &#160; &#160; &#160;return temp;&#160;<br/>&#160; &#160;}&#160;<br/>
If a large structure is to be passed to a function, it is generally more efficient to pass a pointer&#160;<br/>than to copy the whole structure. Structure pointers are just like pointers to ordinary variables.&#160;<br/>The declaration &#160;<br/>&#160;<br/>&#160; &#160;struct point *pp;&#160;<br/>
says that&#160;pp&#160;is a pointer to a structure of type&#160;struct point. If&#160;pp&#160;points to a&#160;point&#160;structure,&#160;<br/>*pp&#160;is the structure, and&#160;(*pp).x&#160;and&#160;(*pp).y&#160;are the members. To use&#160;pp, we might write,&#160;<br/>for example, &#160;<br/>&#160;<br/>&#160; &#160;struct point origin, *pp;&#160;<br/>&#160;<br/>
<hr/>
<a name=118></a>&#160;&#160;<br/>
118&#160;<br/>
&#160; &#160;pp = &amp;origin;&#160;<br/>&#160; &#160;printf(&#34;origin is (%d,%d)\n&#34;, (*pp).x, (*pp).y);&#160;<br/>
The parentheses are necessary in&#160;(*pp).x&#160;because the precedence of the structure member&#160;<br/>operator&#160;&#160;.&#160;is higher then&#160;*. The expression&#160;*pp.x&#160;means&#160;*(pp.x), which is illegal here&#160;<br/>because&#160;x&#160;is not a pointer. &#160;<br/>
Pointers to structures are so frequently used&#160;that an alternative notation is provided as a&#160;<br/>shorthand. If&#160;p&#160;is a pointer to a structure, then &#160;<br/>
&#160;<br/>&#160; &#160;p-&gt;<i>member-of-structure</i>&#160;<br/>
refers to the particular member. So we could write instead &#160;<br/>&#160;<br/>&#160; &#160;printf(&#34;origin is (%d,%d)\n&#34;, pp-&gt;x, pp-&gt;y);&#160;<br/>
Both&#160;.&#160;and&#160;-&gt;&#160;associate from&#160;left to right, so if we have &#160;<br/>&#160;<br/>&#160; &#160;struct rect r, *rp = &amp;r;&#160;<br/>
then these four expressions are equivalent: &#160;<br/>&#160;<br/>&#160; &#160;r.pt1.x&#160;<br/>&#160; &#160;rp-&gt;pt1.x&#160;<br/>&#160; &#160;(r.pt1).x&#160;<br/>&#160; &#160;(rp-&gt;pt1).x&#160;<br/>
The structure operators&#160;.&#160;and&#160;-&gt;, together with&#160;()&#160;for function calls and&#160;[]&#160;for subscripts, are&#160;<br/>at the top of the precedence hierarchy and thus&#160;bind very tightly. For example, given the&#160;<br/>declaration &#160;<br/>&#160;<br/>&#160; &#160;struct {&#160;<br/>&#160; &#160; &#160; &#160;int len;&#160;<br/>&#160; &#160; &#160; &#160;char *str;&#160;<br/>&#160; &#160;} *p;&#160;<br/>
then &#160;<br/>&#160;<br/>&#160; &#160;++p-&gt;len&#160;<br/>
increments&#160;len, not&#160;p, because the implied parenthesization is&#160;++(p-&gt;len). Parentheses can&#160;<br/>be used to alter binding:&#160;(++p)-&gt;len&#160;increments&#160;p&#160;before accessing&#160;len, and&#160;(p++)-&gt;len&#160;<br/>increments&#160;p&#160;afterward. (This last set of parentheses is unnecessary.) &#160;<br/>
In the same way,&#160;*p-&gt;str&#160;fetches whatever&#160;str&#160;points to;&#160;*p-&gt;str++&#160;increments&#160;str&#160;after&#160;<br/>accessing whatever it points to (just like&#160;*s++);&#160;(*p-&gt;str)++&#160;increments whatever&#160;str&#160;points&#160;<br/>to; and&#160;*p++-&gt;str&#160;increments&#160;p&#160;after accessing whatever&#160;str&#160;points to. &#160;<br/>
<b>6.3 Arrays of Structures&#160;</b><br/>
Consider writing a program&#160;to count the occurrences of each C keyword. We&#160;need an array of&#160;<br/>character strings to hold the names, and an array of integers for the counts. One possibility is&#160;<br/>to use two parallel arrays,&#160;keyword&#160;and&#160;keycount, as in &#160;<br/>&#160;<br/>&#160; &#160;char *keyword[NKEYS];&#160;<br/>&#160; &#160;int keycount[NKEYS];&#160;<br/>
But the very fact that the arrays are parallel&#160;suggests a different organization, an array of&#160;<br/>structures. Each keyword is a pair: &#160;<br/>&#160;<br/>&#160; &#160;char *word;&#160;<br/>&#160; &#160;int cout;&#160;<br/>
and there is an array of pairs. The structure declaration &#160;<br/>
<hr/>
<a name=119></a>&#160;&#160;<br/>
119&#160;<br/>
&#160;<br/>&#160; &#160;struct key {&#160;<br/>&#160; &#160; &#160; &#160;char *word;&#160;<br/>&#160; &#160; &#160; &#160;int count;&#160;<br/>&#160; &#160;} keytab[NKEYS];&#160;<br/>
declares a structure type&#160;key, defines an array&#160;keytab&#160;of structures of this type, and sets aside&#160;<br/>storage for them. Each element of&#160;the array is a structure. This could also be written &#160;<br/>&#160;<br/>&#160; &#160;struct key {&#160;<br/>&#160; &#160; &#160; &#160;char *word;&#160;<br/>&#160; &#160; &#160; &#160;int count;&#160;<br/>&#160; &#160;};&#160;<br/>&#160;<br/>&#160; &#160;struct key keytab[NKEYS];&#160;<br/>
Since the structure&#160;keytab&#160;contains a constant set of names,&#160;it is easiest to make it an external&#160;<br/>variable and initialize it once and for all when it is defined. The structure initialization is&#160;<br/>analogous to earlier ones - the definition is followed by a list of initializers enclosed in braces: &#160;<br/>&#160;<br/>&#160; &#160;struct key {&#160;<br/>&#160; &#160; &#160; &#160;char *word;&#160;<br/>&#160; &#160; &#160; &#160;int count;&#160;<br/>&#160; &#160;} keytab[] = {&#160;<br/>&#160; &#160; &#160; &#160;&#34;auto&#34;, 0,&#160;<br/>&#160; &#160; &#160; &#160;&#34;break&#34;, 0,&#160;<br/>&#160; &#160; &#160; &#160;&#34;case&#34;, 0,&#160;<br/>&#160; &#160; &#160; &#160;&#34;char&#34;, 0,&#160;<br/>&#160; &#160; &#160; &#160;&#34;const&#34;, 0,&#160;<br/>&#160; &#160; &#160; &#160;&#34;continue&#34;, 0,&#160;<br/>&#160; &#160; &#160; &#160;&#34;default&#34;, 0,&#160;<br/>&#160; &#160; &#160; &#160;/* ... */&#160;<br/>&#160; &#160; &#160; &#160;&#34;unsigned&#34;, 0,&#160;<br/>&#160; &#160; &#160; &#160;&#34;void&#34;, 0,&#160;<br/>&#160; &#160; &#160; &#160;&#34;volatile&#34;, 0,&#160;<br/>&#160; &#160; &#160; &#160;&#34;while&#34;, 0&#160;<br/>&#160; &#160;};&#160;<br/>
The initializers are listed in pairs corresponding to&#160;the structure members. It would be more&#160;<br/>precise to enclose the initializers for each &#34;row&#34; or structure in braces, as in &#160;<br/>&#160;<br/>&#160; &#160;{ &#34;auto&#34;, 0 },&#160;<br/>&#160; &#160;{ &#34;break&#34;, 0 },&#160;<br/>&#160; &#160;{ &#34;case&#34;, 0 },&#160;<br/>&#160; &#160;...&#160;<br/>
but inner braces are not necessary when the initializers are simple variables or character&#160;<br/>strings, and when all are present. As usual, the number of&#160;entries in the array&#160;keytab&#160;will be&#160;<br/>computed if&#160;the initializers are present and the&#160;[]&#160;is left&#160;empty. &#160;<br/>
The keyword counting program&#160;begins with the definition of&#160;keytab. The main routine reads&#160;<br/>the input by repeatedly calling a function&#160;getword&#160;that fetches one word at a time. Each word&#160;<br/>is looked up in&#160;keytab&#160;with a version of the binary search function that we wrote in&#160;<a href="">Chapter&#160;<br/>3</a>. The list of keywords must be sorted in increasing order in the table. &#160;<br/>
&#160;<br/>&#160; &#160;#include &lt;stdio.h&gt;&#160;<br/>&#160; &#160;#include &lt;ctype.h&gt;&#160;<br/>&#160; &#160;#include &lt;string.h&gt;&#160;<br/>&#160;<br/>&#160; &#160;#define MAXWORD 100&#160;<br/>&#160;<br/>&#160; &#160;int getword(char *, int);&#160;<br/>&#160; &#160;int binsearch(char *, struct key *, int);&#160;<br/>
<hr/>
<a name=120></a>&#160;&#160;<br/>
120&#160;<br/>
&#160;<br/>&#160; &#160;/* count C keywords */&#160;<br/>&#160; &#160;main()&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int n;&#160;<br/>&#160; &#160; &#160; &#160;char word[MAXWORD];&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;while (getword(word, MAXWORD) != EOF)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;if (isalpha(word[0]))&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;if ((n = binsearch(word, keytab, NKEYS)) &gt;= 0)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;keytab[n].count++;&#160;<br/>&#160; &#160; &#160; &#160;for (n = 0; n &lt; NKEYS; n++)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;if (keytab[n].count &gt; 0)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;printf(&#34;%4d %s\n&#34;,&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;keytab[n].count, keytab[n].word);&#160;<br/>&#160; &#160; &#160; &#160;return 0;&#160;<br/>&#160; &#160;}&#160;<br/>&#160;<br/>&#160; &#160;/* binsearch: &#160;find word in tab[0]...tab[n-1] */&#160;<br/>&#160; &#160;int binsearch(char *word, struct key tab[], int n)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int cond;&#160;<br/>&#160; &#160; &#160; &#160;int low, high, mid;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;low = 0;&#160;<br/>&#160; &#160; &#160; &#160;high = n - 1;&#160;<br/>&#160; &#160; &#160; &#160;while (low &lt;= high) {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;mid = (low+high) / 2;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;if ((cond = strcmp(word, tab[mid].word)) &lt; 0)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;high = mid - 1;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;else if (cond &gt; 0)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;low = mid + 1;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;else&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;return mid;&#160;<br/>&#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160; &#160; &#160;return -1;&#160;<br/>&#160; &#160;}&#160;<br/>
We will show the function&#160;getword&#160;in a moment; for now it suffices to say that each call to&#160;<br/>getword&#160;finds a word, which is copied into the array named as its first argument. &#160;<br/>
The quantity&#160;NKEYS&#160;is the number of keywords in&#160;keytab. Although we could count this by&#160;<br/>hand, it's a lot easier and safer to do it by machine,&#160;especially if&#160;the list is subject to change.&#160;<br/>One possibility would be to terminate the list&#160;of initializers with a null pointer, then loop&#160;<br/>along&#160;keytab&#160;until the end is found. &#160;<br/>
But this is more than is needed, since the size of&#160;the array is completely determined at&#160;<br/>compile time. The size of the array is the size of&#160;one entry times the number of&#160;entries, so the&#160;<br/>number of&#160;entries is just &#160;<br/>
&#160;&#160;<i>size of</i>&#160;keytab /&#160;<i>size of</i>&#160;struct key&#160;&#160;<br/>
C provides a compile-time unary operator called&#160;sizeof&#160;that can be used to compute the size&#160;<br/>of any object. The expressions &#160;<br/>
&#160;<br/>&#160; &#160;sizeof&#160;<i>object</i>&#160;<br/>
and &#160;<br/>&#160;<br/>&#160; &#160;sizeof (<i>type name</i>)&#160;<br/>
<hr/>
<a name=121></a>&#160;&#160;<br/>
121&#160;<br/>
yield an integer equal to the size of&#160;the specified object or type in bytes. (Strictly,&#160;sizeof&#160;<br/>produces an unsigned integer value whose type,&#160;size_t, is defined in the header&#160;<br/>&lt;stddef.h&gt;.) An object can be a variable or array or&#160;structure. A type name can be the name&#160;<br/>of a basic type like&#160;int&#160;or&#160;double, or a derived type like a structure or a pointer. &#160;<br/>
In our case, the number of keywords is the&#160;size of the array divided by the size of one&#160;<br/>element. This computation is used in a&#160;#define&#160;statement to set the value of&#160;NKEYS: &#160;<br/>
&#160;<br/>&#160; &#160;#define NKEYS (sizeof keytab / sizeof(struct key))&#160;<br/>
Another way to write this is to divide the array size by the size of a specific element: &#160;<br/>&#160;<br/>&#160; &#160;#define NKEYS (sizeof keytab / sizeof(keytab[0]))&#160;<br/>
This has the advantage that it does not need to be changed if the type changes. &#160;<br/>
A&#160;sizeof&#160;can not be used in a&#160;#if&#160;line, because the preprocessor does not parse type names.&#160;<br/>But the expression in the&#160;#define&#160;is not evaluated by the preprocessor, so the code here is&#160;<br/>legal. &#160;<br/>
Now for the function&#160;getword. We have written a more general&#160;getword&#160;than is necessary for&#160;<br/>this program, but it is not complicated.&#160;getword&#160;fetches the next ``word'' from&#160;the input,&#160;<br/>where a word is either a string of letters and digits beginning with a letter, or a single non-<br/>white space character. The function value is&#160;the first character of the word, or&#160;EOF&#160;for end of&#160;<br/>file, or the character itself&#160;if&#160;it is not alphabetic. &#160;<br/>
&#160;<br/>&#160; &#160;/* getword: &#160;get next word or character from input */&#160;<br/>&#160; &#160;int getword(char *word, int lim)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int c, getch(void);&#160;<br/>&#160; &#160; &#160; &#160;void ungetch(int);&#160;<br/>&#160; &#160; &#160; &#160;char *w = word;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;while (isspace(c = getch()))&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;;&#160;<br/>&#160; &#160; &#160; &#160;if (c != EOF)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;*w++ = c;&#160;<br/>&#160; &#160; &#160; &#160;if (!isalpha(c)) {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;*w = '\0';&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;return c;&#160;<br/>&#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160; &#160; &#160;for ( ; --lim &gt; 0; w++)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;if (!isalnum(*w = getch())) {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;ungetch(*w);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;break;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160; &#160; &#160;*w = '\0';&#160;<br/>&#160; &#160; &#160; &#160;return word[0];&#160;<br/>&#160; &#160;}&#160;<br/>
getword&#160;uses the&#160;getch&#160;and&#160;ungetch<a href="">&#160;that we wrote in&#160;Chapter 4. W</a>hen the collection of an&#160;<br/>alphanumeric token stops,&#160;getword&#160;has gone one character too far. The call to&#160;ungetch&#160;<br/>pushes that character back on the input for the next call.&#160;getword&#160;also uses&#160;isspace&#160;to skip&#160;<br/>whitespace,&#160;isalpha&#160;to identify letters, and&#160;isalnum&#160;to identify letters and digits; all are from&#160;<br/>the standard header&#160;&lt;ctype.h&gt;. &#160;<br/>
<b>Exercise 6-1.</b>&#160;Our version of&#160;getword&#160;does not properly handle underscores, string constants,&#160;<br/>comments, or preprocessor control lines. Write a better version. &#160;<br/>
<hr/>
<a name=122></a>&#160;&#160;<br/>
122&#160;<br/>
<b>6.4 Pointers to Structures&#160;</b><br/>
To illustrate some of the considerations involved&#160;with pointers to and arrays of structures, let&#160;<br/>us write the keyword-counting program&#160;again,&#160;this time using pointers instead of array&#160;<br/>indices. &#160;<br/>
The external declaration of&#160;keytab&#160;need not change, but&#160;main&#160;and&#160;binsearch&#160;do need&#160;<br/>modification. &#160;<br/>
&#160;<br/>&#160; &#160;#include &lt;stdio.h&gt;&#160;<br/>&#160; &#160;#include &lt;ctype.h&gt;&#160;<br/>&#160; &#160;#include &lt;string.h&gt;&#160;<br/>&#160; &#160;#define MAXWORD 100&#160;<br/>&#160;<br/>&#160; &#160;int getword(char *, int);&#160;<br/>&#160; &#160;struct key *binsearch(char *, struct key *, int);&#160;<br/>&#160;<br/>&#160; &#160;/* count C keywords; pointer version */&#160;<br/>&#160; &#160;main()&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;char word[MAXWORD];&#160;<br/>&#160; &#160; &#160; &#160;struct key *p;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;while (getword(word, MAXWORD) != EOF)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;if (isalpha(word[0]))&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;if ((p=binsearch(word, keytab, NKEYS)) != NULL)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;p-&gt;count++;&#160;<br/>&#160; &#160; &#160; &#160;for (p = keytab; p &lt; keytab + NKEYS; p++)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;if (p-&gt;count &gt; 0)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;printf(&#34;%4d %s\n&#34;, p-&gt;count, p-&gt;word);&#160;<br/>&#160; &#160; &#160; &#160;return 0;&#160;<br/>&#160; &#160;}&#160;<br/>&#160;<br/>&#160; &#160;/* binsearch: find word in tab[0]...tab[n-1] */&#160;<br/>&#160; &#160;struct key *binsearch(char *word, struck key *tab, int n)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int cond;&#160;<br/>&#160; &#160; &#160; &#160;struct key *low = &amp;tab[0];&#160;<br/>&#160; &#160; &#160; &#160;struct key *high = &amp;tab[n];&#160;<br/>&#160; &#160; &#160; &#160;struct key *mid;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;while (low &lt; high) {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;mid = low + (high-low) / 2;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;if ((cond = strcmp(word, mid-&gt;word)) &lt; 0)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;high = mid;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;else if (cond &gt; 0)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;low = mid + 1;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;else&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;return mid;&#160;<br/>&#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160; &#160; &#160;return NULL;&#160;<br/>&#160; &#160;}&#160;<br/>
There are several things worthy of note here. First, the declaration of&#160;binsearch&#160;must&#160;<br/>indicate that it returns a pointer to&#160;struct key&#160;instead of&#160;an integer; this is declared both in&#160;<br/>the function prototype and in&#160;binsearch. If&#160;binsearch&#160;finds the word, it returns a pointer to&#160;<br/>it; if&#160;it fails, it returns&#160;NULL. &#160;<br/>
<hr/>
<a name=123></a>&#160;&#160;<br/>
123&#160;<br/>
Second, the elements of&#160;keytab&#160;are now accessed by pointers. This requires significant&#160;<br/>changes in&#160;binsearch. &#160;<br/>
The initializers for&#160;low&#160;and&#160;high&#160;are now pointers to the beginning&#160;and just past the end of the&#160;<br/>table. &#160;<br/>
The computation of the middle element can no longer be simply &#160;<br/>
&#160;<br/>&#160; &#160;mid = (low+high) / 2 &#160; &#160;/* WRONG */&#160;<br/>
because the addition of pointers is illegal. Subtraction is legal, however, so&#160;high-low&#160;is the&#160;<br/>number of elements, and thus &#160;<br/>&#160;<br/>&#160; &#160;mid = low + (high-low) / 2&#160;<br/>
sets&#160;mid&#160;to the element halfway between&#160;low&#160;and&#160;high. &#160;<br/>
The most important change is to adjust the algorithm&#160;to make sure that it does not generate an&#160;<br/>illegal pointer or attempt to access an element outside the array. The problem&#160;is that&#160;&amp;tab[-<br/>1]&#160;and&#160;&amp;tab[n]&#160;are both outside the limits of the array&#160;tab. The former is strictly illegal, and&#160;<br/>it is illegal to dereference the latter. The language definition does guarantee, however, that&#160;<br/>pointer arithmetic that involves the first element beyond the end of an array (that is,&#160;&amp;tab[n])&#160;<br/>will work correctly. &#160;<br/>
In&#160;main&#160;we wrote &#160;<br/>
&#160;<br/>&#160; &#160;for (p = keytab; p &lt; keytab + NKEYS; p++)&#160;<br/>
If&#160;p&#160;is a pointer to a structure, arithmetic on&#160;p&#160;takes into account the size of the structure, so&#160;<br/>p++&#160;increments&#160;p&#160;by the correct amount to get the next element of the array of structures, and&#160;<br/>the test stops the loop at the right time. &#160;<br/>
Don't assume, however, that the size of a structure is the sum&#160;of the sizes of its members.&#160;<br/>Because of alignment requirements for different&#160;objects, there may be unnamed ``holes''&#160;in a&#160;<br/>structure. Thus, for instance, if a&#160;char&#160;is one byte and an&#160;int&#160;four bytes, the structure &#160;<br/>
&#160;<br/>&#160; &#160;struct {&#160;<br/>&#160; &#160; &#160; &#160;char c;&#160;<br/>&#160; &#160; &#160; &#160;int i;&#160;<br/>&#160; &#160;};&#160;<br/>
might well require eight bytes, not five. The&#160;sizeof&#160;operator returns the proper value. &#160;<br/>
Finally, an aside on program&#160;format: when a&#160;function returns a complicated type like a&#160;<br/>structure pointer, as in &#160;<br/>
&#160;<br/>&#160; &#160;struct key *binsearch(char *word, struct key *tab, int n)&#160;<br/>
the function name&#160;can be hard to see, and to find with a text editor. Accordingly an alternate&#160;<br/>style is sometimes used: &#160;<br/>&#160;<br/>&#160; &#160;struct key *&#160;<br/>&#160; &#160;binsearch(char *word, struct key *tab, int n)&#160;<br/>
This is a matter of personal taste; pick the form&#160;you like and hold to it. &#160;<br/>
<hr/>
<a name=124></a><img src="c-124_1.png"/><br/>
&#160;&#160;<br/>
124&#160;<br/>
<b>6.5 Self-referential Structures&#160;</b><br/>
Suppose we want to handle the more general problem&#160;of counting the occurrences of&#160;<i>all</i>&#160;the&#160;<br/>words in some input. Since the list of words&#160;isn't known in advance, we can't conveniently&#160;<br/>sort it and use a binary search. Yet we can't&#160;do&#160;a linear search for each word as it arrives, to&#160;<br/>see if it's already been seen;&#160;the program&#160;would take too long. (More precisely, its running&#160;<br/>time is likely to grow quadratically with the number of input words.) How can we organize&#160;<br/>the data to copy efficiently with a list or arbitrary words?&#160;&#160;<br/>
One solution is to keep the set&#160;of words seen so far sorted at all times, by placing each word&#160;<br/>into its proper position in the order as it arrives. This shouldn't be done by shifting words in a&#160;<br/>linear array, though - that also takes too long.&#160;Instead we will use a data structure called a&#160;<br/><i>binary tree</i>. &#160;<br/>
The tree contains one ``node''&#160;per distinct word; each node contains &#160;<br/>
•&#160;&#160;A pointer to the text of the word, &#160;<br/>•&#160;&#160;A count of the number of occurrences, &#160;<br/>•&#160;&#160;A pointer to the left child node, &#160;<br/>•&#160;&#160;A pointer to the right child node. &#160;<br/>
No node may have more than two children; it might have only zero or one. &#160;<br/>
The nodes are maintained so that at any node the left subtree contains only words that are&#160;<br/>lexicographically less than the word at the&#160;node, and the right subtree contains only words&#160;<br/>that are greater. This is the tree for the sentence ``now is the time for all good men to come to&#160;<br/>the aid of their party'',&#160;as built by inserting each word as it is encountered: &#160;<br/>
&#160;<br/>
To find out whether a new word is already in the tree, start at the root and compare the new&#160;<br/>word to the word stored at that&#160;node. If they match, the question&#160;is answered affirmatively. If&#160;<br/>the new record is less than the tree word, continue&#160;searching at the left child, otherwise at the&#160;<br/>right child. If&#160;there is no child in the required direction, the new word is not in the tree, and in&#160;<br/>fact the empty slot is the proper place to add the new word. This process is recursive, since&#160;<br/>the search from&#160;any node uses a search from&#160;one of its children. Accordingly, recursive&#160;<br/>routines for insertion and printing will be most natural. &#160;<br/>
Going back to the description of a node, it is&#160;most conveniently represented as a structure&#160;<br/>with four components: &#160;<br/>
<hr/>
<a name=125></a>125<br/>
&#160; &#160;struct tnode { &#160; &#160; /* the tree node: */&#160;<br/>
char *word;<br/>
/* points to the text */&#160;<br/>
int count;<br/>
/* number of occurrences */&#160;<br/>
struct tnode *left; &#160; /* left child */&#160;<br/>struct tnode *right; &#160;/* right child */&#160;<br/>
&#160; &#160;};&#160;<br/>
This recursive declaration of a node might look chancy, but it's correct. It is illegal for a&#160;<br/>structure to contain an instance of itself, but &#160;<br/>
&#160; &#160; struct tnode *left;&#160;<br/>
declares&#160;left&#160;to be a pointer to a&#160;tnode, not a&#160;tnode&#160;itself.&#160;&#160;<br/>
Occasionally, one needs a variation of self-referential structures: two structures that refer to&#160;<br/>each other. The way to handle this is: &#160;<br/>
&#160; &#160;struct t {&#160;<br/>
...&#160;<br/>struct s *p; &#160; /* p points to an s */&#160;<br/>
&#160; &#160;};&#160;<br/>&#160; &#160;struct s {&#160;<br/>
...&#160;<br/>struct t *q; &#160; /* q points to a t */&#160;<br/>
&#160; &#160;};&#160;<br/>
The code for the whole program&#160;is surprisingly&#160;small, given a handful of supporting routines&#160;<br/>like&#160;getword&#160;that we have already written. The main routine reads words with&#160;getword&#160;and&#160;<br/>installs them&#160;in the tree with&#160;addtree. &#160;<br/>
&#160; &#160;#include &lt;stdio.h&gt;&#160;<br/>&#160; &#160;#include &lt;ctype.h&gt;&#160;<br/>&#160; &#160;#include &lt;string.h&gt;&#160;<br/>
&#160; &#160;#define MAXWORD 100&#160;<br/>&#160; &#160;struct tnode *addtree(struct tnode *, char *);&#160;<br/>&#160; &#160;void treeprint(struct tnode *);&#160;<br/>&#160; &#160;int getword(char *, int);&#160;<br/>
&#160; &#160;/* word frequency count */&#160;<br/>&#160; &#160;main()&#160;<br/>&#160; &#160;{&#160;<br/>
struct tnode *root;&#160;<br/>char word[MAXWORD];&#160;<br/>
root = NULL;&#160;<br/>while (getword(word, MAXWORD) != EOF)&#160;<br/>
if (isalpha(word[0]))&#160;<br/>
root = addtree(root, word);&#160;<br/>
treeprint(root);&#160;<br/>return 0;&#160;<br/>
&#160; &#160;}&#160;<br/>
The function&#160;addtree&#160;is recursive. A word is presented by&#160;main&#160;to the top level (the root) of&#160;<br/>the tree. At each stage, that word is compared&#160;to the word already stored at the node, and is&#160;<br/>percolated down to either the left or right subtree by a recursive call to&#160;adtree. Eventually,&#160;<br/>the word either matches something already in the tree (in which case the count is&#160;<br/>incremented), or a null pointer is encountered, indicating that a node must be created and&#160;<br/>added to the tree. If a new node is created,&#160;addtree&#160;returns a pointer to it, which is installed&#160;<br/>in the parent node. &#160;<br/>
&#160; &#160;struct tnode *talloc(void);&#160;<br/>
<hr/>
<a name=126></a>&#160;&#160;<br/>
126&#160;<br/>
&#160; &#160;char *strdup(char *);&#160;<br/>&#160;<br/>&#160; &#160;/* addtree: &#160;add a node with w, at or below p */&#160;<br/>&#160; &#160;struct treenode *addtree(struct tnode *p, char *w)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int cond;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;if (p == NULL) { &#160; &#160; /* a new word has arrived */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;p = talloc(); &#160; &#160;/* make a new node */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;p-&gt;word = strdup(w);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;p-&gt;count = 1;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;p-&gt;left = p-&gt;right = NULL;&#160;<br/>&#160; &#160; &#160; &#160;} else if ((cond = strcmp(w, p-&gt;word)) == 0)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;p-&gt;count++; &#160; &#160; &#160;/* repeated word */&#160;<br/>&#160; &#160; &#160; &#160;else if (cond &lt; 0) &#160; /* less than into left subtree */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;p-&gt;left = addtree(p-&gt;left, w);&#160;<br/>&#160; &#160; &#160; &#160;else &#160; &#160; &#160; &#160; &#160; &#160; /* greater than into right subtree */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;p-&gt;right = addtree(p-&gt;right, w);&#160;<br/>&#160; &#160; &#160; &#160;return p;&#160;<br/>&#160; &#160;}&#160;<br/>
Storage for the new node is fetched by a routine&#160;talloc, which returns a pointer to a free&#160;<br/>space suitable for holding a tree node, and the new word is copied into a hidden space by&#160;<br/>strdup. (We will discuss these routines in a moment.) The count is initialized, and the two&#160;<br/>children are made null. This part of the code is&#160;executed only at the leaves of the tree, when a&#160;<br/>new node is being added. We have (unwisely) omitted error checking on the values returned&#160;<br/>by&#160;strdup&#160;and&#160;talloc. &#160;<br/>
treeprint&#160;prints the tree in sorted order; at each node, it prints the left subtree (all the words&#160;<br/>less than this word), then the word itself, then&#160;the right subtree (all the words greater). If you&#160;<br/>feel shaky about how recursion works, simulate&#160;treeprint&#160;as it operates on the tree shown&#160;<br/>above. &#160;<br/>
&#160;<br/>&#160; &#160;/* treeprint: &#160;in-order print of tree p */&#160;<br/>&#160; &#160;void treeprint(struct tnode *p)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;if (p != NULL) {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;treeprint(p-&gt;left);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;printf(&#34;%4d %s\n&#34;, p-&gt;count, p-&gt;word);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;treeprint(p-&gt;right);&#160;<br/>&#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160;}&#160;<br/>
A practical note: if the tree becomes ``unbalanced''&#160;because the words don't arrive in random&#160;<br/>order, the running time of the program&#160;can grow&#160;too much. As a worst case, if the words are&#160;<br/>already in order, this program&#160;does an expensive simulation of linear search. There are&#160;<br/>generalizations of&#160;the binary tree that do not suffer from&#160;this worst-case behavior, but we will&#160;<br/>not describe them&#160;here. &#160;<br/>
Before leaving this example, it is also worth&#160;a brief digression on a problem&#160;related to storage&#160;<br/>allocators. Clearly it's desirable that there be only one storage allocator in a program, even&#160;<br/>though it allocates different kinds of objects. But&#160;if one allocator is to process requests for,&#160;<br/>say, pointers to&#160;chars and pointers to&#160;struct tnodes, two questions arise. First, how does it&#160;<br/>meet the requirement of most real machines&#160;that objects of&#160;certain types must satisfy&#160;<br/>alignment restrictions (for example, integers&#160;often must be located at even addresses)?&#160;<br/>Second, what declarations can cope with the fact that an allocator must necessarily return&#160;<br/>different kinds of pointers?&#160;&#160;<br/>
<hr/>
<a name=127></a>&#160;&#160;<br/>
127&#160;<br/>
Alignment requirements can generally be satisfied&#160;easily, at the cost of some wasted space, by&#160;<br/>ensuring that the allocator always returns a pointer that meets&#160;<i>all</i>&#160;alignment restrictions. The&#160;<br/>alloc&#160;of&#160;<a href="">Chapter 5</a>&#160;does not guarantee any particular alignment, so we will use the standard&#160;<br/>library function&#160;malloc, which does. In&#160;<a href="">Chapter 8</a>&#160;we will show one way to implement&#160;<br/>malloc. &#160;<br/>
The question of the type declaration for a function like&#160;malloc&#160;is a vexing one for any&#160;<br/>language that takes its type-checking seriously.&#160;In C, the proper method is to declare that&#160;<br/>malloc&#160;returns a pointer to&#160;void, then explicitly coerce the pointer&#160;into the desired type with&#160;<br/>a cast.&#160;malloc&#160;and related routines are declared in the standard header&#160;&lt;stdlib.h&gt;. Thus&#160;<br/>talloc&#160;can be written as &#160;<br/>
&#160;<br/>&#160; &#160;#include &lt;stdlib.h&gt;&#160;<br/>&#160;<br/>&#160; &#160;/* talloc: &#160;make a tnode */&#160;<br/>&#160; &#160;struct tnode *talloc(void)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;return (struct tnode *) malloc(sizeof(struct tnode));&#160;<br/>&#160; &#160;}&#160;<br/>
strdup&#160;merely copies the string given by its argument into a safe place, obtained by a call on&#160;<br/>
malloc: &#160;<br/>&#160;<br/>&#160; &#160;char *strdup(char *s) &#160; /* make a duplicate of s */&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;char *p;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;p = (char *) malloc(strlen(s)+1); /* +1 for '\0' */&#160;<br/>&#160; &#160; &#160; &#160;if (p != NULL)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;strcpy(p, s);&#160;<br/>&#160; &#160; &#160; &#160;return p;&#160;<br/>&#160; &#160;}&#160;<br/>
malloc&#160;returns&#160;NULL&#160;if no space is available;&#160;strdup&#160;passes that value on, leaving error-<br/>handling to its caller. &#160;<br/>
Storage obtained by calling&#160;malloc&#160;may be freed for re-use by calling&#160;free; see&#160;<a href="">Chapters 8&#160;<br/></a>and&#160;<a href="">7. &#160;</a><br/>
<b>Exercise 6-2.</b>&#160;Write a program&#160;that reads a C program&#160;and prints in alphabetical order each&#160;<br/>group of variable names that are identical in&#160;the first 6 characters, but different somewhere&#160;<br/>thereafter. Don't count words within strings and comments. Make 6 a parameter that can be&#160;<br/>set from&#160;the command line. &#160;<br/>
<b>Exercise 6-3.</b>&#160;Write a cross-referencer that prints a&#160;list of&#160;all words in a document, and for&#160;<br/>each word, a list of the line numbers on which&#160;it occurs. Remove noise words like ``the,''&#160;<br/>``and,'' and so on. &#160;<br/>
<b>Exercise 6-4.</b>&#160;Write a program&#160;that prints the distinct words in its input sorted into decreasing&#160;<br/>order of frequency of occurrence. Precede each word by its count. &#160;<br/>
<b>6.6 Table Lookup&#160;</b><br/>
In this section we will write the innards of a table-lookup package, to illustrate more aspects&#160;<br/>of structures. This code is typical of what&#160;might be found in the symbol table management&#160;<br/>
<hr/>
<a name=128></a><img src="c-128_1.png"/><br/>
&#160;&#160;<br/>
128&#160;<br/>
routines of a macro processor or a&#160;compiler. For example, consider the&#160;#define&#160;statement.&#160;<br/>When a line like &#160;<br/>&#160;<br/>&#160; &#160;#define &#160;IN &#160;1&#160;<br/>
is encountered, the name&#160;IN&#160;and the replacement text&#160;1&#160;are stored in a table. Later, when the&#160;<br/>name&#160;IN&#160;appears in a statement like &#160;<br/>&#160;<br/>&#160; &#160;state = IN;&#160;<br/>
it must be replaced by&#160;1. &#160;<br/>
There are two routines that manipulate the names and replacement texts.&#160;install(s,t)&#160;<br/>records the name&#160;s&#160;and the replacement text&#160;t&#160;in a table;&#160;s&#160;and&#160;t&#160;are just character strings.&#160;<br/>lookup(s)&#160;searches for&#160;s&#160;in the table, and returns a pointer to the place where it was found,&#160;<br/>or&#160;NULL&#160;if&#160;it wasn't&#160;there. &#160;<br/>
The algorithm&#160;is a hash-search - the incoming&#160;name is converted into a small non-negative&#160;<br/>integer, which is then used to index into an&#160;array of pointers. An array element points to the&#160;<br/>beginning of a linked list of blocks describing&#160;names that have that hash value. It is&#160;NULL&#160;if no&#160;<br/>names have hashed to that value. &#160;<br/>
&#160;<br/>
A block in the list is a structure containing pointers to the name, the replacement text, and the&#160;<br/>next block in the list. A null next-pointer marks the end of the list. &#160;<br/>
&#160;<br/>&#160; &#160;struct nlist { &#160; &#160; &#160; /* table entry: */&#160;<br/>&#160; &#160; &#160; &#160;struct nlist *next; &#160; /* next entry in chain */&#160;<br/>&#160; &#160; &#160; &#160;char *name; &#160; &#160; &#160; &#160; &#160; /* defined name */&#160;<br/>&#160; &#160; &#160; &#160;char *defn; &#160; &#160; &#160; &#160; &#160; /* replacement text */&#160;<br/>&#160; &#160;};&#160;<br/>
The pointer array is just &#160;<br/>&#160;<br/>&#160; &#160;#define HASHSIZE 101&#160;<br/>&#160;<br/>&#160; &#160;static struct nlist *hashtab[HASHSIZE]; &#160;/* pointer table */&#160;<br/>
The hashing function, which is used by both&#160;lookup&#160;and&#160;install, adds each character value&#160;<br/>in the string to a scrambled combination of&#160;the previous ones and returns the remainder&#160;<br/>modulo the array size. This is not the best possible hash function, but it is short and effective. &#160;<br/>&#160;<br/>&#160; &#160;/* hash: &#160;form hash value for string s */&#160;<br/>&#160; &#160;unsigned hash(char *s)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;unsigned hashval;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;for (hashval = 0; *s != '\0'; s++)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;hashval = *s + 31 * hashval;&#160;<br/>
<hr/>
<a name=129></a>&#160;&#160;<br/>
129&#160;<br/>
&#160; &#160; &#160; &#160;return hashval % HASHSIZE;&#160;<br/>&#160; &#160;}&#160;<br/>
Unsigned arithmetic ensures that the hash value is non-negative. &#160;<br/>
The hashing process produces a starting index in the array&#160;hashtab; if&#160;the string is to be&#160;<br/>found anywhere, it will be in the&#160;list of blocks beginning there. The search is performed by&#160;<br/>lookup. If&#160;lookup&#160;finds the entry already present, it returns a pointer to it; if&#160;not, it returns&#160;<br/>
NULL. &#160;<br/>
&#160;<br/>&#160; &#160;/* lookup: &#160;look for s in hashtab */&#160;<br/>&#160; &#160;struct nlist *lookup(char *s)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;struct nlist *np;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;for (np = hashtab[hash(s)]; &#160;np != NULL; np = np-&gt;next)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;if (strcmp(s, np-&gt;name) == 0)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;return np; &#160; &#160; /* found */&#160;<br/>&#160; &#160; &#160; &#160;return NULL; &#160; &#160; &#160; &#160; &#160; /* not found */&#160;<br/>&#160; &#160;}&#160;<br/>
The&#160;for&#160;loop in&#160;lookup&#160;is the standard idiom&#160;for walking along a linked list: &#160;<br/>&#160;<br/>&#160; &#160;for (ptr = head; ptr != NULL; ptr = ptr-&gt;next)&#160;<br/>&#160; &#160;...&#160;<br/>
install&#160;uses&#160;lookup&#160;to determine whether the name being installed is already present; if&#160;so,&#160;<br/>the new definition will supersede the old&#160;one. Otherwise, a new entry is created.&#160;install&#160;<br/>returns&#160;NULL&#160;if for any reason there is no room&#160;for a new entry. &#160;<br/>&#160;<br/>&#160; &#160;struct nlist *lookup(char *);&#160;<br/>&#160; &#160;char *strdup(char *);&#160;<br/>&#160;<br/>&#160; &#160;/* install: &#160;put (name, defn) in hashtab */&#160;<br/>&#160; &#160;struct nlist *install(char *name, char *defn)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;struct nlist *np;&#160;<br/>&#160; &#160; &#160; &#160;unsigned hashval;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;if ((np = lookup(name)) == NULL) { /* not found */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;np = (struct nlist *) malloc(sizeof(*np));&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;if (np == NULL || (np-&gt;name = strdup(name)) == NULL)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;return NULL;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;hashval = hash(name);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;np-&gt;next = hashtab[hashval];&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;hashtab[hashval] = np;&#160;<br/>&#160; &#160; &#160; &#160;} else &#160; &#160; &#160; /* already there */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;free((void *) np-&gt;defn); &#160; /*free previous defn */&#160;<br/>&#160; &#160; &#160; &#160;if ((np-&gt;defn = strdup(defn)) == NULL)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;return NULL;&#160;<br/>&#160; &#160; &#160; &#160;return np;&#160;<br/>&#160; &#160;}&#160;<br/>
<b>Exercise 6-5.</b>&#160;Write a function&#160;undef&#160;that will remove a name and definition from&#160;the table&#160;<br/>maintained by&#160;lookup&#160;and&#160;install. &#160;<br/>
<b>Exercise 6-6.</b>&#160;Implement a simple version of the&#160;#define&#160;processor (i.e., no arguments)&#160;<br/>suitable for use with C programs, based on the routines of this section. You may also find&#160;<br/>getch&#160;and&#160;ungetch&#160;helpful. &#160;<br/>
<b>6.7 Typedef&#160;</b><br/>
<hr/>
<a name=130></a>&#160;&#160;<br/>
130&#160;<br/>
C provides a facility called&#160;typedef&#160;for creating new data type names. For example, the&#160;<br/>declaration &#160;<br/>&#160;<br/>&#160; &#160;typedef int Length;&#160;<br/>
makes the name&#160;Length&#160;a synonym&#160;for&#160;int. The type&#160;Length&#160;can be used in declarations,&#160;<br/>casts, etc., in exactly the same ways that the&#160;int&#160;type can be: &#160;<br/>&#160;<br/>&#160; &#160;Length len, maxlen;&#160;<br/>&#160; &#160;Length *lengths[];&#160;<br/>
Similarly, the declaration &#160;<br/>&#160;<br/>&#160; &#160;typedef char *String;&#160;<br/>
makes&#160;&#160;String&#160;a synonym&#160;for&#160;char *&#160;or character pointer, which may then be used in&#160;<br/>declarations and casts: &#160;<br/>&#160;<br/>&#160; &#160;String p, lineptr[MAXLINES], alloc(int);&#160;<br/>&#160; &#160;int strcmp(String, String);&#160;<br/>&#160; &#160;p = (String) malloc(100);&#160;<br/>
Notice that the type being declared in a&#160;typedef&#160;appears in the position of a variable name,&#160;<br/>not right after the word&#160;typedef. Syntactically,&#160;typedef&#160;is like the storage classes&#160;extern,&#160;<br/>static, etc. We have used capitalized names for&#160;typedefs, to make them&#160;stand out. &#160;<br/>
As a more complicated example, we could make&#160;typedefs for the tree nodes shown earlier in&#160;<br/>this chapter: &#160;<br/>
&#160;<br/>&#160; &#160;typedef struct tnode *Treeptr;&#160;<br/>&#160;<br/>&#160; &#160;typedef struct tnode { /* the tree node: */&#160;<br/>&#160; &#160; &#160; &#160;char *word; &#160; &#160; &#160; &#160; &#160; /* points to the text */&#160;<br/>&#160; &#160; &#160; &#160;int count; &#160; &#160; &#160; &#160; &#160; &#160;/* number of occurrences */&#160;<br/>&#160; &#160; &#160; &#160;struct tnode *left; &#160; /* left child */&#160;<br/>&#160; &#160; &#160; &#160;struct tnode *right; &#160;/* right child */&#160;<br/>&#160; &#160;} Treenode;&#160;<br/>
This creates two new type keywords called&#160;Treenode&#160;(a structure) and&#160;Treeptr&#160;(a pointer to&#160;<br/>the structure). Then the routine&#160;talloc&#160;could become&#160;&#160;<br/>&#160;<br/>&#160; &#160;Treeptr talloc(void)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;return (Treeptr) malloc(sizeof(Treenode));&#160;<br/>&#160; &#160;}&#160;<br/>
It must be emphasized that a&#160;typedef&#160;declaration does not create a&#160;new type in any sense; it&#160;<br/>merely adds a new name&#160;for some&#160;existing type. Nor are there any new semantics: variables&#160;<br/>declared this way have exactly the same properties as variables whose declarations are spelled&#160;<br/>out explicitly. In effect,&#160;typedef&#160;is like&#160;#define, except that since it is interpreted by the&#160;<br/>compiler, it can cope with textual substitutions that are beyond the capabilities of the&#160;<br/>preprocessor. For example, &#160;<br/>&#160;<br/>&#160; &#160;typedef int (*PFI)(char *, char *);&#160;<br/>
creates the type&#160;PFI, for ``pointer to function (of two&#160;char *&#160;arguments) returning&#160;int,''&#160;<br/>which can be used in contexts like &#160;<br/>&#160;<br/>&#160; &#160;PFI strcmp, numcmp;&#160;<br/>
in the sort program&#160;of&#160;<a href="">Chapter 5. &#160;</a><br/>
Besides purely aesthetic issues, there are two main reasons for using&#160;typedefs. The first is to&#160;<br/>parameterize a program&#160;against portability problems. If&#160;typedefs are used for data types that&#160;<br/>
<hr/>
<a name=131></a>&#160;&#160;<br/>
131&#160;<br/>
may be machine-dependent, only the&#160;typedefs need change when the program&#160;is moved. One&#160;<br/>common situation is to use&#160;typedef&#160;names for various integer quantities, then make an&#160;<br/>appropriate set of choices of&#160;short,&#160;int, and&#160;long&#160;for each host machine. Types like&#160;size_t&#160;<br/>and&#160;ptrdiff_t&#160;from&#160;the standard library are examples. &#160;<br/>
The second purpose of&#160;typedefs is to provide better documentation for a program&#160;- a type&#160;<br/>called&#160;&#160;Treeptr&#160;may be easier to understand than one declared only as a pointer to a&#160;<br/>complicated structure. &#160;<br/>
<b>6.8 Unions&#160;</b><br/>
A&#160;&#160;<i>union</i>&#160;is a variable that may hold (at different&#160;times) objects of different types and sizes,&#160;<br/>with the compiler keeping track of size and alignment requirements. Unions provide a way to&#160;<br/>manipulate different kinds of data in a single area of storage, without embedding any&#160;<br/>machine-dependent information in the program. They are analogous to variant records in&#160;<br/>pascal. &#160;<br/>
As an example such as might be found in a&#160;compiler symbol table manager, suppose that a&#160;<br/>constant may be an&#160;int, a&#160;float, or a character pointer. The value of a particular constant&#160;<br/>must be stored in a variable of the proper type, yet it is most convenient for table management&#160;<br/>if the value occupies the same amount of storage and is stored in the same place regardless of&#160;<br/>its type. This is the purpose of&#160;a union - a single variable that can legitimately hold any of&#160;one&#160;<br/>of several types. The syntax is based on structures: &#160;<br/>
&#160;<br/>&#160; &#160;union u_tag {&#160;<br/>&#160; &#160; &#160; &#160;int ival;&#160;<br/>&#160; &#160; &#160; &#160;float fval;&#160;<br/>&#160; &#160; &#160; &#160;char *sval;&#160;<br/>&#160; &#160;} u;&#160;<br/>
The variable&#160;u&#160;will be large enough to hold the largest of&#160;the three types; the specific size is&#160;<br/>implementation-dependent. Any of&#160;these types may be assigned to&#160;u&#160;and then used in&#160;<br/>expressions, so long as the usage is consistent: the type retrieved must be the type most&#160;<br/>recently stored. It is the programmer's responsibility&#160;to keep track of which type is currently&#160;<br/>stored in a union; the results are implementation-dependent if something is stored as one type&#160;<br/>and extracted as another. &#160;<br/>
Syntactically, members of a union are accessed as &#160;<br/>
&#160;&#160;<i>union-name</i>.<i>member</i>&#160;&#160;<br/>
or &#160;<br/>
&#160;&#160;<i>union-pointer</i>-&gt;<i>member</i>&#160;&#160;<br/>
just as for structures. If the variable&#160;utype&#160;is used to keep track of the current type stored in&#160;u,&#160;<br/>then one might see code such as &#160;<br/>
&#160;<br/>&#160; &#160;if (utype == INT)&#160;<br/>&#160; &#160; &#160; &#160;printf(&#34;%d\n&#34;, u.ival);&#160;<br/>&#160; &#160;if (utype == FLOAT)&#160;<br/>&#160; &#160; &#160; &#160;printf(&#34;%f\n&#34;, u.fval);&#160;<br/>
<hr/>
<a name=132></a>&#160;&#160;<br/>
132&#160;<br/>
&#160; &#160;if (utype == STRING)&#160;<br/>&#160; &#160; &#160; &#160;printf(&#34;%s\n&#34;, u.sval);&#160;<br/>&#160; &#160;else&#160;<br/>&#160; &#160; &#160; &#160;printf(&#34;bad type %d in utype\n&#34;, utype);&#160;<br/>
Unions may occur within structures and arrays, and vice versa. The notation for accessing a&#160;<br/>member of a union in a structure (or vice versa) is identical to that for nested structures. For&#160;<br/>example, in the structure array defined by &#160;<br/>&#160;<br/>&#160; &#160;struct {&#160;<br/>&#160; &#160; &#160; &#160;char *name;&#160;<br/>&#160; &#160; &#160; &#160;int flags;&#160;<br/>&#160; &#160; &#160; &#160;int utype;&#160;<br/>&#160; &#160; &#160; &#160;union {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;int ival;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;float fval;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;char *sval;&#160;<br/>&#160; &#160; &#160; &#160;} u;&#160;<br/>&#160; &#160;} symtab[NSYM];&#160;<br/>
the&#160;member&#160;ival&#160;is referred to as &#160;<br/>&#160;<br/>&#160; &#160;symtab[i].u.ival&#160;<br/>
and the first character of the string&#160;sval&#160;by either of &#160;<br/>&#160;<br/>&#160; &#160;*symtab[i].u.sval&#160;<br/>&#160;<br/>&#160; &#160;symtab[i].u.sval[0]&#160;<br/>
In effect, a union is a structure in which all&#160;members have offset zero from&#160;the base, the&#160;<br/>structure is big enough to hold the ``widest'' member, and the alignment is appropriate for all&#160;<br/>of&#160;the types in the union. The same operations are permitted on unions as on structures:&#160;<br/>assignment to or copying as a unit, taking the address, and accessing a member. &#160;<br/>
A union may only be initialized with a value of&#160;the type of&#160;its first member; thus union&#160;u&#160;<br/>described above can only be initialized with an integer value. &#160;<br/>
The storage allocator in&#160;<a href="">Chapter 8&#160;shows how a union can be used to force a variable to be&#160;<br/></a>aligned on a particular kind of storage boundary. &#160;<br/>
<b>6.9 Bit-fields&#160;</b><br/>
When storage space is at a premium,&#160;it may be&#160;necessary to pack several objects into a single&#160;<br/>machine word; one common use is a set of single-bit flags in applications like compiler&#160;<br/>symbol tables. Externally-imposed data formats,&#160;such as interfaces to hardware devices, also&#160;<br/>often require the ability to get at pieces of a word. &#160;<br/>
Imagine a fragment of a compiler that manipulates a symbol table. Each identifier in a&#160;<br/>program&#160;has certain information associated with it, for example, whether or not it is a&#160;<br/>keyword, whether or not it is external and/or static, and so on. The most compact way to&#160;<br/>encode such information is a set of one-bit flags in a single&#160;char&#160;or&#160;int. &#160;<br/>
The usual way this is done is to define a set of ``masks'' corresponding to the relevant bit&#160;<br/>positions, as in &#160;<br/>
&#160;<br/>&#160; &#160;#define KEYWORD &#160;01&#160;<br/>&#160; &#160;#define EXTRENAL 02&#160;<br/>&#160; &#160;#define STATIC &#160; 04&#160;<br/>
<hr/>
<a name=133></a>&#160;&#160;<br/>
133&#160;<br/>
or &#160;<br/>&#160;<br/>&#160; &#160;enum { KEYWORD = 01, EXTERNAL = 02, STATIC = 04 };&#160;<br/>
The numbers must be powers of two. Then&#160;accessing the bits becomes a matter of ``bit-<br/>fiddling'' with the shifting, masking, and complementing operators that were described in&#160;<br/><a href="">Chapter 2. &#160;</a><br/>
Certain idioms appear frequently: &#160;<br/>
&#160;<br/>&#160; &#160;flags |= EXTERNAL | STATIC;&#160;<br/>
turns on the&#160;EXTERNAL&#160;and&#160;STATIC&#160;bits in&#160;flags, while &#160;<br/>&#160;<br/>&#160; &#160;flags &amp;= ~(EXTERNAL | STATIC);&#160;<br/>
turns them&#160;off,&#160;and &#160;<br/>&#160;<br/>&#160; &#160;if ((flags &amp; (EXTERNAL | STATIC)) == 0) ...&#160;<br/>
is true if&#160;both bits are off.&#160;&#160;<br/>
Although these idioms are readily mastered, as&#160;an alternative C offers the capability of&#160;<br/>defining and accessing fields within a word directly rather than by bitwise logical operators.&#160;<br/>A&#160;<i>bit-field</i>, or&#160;<i>field</i>&#160;for short, is a set of adjacent bits within a single implementation-defined&#160;<br/>storage unit that we will call a ``word.''&#160;For example, the symbol table&#160;#defines above could&#160;<br/>be replaced by the definition of three fields: &#160;<br/>
&#160;<br/>&#160; &#160;struct {&#160;<br/>&#160; &#160; &#160; &#160;unsigned int is_keyword : 1;&#160;<br/>&#160; &#160; &#160; &#160;unsigned int is_extern &#160;: 1;&#160;<br/>&#160; &#160; &#160; &#160;unsigned int is_static &#160;: 1;&#160;<br/>&#160; &#160;} flags;&#160;<br/>
This defines a variable table called&#160;flags&#160;that contains three 1-bit fields. The number&#160;<br/>following the colon represents the field width in bits. The fields are declared&#160;unsigned int&#160;<br/>to ensure that they are unsigned quantities. &#160;<br/>
Individual fields are referenced in the&#160;same way as other structure members:&#160;<br/>flags.is_keyword,&#160;&#160;flags.is_extern, etc. Fields behave like small integers, and may&#160;<br/>participate in arithmetic expressions just like other integers. Thus the previous examples may&#160;<br/>be written more naturally as &#160;<br/>
&#160;<br/>&#160; &#160;flags.is_extern = flags.is_static = 1;&#160;<br/>
to turn the bits on; &#160;<br/>&#160;<br/>&#160; &#160;flags.is_extern = flags.is_static = 0;&#160;<br/>
to turn them&#160;off;&#160;and &#160;<br/>&#160;<br/>&#160; &#160;if (flags.is_extern == 0 &amp;&amp; flags.is_static == 0)&#160;<br/>&#160; &#160; &#160; &#160;...&#160;<br/>
to test them. &#160;<br/>
Almost everything about fields is implementation-dependent. Whether a field may overlap a&#160;<br/>word boundary is implementation-defined. Fields&#160;need not be names; unnamed fields (a colon&#160;<br/>and width only) are used for padding. The special&#160;width 0 may be used&#160;to force alignment at&#160;<br/>the next word boundary. &#160;<br/>
<hr/>
<a name=134></a>&#160;&#160;<br/>
134&#160;<br/>
Fields are assigned left to right on some machines&#160;and right to left on others. This means that&#160;<br/>although fields are useful for maintaining internally-defined data structures, the question of&#160;<br/>which end comes first has to be carefully considered when picking apart externally-defined&#160;<br/>data; programs that depend on such things are not&#160;portable. Fields may be declared only as&#160;<br/>ints; for portability, specify&#160;signed&#160;or&#160;unsigned&#160;explicitly. They are not arrays and they do&#160;<br/>not have addresses, so the&#160;&amp;&#160;operator cannot be applied on them. &#160;<br/>
<hr/>
<a name=135></a>&#160;&#160;<br/>
135&#160;<br/>
&#160;<br/>
<b>Chapter&#160;7 - Input and Output&#160;</b><br/>
Input and output are not part of&#160;the C language itself, so we have not emphasized them&#160;in our&#160;<br/>presentation thus far. Nonetheless, programs interact with their environment in much more&#160;<br/>complicated ways than those we have shown before. In this chapter we will describe the&#160;<br/>standard library, a set of functions that provide input and output, string handling, storage&#160;<br/>management, mathematical routines, and a variety of&#160;other services for C programs. We will&#160;<br/>concentrate on input and output &#160;<br/>
The ANSI standard defines these library functions precisely, so that they can exist in&#160;<br/>compatible form&#160;on any system&#160;where C exists. Programs that confine their system&#160;<br/>interactions to facilities provided by the standard library can be moved from&#160;one system&#160;to&#160;<br/>another without change. &#160;<br/>
The properties of library functions are specified in more than a dozen headers; we have&#160;<br/>already seen several of these, including&#160;&lt;stdio.h&gt;,&#160;&#160;&lt;string.h&gt;, and&#160;&lt;ctype.h&gt;. We will&#160;<br/>not present the entire library here, since we are&#160;more interested in writing C programs that use&#160;<br/><a href="">it. The library is described in detail in&#160;Appendix B. &#160;</a><br/>
<b>7.1 Standard Input and Output&#160;</b><br/>
As we said in&#160;<a href="">Chapter 1, the library im</a>plements a simple&#160;model of text input and output. A&#160;<br/>text stream&#160;consists of a sequence of lines;&#160;each line ends with a newline character. If the&#160;<br/>system&#160;doesn't operate that way, the library does&#160;whatever necessary to make it appear as if&#160;it&#160;<br/>does. For instance, the library might convert carriage return and linefeed to newline on input&#160;<br/>and back again on output. &#160;<br/>
The simplest input mechanism&#160;is to read one character at a time from&#160;the&#160;<i>standard input</i>,&#160;<br/>normally the keyboard, with&#160;getchar: &#160;<br/>
&#160;<br/>&#160; &#160;int getchar(void)&#160;<br/>
getchar&#160;returns the next input character each time it is called, or&#160;EOF&#160;when it encounters end&#160;<br/>of file. The symbolic constant&#160;EOF&#160;is defined in&#160;&lt;stdio.h&gt;. The value is typically -1, bus&#160;<br/>tests should be written in terms of&#160;EOF&#160;so as to be independent of the specific value. &#160;<br/>
In many environments, a file may be substituted for the keyboard by using the &lt; convention&#160;<br/>for input redirection: if a program&#160;prog&#160;uses&#160;getchar, then the command line &#160;<br/>
&#160;<br/>&#160; &#160;prog &lt;infile&#160;<br/>
causes&#160;&#160;prog&#160;to read characters from&#160;infile&#160;instead. The switching of the input is done in&#160;<br/>such a way that&#160;prog&#160;itself&#160;is oblivious to the change; in particular, the string ``&lt;infile'' is&#160;<br/>not included in the command-line arguments in&#160;argv. Input switching is also invisible if the&#160;<br/>input comes from&#160;another program&#160;via a pipe mechanism:&#160;on some systems, the command&#160;<br/>line &#160;<br/>&#160;<br/>&#160; &#160;otherprog | prog&#160;<br/>
<hr/>
<a name=136></a>&#160;&#160;<br/>
136&#160;<br/>
runs the two programs&#160;otherprog&#160;and&#160;prog, and pipes the standard output of&#160;otherprog&#160;into&#160;<br/>the standard input for&#160;prog. &#160;<br/>
The function &#160;<br/>
&#160;<br/>&#160; &#160;int putchar(int)&#160;<br/>
is used for output:&#160;putchar(c)&#160;puts the character&#160;c&#160;on the&#160;standard output, which is by&#160;<br/>default the screen.&#160;putchar&#160;returns the character written, or&#160;EOF&#160;is an error occurs. Again,&#160;<br/>output can usually be directed to a file with &gt;<i>filename</i>: if&#160;prog&#160;uses&#160;putchar, &#160;<br/>&#160;<br/>&#160; &#160;prog &gt;outfile&#160;<br/>
will write the standard output to&#160;outfile&#160;instead. If pipes are supported, &#160;<br/>&#160;<br/>&#160; &#160;prog | anotherprog&#160;<br/>
puts the standard output of&#160;prog&#160;into the standard input of&#160;anotherprog. &#160;<br/>
Output produced by&#160;printf&#160;also finds its way to the standard output. Calls to&#160;putchar&#160;and&#160;<br/>printf&#160;may be interleaved - output happens in the order in which the calls are made. &#160;<br/>
Each source file that refers to an input/output library function must contain the line &#160;<br/>
&#160;<br/>&#160; &#160;#include &lt;stdio.h&gt;&#160;<br/>
before the first reference. When the name is bracketed by &lt; and &gt; a search is made for the&#160;<br/>header in a standard set of places (for example, on UNIX systems, typically in the directory&#160;<br/>/usr/include). &#160;<br/>
Many programs read only one input stream&#160;and write only one output stream; for such&#160;<br/>programs, input and output with&#160;getchar,&#160;&#160;putchar, and&#160;printf&#160;may be entirely adequate,&#160;<br/>and is certainly enough to get started. This is particularly true if redirection is used to connect&#160;<br/>the output of one program&#160;to the input of the next. For example, consider the program&#160;lower,&#160;<br/>which converts its input to lower case: &#160;<br/>
&#160;<br/>&#160; &#160;#include &lt;stdio.h&gt;&#160;<br/>&#160; &#160;#include &lt;ctype.h&gt;&#160;<br/>&#160;<br/>&#160; &#160;main() /* lower: convert input to lower case*/&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int c&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;while ((c = getchar()) != EOF)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;putchar(tolower(c));&#160;<br/>&#160; &#160; &#160; &#160;return 0;&#160;<br/>&#160; &#160;}&#160;<br/>
The function&#160;tolower&#160;is defined in&#160;&lt;ctype.h&gt;; it converts an upper case letter to lower case,&#160;<br/>and returns other characters untouched. As we mentioned earlier, ``functions'' like&#160;getchar&#160;<br/>and&#160;&#160;putchar&#160;in&#160;&lt;stdio.h&gt;&#160;and&#160;tolower&#160;in&#160;&lt;ctype.h&gt;&#160;are often macros, thus avoiding the&#160;<br/>overhead of a function call per character. We&#160;will show how this is done in&#160;<a href="">Section 8.5</a>.&#160;<br/>Regardless of how the&#160;&lt;ctype.h&gt;&#160;functions are implemented on a given machine, programs&#160;<br/>that use them&#160;are shielded from&#160;knowledge of the character set. &#160;<br/>
<b>Exercise 7-1.</b>&#160;Write a program&#160;that converts upper case to lower or lower case to upper,&#160;<br/>depending on the name&#160;it is invoked with, as found in&#160;argv[0]. &#160;<br/>
<hr/>
<a name=137></a>&#160;&#160;<br/>
137&#160;<br/>
<b>7.2 Formatted Output - printf&#160;</b><br/>
The output function&#160;printf&#160;translates internal values to characters. We have used&#160;printf&#160;<br/>informally in previous chapters. The description here covers most typical uses but is not&#160;<br/>complete; for the fu<a href="">ll story, see&#160;Appendix B. &#160;<br/></a>&#160;<br/>&#160; &#160;int printf(char *format, arg1, arg2, ...);&#160;<br/>
printf&#160;converts, formats, and prints its arguments on the standard output under control of the&#160;<br/>
format. It returns the number of characters printed. &#160;<br/>
The format string contains two types of objects:&#160;ordinary characters, which are copied to the&#160;<br/>output stream, and conversion specifications, each&#160;of which causes conversion and printing of&#160;<br/>the next successive argument to&#160;printf. Each conversion specification begins with a % and&#160;<br/>ends with a conversion character. Between the % and the conversion character there may be,&#160;<br/>in order: &#160;<br/>
•&#160;&#160;A minus sign, which specifies left adjustment of the converted argument. &#160;<br/>•&#160;&#160;A number that specifies the minimum&#160;field width. The converted argument will be&#160;<br/>
printed in a field at least this wide. If&#160;necessary it will be padded on the left&#160;(or right,&#160;<br/>if&#160;left&#160;adjustment is called for) to make up the field width. &#160;<br/>
•&#160;&#160;A period, which separates the field width from&#160;the precision. &#160;<br/>•&#160;&#160;A number, the precision, that specifies&#160;the maximum&#160;number of characters to be&#160;<br/>
printed from&#160;a string, or the number of digits&#160;after the decimal point of a floating-point&#160;<br/>value, or the minimum&#160;number of digits for an integer. &#160;<br/>
•&#160;&#160;An&#160;h&#160;if&#160;the integer is to be printed as a&#160;short, or&#160;l&#160;(letter ell) if&#160;as a&#160;long. &#160;<br/>
Conversion characters are shown in Table 7.1. If&#160;the character after the % is not a conversion&#160;<br/>specification, the behavior is undefined. &#160;<br/>
<i><b>Table 7.1</b>&#160;Basic Printf Conversions</i>&#160;&#160;<br/>
<b>Character&#160;</b><br/>
<b>Argument type; Printed As &#160;</b><br/>
d,i&#160;<br/>
int; decimal number&#160;<br/>
o&#160;&#160;<br/>
int; unsigned octal number (without a leading zero)&#160;<br/>
x,X&#160;<br/>
int; unsigned hexadecimal number (without a leading&#160;0x&#160;or&#160;0X), using&#160;abcdef&#160;or&#160;<br/>
ABCDEF&#160;for 10, ...,15.&#160;<br/>
u&#160;&#160;<br/>
int; unsigned decimal number&#160;<br/>
c&#160;&#160;<br/>
int; single character&#160;<br/>
s&#160;<br/>
char *; print characters from&#160;the string until a&#160;'\0'&#160;or the number of characters&#160;<br/>given by the precision.&#160;<br/>
f&#160;<br/>
double;&#160;[-]<i>m.dddddd</i>, where the number of&#160;<i>d</i>'s is given by the precision (default&#160;<br/>6).&#160;<br/>
e,E&#160;<br/>
double;&#160;[-]<i>m.dddddd</i>e+/-<i>xx</i>&#160;or&#160;[-]<i>m.dddddd</i>E+/-<i>xx</i>, where the number of&#160;<i>d</i>'s&#160;is&#160;<br/>given by the precision (default 6).&#160;<br/>
double; use&#160;%e&#160;or&#160;%E&#160;if the exponent is less than -4 or greater than or equal to the&#160;<br/>
g,G&#160;<br/>
precision; otherwise use&#160;%f. Trailing zeros and a trailing decimal point are not&#160;<br/>printed.&#160;<br/>
p&#160;&#160;<br/>
void *; pointer (implementation-dependent representation).&#160;<br/>
<hr/>
<a name=138></a>&#160;&#160;<br/>
138&#160;<br/>
%&#160;&#160;<br/>
no argument is converted; print a %&#160;<br/>
A width or precision may be specified as *,&#160;in which case the value is computed by&#160;<br/>converting the next argument (which must be an&#160;int). For example, to print at most&#160;max&#160;<br/>characters from&#160;a string&#160;s, &#160;<br/>
&#160;<br/>&#160; &#160;printf(&#34;%.*s&#34;, max, s);&#160;<br/>
Most of the format conversions have been illustrated in earlier chapters. One exception is the&#160;<br/>precision as it relates to strings. The following table shows the effect of a variety of&#160;<br/>specifications in printing ``hello, world''&#160;(12 characters). We have put colons around each&#160;<br/>field so you can see it extent. &#160;<br/>&#160;<br/>&#160; &#160;:%s: &#160; &#160; &#160; &#160; &#160;:hello, world:&#160;<br/>&#160; &#160;:%10s: &#160; &#160; &#160; &#160;:hello, world:&#160;<br/>&#160; &#160;:%.10s: &#160; &#160; &#160; :hello, wor:&#160;<br/>&#160; &#160;:%-10s: &#160; &#160; &#160; :hello, world:&#160;<br/>&#160; &#160;:%.15s: &#160; &#160; &#160; :hello, world:&#160;<br/>&#160; &#160;:%-15s: &#160; &#160; &#160; :hello, world &#160; :&#160;<br/>&#160; &#160;:%15.10s: &#160; &#160; : &#160; &#160; hello, wor:&#160;<br/>&#160; &#160;:%-15.10s: &#160; &#160;:hello, wor &#160; &#160; :&#160;<br/>
A warning:&#160;printf&#160;uses its first argument to decide&#160;how many arguments follow and what&#160;<br/>their type is. It will get confused, and you&#160;will get wrong answers, if there are not enough&#160;<br/>arguments of if they are the wrong type. You should also be aware of the difference between&#160;<br/>these two calls: &#160;<br/>&#160;<br/>&#160; &#160;printf(s); &#160; &#160; &#160; &#160; /* FAILS if s contains % */&#160;<br/>&#160; &#160;printf(&#34;%s&#34;, s); &#160; /* SAFE */&#160;<br/>
The function&#160;sprintf&#160;does the same conversions as&#160;printf&#160;does, but stores the output in a&#160;<br/>string: &#160;<br/>&#160;<br/>&#160; &#160;int sprintf(char *string, char *format, arg1, arg2, ...);&#160;<br/>
sprintf&#160;formats the arguments in&#160;arg1,&#160;arg2, etc., according to&#160;format&#160;as before, but places&#160;<br/>the result in&#160;string&#160;instead of the standard output;&#160;string&#160;must be big enough to receive the&#160;<br/>result. &#160;<br/>
<b>Exercise 7-2.</b>&#160;Write a program&#160;that will print arbitrary input in a sensible way. As a&#160;<br/>minimum,&#160;it should print non-graphic characters&#160;in octal or hexadecimal according to local&#160;<br/>custom, and break long text lines. &#160;<br/>
<b>7.3 Variable-length Argument Lists&#160;</b><br/>
This section contains an implementation of a minimal version of&#160;printf, to show how to&#160;<br/>write a function that processes a variable-length argument list in a portable way. Since we are&#160;<br/>mainly interested in the argument processing,&#160;minprintf&#160;will process the format string and&#160;<br/>arguments but will call the real&#160;printf&#160;to do the format conversions. &#160;<br/>
The proper declaration for&#160;printf&#160;is &#160;<br/>
&#160;<br/>&#160; &#160;int printf(char *fmt, ...)&#160;<br/>
where the declaration&#160;...&#160;means that the number and types of these arguments may vary. The&#160;<br/>declaration&#160;...&#160;can only appear at the end of an argument list. Our&#160;minprintf&#160;is declared as &#160;<br/>&#160;<br/>
<hr/>
<a name=139></a>&#160;&#160;<br/>
139&#160;<br/>
&#160; &#160;void minprintf(char *fmt, ...)&#160;<br/>
since we will not return the character count that&#160;printf&#160;does. &#160;<br/>
The tricky bit is how&#160;minprintf&#160;walks along the argument list when&#160;the list doesn't even have&#160;<br/>a name. The standard header&#160;&lt;stdarg.h&gt;&#160;contains a set of macro definitions that define how&#160;<br/>to step through an argument list. The implementation of this header will vary from&#160;machine to&#160;<br/>machine, but the interface it presents is uniform. &#160;<br/>
The type&#160;va_list&#160;is used to declare a variable that&#160;will refer to each argument in turn; in&#160;<br/>minprintf, this variable is called&#160;ap, for ``argument pointer.'' The macro&#160;va_start&#160;initializes&#160;<br/>
ap&#160;to point to the first unnamed argument. It must be called once before&#160;ap&#160;is used. There&#160;<br/>must be at least one named argument; the final named argument is used by&#160;va_start&#160;to get&#160;<br/>started. &#160;<br/>
Each call of&#160;va_arg&#160;returns one argument and steps&#160;ap&#160;to the next;&#160;va_arg&#160;uses a type name&#160;<br/>to determine what type to return and how big a step to take. Finally,&#160;va_end&#160;does whatever&#160;<br/>cleanup is necessary. It must be called before the program&#160;returns. &#160;<br/>
These properties form&#160;the basis of our simplified&#160;printf: &#160;<br/>
&#160;<br/>&#160; &#160;#include &lt;stdarg.h&gt;&#160;<br/>&#160;<br/>&#160; &#160;/* minprintf: minimal printf with variable argument list */&#160;<br/>&#160; &#160;void minprintf(char *fmt, ...)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;va_list ap; /* points to each unnamed arg in turn */&#160;<br/>&#160; &#160; &#160; &#160;char *p, *sval;&#160;<br/>&#160; &#160; &#160; &#160;int ival;&#160;<br/>&#160; &#160; &#160; &#160;double dval;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;va_start(ap, fmt); /* make ap point to 1st unnamed arg */&#160;<br/>&#160; &#160; &#160; &#160;for (p = fmt; *p; p++) {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;if (*p != '%') {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;putchar(*p);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;continue;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;switch (*++p) {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;case 'd':&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;ival = va_arg(ap, int);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;printf(&#34;%d&#34;, ival);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;break;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;case 'f':&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;dval = va_arg(ap, double);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;printf(&#34;%f&#34;, dval);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;break;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;case 's':&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;for (sval = va_arg(ap, char *); *sval; sval++)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;putchar(*sval);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;break;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;default:&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;putchar(*p);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;break;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160; &#160; &#160;va_end(ap); /* clean up when done */&#160;<br/>&#160; &#160;}&#160;<br/>
<b>Exercise 7-3.</b>&#160;Revise&#160;minprintf&#160;to handle more of&#160;the other facilities of&#160;printf. &#160;<br/>
<hr/>
<a name=140></a>&#160;&#160;<br/>
140&#160;<br/>
<b>7.4 Formatted Input - Scanf&#160;</b><br/>
The function&#160;scanf&#160;is the input analog of&#160;printf, providing many of the same&#160;conversion&#160;<br/>facilities in the opposite direction. &#160;<br/>&#160;<br/>&#160; &#160;int scanf(char *format, ...)&#160;<br/>
scanf&#160;reads characters from&#160;the standard input, interprets them&#160;according to the specification&#160;<br/>in&#160;&#160;format, and stores the results through the remaining arguments. The format argument is&#160;<br/>described below; the other arguments,&#160;<i>each of which must be a pointer</i>, indicate where the&#160;<br/>corresponding converted input should be stored. As with&#160;printf, this section is a summary of&#160;<br/>the most useful features, not an exhaustive list. &#160;<br/>
scanf&#160;stops when it exhausts its format string, or&#160;when some input fails to match the control&#160;<br/>specification. It returns as its value the number of successfully matched and assigned input&#160;<br/>items. This can be used to decide how many items were found. On the end of file,&#160;EOF&#160;is&#160;<br/>returned; note that this is different from&#160;0, which means that the next input character does not&#160;<br/>match the first specification in the&#160;format string. The next call to&#160;scanf&#160;resumes searching&#160;<br/>immediately after the last character already converted. &#160;<br/>
There is also a function&#160;sscanf&#160;that reads from&#160;a string instead of the standard input: &#160;<br/>
&#160;<br/>&#160; &#160;int sscanf(char *string, char *format, arg1, arg2, ...)&#160;<br/>
It scans the&#160;string&#160;according to the format in&#160;format&#160;and stores the resulting values through&#160;<br/>arg1,&#160;arg2, etc. These arguments must be pointers. &#160;<br/>
The format string usually contains conversion specifications, which are used to control&#160;<br/>conversion of input. The format string may contain: &#160;<br/>
•&#160;&#160;Blanks or tabs, which are not ignored. &#160;<br/>•&#160;&#160;Ordinary characters (not %), which are expected to match the next non-white space&#160;<br/>
character of the input stream. &#160;<br/>
•&#160;&#160;Conversion specifications, consisting of the character&#160;%, an optional assignment&#160;<br/>
suppression character&#160;*, an optional number specifying a maximum&#160;field width, an&#160;<br/>optional&#160;h,&#160;l&#160;or&#160;L&#160;indicating the width of the target, and a conversion character. &#160;<br/>
A conversion specification directs&#160;the conversion of the next input field. Normally the result&#160;<br/>is places in the variable pointed to by the&#160;corresponding argument. If assignment suppression&#160;<br/>is indicated by the * character, however, the input&#160;field is skipped; no assignment is made. An&#160;<br/>input field is defined as a string of non-white&#160;space characters; it extends either to the next&#160;<br/>white space character or until the field width, is&#160;specified, is exhausted. This implies that&#160;<br/>scanf&#160;will read across boundaries to find its input, since newlines are white space. (White&#160;<br/>space characters are blank, tab, newline, carriage return, vertical tab, and formfeed.) &#160;<br/>
The conversion character indicates the interpretation of the input field. The corresponding&#160;<br/>argument must be a pointer, as required by the call-by-value semantics of C. Conversion&#160;<br/>characters are shown in Table 7.2. &#160;<br/>
<i><b>Table 7.2:</b>&#160;Basic Scanf Conversions</i>&#160;&#160;<br/>
<b>Character&#160;</b><br/>
<b>Input Data; Argument type &#160;</b><br/>
<hr/>
<a name=141></a>&#160;&#160;<br/>
141&#160;<br/>
d&#160;<br/>
decimal integer;&#160;int *&#160;<br/>
integer;&#160;int *. The integer may be in octal (leading&#160;0) or hexadecimal (leading&#160;<br/>
i&#160;<br/>
0x&#160;or&#160;0X).&#160;<br/>
o&#160;<br/>
octal integer (with or without leading zero);&#160;int *&#160;<br/>
u&#160;<br/>
unsigned decimal integer;&#160;unsigned int *&#160;<br/>
x&#160;<br/>
hexadecimal integer (with or without leading&#160;0x&#160;or&#160;0X);&#160;int *&#160;<br/>
characters;&#160;char *. The next input characters (default 1) are placed at the&#160;<br/>
c&#160;<br/>
indicated spot. The normal skip-over white space is suppressed; to read the next&#160;<br/>non-white space character, use&#160;%1s&#160;<br/>
character string (not quoted);&#160;char *, pointing to an array of characters long&#160;<br/>
s&#160;<br/>
enough for the string and a terminating&#160;'\0'&#160;that will be added.&#160;<br/>
floating-point number with optional sign, optional decimal point and optional&#160;<br/>
e,f,g&#160;<br/>
exponent;&#160;float *&#160;<br/>
%&#160;<br/>
literal %; no assignment is made.&#160;<br/>
The conversion characters&#160;d,&#160;i,&#160;o,&#160;u, and&#160;x&#160;may be preceded by&#160;h&#160;to indicate that a pointer to&#160;<br/>short&#160;rather than&#160;int&#160;appears in the argument list, or by&#160;l&#160;(letter ell) to indicate that a pointer&#160;<br/>to&#160;long&#160;appears in the argument list. &#160;<br/>
As a first example, the rudimentary calculator of&#160;<a href="">Chapter 4&#160;can be written with&#160;</a>scanf&#160;to do&#160;<br/>the input conversion: &#160;<br/>
&#160;<br/>&#160; &#160;#include &lt;stdio.h&gt;&#160;<br/>&#160;<br/>&#160; &#160;main() &#160;/* rudimentary calculator */&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;double sum, v;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;sum = 0;&#160;<br/>&#160; &#160; &#160; &#160;while (scanf(&#34;%lf&#34;, &amp;v) == 1)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;printf(&#34;\t%.2f\n&#34;, sum += v);&#160;<br/>&#160; &#160; &#160; &#160;return 0;&#160;<br/>&#160; &#160;}&#160;<br/>
Suppose we want to read input lines that contain dates of the form&#160;&#160;<br/>&#160;<br/>&#160; &#160;25 Dec 1988&#160;<br/>
The&#160;scanf&#160;statement is &#160;<br/>&#160;<br/>&#160; &#160;int day, year;&#160;<br/>&#160; &#160;char monthname[20];&#160;<br/>&#160;<br/>&#160; &#160;scanf(&#34;%d %s %d&#34;, &amp;day, monthname, &amp;year);&#160;<br/>
No&#160;&amp;&#160;is used with&#160;monthname, since an array name is a pointer. &#160;<br/>
Literal characters can appear in the&#160;scanf&#160;format string; they must match the same characters&#160;<br/>in the input. So we could read dates of the form&#160;mm/dd/yy&#160;with the&#160;scanf&#160;statement: &#160;<br/>
&#160;<br/>&#160; &#160;int day, month, year;&#160;<br/>&#160;<br/>&#160; &#160;scanf(&#34;%d/%d/%d&#34;, &amp;month, &amp;day, &amp;year);&#160;<br/>
<hr/>
<a name=142></a>&#160;&#160;<br/>
142&#160;<br/>
scanf&#160;ignores blanks and tabs in its format&#160;string. Furthermore, it skips over white space&#160;<br/>(blanks, tabs, newlines, etc.) as it looks for input&#160;values. To read input whose format is not&#160;<br/>fixed, it is often best to read a line at a time, then pick it apart with&#160;scanf. For example,&#160;<br/>suppose we want to read lines that might contain&#160;a date in either of the forms above. Then we&#160;<br/>could write &#160;<br/>&#160;<br/>&#160; &#160;while (getline(line, sizeof(line)) &gt; 0) {&#160;<br/>&#160; &#160; &#160; &#160;if (sscanf(line, &#34;%d %s %d&#34;, &amp;day, monthname, &amp;year) == 3)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;printf(&#34;valid: %s\n&#34;, line); /* 25 Dec 1988 form */&#160;<br/>&#160; &#160; &#160; &#160;else if (sscanf(line, &#34;%d/%d/%d&#34;, &amp;month, &amp;day, &amp;year) == 3)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;printf(&#34;valid: %s\n&#34;, line); /* mm/dd/yy form */&#160;<br/>&#160; &#160; &#160; &#160;else&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;printf(&#34;invalid: %s\n&#34;, line); /* invalid form */&#160;<br/>&#160; &#160;}&#160;<br/>
Calls to&#160;scanf&#160;can be mixed with calls to other input&#160;functions. The next call to any input&#160;<br/>function will begin by reading the first character not read by&#160;scanf. &#160;<br/>
A final warning: the arguments to&#160;scanf&#160;and&#160;sscanf&#160;&#160;<i>must</i>&#160;be pointers. By far the most&#160;<br/>common error is writing &#160;<br/>
&#160;<br/>&#160; &#160;scanf(&#34;%d&#34;, n);&#160;<br/>
instead of &#160;<br/>&#160;<br/>&#160; &#160;scanf(&#34;%d&#34;, &amp;n);&#160;<br/>
This error is not generally detected at compile time. &#160;<br/>
<b>Exercise 7-4.</b>&#160;Write a private version of&#160;scanf&#160;analogous to&#160;minprintf&#160;from&#160;the previous&#160;<br/>section. &#160;<br/>
<b>Exercise 5-5.</b>&#160;Rewrite the postfix calculator of<a href="">&#160;Chapter 4&#160;to use&#160;</a>scanf&#160;and/or&#160;sscanf&#160;to do&#160;<br/>the input and number conversion. &#160;<br/>
<b>7.5 File Access&#160;</b><br/>
The examples so far have all read the standard input and written the standard output, which&#160;<br/>are automatically defined for a program&#160;by the local operating system. &#160;<br/>
The next step is to write a program&#160;that accesses a file that is&#160;<i>not</i>&#160;already connected to the&#160;<br/>program. One program&#160;that illustrates the need for such operations is&#160;cat, which concatenates&#160;<br/>a set of named files into the standard output.&#160;cat&#160;is used for printing files on the screen, and&#160;<br/>as a general-purpose input collector for programs that do not have the capability of accessing&#160;<br/>files by name. For example, the command &#160;<br/>
&#160;<br/>&#160; &#160;cat x.c y.c&#160;<br/>
prints the contents of&#160;the files&#160;x.c&#160;and&#160;y.c&#160;(and nothing else) on the standard output. &#160;<br/>
The question is how to arrange for the named files to be read - that is, how to connect the&#160;<br/>external names that a user thinks of to the statements that read the data. &#160;<br/>
The rules are simple. Before it can be read or written, a file has to be&#160;<i>opened</i>&#160;by the library&#160;<br/>function&#160;fopen.&#160;fopen&#160;takes an external name like&#160;x.c&#160;or&#160;y.c, does some&#160;housekeeping and&#160;<br/>
<hr/>
<a name=143></a>&#160;&#160;<br/>
143&#160;<br/>
negotiation with the operating system&#160;(details&#160;of which needn't concern us), and returns a&#160;<br/>pointer to be used in subsequent reads or writes of the file. &#160;<br/>
This pointer, called the&#160;<i>file pointer</i>, points to a structure that contains information about the&#160;<br/>file, such as the location of a buffer, the current character position in the buffer, whether the&#160;<br/>file is being read or written, and whether errors&#160;or end of file have occurred. Users don't need&#160;<br/>to know the details, because the definitions obtained from&#160;&lt;stdio.h&gt;&#160;include a structure&#160;<br/>declaration called&#160;FILE. The only declaration needed for a file pointer is exemplified by &#160;<br/>
&#160;<br/>&#160; &#160;FILE *fp;&#160;<br/>&#160; &#160;FILE *fopen(char *name, char *mode);&#160;<br/>
This says that&#160;fp&#160;is a pointer to a&#160;FILE, and&#160;fopen&#160;returns a pointer to a&#160;FILE. Notice that&#160;<br/>FILE&#160;is a type name, like&#160;int, not a structure tag; it is defined with a&#160;typedef. (Details of&#160;<br/>how&#160;fopen&#160;can be implemented on the UNIX system<a href="">&#160;are given in&#160;Section 8.5</a>.) &#160;<br/>
The call to&#160;fopen&#160;in a program&#160;is &#160;<br/>
&#160;<br/>&#160; &#160;fp = fopen(name, mode);&#160;<br/>
The first argument of&#160;fopen&#160;is a character string containing&#160;the name&#160;of the file. The second&#160;<br/>argument is the&#160;<i>mode</i>, also a character string, which indicates how one intends to use the file.&#160;<br/>Allowable modes include read (&#34;r&#34;), write (&#34;w&#34;), and append (&#34;a&#34;). Some systems&#160;<br/>distinguish between text and binary files; for the latter, a&#160;&#34;b&#34;&#160;must be appended to the mode&#160;<br/>string. &#160;<br/>
If a file that does not exist is opened for writing or appending, it is created if possible.&#160;<br/>Opening an existing file for writing causes the old contents to be discarded, while opening for&#160;<br/>appending preserves them. Trying to read a file that does not exist is an error, and there may&#160;<br/>be other causes of error as well, like trying to&#160;read a file when you don't have permission. If&#160;<br/>there is any error,&#160;fopen&#160;will return&#160;NULL. (The error can be identified more precisely; see the&#160;<br/>discussion of error-handling functions at the end of&#160;<a href="">Section 1 in Appendix B.) &#160;</a><br/>
The next thing needed is a way to read or write the file once it is open.&#160;getc&#160;returns the next&#160;<br/>character from&#160;a file; it needs the file pointer to tell it which file. &#160;<br/>
&#160;<br/>&#160; &#160;int getc(FILE *fp)&#160;<br/>
getc&#160;returns the next character from&#160;the stream&#160;referred to by&#160;fp; it returns&#160;EOF&#160;for end of file&#160;<br/>or error. &#160;<br/>
putc&#160;is an output function: &#160;<br/>
&#160;<br/>&#160; &#160;int putc(int c, FILE *fp)&#160;<br/>
putc&#160;writes the character&#160;c&#160;to the file&#160;fp&#160;and returns the character written, or EOF if&#160;an error&#160;<br/>occurs. Like&#160;getchar&#160;and&#160;putchar,&#160;getc&#160;and&#160;putc&#160;may be macros instead of functions. &#160;<br/>
When a C program&#160;is started, the operating system&#160;environment is responsible for opening&#160;<br/>three files and providing pointers for them. These files are the standard input, the standard&#160;<br/>output, and the standard error; the corresponding file pointers are called&#160;stdin,&#160;stdout, and&#160;<br/>stderr, and are declared in&#160;&lt;stdio.h&gt;. Normally&#160;stdin&#160;is connected to the keyboard and&#160;<br/>
<hr/>
<a name=144></a>&#160;&#160;<br/>
144&#160;<br/>
stdout&#160;and&#160;stderr&#160;are connected to the screen, but&#160;stdin&#160;and&#160;stdout&#160;may be redirected to&#160;<br/>files or pipes as described in&#160;<a href="">Section 7.1. &#160;</a><br/>
getchar&#160;and&#160;putchar&#160;can be defined in terms of&#160;getc,&#160;putc,&#160;stdin, and&#160;stdout&#160;as follows: &#160;<br/>
&#160;<br/>&#160; &#160;#define getchar() &#160; &#160;getc(stdin)&#160;<br/>&#160; &#160;#define putchar(c) &#160; putc((c), stdout)&#160;<br/>
For formatted input or output&#160;of files, the functions&#160;fscanf&#160;and&#160;fprintf&#160;may be used. These&#160;<br/>are identical to&#160;scanf&#160;and&#160;printf, except that the first argument is a file pointer that specifies&#160;<br/>the file to be read or written; the format string is the second argument. &#160;<br/>&#160;<br/>&#160; &#160;int fscanf(FILE *fp, char *format, ...)&#160;<br/>&#160; &#160;int fprintf(FILE *fp, char *format, ...)&#160;<br/>
With these preliminaries out of&#160;the way, we&#160;are now in a position to write the program&#160;cat&#160;to&#160;<br/>concatenate files. The design is one that has been found convenient for many programs. If&#160;<br/>there are command-line arguments, they are interpreted as filenames, and processed in order.&#160;<br/>If there are no arguments, the standard input is processed. &#160;<br/>&#160;<br/>&#160; &#160;#include &lt;stdio.h&gt;&#160;<br/>&#160;<br/>&#160; &#160;/* cat: &#160;concatenate files, version 1 */&#160;<br/>&#160; &#160;main(int argc, char *argv[])&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;FILE *fp;&#160;<br/>&#160; &#160; &#160; &#160;void filecopy(FILE *, FILE *)&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;if (argc == 1) /* no args; copy standard input */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;filecopy(stdin, stdout);&#160;<br/>&#160; &#160; &#160; &#160;else&#160;<br/>&#160; &#160; &#160; &#160; &#160; while(--argc &gt; 0)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; if ((fp = fopen(*++argv, &#34;r&#34;)) == NULL) {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; printf(&#34;cat: can't open %s\n, *argv);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; return 1;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; } else {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;filecopy(fp, stdout);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;fclose(fp);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; }&#160;<br/>&#160; &#160; &#160; &#160; &#160; return 0;&#160;<br/>&#160; &#160;}&#160;<br/>&#160;<br/>&#160; &#160; /* filecopy: &#160;copy file ifp to file ofp */&#160;<br/>&#160; &#160; void filecopy(FILE *ifp, FILE *ofp)&#160;<br/>&#160; &#160; {&#160;<br/>&#160; &#160; &#160; &#160; int c;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160; while ((c = getc(ifp)) != EOF)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; putc(c, ofp);&#160;<br/>&#160; &#160; }&#160;<br/>
The file pointers&#160;stdin&#160;and&#160;stdout&#160;are objects of type&#160;FILE *. They are constants, however,&#160;<br/><i>not</i>&#160;variables, so it is not possible to assign to them. &#160;<br/>
The function &#160;<br/>
&#160;<br/>&#160; &#160;int fclose(FILE *fp)&#160;<br/>
is the inverse of&#160;fopen, it breaks the connection between the file pointer and the external&#160;<br/>name that was established by&#160;fopen, freeing the file pointer for another file. Since most&#160;<br/>operating systems have some limit on the number of files that a program&#160;may have open&#160;<br/>
<hr/>
<a name=145></a>145<br/>
simultaneously, it's a good idea to free the file pointers when they are no longer needed, as we&#160;<br/>did in&#160;cat. There is also another reason for&#160;fclose&#160;on an output file - it flushes the buffer in&#160;<br/>which&#160;&#160;putc&#160;is collecting output.&#160;fclose&#160;is called automatically&#160;for each open file when a&#160;<br/>program&#160;terminates normally. (You can close&#160;stdin&#160;and&#160;stdout&#160;if they are not needed. They&#160;<br/>can also be reassigned by the library function&#160;freopen.) &#160;<br/>
<b>7.6 Error Handling - Stderr and Exit&#160;</b><br/>
The treatment of errors in&#160;cat&#160;is not ideal. The trouble is that&#160;if one of the files can't be&#160;<br/>accessed for some reason, the diagnostic is printed at the end of the concatenated output. That&#160;<br/>might be acceptable if the output is going to a screen, but not if it's going into a file or into&#160;<br/>another program&#160;via a pipeline. &#160;<br/>
To handle this situation better,&#160;a second output stream, called&#160;stderr, is assigned to a&#160;<br/>program&#160;in the same way that&#160;stdin&#160;and&#160;stdout&#160;are. Output written on&#160;stderr&#160;normally&#160;<br/>appears on the screen even if the standard output is redirected. &#160;<br/>
Let us revise&#160;cat&#160;to write its error messages on the standard error. &#160;<br/>
&#160; &#160;#include &lt;stdio.h&gt;&#160;<br/>
&#160; &#160;/* cat: &#160;concatenate files, version 2 */&#160;<br/>&#160; &#160;main(int argc, char *argv[])&#160;<br/>&#160; &#160;{&#160;<br/>
FILE *fp;&#160;<br/>void filecopy(FILE *, FILE *);&#160;<br/>char *prog = argv[0]; &#160;/* program name for errors */&#160;<br/>
if (argc == 1 ) /* no args; copy standard input */&#160;<br/>
filecopy(stdin, stdout);&#160;<br/>
else&#160;<br/>
while (--argc &gt; 0)&#160;<br/>
if ((fp = fopen(*++argv, &#34;r&#34;)) == NULL) {&#160;<br/>
fprintf(stderr, &#34;%s: can't open %s\n&#34;,&#160;<br/>
prog, *argv);&#160;<br/>
exit(1);&#160;<br/>
} else {&#160;<br/>
filecopy(fp, stdout);&#160;<br/>fclose(fp);&#160;<br/>
}&#160;<br/>
if (ferror(stdout)) {&#160;<br/>
fprintf(stderr, &#34;%s: error writing stdout\n&#34;, prog);&#160;<br/>exit(2);&#160;<br/>
}&#160;<br/>exit(0);&#160;<br/>
&#160; &#160;}&#160;<br/>
The program&#160;signals errors in two ways. First, the diagnostic output produced by&#160;fprintf&#160;<br/>goes to&#160;stderr, so it finds its way to the screen instead of disappearing down a pipeline or&#160;<br/>into an output file. We included the program&#160;name, from&#160;argv[0], in the message, so if&#160;this&#160;<br/>program&#160;is used with others, the source of an error is identified. &#160;<br/>
Second, the program&#160;uses the standard library function&#160;exit, which terminates program&#160;<br/>execution when it is called. The argument of&#160;exit&#160;is available to whatever process called this&#160;<br/>one, so the success or failure of the program&#160;can&#160;be tested by another program&#160;that uses this&#160;<br/>one as a sub-process. Conventionally, a return&#160;value of 0 signals that all is well; non-zero&#160;<br/>
<hr/>
<a name=146></a>&#160;&#160;<br/>
146&#160;<br/>
values usually signal abnormal situations.&#160;exit&#160;calls&#160;fclose&#160;for each open output file, to&#160;<br/>flush out any buffered output. &#160;<br/>
Within&#160;main,&#160;return&#160;<i>expr</i>&#160;is equivalent to&#160;exit(<i>expr</i>).&#160;exit&#160;has the advantage that it can be&#160;<br/>called from&#160;other functions, and that calls to&#160;it can be found with a pattern-searching program&#160;<br/><a href="">like those in&#160;Chapter 5. &#160;</a><br/>
The function&#160;ferror&#160;returns non-zero if an error occurred on the stream&#160;fp. &#160;<br/>
&#160;<br/>&#160; &#160;int ferror(FILE *fp)&#160;<br/>
Although output errors are rare, they do occur (for example, if a disk fills up), so a production&#160;<br/>program&#160;should check this as well. &#160;<br/>
The function&#160;feof(FILE *)&#160;is analogous to&#160;ferror; it returns non-zero if&#160;end of file has&#160;<br/>occurred on the specified file. &#160;<br/>
&#160;<br/>&#160; &#160;int feof(FILE *fp)&#160;<br/>
We have generally not worried about exit status in our small illustrative programs, but any&#160;<br/>serious program&#160;should take care to return sensible, useful status values. &#160;<br/>
<b>7.7 Line Input and Output&#160;</b><br/>
The standard library provides an input and output routine&#160;fgets&#160;that is similar to the&#160;getline&#160;<br/>function that we have used in earlier chapters: &#160;<br/>&#160;<br/>&#160; &#160;char *fgets(char *line, int maxline, FILE *fp)&#160;<br/>
fgets&#160;reads the next input line (including the newline) from&#160;file&#160;fp&#160;into the character array&#160;<br/>
line; at most&#160;maxline-1&#160;characters will be read. The resulting line is terminated with&#160;'\0'.&#160;<br/>Normally&#160;fgets&#160;returns&#160;line; on end of file or error it returns&#160;NULL. (Our&#160;getline&#160;returns the&#160;<br/>line length, which is a more useful value; zero means end of file.) &#160;<br/>
For output, the function&#160;fputs&#160;writes a string (which need not contain a newline) to a file: &#160;<br/>
&#160;<br/>&#160; &#160;int fputs(char *line, FILE *fp)&#160;<br/>
It returns&#160;EOF&#160;if an error occurs, and non-negative otherwise. &#160;<br/>
The library functions&#160;gets&#160;and&#160;puts&#160;are similar to&#160;fgets&#160;and&#160;fputs, but operate on&#160;stdin&#160;<br/>and&#160;stdout. Confusingly,&#160;gets&#160;deletes the terminating&#160;'\n', and&#160;puts&#160;adds it. &#160;<br/>
To show that there is nothing special about functions like&#160;fgets&#160;and&#160;fputs, here they are,&#160;<br/>copied from&#160;the standard library on our system: &#160;<br/>
&#160;<br/>&#160; &#160;/* fgets: &#160;get at most n chars from iop */&#160;<br/>&#160; &#160;char *fgets(char *s, int n, FILE *iop)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;register int c;&#160;<br/>&#160; &#160; &#160; &#160;register char *cs;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;cs = s;&#160;<br/>&#160; &#160; &#160; &#160;while (--n &gt; 0 &amp;&amp; (c = getc(iop)) != EOF)&#160;<br/>
<hr/>
<a name=147></a>&#160;&#160;<br/>
147&#160;<br/>
&#160; &#160; &#160; &#160; &#160; &#160;if ((*cs++ = c) == '\n')&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;break;&#160;<br/>&#160; &#160; &#160; &#160;*cs = '\0';&#160;<br/>&#160; &#160; &#160; &#160;return (c == EOF &amp;&amp; cs == s) ? NULL : s;&#160;<br/>&#160; &#160;}&#160;<br/>&#160;<br/>&#160; &#160;/* fputs: &#160;put string s on file iop */&#160;<br/>&#160; &#160;int fputs(char *s, FILE *iop)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int c;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;while (c = *s++)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;putc(c, iop);&#160;<br/>&#160; &#160; &#160; &#160;return ferror(iop) ? EOF : 0;&#160;<br/>&#160; &#160;}&#160;<br/>
For no obvious reason, the standard specifies different return values for&#160;ferror&#160;and&#160;fputs. &#160;<br/>
It is easy to implement our&#160;getline&#160;from&#160;fgets: &#160;<br/>
&#160;<br/>&#160; &#160;/* getline: &#160;read a line, return length */&#160;<br/>&#160; &#160;int getline(char *line, int max)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;if (fgets(line, max, stdin) == NULL)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;return 0;&#160;<br/>&#160; &#160; &#160; &#160;else&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;return strlen(line);&#160;<br/>&#160; &#160;}&#160;<br/>
<b>Exercise 7-6.</b>&#160;Write a program&#160;to compare two files, printing the first line where they differ. &#160;<br/>
<b>Exercise 7-7.</b>&#160;Modify the pattern finding program&#160;of&#160;<a href="">Chapter 5&#160;to take its input from</a>&#160;a set of&#160;<br/>named files or, if no files are named as arguments, from&#160;the standard input. Should the file&#160;<br/>name&#160;be printed when a matching line is found?&#160;&#160;<br/>
<b>Exercise 7-8.</b>&#160;Write a program&#160;to print a set of files, starting each new one on a new page,&#160;<br/>with a title and a running page count for each file. &#160;<br/>
<b>7.8 Miscellaneous Functions&#160;</b><br/>
The standard library provides a wide variety of&#160;functions. This section is a brief synopsis of&#160;<br/>the most useful. More details and many other functions can be found in&#160;<a href="">Appendix B</a>. &#160;<br/>
<b>7.8.1 String Operations&#160;</b><br/>
We have already mentioned the string functions&#160;strlen,&#160;strcpy,&#160;strcat, and&#160;strcmp, found&#160;<br/>in&#160;&lt;string.h&gt;. In the following,&#160;s&#160;and&#160;t&#160;are&#160;char *'s, and&#160;c&#160;and&#160;n&#160;are&#160;ints. &#160;<br/>
strcat(s,t)&#160;&#160;<br/>
concatenate&#160;t&#160;to end of&#160;s&#160;<br/>
strncat(s,t,n)&#160;&#160;concatenate&#160;n&#160;characters of&#160;t&#160;to end of&#160;s&#160;<br/>
strcmp(s,t)&#160;&#160;<br/>
return negative, zero, or positive for&#160;s &lt; t,&#160;s == t,&#160;s &gt; t&#160;<br/>
strncmp(s,t,n)&#160;&#160;same as&#160;strcmp&#160;but only in first&#160;n&#160;characters&#160;<br/>
strcpy(s,t)&#160;&#160;<br/>
copy&#160;t&#160;to&#160;s&#160;<br/>
strncpy(s,t,n)&#160;&#160;copy at most&#160;n&#160;characters of&#160;t&#160;to&#160;s&#160;<br/>
strlen(s)&#160;&#160;<br/>
return length of&#160;s&#160;<br/>
<hr/>
<a name=148></a>&#160;&#160;<br/>
148&#160;<br/>
strchr(s,c)&#160;&#160;<br/>
return pointer to first&#160;c&#160;in&#160;s, or&#160;NULL&#160;if not present&#160;<br/>
strrchr(s,c)&#160;&#160;<br/>
return pointer to last&#160;c&#160;in&#160;s, or&#160;NULL&#160;if not present&#160;<br/>
<b>7.8.2 Character Class Testing and Conversion&#160;</b><br/>
Several functions from&#160;&lt;ctype.h&gt;&#160;perform&#160;character tests and conversions. In the following,&#160;<br/>c&#160;is an&#160;int&#160;that can be represented as an&#160;unsigned char&#160;or&#160;EOF. The function returns&#160;int. &#160;<br/>
isalpha(c)&#160;&#160;non-zero if&#160;c&#160;is alphabetic, 0 if not&#160;<br/>
isupper(c)&#160;&#160;non-zero if&#160;c&#160;is upper case, 0 if not&#160;<br/>
islower(c)&#160;&#160;non-zero if&#160;c&#160;is lower case, 0 if&#160;not&#160;<br/>
isdigit(c)&#160;&#160;non-zero if&#160;c&#160;is digit, 0 if not&#160;<br/>
isalnum(c)&#160;&#160;non-zero if&#160;isalpha(c)&#160;or&#160;isdigit(c), 0 if not&#160;<br/>
isspace(c)&#160;&#160;non-zero if&#160;c&#160;is blank, tab, newline, return, formfeed, vertical tab&#160;<br/>
toupper(c)&#160;&#160;return&#160;c&#160;converted to upper case&#160;<br/>
tolower(c)&#160;&#160;return&#160;c&#160;converted to lower case&#160;<br/>
<b>7.8.3 Ungetc&#160;</b><br/>
The standard library provides a rather&#160;restricted version of the function&#160;ungetch&#160;that we&#160;<br/><a href="">wrote in&#160;Chapter 4</a>; it is called&#160;ungetc. &#160;<br/>&#160;<br/>&#160; &#160;int ungetc(int c, FILE *fp)&#160;<br/>
pushes the character&#160;c&#160;back onto file&#160;fp, and returns either&#160;c, or&#160;EOF&#160;for an error. Only one&#160;<br/>character of pushback is guaranteed per file.&#160;ungetc&#160;may be used with any of the input&#160;<br/>functions like&#160;scanf,&#160;getc, or&#160;getchar. &#160;<br/>
<b>7.8.4 Command Execution&#160;</b><br/>
The function&#160;system(char *s)&#160;executes the command contained in the character string&#160;s,&#160;<br/>then resumes execution of the current program. The contents of&#160;s&#160;depend strongly on the local&#160;<br/>operating system. As a trivial example, on UNIX systems, the statement &#160;<br/>&#160;<br/>&#160; &#160;system(&#34;date&#34;);&#160;<br/>
causes the program&#160;date&#160;to be run; it prints the date and time of day on the standard output.&#160;<br/>system&#160;returns a system-dependent integer status from&#160;the command executed. In the UNIX&#160;<br/>system, the status return is the value returned by&#160;exit. &#160;<br/>
<b>7.8.5 Storage Management&#160;</b><br/>
The functions&#160;malloc&#160;and&#160;calloc&#160;obtain blocks of memory dynamically. &#160;<br/>&#160;<br/>&#160; &#160;void *malloc(size_t n)&#160;<br/>
returns a pointer to&#160;n&#160;bytes of&#160;uninitialized storage, or&#160;NULL&#160;if the request cannot be satisfied. &#160;<br/>&#160;<br/>&#160; &#160;void *calloc(size_t n, size_t size)&#160;<br/>
returns a pointer to enough free space for an array of&#160;n&#160;objects of the specified size, or&#160;NULL&#160;if&#160;<br/>the request cannot be satisfied. The storage is initialized to zero. &#160;<br/>
<hr/>
<a name=149></a>&#160;&#160;<br/>
149&#160;<br/>
The pointer returned by&#160;malloc&#160;or&#160;calloc&#160;has the proper alignment for the object in question,&#160;<br/>but it must be cast into the appropriate type, as in &#160;<br/>
&#160;<br/>&#160; &#160;int *ip;&#160;<br/>&#160;<br/>&#160; &#160;ip = (int *) calloc(n, sizeof(int));&#160;<br/>
free(p)&#160;frees the space pointed to by&#160;p, where&#160;p&#160;was originally obtained by a call to&#160;malloc&#160;<br/>or&#160;calloc. There are no restrictions on the order in&#160;which space is freed, but it is a ghastly&#160;<br/>error to free something not obtained by calling&#160;malloc&#160;or&#160;calloc. &#160;<br/>
It is also an error to use something after it&#160;has been freed. A typical&#160;but incorrect piece of&#160;<br/>code is this loop that frees items from&#160;a list: &#160;<br/>
&#160;<br/>&#160; &#160;for (p = head; p != NULL; p = p-&gt;next) /* WRONG */&#160;<br/>&#160; &#160; &#160; &#160;free(p);&#160;<br/>
The right way is to save whatever is needed before freeing: &#160;<br/>&#160;<br/>&#160; &#160;for (p = head; p != NULL; p = q) {&#160;<br/>&#160; &#160; &#160; &#160;q = p-&gt;next;&#160;<br/>&#160; &#160; &#160; &#160;free(p);&#160;<br/>&#160; &#160;}&#160;<br/>
<a href="">Section 8.7&#160;shows the im</a>plementation of&#160;a storage allocator like&#160;malloc, in which allocated&#160;<br/>blocks may be freed in any order. &#160;<br/>
<b>7.8.6 Mathematical Functions&#160;</b><br/>
There are more than twenty mathematical functions declared in&#160;&lt;math.h&gt;; here are some of&#160;<br/>the more frequently used. Each takes one or two&#160;double&#160;arguments and returns a&#160;double. &#160;<br/>
sin(x)&#160;&#160;<br/>
sine of&#160;<i>x</i>,&#160;<i>x</i>&#160;in radians&#160;<br/>
cos(x)&#160;&#160;<br/>
cosine of&#160;<i>x</i>,&#160;<i>x</i>&#160;in radians&#160;<br/>
atan2(y,x)&#160;&#160;arctangent of&#160;<i>y/x</i>, in radians&#160;<br/>
exp(x)&#160;&#160;<br/>
exponential function&#160;<i>ex</i>&#160;<br/>
log(x)&#160;&#160;<br/>
natural (base&#160;<i>e</i>) logarithm&#160;of&#160;<i>x (x&gt;0)</i>&#160;<br/>
log10(x)&#160;&#160;<br/>
common (base 10) logarithm&#160;of&#160;<i>x (x&gt;0)</i>&#160;<br/>
pow(x,y)&#160;&#160;<br/>
<i>xy</i>&#160;<br/>
sqrt(x)&#160;&#160;<br/>
square root of&#160;<i>x (x&gt;0)</i>&#160;<br/>
fabs(x)&#160;&#160;<br/>
absolute value of&#160;<i>x</i>&#160;<br/>
<b>7.8.7 Random Number generation&#160;</b><br/>
The function&#160;rand()&#160;computes a sequence of pseudo-random&#160;integers in the range zero to&#160;<br/>RAND_MAX, which is defined in&#160;&lt;stdlib.h&gt;. One way to produce random&#160;floating-point&#160;<br/>numbers greater than or equal to zero but less than one is &#160;<br/>&#160;<br/>&#160; &#160;#define frand() ((double) rand() / (RAND_MAX+1.0))&#160;<br/>
(If your library already provides a function for&#160;floating-point random&#160;numbers, it is likely to&#160;<br/>have better statistical properties than this one.) &#160;<br/>
<hr/>
<a name=150></a>&#160;&#160;<br/>
150&#160;<br/>
The function&#160;srand(unsigned)&#160;sets the seed for&#160;rand. The portable implementation of&#160;rand&#160;<br/>and&#160;srand&#160;suggested by the standard appears in&#160;<a href="">Section 2.7. &#160;</a><br/>
<b>Exercise 7-9.</b>&#160;Functions like&#160;isupper&#160;can be implemented to save space or to save time.&#160;<br/>Explore both possibilities. &#160;<br/>
<hr/>
<a name=151></a>&#160;&#160;<br/>
151&#160;<br/>
&#160;<br/>
<b>Chapter&#160;8 -&#160;The UNIX System Interface&#160;</b><br/>
The UNIX operating system&#160;provides its services through a set of&#160;<i>system calls</i>, which are in&#160;<br/>effect functions within the operating system&#160;that may be called by user programs. This&#160;<br/>chapter describes how to use some of the most&#160;important system&#160;calls from&#160;C programs. If&#160;<br/>you use UNIX, this should be directly helpful,&#160;for it is sometimes necessary to employ system&#160;<br/>calls for maximum&#160;efficiency, or to access some facility that is not in&#160;the library. Even if you&#160;<br/>use C on a different operating system, however,&#160;you should be able to glean insight into C&#160;<br/>programming from&#160;studying these examples; although details vary, similar code will be found&#160;<br/>on any system. Since the ANSI C library is in&#160;many cases modeled on UNIX facilities, this&#160;<br/>code may help your understanding of the library as well. &#160;<br/>
This chapter is divided into three major parts:&#160;input/output, file system, and storage allocation.&#160;<br/>The first two parts assume a modest familiarity with the external characteristics of&#160;UNIX&#160;<br/>systems. &#160;<br/>
<a href="">Chapter 7&#160;was concerned with an input/output interface that is uniform</a>&#160;across operating&#160;<br/>systems. On any particular system&#160;the routines&#160;of&#160;the standard library have to be written in&#160;<br/>terms of&#160;the facilities provided by the host system.&#160;In the next few sections we will describe&#160;<br/>the UNIX system&#160;calls for input and output, and show how parts of the standard library can be&#160;<br/>implemented with them. &#160;<br/>
<b>8.1 File Descriptors&#160;</b><br/>
In the UNIX operating system, all input and&#160;output is done by reading or writing files,&#160;<br/>because all peripheral devices, even keyboard and&#160;screen, are files in the file system. This&#160;<br/>means that a single homogeneous interface handles all communication between a program&#160;<br/>and peripheral devices. &#160;<br/>
In the most general case, before you read and write a file, you must inform&#160;the system&#160;of your&#160;<br/>intent to do so, a process called&#160;<i>opening</i>&#160;the file. If you are going to&#160;write on a file it may also&#160;<br/>be necessary to create it or to discard its previous contents. The system&#160;checks your right to&#160;<br/>do so (Does the file exist?&#160;Do you have permission to access it?) and if all is well, returns to&#160;<br/>the program&#160;a small non-negative integer called a&#160;<i>file descriptor</i>. Whenever input or output is&#160;<br/>to be done on the file, the file descriptor is used&#160;instead of the name to identify the file. (A file&#160;<br/>descriptor is analogous to the file pointer used&#160;by the standard library, or&#160;to the file handle of&#160;<br/>MS-DOS.) All information about an open file is&#160;maintained by the system; the user program&#160;<br/>refers to the file only by the file descriptor. &#160;<br/>
Since input and output involving&#160;keyboard and screen is so common, special arrangements&#160;<br/>exist to make this convenient. When the command interpreter (the ``shell'') runs a program,&#160;<br/>three files are open, with file descriptors 0, 1,&#160;and 2, called the standard input, the standard&#160;<br/>output, and the standard error. If a program&#160;reads 0 and writes 1 and 2, it can do input and&#160;<br/>output without worrying about opening files. &#160;<br/>
The user of a program&#160;can redirect I/O to and from&#160;files with &lt; and &gt;: &#160;<br/>
&#160;<br/>&#160; &#160;prog &lt;infile &gt;outfile&#160;<br/>
<hr/>
<a name=152></a>&#160;&#160;<br/>
152&#160;<br/>
In this case, the shell changes the default assignments for the file descriptors 0 and 1 to the&#160;<br/>named files. Normally file descriptor 2 remains attached to the screen, so error messages can&#160;<br/>go there. Similar observations hold for input or output associated with a pipe. In all cases, the&#160;<br/>file assignments are changed by the shell,&#160;not by the program. The program&#160;does not know&#160;<br/>where its input comes from&#160;nor where its output goes, so long as it uses file 0 for input and 1&#160;<br/>and 2 for output. &#160;<br/>
<b>8.2 Low Level I/O - Read and Write&#160;</b><br/>
Input and output uses the&#160;read&#160;and&#160;write&#160;system&#160;calls, which are accessed from&#160;C programs&#160;<br/>through two functions called&#160;read&#160;and&#160;write. For both, the first argument is a file descriptor.&#160;<br/>The second argument is a character array in your&#160;program&#160;where the data is to go to or to&#160;<br/>come from. The third argument is the number is the number of bytes to be transferred. &#160;<br/>&#160;<br/>&#160; &#160;int n_read = read(int fd, char *buf, int n);&#160;<br/>&#160; &#160;int n_written = write(int fd, char *buf, int n);&#160;<br/>
Each call returns a count of the number of bytes&#160;transferred. On reading, the number of bytes&#160;<br/>returned may be less than the number requested.&#160;A return value of zero bytes implies end of&#160;<br/>file, and&#160;-1&#160;indicates an error of some sort. For writing, the return value is the number of&#160;<br/>bytes written; an error has occurred if&#160;this isn't equal to the number requested. &#160;<br/>
Any number of&#160;bytes can be read or written in&#160;one call. The most common values are 1,&#160;<br/>which means one character at a time (``unbuffered''), and a number like 1024 or 4096 that&#160;<br/>corresponds to a physical block size on a peripheral&#160;device. Larger sizes will be more efficient&#160;<br/>because fewer system&#160;calls will be made. &#160;<br/>
Putting these facts together, we can write a simple program&#160;to copy its input to its output, the&#160;<br/>equivalent of the file copying program<a href="">&#160;written for&#160;Chapter 1. This program</a>&#160;will copy anything&#160;<br/>to anything, since the input and output can&#160;be redirected to any file or device. &#160;<br/>
&#160;<br/>&#160; &#160;#include &#34;syscalls.h&#34;&#160;<br/>&#160;<br/>&#160; &#160;main() &#160;/* copy input to output */&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;char buf[BUFSIZ];&#160;<br/>&#160; &#160; &#160; &#160;int n;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;while ((n = read(0, buf, BUFSIZ)) &gt; 0)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;write(1, buf, n);&#160;<br/>&#160; &#160; &#160; &#160;return 0;&#160;<br/>&#160; &#160;}&#160;<br/>
We&#160;have collected function prototypes for the system&#160;calls into a file called&#160;syscalls.h&#160;so&#160;<br/>we can include it in the programs of this chapter. This name is not standard, however. &#160;<br/>
The parameter&#160;BUFSIZ&#160;is also defined in&#160;syscalls.h; its value is a good size for the local&#160;<br/>system. If&#160;the file size is not a multiple of&#160;BUFSIZ, some&#160;read&#160;will return a smaller number of&#160;<br/>bytes to be written by&#160;write; the next call to&#160;read&#160;after that will return zero. &#160;<br/>
It is instructive to see how&#160;read&#160;and&#160;write&#160;can be used to construct higher-level routines like&#160;<br/>getchar,&#160;putchar, etc. For example, here is a version of&#160;getchar&#160;that does unbuffered input,&#160;<br/>by reading the standard input one character at a time. &#160;<br/>
&#160;<br/>
<hr/>
<a name=153></a>&#160;&#160;<br/>
153&#160;<br/>
&#160; &#160;#include &#34;syscalls.h&#34;&#160;<br/>&#160;<br/>&#160; &#160;/* getchar: &#160;unbuffered single character input */&#160;<br/>&#160; &#160;int getchar(void)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;char c;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;return (read(0, &amp;c, 1) == 1) ? (unsigned char) c : EOF;&#160;<br/>&#160; &#160;}&#160;<br/>
c&#160;must&#160;be&#160;a&#160;char, because&#160;read&#160;needs a character pointer. Casting&#160;c&#160;to&#160;unsigned char&#160;in the&#160;<br/>return statement eliminates any problem&#160;of sign extension. &#160;<br/>
The second version of&#160;getchar&#160;does input in big chunks, and hands out the characters one at&#160;<br/>a time. &#160;<br/>
&#160;<br/>&#160; &#160;#include &#34;syscalls.h&#34;&#160;<br/>&#160;<br/>&#160; &#160;/* getchar: &#160;simple buffered version */&#160;<br/>&#160; &#160;int getchar(void)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;static char buf[BUFSIZ];&#160;<br/>&#160; &#160; &#160; &#160;static char *bufp = buf;&#160;<br/>&#160; &#160; &#160; &#160;static int n = 0;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;if (n == 0) { &#160;/* buffer is empty */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;n = read(0, buf, sizeof buf);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;bufp = buf;&#160;<br/>&#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160; &#160; &#160;return (--n &gt;= 0) ? (unsigned char) *bufp++ : EOF;&#160;<br/>&#160; &#160;}&#160;<br/>
If these versions of&#160;getchar&#160;were to be compiled with&#160;&lt;stdio.h&gt;&#160;included, it would be&#160;<br/>necessary to&#160;#undef&#160;the name&#160;getchar&#160;in case it is implemented as a macro. &#160;<br/>
<b>8.3 Open, Creat, Close, Unlink&#160;</b><br/>
Other than the default standard input, output and error, you must explicitly open files in order&#160;<br/>to read or write them. There are two system&#160;calls for this,&#160;open&#160;and&#160;creat&#160;[sic]. &#160;<br/>
open&#160;is rather like the&#160;fopen&#160;discussed in&#160;<a href="">Chapter 7</a>, except that instead of returning a file&#160;<br/>pointer, it returns a file descriptor, which is just an&#160;int.&#160;open&#160;returns&#160;-1&#160;if any error occurs. &#160;<br/>
&#160;<br/>&#160; &#160;#include &lt;fcntl.h&gt;&#160;<br/>&#160;<br/>&#160; &#160;int fd;&#160;<br/>&#160; &#160;int open(char *name, int flags, int perms);&#160;<br/>&#160;<br/>&#160; &#160;fd = open(name, flags, perms);&#160;<br/>
As with&#160;fopen, the&#160;name&#160;argument is a character string containing the filename. The second&#160;<br/>argument,&#160;flags, is an&#160;int&#160;that specifies how the file is to be opened; the main values are &#160;<br/>
O_RDONLY&#160;&#160;open for reading only&#160;<br/>
O_WRONLY&#160;&#160;open for writing only&#160;<br/>
O_RDWR&#160;&#160;&#160;open for both reading and writing<br/>
<hr/>
<a name=154></a>&#160;&#160;<br/>
154&#160;<br/>
These constants are defined in&#160;&lt;fcntl.h&gt;&#160;on System&#160;V UNIX systems, and in&#160;&lt;sys/file.h&gt;&#160;<br/>on Berkeley (BSD) versions. &#160;<br/>
To open an existing file for reading, &#160;<br/>
&#160;<br/>&#160; &#160;fd = open(name, O_RDONLY,0);&#160;<br/>
The&#160;perms&#160;argument is always zero for the uses of&#160;open&#160;that we will discuss. &#160;<br/>
It is an error to try to open a file&#160;that does not exist. The system&#160;call&#160;creat&#160;is provided to&#160;<br/>create new files, or to re-write old ones. &#160;<br/>
&#160;<br/>&#160; &#160;int creat(char *name, int perms);&#160;<br/>&#160;<br/>&#160; &#160;fd = creat(name, perms);&#160;<br/>
returns a file descriptor if&#160;it was able to create the file, and&#160;-1&#160;if&#160;not. If&#160;the file already exists,&#160;<br/>creat&#160;will truncate it to zero length, thereby discarding its previous contents; it is not an error&#160;<br/>to&#160;creat&#160;a file that already exists. &#160;<br/>
If the file does not already exist,&#160;creat&#160;creates it with the permissions specified by the&#160;perms&#160;<br/>argument. In the UNIX file system, there are nine bits of permission information associated&#160;<br/>with a file that control read,&#160;write and execute access for the owner of the file, for the owner's&#160;<br/>group, and for all others. Thus a three-digit&#160;octal number is convenient for specifying the&#160;<br/>permissions. For example,&#160;0775&#160;specifies read, write and execute permission for the owner,&#160;<br/>and read and execute permission for the group and everyone else. &#160;<br/>
To illustrate, here is a simplified version of&#160;the UNIX program&#160;cp, which copies one file to&#160;<br/>another. Our version copies only one file,&#160;it does not permit the second argument to be a&#160;<br/>directory, and it invents permissions instead of copying them. &#160;<br/>
&#160;<br/>&#160; &#160;#include &lt;stdio.h&gt;&#160;<br/>&#160; &#160;#include &lt;fcntl.h&gt;&#160;<br/>&#160; &#160;#include &#34;syscalls.h&#34;&#160;<br/>&#160; &#160;#define PERMS 0666 &#160; &#160; /* RW for owner, group, others */&#160;<br/>&#160;<br/>&#160; &#160;void error(char *, &#160;...);&#160;<br/>&#160;<br/>&#160; &#160;/* cp: &#160;copy f1 to f2 */&#160;<br/>&#160; &#160;main(int argc, char *argv[])&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int f1, f2, n;&#160;<br/>&#160; &#160; &#160; &#160;char buf[BUFSIZ];&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;if (argc != 3)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;error(&#34;Usage: cp from to&#34;);&#160;<br/>&#160; &#160; &#160; &#160;if ((f1 = open(argv[1], O_RDONLY, 0)) == -1)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;error(&#34;cp: can't open %s&#34;, argv[1]);&#160;<br/>&#160; &#160; &#160; &#160;if ((f2 = creat(argv[2], PERMS)) == -1)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;error(&#34;cp: can't create %s, mode %03o&#34;,&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;argv[2], PERMS);&#160;<br/>&#160; &#160; &#160; &#160;while ((n = read(f1, buf, BUFSIZ)) &gt; 0)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;if (write(f2, buf, n) != n)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;error(&#34;cp: write error on file %s&#34;, argv[2]);&#160;<br/>&#160; &#160; &#160; &#160;return 0;&#160;<br/>&#160; &#160;}&#160;<br/>
<hr/>
<a name=155></a>&#160;&#160;<br/>
155&#160;<br/>
This program&#160;creates the output file with fixed permissions of&#160;0666. With the&#160;stat&#160;system&#160;<br/>call, described in&#160;<a href="cs.html#159">Section 8.6, we can determ</a>ine the mode of an existing file and thus give the&#160;<br/>same&#160;mode to the copy. &#160;<br/>
Notice that the function&#160;error&#160;is called with variable argument lists much like&#160;printf. The&#160;<br/>implementation of&#160;error illustrates how to use another member of&#160;the&#160;printf&#160;family. The&#160;<br/>standard library function&#160;vprintf&#160;is like&#160;printf&#160;except that the variable argument list is&#160;<br/>replaced by a single argument that&#160;has been initialized by calling the&#160;va_start&#160;macro.&#160;<br/>Similarly,&#160;vfprintf&#160;and&#160;vsprintf&#160;match&#160;fprintf&#160;and&#160;sprintf. &#160;<br/>
&#160;<br/>&#160; &#160;#include &lt;stdio.h&gt;&#160;<br/>&#160; &#160;#include &lt;stdarg.h&gt;&#160;<br/>&#160;<br/>&#160; &#160;/* error: &#160;print an error message and die */&#160;<br/>&#160; &#160;void error(char *fmt, ...)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;va_list args;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;va_start(args, fmt);&#160;<br/>&#160; &#160; &#160; &#160;fprintf(stderr, &#34;error: &#34;);&#160;<br/>&#160; &#160; &#160; &#160;vprintf(stderr, fmt, args);&#160;<br/>&#160; &#160; &#160; &#160;fprintf(stderr, &#34;\n&#34;);&#160;<br/>&#160; &#160; &#160; &#160;va_end(args);&#160;<br/>&#160; &#160; &#160; &#160;exit(1);&#160;<br/>&#160; &#160;}&#160;<br/>
There is a limit (often about 20) on the number of files that a program&#160;may open&#160;<br/>simultaneously. Accordingly, any program&#160;that intends to process many files must be&#160;<br/>prepared to re-use file descriptors. The function&#160;close(int fd)&#160;breaks the connection&#160;<br/>between a file descriptor and an open file, and frees the file descriptor for use with some other&#160;<br/>file; it corresponds to&#160;fclose&#160;in the standard library except that there is no buffer to flush.&#160;<br/>Termination of a program&#160;via&#160;exit&#160;or return from&#160;the main program&#160;closes all open files. &#160;<br/>
The function&#160;unlink(char *name)&#160;removes the file&#160;name&#160;from&#160;the file system. It&#160;<br/>corresponds to the standard library function&#160;remove. &#160;<br/>
<b>Exercise 8-1.</b>&#160;Rewrite the program&#160;cat&#160;from&#160;<a href="">Chapter 7&#160;using&#160;</a>read,&#160;write,&#160;open, and&#160;close&#160;<br/>instead of their standard library equivalents.&#160;Perform&#160;experiments to determine the relative&#160;<br/>speeds of the two versions. &#160;<br/>
<b>8.4 Random Access - Lseek&#160;</b><br/>
Input and output are normally sequential: each&#160;read&#160;or&#160;write&#160;takes place at a position in the&#160;<br/>file right after the previous one. When necessary, however, a file can be&#160;read or written in any&#160;<br/>arbitrary order. The system&#160;call&#160;lseek&#160;provides a way to move&#160;around in a file without&#160;<br/>reading or writing any data: &#160;<br/>&#160;<br/>&#160; &#160;long lseek(int fd, long offset, int origin);&#160;<br/>
sets the current position in the file whose descriptor is&#160;fd&#160;to&#160;offset, which is taken relative to&#160;<br/>the location specified by&#160;origin. Subsequent reading or writing will begin at that position.&#160;<br/>origin&#160;can be 0, 1, or 2 to specify that&#160;offset&#160;is to be measured from&#160;the beginning, from&#160;<br/>the current position, or from&#160;the end of the file&#160;respectively. For example, to append to a file&#160;<br/>(the redirection &gt;&gt; in the UNIX shell, or&#160;&#34;a&#34;&#160;for&#160;fopen), seek to the end before writing: &#160;<br/>&#160;<br/>&#160; &#160;lseek(fd, 0L, 2);&#160;<br/>
<hr/>
<a name=156></a>&#160;&#160;<br/>
156&#160;<br/>
To get back to the beginning (``rewind''), &#160;<br/>&#160;<br/>&#160; &#160;lseek(fd, 0L, 0);&#160;<br/>
Notice the&#160;0L&#160;argument; it could also be written as&#160;(long) 0&#160;or&#160;just&#160;as&#160;0&#160;if&#160;lseek&#160;is properly&#160;<br/>declared. &#160;<br/>
With&#160;lseek, it is possible to treat files more or less&#160;like arrays, at the price of slower access.&#160;<br/>For example, the following function reads any number of bytes from&#160;any arbitrary place in a&#160;<br/>file. It returns the number read, or&#160;-1&#160;on error. &#160;<br/>
&#160;<br/>&#160; &#160;#include &#34;syscalls.h&#34;&#160;<br/>&#160;<br/>&#160; &#160;/*get: &#160;read n bytes from position pos */&#160;<br/>&#160; &#160;int get(int fd, long pos, char *buf, int n)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;if (lseek(fd, pos, 0) &gt;= 0) /* get to pos */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;return read(fd, buf, n);&#160;<br/>&#160; &#160; &#160; &#160;else&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;return -1;&#160;<br/>&#160; &#160;}&#160;<br/>
The return value from&#160;lseek&#160;is a long that gives the new position in the file, or&#160;-1&#160;if an error&#160;<br/>occurs. The standard library function&#160;fseek&#160;is similar to&#160;lseek&#160;except that the first argument&#160;<br/>is a&#160;FILE *&#160;and the return is non-zero if an error occurred. &#160;<br/>
<b>8.5 Example - An implementation of Fopen and Getc&#160;</b><br/>
Let us illustrate how some of these pieces fit&#160;together by showing an implementation of the&#160;<br/>standard library routines&#160;fopen&#160;and&#160;getc. &#160;<br/>
Recall that files in the standard library are&#160;described by file pointers rather than file&#160;<br/>descriptors. A file pointer is a pointer to a structure that contains several pieces of information&#160;<br/>about the file: a pointer to a buffer, so the file can be read in large chunks; a count of the&#160;<br/>number of characters left in the&#160;buffer; a pointer to the next character position in the buffer;&#160;<br/>the file descriptor; and flags describing read/write mode, error status, etc. &#160;<br/>
The data structure that describes a file is contained in&#160;&lt;stdio.h&gt;, which must be included (by&#160;<br/>#include) in any source file that uses routines from&#160;the standard input/output library. It is&#160;<br/>also included by functions in that library. In the following excerpt from&#160;a typical&#160;&lt;stdio.h&gt;,&#160;<br/>names that are intended for use only by functions&#160;of the library begin with an underscore so&#160;<br/>they are less likely to collide with names in a user's program. This convention is used by all&#160;<br/>standard library routines. &#160;<br/>
&#160;<br/>&#160; &#160;#define NULL &#160; &#160; &#160;0&#160;<br/>&#160; &#160;#define EOF &#160; &#160; &#160; (-1)&#160;<br/>&#160; &#160;#define BUFSIZ &#160; &#160;1024&#160;<br/>&#160; &#160;#define OPEN_MAX &#160;20 &#160; &#160;/* max #files open at once */&#160;<br/>&#160;<br/>&#160; &#160;typedef struct _iobuf {&#160;<br/>&#160; &#160; &#160; &#160;int &#160;cnt; &#160; &#160; &#160; /* characters left */&#160;<br/>&#160; &#160; &#160; &#160;char *ptr; &#160; &#160; &#160;/* next character position */&#160;<br/>&#160; &#160; &#160; &#160;char *base; &#160; &#160; /* location of buffer */&#160;<br/>&#160; &#160; &#160; &#160;int &#160;flag; &#160; &#160; &#160;/* mode of file access */&#160;<br/>&#160; &#160; &#160; &#160;int &#160;fd; &#160; &#160; &#160; &#160;/* file descriptor */&#160;<br/>&#160; &#160;} FILE;&#160;<br/>
<hr/>
<a name=157></a>&#160;&#160;<br/>
157&#160;<br/>
&#160; &#160;extern FILE _iob[OPEN_MAX];&#160;<br/>&#160;<br/>&#160; &#160;#define stdin &#160; (&amp;_iob[0])&#160;<br/>&#160; &#160;#define stdout &#160;(&amp;_iob[1])&#160;<br/>&#160; &#160;#define stderr &#160;(&amp;_iob[2])&#160;<br/>&#160;<br/>&#160; &#160;enum _flags {&#160;<br/>&#160; &#160; &#160; &#160;_READ &#160; = 01, &#160; /* file open for reading */&#160;<br/>&#160; &#160; &#160; &#160;_WRITE &#160;= 02, &#160; /* file open for writing */&#160;<br/>&#160; &#160; &#160; &#160;_UNBUF &#160;= 04, &#160; /* file is unbuffered */&#160;<br/>&#160; &#160; &#160; &#160;_EOF &#160; &#160;= 010, &#160;/* EOF has occurred on this file */&#160;<br/>&#160; &#160; &#160; &#160;_ERR &#160; &#160;= 020 &#160; /* error occurred on this file */&#160;<br/>&#160; &#160;};&#160;<br/>&#160;<br/>&#160; &#160;int _fillbuf(FILE *);&#160;<br/>&#160; &#160;int _flushbuf(int, FILE *);&#160;<br/>&#160;<br/>&#160; &#160;#define feof(p) &#160; &#160; ((p)-&gt;flag &amp; _EOF) != 0)&#160;<br/>&#160; &#160;#define ferror(p) &#160; ((p)-&gt;flag &amp; _ERR) != 0)&#160;<br/>&#160; &#160;#define fileno(p) &#160; ((p)-&gt;fd)&#160;<br/>&#160;<br/>&#160; &#160;#define getc(p) &#160; (--(p)-&gt;cnt &gt;= 0 \&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; ? (unsigned char) *(p)-&gt;ptr++ : _fillbuf(p))&#160;<br/>&#160; &#160;#define putc(x,p) (--(p)-&gt;cnt &gt;= 0 \&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; ? *(p)-&gt;ptr++ = (x) : _flushbuf((x),p))&#160;<br/>&#160;<br/>&#160; &#160;#define getchar() &#160; getc(stdin)&#160;<br/>&#160; &#160;#define putcher(x) &#160;putc((x), stdout)&#160;<br/>
The&#160;&#160;getc&#160;macro normally decrements the count, advances the pointer, and returns the&#160;<br/>character. (Recall that a long&#160;#define&#160;is continued with a backslash.) If the count goes&#160;<br/>negative, however,&#160;getc&#160;calls the function&#160;_fillbuf&#160;to replenish the buffer, re-initialize the&#160;<br/>structure contents, and return a character. The characters are returned&#160;unsigned, which&#160;<br/>ensures that all characters will be positive. &#160;<br/>
Although we will not discuss any details,&#160;we have included the definition of&#160;putc&#160;to show&#160;<br/>that it operates in much the same way as&#160;getc, calling a function&#160;_flushbuf&#160;when its buffer&#160;<br/>is full. We have also included macros for accessing the error and end-of-file&#160;status and the file&#160;<br/>descriptor. &#160;<br/>
The function&#160;fopen&#160;can now be written. Most of&#160;fopen&#160;is concerned with getting the file&#160;<br/>opened and positioned at the right place, and setting&#160;the flag bits to indicate the proper state.&#160;<br/>fopen&#160;does not allocate any buffer space; this is done by&#160;_fillbuf&#160;when the file is first read. &#160;<br/>
&#160;<br/>&#160; &#160;#include &lt;fcntl.h&gt;&#160;<br/>&#160; &#160;#include &#34;syscalls.h&#34;&#160;<br/>&#160; &#160;#define PERMS 0666 &#160; &#160;/* RW for owner, group, others */&#160;<br/>&#160;<br/>&#160; &#160;FILE *fopen(char *name, char *mode)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int fd;&#160;<br/>&#160; &#160; &#160; &#160;FILE *fp;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;if (*mode != 'r' &amp;&amp; *mode != 'w' &amp;&amp; *mode != 'a')&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;return NULL;&#160;<br/>&#160; &#160; &#160; &#160;for (fp = _iob; fp &lt; _iob + OPEN_MAX; fp++)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;if ((fp-&gt;flag &amp; (_READ | _WRITE)) == 0)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;break; &#160; &#160; &#160; &#160;/* found free slot */&#160;<br/>&#160; &#160; &#160; &#160;if (fp &gt;= _iob + OPEN_MAX) &#160; /* no free slots */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;return NULL;&#160;<br/>
<hr/>
<a name=158></a>&#160;&#160;<br/>
158&#160;<br/>
&#160;<br/>&#160; &#160; &#160; &#160;if (*mode == 'w')&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;fd = creat(name, PERMS);&#160;<br/>&#160; &#160; &#160; &#160;else if (*mode == 'a') {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;if ((fd = open(name, O_WRONLY, 0)) == -1)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;fd = creat(name, PERMS);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;lseek(fd, 0L, 2);&#160;<br/>&#160; &#160; &#160; &#160;} else&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;fd = open(name, O_RDONLY, 0);&#160;<br/>&#160; &#160; &#160; &#160;if (fd == -1) &#160; &#160; &#160; &#160; /* couldn't access name */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;return NULL;&#160;<br/>&#160; &#160; &#160; &#160;fp-&gt;fd = fd;&#160;<br/>&#160; &#160; &#160; &#160;fp-&gt;cnt = 0;&#160;<br/>&#160; &#160; &#160; &#160;fp-&gt;base = NULL;&#160;<br/>&#160; &#160; &#160; &#160;fp-&gt;flag = (*mode == 'r') ? _READ : _WRITE;&#160;<br/>&#160; &#160; &#160; &#160;return fp;&#160;<br/>&#160; &#160;}&#160;<br/>
This version of&#160;fopen&#160;does not handle all of the access mode possibilities of the standard,&#160;<br/>though adding them&#160;would not take&#160;much code. In particular, our&#160;fopen&#160;does not recognize&#160;<br/>the ``b''&#160;that signals binary access, since that&#160;is meaningless on UNIX systems, nor the ``+''&#160;<br/>that permits both reading and writing. &#160;<br/>
The first call to&#160;getc&#160;for a particular file finds a count&#160;of zero, which forces a call of&#160;<br/>_fillbuf. If&#160;_fillbuf&#160;finds that the file is not open for reading, it returns&#160;EOF&#160;immediately.&#160;<br/>Otherwise, it tries to allocate a buffer (if&#160;reading is to be buffered). &#160;<br/>
Once the buffer is established,&#160;_fillbuf&#160;calls&#160;read&#160;to fill it, sets the count and pointers, and&#160;<br/>returns the character at the beginning of the buffer. Subsequent calls to&#160;_fillbuf&#160;will find a&#160;<br/>buffer allocated. &#160;<br/>
&#160;<br/>&#160; &#160;#include &#34;syscalls.h&#34;&#160;<br/>&#160;<br/>&#160; &#160;/* _fillbuf: &#160;allocate and fill input buffer */&#160;<br/>&#160; &#160;int _fillbuf(FILE *fp)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int bufsize;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;if ((fp-&gt;flag&amp;(_READ|_EOF_ERR)) != _READ)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;return EOF;&#160;<br/>&#160; &#160; &#160; &#160;bufsize = (fp-&gt;flag &amp; _UNBUF) ? 1 : BUFSIZ;&#160;<br/>&#160; &#160; &#160; &#160;if (fp-&gt;base == NULL) &#160; &#160; /* no buffer yet */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;if ((fp-&gt;base = (char *) malloc(bufsize)) == NULL)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;return EOF; &#160; &#160; &#160; /* can't get buffer */&#160;<br/>&#160; &#160; &#160; &#160;fp-&gt;ptr = fp-&gt;base;&#160;<br/>&#160; &#160; &#160; &#160;fp-&gt;cnt = read(fp-&gt;fd, fp-&gt;ptr, bufsize);&#160;<br/>&#160; &#160; &#160; &#160;if (--fp-&gt;cnt &lt; 0) {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;if (fp-&gt;cnt == -1)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;fp-&gt;flag |= _EOF;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;else&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;fp-&gt;flag |= _ERR;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;fp-&gt;cnt = 0;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;return EOF;&#160;<br/>&#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160; &#160; &#160;return (unsigned char) *fp-&gt;ptr++;&#160;<br/>&#160; &#160;}&#160;<br/>
The only remaining loose end is how everything gets started. The array&#160;_iob&#160;must be defined&#160;<br/>and initialized for&#160;stdin,&#160;stdout&#160;and&#160;stderr: &#160;<br/>&#160;<br/>&#160; &#160;FILE _iob[OPEN_MAX] = { &#160; &#160;/* stdin, stdout, stderr */&#160;<br/>
<hr/>
<a name=159></a>&#160;&#160;<br/>
159&#160;<br/>
&#160; &#160; &#160; &#160;{ 0, (char *) 0, (char *) 0, _READ, 0 },&#160;<br/>&#160; &#160; &#160; &#160;{ 0, (char *) 0, (char *) 0, _WRITE, 1 },&#160;<br/>&#160; &#160; &#160; &#160;{ 0, (char *) 0, (char *) 0, _WRITE, | _UNBUF, 2 }&#160;<br/>&#160; &#160;};&#160;<br/>
The initialization of&#160;the&#160;flag&#160;part of the structure shows that&#160;stdin&#160;is to be read,&#160;stdout&#160;is to&#160;<br/>be written, and&#160;stderr&#160;is to be written unbuffered. &#160;<br/>
<b>Exercise 8-2.</b>&#160;Rewrite&#160;fopen&#160;and&#160;_fillbuf&#160;with fields instead of&#160;explicit bit operations.&#160;<br/>Compare code size and execution speed. &#160;<br/>
<b>Exercise 8-3.</b>&#160;Design and write&#160;_flushbuf,&#160;fflush, and&#160;fclose. &#160;<br/>
<b>Exercise 8-4.</b>&#160;The standard library function &#160;<br/>
&#160;<br/>&#160; &#160;int fseek(FILE *fp, long offset, int origin)&#160;<br/>
is identical to&#160;lseek&#160;except that&#160;fp&#160;is a file pointer instead of a file descriptor and return value&#160;<br/>is an&#160;int&#160;status, not a position. Write&#160;fseek. Make sure that your&#160;fseek&#160;coordinates properly&#160;<br/>with the buffering done for the other functions of the library. &#160;<br/>
<b>8.6 Example - Listing Directories&#160;</b><br/>
A different kind of&#160;file system&#160;interaction is sometimes called for - determining information&#160;<br/><i>about</i>&#160;a file, not what it contains. A directory-listing program&#160;such as the UNIX command&#160;ls&#160;<br/>is an example - it prints the names of&#160;files in&#160;a directory, and, optionally, other information,&#160;<br/>such as sizes, permissions, and so on. The MS-DOS&#160;dir&#160;command is analogous. &#160;<br/>
Since a UNIX directory is just a file,&#160;ls&#160;need only read it to retrieve the filenames. But is is&#160;<br/>necessary to use a system&#160;call to access other information about a file, such as its size. On&#160;<br/>other systems, a system&#160;call may be needed even to access filenames;&#160;this is the case on MS-<br/>DOS for instance. What we want is provide access to the information in a relatively system-<br/>independent way, even though the implementation may be highly system-dependent. &#160;<br/>
We will illustrate some of&#160;this by writing a program&#160;called&#160;fsize.&#160;fsize&#160;is a special form&#160;of&#160;<br/>ls&#160;that prints the sizes of&#160;all files named in&#160;its commandline argument list. If&#160;one of&#160;the files&#160;<br/>is a directory,&#160;fsize&#160;applies itself&#160;recursively to that directory. If there are no arguments at&#160;<br/>all, it processes the current directory. &#160;<br/>
Let us begin with a short review&#160;of UNIX file system&#160;structure. A&#160;<i>directory</i>&#160;is a file that&#160;<br/>contains a list of filenames and some indication&#160;of where they are located. The ``location''&#160;is&#160;<br/>an index into another table called the ``inode list.'' The&#160;<i>inode</i>&#160;for a file is where all&#160;<br/>information about the file except its name is kept. A directory entry generally consists of only&#160;<br/>two items, the filename&#160;and an inode number. &#160;<br/>
Regrettably, the format and precise contents of&#160;a directory are not the same on all versions of&#160;<br/>the system. So we will divide the task into two pieces to try to isolate the non-portable parts.&#160;<br/>The outer level defines a structure called a&#160;Dirent&#160;and three routines&#160;opendir,&#160;readdir, and&#160;<br/>closedir&#160;to provide system-independent access to the name and inode number in a directory&#160;<br/>entry. We will write&#160;fsize&#160;with this interface. Then we will show how to implement these on&#160;<br/>systems that use the same directory structure&#160;as Version 7 and System&#160;V UNIX; variants are&#160;<br/>left as exercises. &#160;<br/>
<hr/>
<a name=160></a>&#160;&#160;<br/>
160&#160;<br/>
The&#160;&#160;Dirent&#160;structure contains the inode number&#160;and the name. The maximum&#160;length of a&#160;<br/>filename component is&#160;NAME_MAX, which is a system-dependent value.&#160;opendir&#160;returns a&#160;<br/>pointer to a structure called&#160;DIR, analogous to&#160;FILE, which is used by&#160;readdir&#160;and&#160;closedir.&#160;<br/>This information is collected into a file called&#160;dirent.h. &#160;<br/>
&#160;<br/>&#160; &#160;#define NAME_MAX &#160; 14 &#160;/* longest filename component; */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; /* system-dependent */&#160;<br/>&#160;<br/>&#160; &#160;typedef struct { &#160; &#160; &#160; /* portable directory entry */&#160;<br/>&#160; &#160; &#160; &#160;long ino; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;/* inode number */&#160;<br/>&#160; &#160; &#160; &#160;char name[NAME_MAX+1]; &#160; &#160; /* name + '\0' terminator */&#160;<br/>&#160; &#160;} Dirent;&#160;<br/>&#160;<br/>&#160; &#160;typedef struct { &#160; &#160; &#160; /* minimal DIR: no buffering, etc. */&#160;<br/>&#160; &#160; &#160; &#160;int fd; &#160; &#160; &#160; &#160; &#160; &#160; &#160; /* file descriptor for the directory */&#160;<br/>&#160; &#160; &#160; &#160;Dirent d; &#160; &#160; &#160; &#160; &#160; &#160; /* the directory entry */&#160;<br/>&#160; &#160;} DIR;&#160;<br/>&#160;<br/>&#160; &#160;DIR *opendir(char *dirname);&#160;<br/>&#160; &#160;Dirent *readdir(DIR *dfd);&#160;<br/>&#160; &#160;void closedir(DIR *dfd);&#160;<br/>
The system&#160;call&#160;stat&#160;takes a filename and returns all of the information in the inode for that&#160;<br/>file, or&#160;-1&#160;if there is an error. That is, &#160;<br/>&#160;<br/>&#160; &#160;char *name;&#160;<br/>&#160; &#160;struct stat stbuf;&#160;<br/>&#160; &#160;int stat(char *, struct stat *);&#160;<br/>&#160;<br/>&#160; &#160;stat(name, &amp;stbuf);&#160;<br/>
fills the structure&#160;stbuf&#160;with the inode information for the&#160;file name. The structure describing&#160;<br/>the value returned by&#160;stat&#160;is in&#160;&lt;sys/stat.h&gt;, and typically looks like this: &#160;<br/>&#160;<br/>&#160; &#160;struct stat &#160; /* inode information returned by stat */&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;dev_t &#160; &#160; st_dev; &#160; &#160; &#160;/* device of inode */&#160;<br/>&#160; &#160; &#160; &#160;ino_t &#160; &#160; st_ino; &#160; &#160; &#160;/* inode number */&#160;<br/>&#160; &#160; &#160; &#160;short &#160; &#160; st_mode; &#160; &#160; /* mode bits */&#160;<br/>&#160; &#160; &#160; &#160;short &#160; &#160; st_nlink; &#160; &#160;/* number of links to file */&#160;<br/>&#160; &#160; &#160; &#160;short &#160; &#160; st_uid; &#160; &#160; &#160;/* owners user id */&#160;<br/>&#160; &#160; &#160; &#160;short &#160; &#160; st_gid; &#160; &#160; &#160;/* owners group id */&#160;<br/>&#160; &#160; &#160; &#160;dev_t &#160; &#160; st_rdev; &#160; &#160; /* for special files */&#160;<br/>&#160; &#160; &#160; &#160;off_t &#160; &#160; st_size; &#160; &#160; /* file size in characters */&#160;<br/>&#160; &#160; &#160; &#160;time_t &#160; &#160;st_atime; &#160; &#160;/* time last accessed */&#160;<br/>&#160; &#160; &#160; &#160;time_t &#160; &#160;st_mtime; &#160; &#160;/* time last modified */&#160;<br/>&#160; &#160; &#160; &#160;time_t &#160; &#160;st_ctime; &#160; &#160;/* time originally created */&#160;<br/>&#160; &#160;};&#160;<br/>
Most of these values are explained&#160;by the comment fields. The types like&#160;dev_t&#160;and&#160;ino_t&#160;<br/>are defined in&#160;&lt;sys/types.h&gt;, which must be included too. &#160;<br/>
The&#160;&#160;st_mode&#160;entry contains a set of flags describing the file. The flag definitions are also&#160;<br/>included in&#160;&lt;sys/types.h&gt;; we need only the part that deals with file type: &#160;<br/>
&#160;<br/>&#160; &#160;#define S_IFMT &#160; &#160;0160000 &#160;/* type of file: */&#160;<br/>&#160; &#160;#define S_IFDIR &#160; 0040000 &#160;/* directory */&#160;<br/>&#160; &#160;#define S_IFCHR &#160; 0020000 &#160;/* character special */&#160;<br/>&#160; &#160;#define S_IFBLK &#160; 0060000 &#160;/* block special */&#160;<br/>&#160; &#160;#define S_IFREG &#160; 0010000 &#160;/* regular */&#160;<br/>&#160; &#160;/* ... */&#160;<br/>
<hr/>
<a name=161></a>&#160;&#160;<br/>
161&#160;<br/>
Now we are ready to write the program&#160;fsize. If the mode obtained from&#160;stat&#160;indicates that&#160;<br/>a file is not a directory, then the size is at hand and can be printed directly. If the name is a&#160;<br/>directory, however, then we have to process that&#160;directory one file at a time; it may in turn&#160;<br/>contain sub-directories, so the process is recursive. &#160;<br/>
The main routine deals with command-line arguments; it hands each argument to the function&#160;<br/>fsize. &#160;<br/>
&#160;<br/>&#160; &#160;#include &lt;stdio.h&gt;&#160;<br/>&#160; &#160;#include &lt;string.h&gt;&#160;<br/>&#160; &#160;#include &#34;syscalls.h&#34;&#160;<br/>&#160; &#160;#include &lt;fcntl.h&gt; &#160; &#160; &#160;/* flags for read and write */&#160;<br/>&#160; &#160;#include &lt;sys/types.h&gt; &#160;/* typedefs */&#160;<br/>&#160; &#160;#include &lt;sys/stat.h&gt; &#160; /* structure returned by stat */&#160;<br/>&#160; &#160;#include &#34;dirent.h&#34;&#160;<br/>&#160;<br/>&#160; &#160;void fsize(char *)&#160;<br/>&#160;<br/>&#160; &#160;/* print file name */&#160;<br/>&#160; &#160;main(int argc, char **argv)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;if (argc == 1) &#160;/* default: current directory */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;fsize(&#34;.&#34;);&#160;<br/>&#160; &#160; &#160; &#160;else&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;while (--argc &gt; 0)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;fsize(*++argv);&#160;<br/>&#160; &#160; &#160; &#160;return 0;&#160;<br/>&#160; &#160;}&#160;<br/>
The function&#160;fsize&#160;prints the size of&#160;the file. If&#160;the file is a directory, however,&#160;fsize&#160;first&#160;<br/>calls&#160;dirwalk&#160;to handle all the files in&#160;it. Note how the flag names&#160;S_IFMT&#160;and&#160;S_IFDIR&#160;are&#160;<br/>used to decide if the file is a directory.&#160;Parenthesization matters, because the precedence of&#160;&amp;&#160;<br/>is lower than that of&#160;==. &#160;<br/>&#160;<br/>&#160; &#160;int stat(char *, struct stat *);&#160;<br/>&#160; &#160;void dirwalk(char *, void (*fcn)(char *));&#160;<br/>&#160;<br/>&#160; &#160;/* fsize: &#160;print the name of file &#34;name&#34; */&#160;<br/>&#160; &#160;void fsize(char *name)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;struct stat stbuf;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;if (stat(name, &amp;stbuf) == -1) {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;fprintf(stderr, &#34;fsize: can't access %s\n&#34;, name);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;return;&#160;<br/>&#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160; &#160; &#160;if ((stbuf.st_mode &amp; S_IFMT) == S_IFDIR)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;dirwalk(name, fsize);&#160;<br/>&#160; &#160; &#160; &#160;printf(&#34;%8ld %s\n&#34;, stbuf.st_size, name);&#160;<br/>&#160; &#160;}&#160;<br/>
The function&#160;dirwalk&#160;is a general routine that applies a function to each file in a directory. It&#160;<br/>opens the directory, loops through the files in&#160;it, calling the function on each, then closes the&#160;<br/>directory and returns. Since&#160;fsize&#160;calls&#160;dirwalk&#160;on each directory, the two functions call&#160;<br/>each other recursively. &#160;<br/>&#160;<br/>&#160; &#160;#define MAX_PATH 1024&#160;<br/>&#160;<br/>&#160; &#160;/* dirwalk: &#160;apply fcn to all files in dir */&#160;<br/>&#160; &#160;void dirwalk(char *dir, void (*fcn)(char *))&#160;<br/>&#160; &#160;{&#160;<br/>
<hr/>
<a name=162></a>&#160;&#160;<br/>
162&#160;<br/>
&#160; &#160; &#160; &#160;char name[MAX_PATH];&#160;<br/>&#160; &#160; &#160; &#160;Dirent *dp;&#160;<br/>&#160; &#160; &#160; &#160;DIR *dfd;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;if ((dfd = opendir(dir)) == NULL) {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;fprintf(stderr, &#34;dirwalk: can't open %s\n&#34;, dir);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;return;&#160;<br/>&#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160; &#160; &#160;while ((dp = readdir(dfd)) != NULL) {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;if (strcmp(dp-&gt;name, &#34;.&#34;) == 0&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;|| strcmp(dp-&gt;name, &#34;..&#34;))&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;continue; &#160; &#160;/* skip self and parent */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;if (strlen(dir)+strlen(dp-&gt;name)+2 &gt; sizeof(name))&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;fprintf(stderr, &#34;dirwalk: name %s %s too long\n&#34;,&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;dir, dp-&gt;name);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;else {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;sprintf(name, &#34;%s/%s&#34;, dir, dp-&gt;name);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;(*fcn)(name);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160; &#160; &#160;closedir(dfd);&#160;<br/>&#160; &#160;}&#160;<br/>
Each call to&#160;readdir&#160;returns a pointer to information for the next file, or&#160;NULL&#160;when there are&#160;<br/>no files left. Each directory always&#160;contains entries for itself,&#160;called&#160;&#34;.&#34;, and its parent,&#160;&#34;..&#34;;&#160;<br/>these must be skipped, or the program&#160;will loop forever. &#160;<br/>
Down to this last level, the code is independent of how directories are formatted. The next&#160;<br/>step is to present minimal versions of&#160;opendir,&#160;readdir, and&#160;closedir&#160;for a specific system.&#160;<br/>The following routines are for Version 7 and System&#160;V UNIX systems; they use the directory&#160;<br/>information in the header&#160;&lt;sys/dir.h&gt;, which looks like this: &#160;<br/>
&#160;<br/>&#160; &#160;#ifndef DIRSIZ&#160;<br/>&#160; &#160;#define DIRSIZ &#160;14&#160;<br/>&#160; &#160;#endif&#160;<br/>&#160; &#160;struct direct { &#160; /* directory entry */&#160;<br/>&#160; &#160; &#160; &#160;ino_t d_ino; &#160; &#160; &#160; &#160; &#160; /* inode number */&#160;<br/>&#160; &#160; &#160; &#160;char &#160;d_name[DIRSIZ]; &#160;/* long name does not have '\0' */&#160;<br/>&#160; &#160;};&#160;<br/>
Some versions of the system&#160;permit much longer names and have a more complicated&#160;<br/>directory structure. &#160;<br/>
The type&#160;ino_t&#160;is a&#160;typedef&#160;that describes the index into the inode list. It happens to be&#160;<br/>unsigned short&#160;on the systems we use regularly, but this&#160;is not the sort of&#160;information to&#160;<br/>embed in a program; it might be different on a different system, so the&#160;typedef&#160;is better. A&#160;<br/>complete set of ``system'' types is found in&#160;&lt;sys/types.h&gt;. &#160;<br/>
opendir&#160;opens the directory, verifies that the file&#160;is a directory (this time by the system&#160;call&#160;<br/>
fstat, which is like&#160;stat&#160;except that it applies to a file descriptor), allocates a directory&#160;<br/>structure, and records the information: &#160;<br/>
&#160;<br/>&#160; &#160;int fstat(int fd, struct stat *);&#160;<br/>&#160;<br/>&#160; &#160;/* opendir: &#160;open a directory for readdir calls */&#160;<br/>&#160; &#160;DIR *opendir(char *dirname)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int fd;&#160;<br/>&#160; &#160; &#160; &#160;struct stat stbuf;&#160;<br/>
<hr/>
<a name=163></a>163<br/>
DIR *dp;&#160;<br/>
if ((fd = open(dirname, O_RDONLY, 0)) == -1&#160;<br/>
|| fstat(fd, &amp;stbuf) == -1&#160;<br/>|| (stbuf.st_mode &amp; S_IFMT) != S_IFDIR&#160;<br/>|| (dp = (DIR *) malloc(sizeof(DIR))) == NULL)&#160;<br/>
return NULL;&#160;<br/>
dp-&gt;fd = fd;&#160;<br/>return dp;&#160;<br/>
&#160; &#160;}&#160;<br/>
closedir&#160;closes the directory file and frees the space: &#160;<br/>
&#160; &#160;/* closedir: &#160;close directory opened by opendir */&#160;<br/>&#160; &#160;void closedir(DIR *dp)&#160;<br/>&#160; &#160;{&#160;<br/>
if (dp) {&#160;<br/>
close(dp-&gt;fd);&#160;<br/>free(dp);&#160;<br/>
}&#160;<br/>
&#160; &#160;}&#160;<br/>
Finally,&#160;readdir&#160;uses&#160;read&#160;to read each directory entry. If a&#160;directory slot is not currently in&#160;<br/>use (because a file has been removed), the inode number is zero, and this position is skipped.&#160;<br/>Otherwise, the inode number and name are placed in a&#160;static&#160;structure and a pointer to that&#160;<br/>is returned to the user. Each call overwrites the information from&#160;the previous one. &#160;<br/>
&#160; &#160;#include &lt;sys/dir.h&gt; &#160; /* local directory structure */&#160;<br/>
&#160; &#160;/* readdir: &#160;read directory entries in sequence */&#160;<br/>&#160; &#160;Dirent *readdir(DIR *dp)&#160;<br/>&#160; &#160;{&#160;<br/>
struct direct dirbuf; &#160;/* local directory structure */&#160;<br/>static Dirent &#160;d;<br/>
/* return: portable structure */&#160;<br/>
while (read(dp-&gt;fd, (char *) &amp;dirbuf, sizeof(dirbuf))&#160;<br/>
== sizeof(dirbuf)) {&#160;<br/>
if (dirbuf.d_ino == 0) /* slot not in use */&#160;<br/>
continue;&#160;<br/>
d.ino = dirbuf.d_ino;&#160;<br/>strncpy(d.name, dirbuf.d_name, DIRSIZ);&#160;<br/>d.name[DIRSIZ] = '\0'; &#160;/* ensure termination */&#160;<br/>return &amp;d;&#160;<br/>
}&#160;<br/>return NULL;&#160;<br/>
&#160; &#160;}&#160;<br/>
Although the&#160;fsize&#160;program&#160;is rather specialized, it&#160;does illustrate a couple of important&#160;<br/>ideas. First, many programs are not ``system&#160;programs'';&#160;they merely use information that is&#160;<br/>maintained by the operating system. For such programs, it is crucial that the representation of&#160;<br/>the information appear only in standard headers, and that programs include those headers&#160;<br/>instead of embedding the declarations in themselves. The second observation is that with care&#160;<br/>it is possible to create an interface to system-dependent objects that is itself relatively system-<br/>independent. The functions of the standard library are good examples. &#160;<br/>
<b>Exercise 8-5.</b>&#160;Modify the&#160;fsize&#160;program&#160;to print the other information contained in the inode&#160;<br/>entry. &#160;<br/>
<b>8.7 Example - A Storage Allocator&#160;</b><br/>
In&#160;Chapter 5, we presented a vary limited stack-oriented storage allocator. The version that we&#160;<br/>will now write is unrestricted. Calls to&#160;malloc&#160;and&#160;free&#160;may occur in any order;&#160;malloc&#160;calls&#160;<br/>
<hr/>
<a name=164></a><img src="c-164_1.png"/><br/>
&#160;&#160;<br/>
164&#160;<br/>
upon the operating system&#160;to obtain more memory&#160;as necessary. These routines illustrate&#160;<br/>some&#160;of the considerations involved in writing machine-dependent code in a relatively&#160;<br/>machine-independent way, and also show a real-life application of structures, unions and&#160;<br/>typedef. &#160;<br/>
Rather than allocating from&#160;a compiled-in fixed-size array,&#160;malloc&#160;will request space from&#160;<br/>the operating system&#160;as needed. Since other activities in the program&#160;may also request space&#160;<br/>without calling this allocator, the space that&#160;malloc&#160;manages may not be contiguous. Thus its&#160;<br/>free storage is kept as a list of free blocks. Each&#160;block contains a size,&#160;a pointer to the next&#160;<br/>block, and the space itself. The blocks are kept&#160;in order of increasing storage address, and the&#160;<br/>last block (highest address) points to the first. &#160;<br/>
&#160;<br/>
When a request is made, the free list is scanned until a big-enough block is found. This&#160;<br/>algorithm&#160;is called ``first fit,'' by&#160;contrast with ``best fit,'' which looks for the smallest block&#160;<br/>that will satisfy&#160;the request. If&#160;the block is exactly the size requested it is unlinked from&#160;the&#160;<br/>list and returned to the user.&#160;If the block is too big, it is split, and the proper amount is&#160;<br/>returned to the user while the residue remains on the free list. If no&#160;big-enough block is found,&#160;<br/>another large chunk is obtained by the operating system&#160;and linked into the free list. &#160;<br/>
Freeing also causes a search of the free list, to&#160;find the proper place to&#160;insert the block being&#160;<br/>freed. If the block being freed is adjacent to a&#160;free block on either side, it is coalesced with it&#160;<br/>into a single bigger block, so storage does&#160;not become too fragmented. Determining the&#160;<br/>adjacency is easy because the free list is maintained in order of decreasing address. &#160;<br/>
One problem<a href="">, which we alluded to in&#160;Chapter 5</a>, is to ensure that the storage returned by&#160;<br/>malloc&#160;is aligned properly for the objects that will be stored in it. Although machines vary,&#160;<br/>for each machine there is a most restrictive type: if&#160;the most restrictive type can be stored at a&#160;<br/>particular address, all other types may be also.&#160;On some machines, the most restrictive type is&#160;<br/>a&#160;double; on others,&#160;int&#160;or&#160;long&#160;suffices. &#160;<br/>
A free block contains a pointer to&#160;the next block in the chain, a record of the size of the block,&#160;<br/>and then the free space itself; the control information at the beginning is called the ``header.''&#160;<br/>To simplify alignment, all blocks are multiples of&#160;the header size, and the header is aligned&#160;<br/>properly. This is achieved by a union that contains the desired header structure and an&#160;<br/>instance of&#160;the most restrictive alignment type, which we have arbitrarily made a&#160;long: &#160;<br/>
&#160;<br/>&#160; &#160;typedef long Align; &#160; &#160;/* for alignment to long boundary */&#160;<br/>&#160;<br/>&#160; &#160;union header { &#160; &#160; &#160; &#160; /* block header */&#160;<br/>
<hr/>
<a name=165></a><img src="c-165_1.png"/><br/>
&#160;&#160;<br/>
165&#160;<br/>
&#160; &#160; &#160; &#160;struct {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;union header *ptr; /* next block if on free list */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;unsigned size; &#160; &#160; /* size of this block */&#160;<br/>&#160; &#160; &#160; &#160;} s;&#160;<br/>&#160; &#160; &#160; &#160;Align x; &#160; &#160; &#160; &#160; &#160; /* force alignment of blocks */&#160;<br/>&#160; &#160;};&#160;<br/>&#160;<br/>&#160; &#160;typedef union header Header;&#160;<br/>
The&#160;&#160;Align&#160;field is never used; it just forces each header to be aligned on a worst-case&#160;<br/>boundary. &#160;<br/>
In&#160;malloc, the requested size in characters is rounded up to the proper number of header-sized&#160;<br/>units; the block that will be allocated contains one&#160;more unit, for the header itself,&#160;and this is&#160;<br/>the value recorded in the&#160;size&#160;field of the header. The pointer returned by&#160;malloc&#160;points at&#160;<br/>the free space, not at the header itself. The user can do anything with the space requested, but&#160;<br/>if anything is written outside of the allocated space the list is likely to be scrambled. &#160;<br/>
&#160;<br/>
The size field is necessary because the blocks controlled by&#160;malloc&#160;need not be contiguous -&#160;<br/>it is not possible to compute sizes by pointer arithmetic. &#160;<br/>
The variable&#160;base&#160;is used to get started. If&#160;freep&#160;is&#160;NULL, as it is at the first call of&#160;malloc,&#160;<br/>then a degenerate free list is created; it contains one block of size zero, and points to itself. In&#160;<br/>any case, the free list is then searched. The search for a free block of adequate size begins at&#160;<br/>the point (freep) where the last block was found;&#160;this strategy helps keep the list&#160;<br/>homogeneous. If a too-big block is found, the tail end is returned to the user; in this way the&#160;<br/>header of the original needs only to have its size adjusted. In all cases, the pointer returned to&#160;<br/>the user points to the free space within the block, which begins one unit beyond the header. &#160;<br/>
&#160;<br/>&#160; &#160;static Header base; &#160; &#160; &#160; /* empty list to get started */&#160;<br/>&#160; &#160;static Header *freep = NULL; &#160; &#160; /* start of free list */&#160;<br/>&#160;<br/>&#160; &#160;/* malloc: &#160;general-purpose storage allocator */&#160;<br/>&#160; &#160;void *malloc(unsigned nbytes)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;Header *p, *prevp;&#160;<br/>&#160; &#160; &#160; &#160;Header *moreroce(unsigned);&#160;<br/>&#160; &#160; &#160; &#160;unsigned nunits;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;nunits = (nbytes+sizeof(Header)-1)/sizeof(header) + 1;&#160;<br/>&#160; &#160; &#160; &#160;if ((prevp = freep) == NULL) { &#160; /* no free list yet */ &#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;base.s.ptr = freeptr = prevptr = &amp;base;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;base.s.size = 0;&#160;<br/>&#160; &#160; &#160; &#160;}&#160;<br/>
<hr/>
<a name=166></a>&#160;&#160;<br/>
166&#160;<br/>
&#160; &#160; &#160; &#160;for (p = prevp-&gt;s.ptr; ; prevp = p, p = p-&gt;s.ptr) {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;if (p-&gt;s.size &gt;= nunits) { &#160;/* big enough */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;if (p-&gt;s.size == nunits) &#160;/* exactly */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;prevp-&gt;s.ptr = p-&gt;s.ptr;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;else { &#160; &#160; &#160; &#160; &#160; &#160; &#160;/* allocate tail end */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;p-&gt;s.size -= nunits;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;p += p-&gt;s.size;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;p-&gt;s.size = nunits;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;freep = prevp;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;return (void *)(p+1);&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;if (p == freep) &#160;/* wrapped around free list */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;if ((p = morecore(nunits)) == NULL)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;return NULL; &#160; &#160;/* none left */&#160;<br/>&#160; &#160; &#160; &#160;}&#160;<br/>&#160; &#160;}&#160;<br/>
The function&#160;morecore&#160;obtains storage from&#160;the operating&#160;system. The details of how it does&#160;<br/>this vary from&#160;system&#160;to system. Since asking the system&#160;for memory is a comparatively&#160;<br/>expensive operation. we don't want&#160;to do that on every call to&#160;malloc, so&#160;morecore&#160;requests&#160;<br/>al least&#160;NALLOC&#160;units; this larger block will be chopped up as needed. After setting the size&#160;<br/>field,&#160;morecore&#160;inserts the additional memory into the arena by calling&#160;free. &#160;<br/>
The UNIX system&#160;call&#160;sbrk(n)&#160;returns a pointer to&#160;n&#160;more bytes of storage.&#160;sbrk&#160;returns&#160;-1&#160;<br/>if there was no space, even though&#160;NULL&#160;could have been a better design. The&#160;-1&#160;must&#160;be&#160;cast&#160;<br/>to&#160;&#160;char *&#160;so it can be compared with the return&#160;value. Again, casts make the function&#160;<br/>relatively immune to the details of&#160;pointer representation on different machines. There is still&#160;<br/>one assumption, however, that pointers to different blocks returned by&#160;sbrk&#160;can be&#160;<br/>meaningfully compared. This is not guaranteed by the standard, which permits pointer&#160;<br/>comparisons only within an array. Thus this version of&#160;malloc&#160;is portable only among&#160;<br/>machines for which general pointer comparison is meaningful. &#160;<br/>
&#160;<br/>&#160; &#160;#define NALLOC &#160;1024 &#160; /* minimum #units to request */&#160;<br/>&#160;<br/>&#160; &#160;/* morecore: &#160;ask system for more memory */&#160;<br/>&#160; &#160;static Header *morecore(unsigned nu)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;char *cp, *sbrk(int);&#160;<br/>&#160; &#160; &#160; &#160;Header *up;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;if (nu &lt; NALLOC)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;nu = NALLOC;&#160;<br/>&#160; &#160; &#160; &#160;cp = sbrk(nu * sizeof(Header));&#160;<br/>&#160; &#160; &#160; &#160;if (cp == (char *) -1) &#160; /* no space at all */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;return NULL;&#160;<br/>&#160; &#160; &#160; &#160;up = (Header *) cp;&#160;<br/>&#160; &#160; &#160; &#160;up-&gt;s.size = nu;&#160;<br/>&#160; &#160; &#160; &#160;free((void *)(up+1));&#160;<br/>&#160; &#160; &#160; &#160;return freep;&#160;<br/>&#160; &#160;}&#160;<br/>
free&#160;itself&#160;is the last thing. It scans the free list, starting at&#160;freep, looking for the place to&#160;<br/>insert the free block. This is either between two&#160;existing blocks or at the end of the list. In any&#160;<br/>case, if the block being freed is&#160;adjacent to either neighbor, the adjacent blocks are combined.&#160;<br/>The only troubles are keeping the pointers pointing&#160;to the right things and the sizes correct. &#160;<br/>&#160;<br/>&#160; &#160;/* free: &#160;put block ap in free list */&#160;<br/>&#160; &#160;void free(void *ap)&#160;<br/>&#160; &#160;{&#160;<br/>
<hr/>
<a name=167></a>&#160;&#160;<br/>
167&#160;<br/>
&#160; &#160; &#160; &#160;Header *bp, *p;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;bp = (Header *)ap - 1; &#160; &#160;/* point to &#160;block header */&#160;<br/>&#160; &#160; &#160; &#160;for (p = freep; !(bp &gt; p &amp;&amp; bp &lt; p-&gt;s.ptr); p = p-&gt;s.ptr)&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; if (p &gt;= p-&gt;s.ptr &amp;&amp; (bp &gt; p || bp &lt; p-&gt;s.ptr))&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; break; &#160;/* freed block at start or end of arena */&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;if (bp + bp-&gt;size == p-&gt;s.ptr) { &#160; &#160;/* join to upper nbr */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;bp-&gt;s.size += p-&gt;s.ptr-&gt;s.size;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;bp-&gt;s.ptr = p-&gt;s.ptr-&gt;s.ptr;&#160;<br/>&#160; &#160; &#160; &#160;} else&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;bp-&gt;s.ptr = p-&gt;s.ptr;&#160;<br/>&#160; &#160; &#160; &#160;if (p + p-&gt;size == bp) { &#160; &#160; &#160; &#160; &#160; &#160;/* join to lower nbr */&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;p-&gt;s.size += bp-&gt;s.size;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;p-&gt;s.ptr = bp-&gt;s.ptr;&#160;<br/>&#160; &#160; &#160; &#160;} else&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;p-&gt;s.ptr = bp;&#160;<br/>&#160; &#160; &#160; &#160;freep = p;&#160;<br/>&#160; &#160;}&#160;<br/>
Although storage allocation is intrinsically machine-dependent, the code above illustrates how&#160;<br/>the machine dependencies can be controlled and confined to a very small part of the program.&#160;<br/>The use of&#160;typedef&#160;and&#160;union&#160;handles alignment (given that&#160;sbrk&#160;supplies an appropriate&#160;<br/>pointer). Casts arrange that pointer conversions&#160;are made explicit, and even cope with a&#160;<br/>badly-designed system&#160;interface. Even though&#160;the details here are related to storage&#160;<br/>allocation, the general approach is applicable to other situations as well. &#160;<br/>
<b>Exercise 8-6.</b>&#160;The standard library function&#160;calloc(n,size)&#160;returns a pointer to&#160;n&#160;objects of&#160;<br/>size&#160;&#160;size, with the storage initialized to zero. Write&#160;calloc, by calling&#160;malloc&#160;or by&#160;<br/>modifying it. &#160;<br/>
<b>Exercise 8-7.</b>&#160;malloc&#160;accepts a size request without checking its plausibility;&#160;free&#160;believes&#160;<br/>that the block it is asked to free contains a valid size field. Improve these routines so they&#160;<br/>make more pains with error checking. &#160;<br/>
<b>Exercise 8-8.</b>&#160;Write a routine&#160;bfree(p,n)&#160;that will free any arbitrary block&#160;p&#160;of&#160;n&#160;characters&#160;<br/>into the free list maintained by&#160;malloc&#160;and&#160;free. By using&#160;bfree, a user can add a static or&#160;<br/>external array to the free list at any time. &#160;<br/>
<hr/>
<a name=168></a>&#160;&#160;<br/>
168&#160;<br/>
&#160;<br/>
<b>Appendix&#160;A&#160;- Reference Manual&#160;</b><br/>
<b>A.1 Introduction&#160;</b><br/>
This manual describes the C language specified by the draft submitted to ANSI on 31&#160;<br/>October, 1988, for approval as ``American Standard for Information Systems - programming&#160;<br/>Language C, X3.159-1989.'' The manual is an interpretation of the proposed standard, not the&#160;<br/>standard itself, although care has been taken to make it a reliable guide to the language. &#160;<br/>
For the most part, this document follows the&#160;broad outline of&#160;the standard, which in turn&#160;<br/>follows that of the first edition of this book,&#160;although the organization differs in detail. Except&#160;<br/>for renaming a few productions, and not formalizing the definitions of the lexical tokens or&#160;<br/>the preprocessor, the grammar given here for the&#160;language proper is equivalent to that of the&#160;<br/>standard. &#160;<br/>
Throughout this manual, commentary material is indented and written in smaller type, as&#160;this&#160;is.&#160;Most&#160;<br/>often&#160;these&#160;comments highlight&#160;ways&#160;in&#160;which ANSI&#160;Standard C&#160;differs from&#160;the language defined by&#160;<br/>the first&#160;edition of this&#160;book, or from&#160;refinements subsequently&#160;introduced in&#160;various compilers.&#160;&#160;<br/>
<b>A.2 Lexical Conventions&#160;</b><br/>
A program&#160;consists of one or more&#160;<i>translation units</i>&#160;stored in files. It is translated in several&#160;<br/>phases, which are described in&#160;<a href="cs.html#206">Par.A.12. The f</a>irst phases do low-level lexical&#160;<br/>transformations, carry out directives introduced&#160;by the lines beginning with the # character,&#160;<br/>and perform&#160;macro definition and expansion. When the preprocessing of&#160;<a href="cs.html#206">Par.A.12&#160;is&#160;<br/></a>complete, the program&#160;has been reduced to a sequence of tokens. &#160;<br/>
<b>A.2.1 Tokens&#160;</b><br/>
There are six classes of&#160;tokens: identifiers, keywords, constants, string literals, operators, and&#160;<br/>other separators. Blanks, horizontal and vertical tabs, newlines, formfeeds and comments as&#160;<br/>described below (collectively, ``white space'')&#160;are ignored except as they separate tokens.&#160;<br/>Some white space is required to separate otherwise adjacent identifiers, keywords, and&#160;<br/>constants. &#160;<br/>
If the input stream&#160;has been separated into tokens up to a given character, the next token is the&#160;<br/>longest string of characters that could constitute a token. &#160;<br/>
<b>A.2.2 Comments&#160;</b><br/>
The characters&#160;/*&#160;introduce a comment, which terminates with the characters&#160;*/.&#160;Comments&#160;<br/>do not nest, and they do not occur within a string or character literals. &#160;<br/>
<b>A.2.3 Identifiers&#160;</b><br/>
An identifier is a sequence of&#160;letters and digits. The first character must be a letter; the&#160;<br/>underscore&#160;&#160;_&#160;counts as a letter. Upper and lower case letters are different. Identifiers may&#160;<br/>have any length, and for internal identifiers,&#160;at least the first 31 characters are significant;&#160;<br/>
<hr/>
<a name=169></a>&#160;&#160;<br/>
169&#160;<br/>
some implementations may take more characters significant. Internal identifiers include&#160;<br/>preprocessor macro names and all other names that do not have external linkage (<a href="cs.html#206">Par.A.11.2</a>).&#160;<br/>Identifiers with external linkage are more restricted: implementations may make as few as the&#160;<br/>first six characters significant, and may ignore case distinctions. &#160;<br/>
<b>A.2.4 Keywords&#160;</b><br/>
The following identifiers are reserved for the use as keywords, and may not be used&#160;<br/>otherwise: &#160;<br/>&#160;<br/>&#160; &#160; &#160;auto &#160; &#160; &#160; &#160; &#160;double &#160; &#160; &#160;int &#160; &#160; &#160; &#160; &#160;struct&#160;<br/>&#160; &#160; &#160;break &#160; &#160; &#160; &#160; else &#160; &#160; &#160; &#160;long &#160; &#160; &#160; &#160; switch&#160;<br/>&#160; &#160; &#160;case &#160; &#160; &#160; &#160; &#160;enum &#160; &#160; &#160; &#160;register &#160; &#160; typedef&#160;<br/>&#160; &#160; &#160;char &#160; &#160; &#160; &#160; &#160;extern &#160; &#160; &#160;return &#160; &#160; &#160; union&#160;<br/>&#160; &#160; &#160;const &#160; &#160; &#160; &#160; float &#160; &#160; &#160; short &#160; &#160; &#160; &#160;unsigned&#160;<br/>&#160; &#160; &#160;continue &#160; &#160; &#160;for &#160; &#160; &#160; &#160; signed &#160; &#160; &#160; void&#160;<br/>&#160; &#160; &#160;default &#160; &#160; &#160; goto &#160; &#160; &#160; &#160;sizeof &#160; &#160; &#160; volatile&#160;<br/>&#160; &#160; &#160;do &#160; &#160; &#160; &#160; &#160; &#160;if &#160; &#160; &#160; &#160; &#160;static &#160; &#160; &#160; while&#160;<br/>
Some implementations also reserve the words&#160;fortran&#160;and&#160;asm. &#160;<br/>
The keywords&#160;const,&#160;&#160;signed, and&#160;volatile&#160;are&#160;new with the ANSI standard;&#160;enum&#160;and&#160;void&#160;<br/>are new since the first edition, but in common use;&#160;entry, formerly&#160;reserved but&#160;never used,&#160;is&#160;no&#160;<br/>longer reserved.&#160;&#160;<br/>
<b>A.2.5 Constants&#160;</b><br/>
There are several kinds of constants. Each has a data type;&#160;<a href="cs.html#172">Par.A.4.2</a>&#160;discusses the basic types: &#160;<br/>
<i>&#160; &#160; constant:&#160;<br/>&#160; &#160; &#160; integer-constant&#160;<br/>&#160; &#160; &#160; character-constant&#160;<br/>&#160; &#160; &#160; floating-constant&#160;<br/>&#160; &#160; &#160; enumeration-constant&#160;</i>&#160;<br/>
<b>A.2.5.1 Integer Constants&#160;</b><br/>
An integer constant consisting of a sequence of digits is taken to be octal if&#160;it begins with 0&#160;<br/>(digit zero), decimal otherwise. Octal&#160;constants do not contain the digits&#160;8&#160;or&#160;9. A sequence of&#160;<br/>digits preceded by&#160;0x&#160;or&#160;0X&#160;(digit zero) is taken to be a hexadecimal integer. The hexadecimal&#160;<br/>digits include&#160;a&#160;or&#160;A&#160;through&#160;f&#160;or&#160;F&#160;with values&#160;10&#160;through&#160;15. &#160;<br/>
An integer constant may be suffixed by the letter&#160;u&#160;or&#160;U, to specify&#160;that it is unsigned. It may&#160;<br/>also be suffixed by the letter&#160;l&#160;or&#160;L&#160;to specify that it is long. &#160;<br/>
The type of an integer constant depends on its form<a href="cs.html#171">, value and suffix. (See&#160;Par.A.4&#160;for a&#160;<br/></a>discussion of types). If it is unsuffixed and decimal, it has the first of&#160;these types in which its&#160;<br/>value can be represented:&#160;int,&#160;&#160;long int,&#160;&#160;unsigned long int. If it is unsuffixed, octal or&#160;<br/>hexadecimal, it has the first possible of these types:&#160;int,&#160;&#160;unsigned int,&#160;&#160;long int,&#160;<br/>unsigned long int. If it is suffixed by&#160;u&#160;or&#160;U, then&#160;unsigned int,&#160;unsigned long int. If&#160;<br/>it is suffixed by&#160;l&#160;or&#160;L, then&#160;long int,&#160;unsigned long int. If an integer constant is suffixed&#160;<br/>by&#160;UL, it is&#160;unsigned long. &#160;<br/>
The&#160;elaboration&#160;of the types of integer constants goes considerably beyond the first edition, which&#160;<br/>merely caused&#160;large integer constants to&#160;be&#160;long. The&#160;U&#160;suffixes are new.&#160;&#160;<br/>
<hr/>
<a name=170></a>&#160;&#160;<br/>
170&#160;<br/>
<b>A.2.5.2 Character Constants&#160;</b><br/>
A character constant is a sequence of one or more characters enclosed in single quotes as in&#160;<br/>'x'. The value of a character constant with only one character is the numeric value of the&#160;<br/>character in the machine's character set at&#160;execution time. The value of&#160;a multi-character&#160;<br/>constant is implementation-defined. &#160;<br/>
Character constants do not contain the&#160;'&#160;character or newlines; in order to represent them, and&#160;<br/>certain other characters, the following escape sequences may be used: &#160;<br/>
newline &#160;<br/>
NL (LF)&#160;&#160;\n&#160; &#160;&#160;&#160;backslash &#160;<br/>
\&#160;&#160;<br/>
\\&#160;<br/>
horizontal tab &#160;&#160;HT &#160;<br/>
\t&#160;<br/>
question mark&#160;?&#160;&#160;&#160;\?&#160;<br/>
vertical tab &#160;<br/>
VT &#160;<br/>
\v&#160;<br/>
single quote &#160;&#160;'&#160;&#160;&#160;\'&#160;<br/>
backspace &#160;<br/>
BS &#160;<br/>
\b&#160;<br/>
double quote&#160;&#160;&#34;&#160;&#160;&#160;\&#34;&#160;<br/>
carriage return&#160;&#160;CR&#160;&#160;<br/>
\r&#160;<br/>
octal number&#160;&#160;ooo&#160;\ooo&#160;<br/>
formfeed &#160;<br/>
FF &#160;<br/>
\f&#160;<br/>
hex number &#160;&#160;hh&#160;&#160;\xhh&#160;<br/>
audible alert &#160;&#160;BEL &#160;<br/>
\a&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
The escape&#160;\ooo&#160;consists of the backslash followed by 1, 2, or 3 octal digits, which are taken&#160;<br/>to specify the value of the desired character. A common example of this construction is&#160;\0&#160;<br/>(not followed by a digit), which specifies the character NUL. The escape&#160;\xhh&#160;consists of&#160;the&#160;<br/>backslash, followed by&#160;x, followed by hexadecimal digits, which are taken to specify the&#160;<br/>value of the desired character. There is no limit&#160;on the number of digits, but the behavior is&#160;<br/>undefined if the resulting character value exceeds that of the largest character. For either octal&#160;<br/>or hexadecimal escape characters, if the implementation treats the&#160;char&#160;type as signed, the&#160;<br/>value is sign-extended as if&#160;cast to&#160;char&#160;type. If the character following the \ is not one of&#160;<br/>those specified, the behavior is undefined. &#160;<br/>
In some implementations, there is an extended set of characters that cannot be represented in&#160;<br/>the&#160;char&#160;type. A constant in this extended set is written with a preceding&#160;L, for example&#160;L'x',&#160;<br/>and is called a wide character constant. Such a constant has type&#160;wchar_t, an integral type&#160;<br/>defined in the standard header&#160;&lt;stddef.h&gt;. As with ordinary character constants,&#160;<br/>hexadecimal escapes may be used; the effect is&#160;undefined if the specified value exceeds that&#160;<br/>representable with&#160;wchar_t. &#160;<br/>
Some&#160;of these escape sequences are new, in particular the hexadecimal character representation.&#160;<br/>Extended&#160;characters are also new.&#160;The character sets commonly used&#160;in the Americas and western&#160;<br/>Europe can be encoded to&#160;fit&#160;in&#160;the&#160;char&#160;type; the main&#160;intent in&#160;adding&#160;wchar_t&#160;was to&#160;<br/>accommodate Asian languages.&#160;&#160;<br/>
<b>A.2.5.3 Floating Constants&#160;</b><br/>
A floating constant consists of an integer part, a decimal part, a fraction part, an&#160;e&#160;or&#160;E, an&#160;<br/>optionally signed integer exponent and an optional type suffix, one of&#160;f,&#160;F,&#160;l, or&#160;L. The integer&#160;<br/>and fraction parts both consist of a sequence of digits. Either the integer part, or the fraction&#160;<br/>part (not both) may be missing; either the decimal point or the&#160;e&#160;and the exponent (not both)&#160;<br/>may be missing. The type is determined by the suffix;&#160;F&#160;or&#160;f&#160;makes it&#160;float,&#160;L&#160;or&#160;l&#160;makes it&#160;<br/>long double, otherwise it is&#160;double. &#160;<br/>
<b>A2.5.4 Enumeration Constants&#160;</b><br/>
<hr/>
<a name=171></a>&#160;&#160;<br/>
171&#160;<br/>
Identifiers declared as enum<a href="cs.html#191">erators (see&#160;Par.A.8.4) are constants of type&#160;</a>int. &#160;<br/>
<b>A.2.6 String Literals&#160;</b><br/>
A string literal, also called a string constant, is a sequence of characters surrounded by double&#160;<br/>quotes as in&#160;&#34;...&#34;. A string has type ``array of characters'' and storage class&#160;static&#160;(see&#160;<br/><a href="cs.html#171">Par.A.3</a>&#160;below) and is initialized with the given&#160;characters. Whether identical string literals&#160;<br/>are distinct is implementation-defined, and the behavior of a program&#160;that attempts to alter a&#160;<br/>string literal is undefined. &#160;<br/>
Adjacent string literals are concatenated into a&#160;single string. After any concatenation, a null&#160;<br/>byte&#160;\0&#160;is appended to the string so that programs&#160;that scan the string can find its end. String&#160;<br/>literals do not contain newline or double-quote characters; in order to represent them, the&#160;<br/>same escape sequences as for character constants are available. &#160;<br/>
As with character constants, string literals in&#160;an extended character set are written with a&#160;<br/>preceding&#160;&#160;L, as in&#160;L&#34;...&#34;. Wide-character string literals have type ``array of&#160;wchar_t.''&#160;<br/>Concatenation of ordinary and wide string literals is undefined. &#160;<br/>
The specification&#160;that string&#160;literals need&#160;not&#160;be distinct, and&#160;the&#160;prohibition&#160;against&#160;modifying&#160;them,&#160;<br/>are new in the ANSI standard, as is the concatenation of adjacent string literals. Wide-character string&#160;<br/>literals are new.&#160;&#160;<br/>
<b>A.3 Syntax Notation&#160;</b><br/>
In the syntax notation used in this manual, syntactic categories are indicated by&#160;<i>italic</i>&#160;type,&#160;<br/>and literal words and characters in&#160;typewriter&#160;style. Alternative categories are usually listed&#160;<br/>on separate lines; in a few cases, a long set of&#160;narrow alternatives is presented on one line,&#160;<br/>marked by the phrase ``one of.'' An optional&#160;terminal or nonterminal symbol carries the&#160;<br/>subscript ``<i>opt</i>,''&#160;so that, for example, &#160;<br/>
{&#160;<i>expressionopt</i>&#160;} &#160;<br/>
means an optional expression, enclosed in braces. The syntax is summarized in&#160;Par.A.13. &#160;<br/>
Unlike the grammar given in the first edition&#160;of&#160;this book, the one given here makes precedence and&#160;<br/>associativity of&#160;expression&#160;operators explicit. &#160;<br/>
<b>A.4 Meaning of Identifiers&#160;</b><br/>
Identifiers, or names, refer to a variety of things: functions; tags of structures, unions, and&#160;<br/>enumerations; members of structures or unions; enumeration constants; typedef names; and&#160;<br/>objects. An object, sometimes called a variable, is&#160;a location in storage, and its interpretation&#160;<br/>depends on two main attributes: its&#160;<i>storage class</i>&#160;and its&#160;<i>type</i>. The storage class determines the&#160;<br/>lifetime of&#160;the storage associated with the identified object; the type determines the meaning&#160;<br/>of the values found in the identified object. A name also has a scope, which is the region of&#160;<br/>the program&#160;in which it is known, and a linkage, which determines whether the same name in&#160;<br/>another scope refers to the same object or&#160;function. Scope and linkage are discussed in&#160;<br/><a href="cs.html#205">Par.A.11</a>. &#160;<br/>
<b>A.4.1 Storage Class&#160;</b><br/>
<hr/>
<a name=172></a>&#160;&#160;<br/>
172&#160;<br/>
There are two storage classes: automatic and&#160;static. Several keywords, together with the&#160;<br/>context of an object's declaration, specify its&#160;storage class. Automatic objects are local to a&#160;<br/><a href="cs.html#200">block (Par.9.3</a>), and are discarded on exit from&#160;the block. Declarations within a block create&#160;<br/>automatic objects if no storage class specification is mentioned, or if the&#160;auto&#160;specifier is&#160;<br/>used. Objects declared&#160;register&#160;are automatic, and are (if possible)&#160;stored in fast registers of&#160;<br/>the machine. &#160;<br/>
Static objects may be local to a block or external to all blocks, but in either case retain their&#160;<br/>values across exit from&#160;and reentry to functions&#160;and blocks. Within a block, including a block&#160;<br/>that provides the code for a function, static objects are declared with the keyword&#160;static.&#160;<br/>The objects declared outside all blocks, at the&#160;same level as function definitions, are always&#160;<br/>static. They may be made local to a particular translation unit by use of the&#160;static&#160;keyword;&#160;<br/>this gives them&#160;<i>internal linkage</i>. They become global to an entire program&#160;by omitting an&#160;<br/>explicit storage class, or by using the keyword&#160;extern; this gives them&#160;<i>external linkage</i>. &#160;<br/>
<b>A.4.2 Basic Types&#160;</b><br/>
There are several fundamental types. The standard header&#160;&lt;limits.h&gt;&#160;described in&#160;<a href="">Appendix&#160;<br/>B</a>&#160;defines the largest and smallest values of&#160;each type in the local implementation. The&#160;<br/>numbers given in&#160;<a href="">Appendix B</a>&#160;show the smallest acceptable magnitudes. &#160;<br/>
Objects declared as characters (char) are large enough to store any member of the execution&#160;<br/>character set. If a genuine character&#160;from&#160;that set is stored in a&#160;char&#160;object, its value is&#160;<br/>equivalent to the integer code for the character, and is non-negative. Other quantities may be&#160;<br/>stored into&#160;char&#160;variables, but the available range of values, and especially whether the value&#160;<br/>is signed, is implementation-dependent. &#160;<br/>
Unsigned characters declared&#160;unsigned char&#160;consume the same amount of space as plain&#160;<br/>characters, but always appear non-negative; explicitly signed characters declared&#160;signed&#160;<br/>char&#160;likewise take the same space as plain characters. &#160;<br/>
unsigned&#160;char&#160;type does not&#160;appear in&#160;the first&#160;edition of this&#160;book, but&#160;is&#160;in&#160;common use.&#160;signed&#160;<br/>char&#160;is new.&#160;&#160;<br/>
Besides the&#160;char&#160;types, up to three sizes of integer, declared&#160;short int,&#160;int, and&#160;long int,&#160;<br/>are available. Plain&#160;int&#160;objects have the natural size suggested by the host machine&#160;<br/>architecture; the other sizes are provided to meet special needs. Longer integers provide at&#160;<br/>least as much storage as shorter ones, but&#160;the implementation may make plain integers&#160;<br/>equivalent to either short integers, or long integers. The&#160;int&#160;types all represent signed values&#160;<br/>unless specified otherwise. &#160;<br/>
Unsigned integers, declared using the keyword&#160;unsigned, obey the laws of arithmetic modulo&#160;<br/>2<i>n</i>&#160;where&#160;<i>n</i>&#160;is the number of bits in the representation, and thus arithmetic on unsigned&#160;<br/>quantities can never overflow. The set of non-negative values that can be stored in a signed&#160;<br/>object is a subset of the values that can be&#160;stored in the corresponding unsigned object, and&#160;<br/>the representation for the overlapping values is the same. &#160;<br/>
Any of single precision floating point (float), double precision floating point (double), and&#160;<br/>extra precision floating point (long double) may be synonymous, but the ones later in the&#160;<br/>list are at least as precise as those before. &#160;<br/>
<hr/>
<a name=173></a>&#160;&#160;<br/>
173&#160;<br/>
long double&#160;is new. The first&#160;edition&#160;made&#160;long float&#160;equivalent&#160;to&#160;double; the locution&#160;has&#160;<br/>been withdrawn.&#160;&#160;<br/>
<i>Enumerations</i>&#160;are unique types that have integral values; associated with each enumeration is&#160;<br/>a set of nam<a href="cs.html#191">ed constants (Par.A.8.4). Enum</a>erations behave like integers, but it is common for&#160;<br/>a compiler to issue a warning when an object&#160;of a particular enumeration is assigned&#160;<br/>something other than one of its constants, or an expression of its type. &#160;<br/>
Because objects of these types can be interpreted as numbers, they will be referred to as&#160;<br/><i>arithmetic</i>&#160;types. Types&#160;char, and&#160;int&#160;of all sizes, each with or without sign, and also&#160;<br/>enumeration types, will collectively be called&#160;<i>integral</i>&#160;types. The types&#160;float,&#160;&#160;double, and&#160;<br/>long double&#160;will be called&#160;<i>floating</i>&#160;types. &#160;<br/>
The&#160;&#160;void&#160;type specifies an empty set of values. It&#160;is used as the type returned by functions&#160;<br/>that generate no value. &#160;<br/>
<b>A.4.3 Derived types&#160;</b><br/>
Beside the basic types, there is a conceptually&#160;infinite class of derived types constructed from&#160;<br/>the fundamental types in the following ways: &#160;<br/>
&#160;&#160;<i>arrays</i>&#160;of objects of a given type;&#160;<br/>&#160;&#160;<i>functions</i>&#160;returning objects of a given type;&#160;<br/>&#160;&#160;<i>pointers</i>&#160;to objects of a given type;&#160;<br/>&#160;&#160;<i>structures</i>&#160;containing a sequence of objects of various types;&#160;<br/>&#160;&#160;<i>unions</i>&#160;capable of containing any of one of several objects of various types. &#160;<br/>
In general these methods of constructing objects can be applied recursively. &#160;<br/>
<b>A.4.4 Type Qualifiers&#160;</b><br/>
An object's type may have additional qualifiers. Declaring an object&#160;const&#160;announces that its&#160;<br/>value will not be changed; declaring it&#160;volatile&#160;announces that it has special properties&#160;<br/>relevant to optimization. Neither qualifier affects the range of&#160;values or arithmetic properties&#160;<br/>of the object. Qualifiers are discussed in&#160;<a href="cs.html#188">Par.A.8.2</a>. &#160;<br/>
<b>A.5 Objects and Lvalues&#160;</b><br/>
An&#160;<i>Object</i>&#160;is a named region of storage; an&#160;<i>lvalue</i>&#160;is an expression referring to an object. An&#160;<br/>obvious example of an lvalue expression is an identifier with suitable type and storage class.&#160;<br/>There are operators that yield lvalues, if&#160;E&#160;is an expression of&#160;pointer type, then&#160;*E&#160;is an lvalue&#160;<br/>expression referring to the object to which&#160;E&#160;points. The name&#160;``lvalue'' comes from&#160;the&#160;<br/>assignment expression&#160;E1 = E2&#160;in which the left&#160;operand&#160;E1&#160;must be an lvalue expression.&#160;<br/>The discussion of each operator specifies whether it expects lvalue operands and whether it&#160;<br/>yields an lvalue. &#160;<br/>
<b>A.6 Conversions&#160;</b><br/>
Some operators may, depending on their operands, cause conversion of the value of an&#160;<br/>operand from&#160;one type to another. This section&#160;explains the result to be expected from&#160;such&#160;<br/>
<hr/>
<a name=174></a>&#160;&#160;<br/>
174&#160;<br/>
conversions.&#160;&#160;<a href="cs.html#174">Par.6.5&#160;sum</a>marizes the conversions demanded by most ordinary operators; it&#160;<br/>will be supplemented as required by the discussion of each operator. &#160;<br/>
<b>A.6.1 Integral Promotion&#160;</b><br/>
A character, a short integer, or an integer bit-field, all either signed or not, or an object of&#160;<br/>enumeration type, may be used in an expression wherever an integer may be used. If an&#160;int&#160;<br/>can represent all the values of the original type, then the value is converted to&#160;int; otherwise&#160;<br/>the value is converted to&#160;unsigned int. This process is called&#160;<i>integral promotion</i>. &#160;<br/>
<b>A.6.2 Integral Conversions&#160;</b><br/>
Any integer is converted to a given unsigned&#160;type by finding the smallest non-negative value&#160;<br/>that is congruent to that integer, modulo one&#160;more than the largest value that can be&#160;<br/>represented in the unsigned type. In a two's complement representation, this is equivalent to&#160;<br/>left-truncation if&#160;the bit pattern of&#160;the unsigned type is narrower, and to zero-filling unsigned&#160;<br/>values and sign-extending signed values if the unsigned type is wider. &#160;<br/>
When any integer is converted to a signed type,&#160;the value is unchanged if it can be represented&#160;<br/>in the new type and is implementation-defined otherwise. &#160;<br/>
<b>A.6.3 Integer and Floating&#160;</b><br/>
When a value of floating type is converted to integral type, the fractional part is discarded; if&#160;<br/>the resulting value cannot be represented in the&#160;integral type, the behavior is undefined. In&#160;<br/>particular, the result of converting negative floating values to unsigned integral types is not&#160;<br/>specified. &#160;<br/>
When a value of integral type is converted to&#160;floating, and the value is in the representable&#160;<br/>range but is not exactly representable, then the result may be either the next higher or next&#160;<br/>lower representable value. If the result is out of range, the behavior is undefined. &#160;<br/>
<b>A.6.4 Floating Types&#160;</b><br/>
When a less precise floating value is converted to an equally or more precise floating type, the&#160;<br/>value is unchanged. When a more precise floating value is converted to a less precise floating&#160;<br/>type, and the value is within representable range, the result may be either the next higher or&#160;<br/>the next lower representable value. If the result is out of range, the behavior is undefined. &#160;<br/>
<b>A.6.5 Arithmetic Conversions&#160;</b><br/>
Many operators cause conversions and yield result&#160;types in a similar way. The effect is to&#160;<br/>bring operands into a common type, which is also the type of&#160;the result. This pattern is called&#160;<br/>the&#160;<i>usual arithmetic conversions</i>. &#160;<br/>
•&#160;&#160;First, if&#160;either operand is&#160;long double, the other is converted to&#160;long double. &#160;<br/>•&#160;&#160;Otherwise, if&#160;either operand is&#160;double, the other is converted to&#160;double. &#160;<br/>•&#160;&#160;Otherwise, if&#160;either operand is&#160;float, the other is converted to&#160;float. &#160;<br/>•&#160;&#160;Otherwise, the integral promotions are&#160;performed on both operands; then, if either&#160;<br/>
operand is&#160;unsigned long int, the other is converted to&#160;unsigned long int. &#160;<br/>
<hr/>
<a name=175></a>&#160;&#160;<br/>
175&#160;<br/>
•&#160;&#160;Otherwise, if one operand is&#160;long int&#160;and the other is&#160;unsigned int, the effect&#160;<br/>
depends on whether a&#160;long int&#160;can represent all values of an&#160;unsigned int; if&#160;so,&#160;<br/>the&#160;&#160;unsigned int&#160;operand is converted to&#160;long int; if not, both are converted to&#160;<br/>unsigned long int. &#160;<br/>
•&#160;&#160;Otherwise, if one operand is&#160;long int, the other is converted to&#160;long int. &#160;<br/>•&#160;&#160;Otherwise, if&#160;either operand is&#160;unsigned int, the other is converted to&#160;unsigned&#160;<br/>
int. &#160;<br/>
•&#160;&#160;Otherwise, both operands have type&#160;int. &#160;<br/>
There are two changes here. First, arithmetic&#160;on&#160;float&#160;operands may&#160;be done in&#160;single precision,&#160;<br/>rather than double; the first edition specified that all&#160;floating&#160;arithmetic was double precision. Second,&#160;<br/>shorter unsigned types, when&#160;combined&#160;with&#160;a&#160;larger signed type, do not&#160;propagate&#160;the unsigned&#160;<br/>property&#160;to&#160;the&#160;result&#160;type;&#160;in&#160;the first edition,&#160;the unsigned&#160;always dominated. The new rules are&#160;<br/>slightly more complicated, but reduce somewhat&#160;the surprises that may occur when an unsigned&#160;<br/>quantity&#160;meets&#160;signed.&#160;Unexpected&#160;results&#160;may still occur when&#160;an&#160;unsigned&#160;expression&#160;is compared&#160;to&#160;<br/>a signed expression of the same&#160;size.&#160;&#160;<br/>
<b>A.6.6 Pointers and Integers&#160;</b><br/>
An expression of integral type may be added to&#160;or subtracted from&#160;a pointer; in such a case&#160;<br/>the integral expression is converted as specified in the discussion of the addition operator&#160;<br/><a href="cs.html#182">(Par.A.7.7). &#160;</a><br/>
Two pointers to objects of the same type, in the&#160;same array, may be subtracted; the result is&#160;<br/>converted to an integer as specified in the discussion of the subtraction operator (<a href="cs.html#182">Par.A.7.7</a>). &#160;<br/>
An integral constant expression with value 0, or such an expression cast to type&#160;void *, may&#160;<br/>be converted, by a cast, by assignment, or by comparison, to a pointer of any type. This&#160;<br/>produces a null pointer that is equal to another null pointer of the same type, but unequal to&#160;<br/>any pointer to a function or object. &#160;<br/>
Certain other conversions involving pointers are permitted, but have implementation-defined&#160;<br/>aspects. They must be specified by an explicit type-conversion operator, or cast (Pars.<a href="cs.html#181">A.7.5&#160;<br/></a>and&#160;<a href="cs.html#198">A.8.8). &#160;</a><br/>
A pointer may be converted to an integral&#160;type large enough to hold it; the required size is&#160;<br/>implementation-dependent. The mapping function is also implementation-dependent. &#160;<br/>
A pointer to one type may be converted to a pointer to another type. The resulting pointer may&#160;<br/>cause addressing exceptions if the subject pointer&#160;does not refer to an object suitably aligned&#160;<br/>in storage. It is guaranteed that a pointer to&#160;an object may be converted&#160;to a pointer to an&#160;<br/>object whose type requires less or equally strict storage alignment and back again without&#160;<br/>change; the notion of ``alignment'' is implementation-dependent, but objects of the&#160;char&#160;types&#160;<br/>have least strict alignment requirements. As described in&#160;<a href="cs.html#176">Par.A.6.8</a>, a pointer may also be&#160;<br/>converted to type&#160;void *&#160;and back again without change. &#160;<br/>
A pointer may be converted to another pointer whose type is the same except for the addition&#160;<br/>or rem<a href="cs.html#173">oval of qualifiers (Pars.A.4.4</a>,&#160;<a href="cs.html#188">A.8.2) of the object type to which the pointer refers. If&#160;<br/></a>qualifiers are added, the new pointer is equivalent to the old except for restrictions implied by&#160;<br/>the new qualifiers. If qualifiers are removed, operations on the underlying object remain&#160;<br/>subject to the qualifiers in its actual declaration. &#160;<br/>
<hr/>
<a name=176></a>&#160;&#160;<br/>
176&#160;<br/>
Finally, a pointer to a function may be converted&#160;to a pointer to another function type. Calling&#160;<br/>the function specified by the converted pointer&#160;is implementation-dependent; however, if the&#160;<br/>converted pointer is reconverted to its original&#160;type, the result is identical to the original&#160;<br/>pointer. &#160;<br/>
<b>A.6.7 Void&#160;</b><br/>
The (nonexistent) value of a&#160;void&#160;object may not be used in any way, and neither explicit nor&#160;<br/>implicit conversion to any non-void type may be&#160;applied. Because a void expression denotes a&#160;<br/>nonexistent value, such an expression may be used only where the value is not required, for&#160;<br/>example as an expression statement (Par.A.9.2) or as the left operand of a comma operator&#160;<br/>(Par.A.7.18). &#160;<br/>
An expression may be converted to type&#160;void&#160;by a cast. For example, a void cast documents&#160;<br/>the discarding of the value of a function call used as an expression statement. &#160;<br/>
void&#160;did not&#160;appear in&#160;the first&#160;edition of this&#160;book, but&#160;has become&#160;common since.&#160;&#160;<br/>
<b>A.6.8 Pointers to Void&#160;</b><br/>
Any pointer to an object may be converted to type&#160;void *&#160;without loss of information. If the&#160;<br/>result is converted back to the original pointer&#160;type, the original pointer is recovered. Unlike&#160;<br/><a href="cs.html#175">the pointer-to-pointer conversions discussed in&#160;Par.A.6.6, which generally require an explicit&#160;<br/></a>cast, pointers may be assigned to and from&#160;pointers of type&#160;void *, and may be compared&#160;<br/>with them. &#160;<br/>
This interpretation&#160;of&#160;void *&#160;pointers is&#160;new;&#160;previously,&#160;char *&#160;pointers played the role&#160;of&#160;generic&#160;<br/>pointer.&#160;The ANSI standard specifically blesses the meeting of&#160;void *&#160;pointers with&#160;object&#160;pointers in&#160;<br/>assignments&#160;and relationals, while&#160;requiring explicit&#160;casts&#160;for other pointer mixtures.&#160;&#160;<br/>
<b>A.7 Expressions&#160;</b><br/>
The precedence of expression operators is the same&#160;as the order of the major subsections of&#160;<br/>this section, highest precedence first. Thus, for example, the expressions referred to as the&#160;<br/>operands of&#160;+&#160;&#160;(<a href="cs.html#182">Par.A.7.7</a><a href="cs.html#177">) are those expressions defined in Pars.A.7.1-</a><a href="cs.html#181">A.7.6. W</a>ithin each&#160;<br/>subsection, the operators have the same precedence.&#160;Left- or right-associativity is specified in&#160;<br/>each subsection for the operators discussed therein. The gramm<a href="cs.html#212">ar given in&#160;Par.13&#160;incorporates&#160;<br/></a>the precedence and associativity of the operators. &#160;<br/>
The precedence and associativity of operators is&#160;fully specified, but the order of evaluation of&#160;<br/>expressions is, with certain exceptions, undefined, even if the subexpressions involve side&#160;<br/>effects. That is, unless the definition of the operator guarantees that its operands are evaluated&#160;<br/>in a particular order, the implementation is free to evaluate operands in any order, or even to&#160;<br/>interleave their evaluation. However, each operator combines the values produced by its&#160;<br/>operands in a way compatible with the parsing of the expression in which it appears. &#160;<br/>
This&#160;rule&#160;revokes the previous freedom&#160;to&#160;reorder expressions&#160;with&#160;operators that&#160;are mathematically&#160;<br/>commutative and associative, but can&#160;fail to&#160;be&#160;computationally associative. The change affects only&#160;<br/>floating-point computations near the limits of their accuracy, and situations where overflow is possible.&#160;&#160;<br/>
The handling of overflow, divide check, and other exceptions in expression evaluation is not&#160;<br/>defined by the language. Most existing implementations of C ignore overflow in evaluation of&#160;<br/>signed integral expressions and assignments, but&#160;this behavior is not guaranteed. Treatment of&#160;<br/>
<hr/>
<a name=177></a>&#160;&#160;<br/>
177&#160;<br/>
division by 0, and all floating-point exceptions, varies among implementations; sometimes it&#160;<br/>is adjustable by a non-standard library function. &#160;<br/>
<b>A.7.1 Pointer Conversion&#160;</b><br/>
If the type of an expression or subexpression is ``array of&#160;<i>T</i>,'' for&#160;some&#160;type&#160;<i>T</i>, then the value&#160;<br/>of the expression is a pointer to the first object&#160;in the array, and the type of the expression is&#160;<br/>altered to ``pointer to&#160;<i>T</i>.''&#160;This conversion does not take place if the expression is in the&#160;<br/>operand of the unary&#160;&amp;&#160;operator, or of&#160;++,&#160;--,&#160;sizeof, or as the left operand of an assignment&#160;<br/>operator or the&#160;.&#160;operator. Similarly, an expression of type ``function returning&#160;<i>T</i>,''&#160;except&#160;<br/>when used as the operand of the&#160;&amp;&#160;operator, is converted to ``pointer to function returning&#160;<i>T</i>.'' &#160;<br/>
<b>A.7.2 Primary Expressions&#160;</b><br/>
Primary expressions are identifiers, constants, strings, or expressions in parentheses. &#160;<br/>
<i>&#160; &#160; primary-expression&#160;<br/>&#160; &#160; &#160; identifier&#160;<br/>&#160; &#160; &#160; constant&#160;<br/>&#160; &#160; &#160; string&#160;<br/>&#160; &#160; &#160; (expression)&#160;</i>&#160;<br/>
An identifier is a primary expression, provided it has been suitably declared as discussed&#160;<br/>below. Its type is specified by its declaration. An&#160;identifier is an lvalue if&#160;it refers to an object&#160;<br/><a href="cs.html#173">(Par.A.5</a>) and if its type is arithmetic, structure, union, or pointer. &#160;<br/>
A constant is a primary expression. Its type depends on its form&#160;as discussed in&#160;<a href="cs.html#169">Par.A.2.5</a>. &#160;<br/>
A string literal is a primary expression.&#160;Its type is originally ``array of&#160;char'' (for wide-char&#160;<br/>strings, ``array of&#160;wchar_t<a href="cs.html#177">''), but following the rule given in&#160;Par.A.7.1</a>, this is usually&#160;<br/>modified to ``pointer to&#160;char'' (wchar_t) and the result is a pointer to the first character in the&#160;<br/><a href="cs.html#196">string. The conversion also does not occur in certain initializers; see&#160;Par.A.8.7. &#160;</a><br/>
A parenthesized expression is a primary expression whose type and value are identical to&#160;<br/>those of the unadorned expression. The precedence&#160;of parentheses does not affect whether the&#160;<br/>expression is an lvalue. &#160;<br/>
<b>A.7.3 Postfix Expressions&#160;</b><br/>
The operators in postfix expressions group left to right. &#160;<br/>
<i>&#160; &#160; postfix-expression:&#160;<br/>&#160; &#160; &#160; primary-expression&#160;<br/>&#160; &#160; &#160; postfix-expression[expression]&#160;<br/>&#160; &#160; &#160; postfix-expression(argument-expression-listopt)&#160;<br/>&#160; &#160; &#160; postfix-expression.identifier&#160;<br/>&#160; &#160; &#160; postfix-expression-&gt;identifier&#160;<br/>&#160; &#160; &#160; postfix-expression++&#160;<br/>&#160; &#160; &#160; postfix-expression--&#160;&#160;</i><br/>
<hr/>
<a name=178></a>&#160;&#160;<br/>
178&#160;<br/>
<i>&#160; &#160; argument-expression-list:&#160;<br/>&#160; &#160; &#160; assignment-expression&#160;<br/>&#160; &#160; &#160; assignment-expression-list&#160;,&#160;assignment-expression&#160;</i>&#160;<br/>
<b>A.7.3.1 Array References&#160;</b><br/>
A postfix expression followed by an expression&#160;in square brackets is a postfix expression&#160;<br/>denoting a subscripted array reference. One of the two expressions must have type ``pointer to&#160;<br/><i>T</i>'',&#160;where&#160;<i>T</i>&#160;is some type, and the other must have integral type; the type of the subscript&#160;<br/>expression is&#160;<i>T</i>. The expression&#160;E1[E2]&#160;is identical (by definition) to&#160;*((E1)+(E2)). See&#160;<br/><a href="cs.html#194">Par.A.8.6.2</a>&#160;for further discussion. &#160;<br/>
<b>A.7.3.2 Function Calls&#160;</b><br/>
A function call is a postfix expression, called&#160;the function designator, followed by parentheses&#160;<br/>containing a possibly empty, comma-separated list of assignm<a href="cs.html#185">ent expressions (Par.A7.17</a>),&#160;<br/>which constitute the arguments to the function. If&#160;the postfix expression consists of&#160;an&#160;<br/>identifier for which no declaration exists in&#160;the current scope, the identifier is implicitly&#160;<br/>declared as if the declaration &#160;<br/>
&#160; &#160;&#160;extern int&#160;<i>identifier</i>();&#160;&#160;<br/>
had been given in the innermost block containing the function call. The postfix expression&#160;<br/><a href="cs.html#177">(after possible explicit declaration and pointer generation,&#160;Par.A7.1</a>) must be of type ``pointer&#160;<br/>to function returning&#160;<i>T</i>,'' for&#160;some&#160;type&#160;<i>T</i>, and the value of the function call has type&#160;<i>T</i>. &#160;<br/>
In&#160;the first edition,&#160;the type was restricted&#160;to&#160;``function,'' and&#160;an&#160;explicit&#160;*&#160;operator was required to call&#160;<br/>through pointers to&#160;functions. The ANSI standard blesses the practice&#160;of&#160;some&#160;existing&#160;compilers&#160;by&#160;<br/>permitting&#160;the same syntax&#160;for calls to&#160;functions&#160;and&#160;to&#160;functions&#160;specified&#160;by&#160;pointers. The&#160;older&#160;<br/>syntax&#160;is still usable.&#160;&#160;<br/>
The term&#160;<i>argument</i>&#160;is used for an expression passed by a function call; the term&#160;<i>parameter</i>&#160;is&#160;<br/>used for an input object (or its&#160;identifier) received by a function definition, or described in a&#160;<br/>function declaration. The terms ``actual argument (parameter)''&#160;and ``formal argument&#160;<br/>(parameter)''&#160;respectively are sometimes used for the same distinction. &#160;<br/>
In preparing for the call to a function, a copy is made of each argument; all argument-passing&#160;<br/>is strictly by value. A function may change the values of its parameter objects, which are&#160;<br/>copies of the argument expressions, but these changes cannot affect the values of the&#160;<br/>arguments. However, it is possible to pass a&#160;pointer on the understanding that the function&#160;<br/>may change the value of the object to which the pointer points. &#160;<br/>
There are two styles in which functions may be&#160;declared. In the new style, the types of&#160;<br/>parameters are explicit and are part of the type&#160;of the function; such a declaration os also&#160;<br/>called a function prototype. In the old style,&#160;parameter types are not specified. Function&#160;<br/>declaration is issued in&#160;<a href="cs.html#194">Pars.A.8.6.3&#160;and&#160;</a><a href="cs.html#203">A.10.1. &#160;</a><br/>
If the function declaration in scope for a call is old-style, then default argument promotion is&#160;<br/>applied to each argument as follows: integral promotion (<a href="cs.html#174">Par.A.6.1) is perform</a>ed on each&#160;<br/>argument of integral type, and each&#160;float&#160;argument is converted to&#160;double. The effect of the&#160;<br/>call is undefined if the number of arguments disagrees with the number of parameters in the&#160;<br/>definition of the function, or if the type of an&#160;argument after promotion&#160;disagrees with that of&#160;<br/>the corresponding parameter. Type agreement depends on whether the function's definition is&#160;<br/>
<hr/>
<a name=179></a>&#160;&#160;<br/>
179&#160;<br/>
new-style or old-style. If it is old-style, then&#160;the comparison is between the promoted type of&#160;<br/>the arguments of the call, and the promoted type&#160;of&#160;the parameter, if&#160;the definition is new-<br/>style, the promoted type of the argument must&#160;be that of the parameter itself, without&#160;<br/>promotion. &#160;<br/>
If the function declaration in scope for a call is&#160;new-style, then the arguments are converted,&#160;<br/>as if by assignment, to the types of the corresponding parameters of the function's prototype.&#160;<br/>The number of&#160;arguments must be the same as&#160;the number of&#160;explicitly described parameters,&#160;<br/>unless the declaration's parameter list ends with the ellipsis notation&#160;(, ...). In that case, the&#160;<br/>number of arguments must equal or exceed the number of parameters; trailing arguments&#160;<br/>beyond the explicitly typed parameters suffer default argument promotion as described in the&#160;<br/>preceding paragraph. If the definition of the function is old-style, then the type of each&#160;<br/>parameter in the definition, after the definition parameter's type has undergone argument&#160;<br/>promotion. &#160;<br/>
These rules are especially complicated because they must cater to&#160;a mixture of old- and&#160;new-style&#160;<br/>functions. Mixtures are to&#160;be avoided if&#160;possible.&#160;&#160;<br/>
The order of evaluation of arguments is unspecified; take note that various compilers differ.&#160;<br/>However, the arguments and the function designator are completely evaluated, including all&#160;<br/>side effects, before the function is entered. Recursive calls to any function are permitted. &#160;<br/>
<b>A.7.3.3 Structure References&#160;</b><br/>
A postfix expression followed by a dot followed by&#160;an identifier is a postfix expression. The&#160;<br/>first operand expression must be a structure or a union, and the identifier must name a&#160;<br/>member of the structure or union. The value is the named member of the structure or union,&#160;<br/>and its type is the type of the member. The expression is an lvalue if the first expression is an&#160;<br/>lvalue, and if the type of the second expression is not an array type. &#160;<br/>
A postfix expression followed by an arrow (built from&#160;-&#160;and&#160;&gt;) followed by an identifier is a&#160;<br/>postfix expression. The first operand expression must be a pointer to a structure or union, and&#160;<br/>the identifier must name a member of&#160;the structure or union. The result refers to the named&#160;<br/>member of the structure or union to which the&#160;pointer expression points, and the type is the&#160;<br/>type of&#160;the member; the result is an lvalue if&#160;the type is not an array type. &#160;<br/>
Thus the expression&#160;E1-&gt;MOS&#160;is the same as&#160;(*E1).MOS. Structures and unions are discussed&#160;<br/>in&#160;<a href="cs.html#188">Par.A.8.3</a>. &#160;<br/>
In&#160;the first&#160;edition of this&#160;book, it&#160;was already&#160;the rule&#160;that&#160;a member name&#160;in&#160;such an expression had to&#160;<br/>belong to the structure or union mentioned in the postfix expression;&#160;however, a note admitted that this&#160;<br/>rule was not firmly enforced. Recent compilers, and ANSI, do enforce it.&#160;&#160;<br/>
<b>A.7.3.4 Postfix Incrementation&#160;</b><br/>
A postfix expression followed by a&#160;++&#160;or&#160;--&#160;operator is a postfix expression. The value of the&#160;<br/>expression is the value of the operand. After&#160;the value is noted, the operand is incremented&#160;++&#160;<br/>or decremented&#160;--&#160;by 1. The operand must be an lvalue; see the discussion of&#160;additive&#160;<br/><a href="cs.html#182">operators (Par.A.7.7) and assignm</a><a href="cs.html#185">ent (Par.A.7.17) for further constraints on the operand and&#160;<br/></a>details of&#160;the operation. The result is not an lvalue. &#160;<br/>
<b>A.7.4 Unary Operators&#160;</b><br/>
<hr/>
<a name=180></a>&#160;&#160;<br/>
180&#160;<br/>
Expressions with unary operators group right-to-left. &#160;<br/>
&#160; &#160;&#160;<i>unary-expression</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>postfix expression</i>&#160;<br/>&#160; &#160; &#160;&#160;++<i>unary expression</i>&#160;<br/>&#160; &#160; &#160;&#160;--<i>unary expression</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>unary-operator cast-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;sizeof&#160;<i>unary-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;sizeof(<i>type-name</i>) &#160;<br/>
&#160; &#160;&#160;<i>unary operator:</i>&#160;one of&#160;<br/>&#160; &#160; &#160;&#160;&amp; * + - ~ !&#160;&#160;<br/>
<b>A.7.4.1 Prefix Incrementation Operators&#160;</b><br/>
A unary expression followed by a&#160;++&#160;or&#160;--&#160;operator is a unary expression. The operand is&#160;<br/>incremented&#160;&#160;++&#160;or decremented&#160;--&#160;by 1. The value of the expression is the value after the&#160;<br/>incrementation (decrementation). The operand must be an lvalue; see the discussion of&#160;<br/>additive operators (<a href="cs.html#182">Par.A.7.7</a>) and assignm<a href="cs.html#185">ent (Par.A.7.17) for further constraints on the&#160;<br/></a>operands and details of the operation. The result is not an lvalue. &#160;<br/>
<b>A.7.4.2 Address Operator&#160;</b><br/>
The unary operator&#160;&amp;&#160;takes the address of its operand. The operand must be an lvalue referring&#160;<br/>neither to a bit-field nor to an object declared as&#160;register, or must be of function type. The&#160;<br/>result is a pointer to the object or function referred to by the lvalue. If&#160;the type of the operand&#160;<br/>is&#160;<i>T</i>, the type of&#160;the result is ``pointer to&#160;<i>T</i>.'' &#160;<br/>
<b>A.7.4.3 Indirection Operator&#160;</b><br/>
The unary&#160;*&#160;operator denotes indirection, and returns the object or function to which its&#160;<br/>operand points. It is an lvalue if the operand is&#160;a pointer to an object of arithmetic, structure,&#160;<br/>union, or pointer type. If the type&#160;of the expression is ``pointer to&#160;<i>T</i>,''&#160;the type of&#160;the result is&#160;<br/><i>T</i>. &#160;<br/>
<b>A.7.4.4 Unary Plus Operator&#160;</b><br/>
The operand of the unary&#160;+&#160;operator must have arithmetic type, and the result is the value of&#160;<br/>the operand. An integral operand undergoes integral&#160;promotion. The type of the result is the&#160;<br/>type of the promoted operand. &#160;<br/>
The unary&#160;+&#160;is new with&#160;the ANSI standard. It was added&#160;for symmetry with&#160;the unary&#160;-.&#160;&#160;<br/>
<b>A.7.4.5 Unary Minus Operator&#160;</b><br/>
The operand of the unary&#160;-&#160;operator must have arithmetic type, and the result is the negative&#160;<br/>of its operand. An integral operand undergoes&#160;integral promotion. The negative of an&#160;<br/>unsigned quantity is computed by subtracting the&#160;promoted value from&#160;the largest value of&#160;the&#160;<br/>promoted type and adding one; but negative zero is&#160;zero. The type of the&#160;result is the type of&#160;<br/>the promoted operand. &#160;<br/>
<b>A.7.4.6 One's Complement Operator&#160;</b><br/>
<hr/>
<a name=181></a>181<br/>
The operand of the&#160;~&#160;operator must have integral type, and the result is the one's complement&#160;<br/>of its operand. The integral promotions are performed. If the operand is unsigned, the result is&#160;<br/>computed by subtracting the value from&#160;the largest value of the promoted type. If the operand&#160;<br/>is signed, the result is computed by converting the promoted operand to the corresponding&#160;<br/>unsigned type, applying&#160;~, and converting back to the signed type. The type of the result is the&#160;<br/>type of the promoted operand. &#160;<br/>
<b>A.7.4.7 Logical Negation Operator&#160;</b><br/>
The operand of the&#160;!&#160;operator must have arithmetic type or be a pointer, and the result is 1 if&#160;<br/>the value of its operand compares equal to 0, and 0 otherwise. The type of the result is&#160;int. &#160;<br/>
<b>A.7.4.8 Sizeof Operator&#160;</b><br/>
The&#160;sizeof&#160;operator yields the number of bytes required to store an object of the type of its&#160;<br/>operand. The operand is either an expression, which is not evaluated, or a parenthesized type&#160;<br/>name. When&#160;sizeof&#160;is applied to a&#160;char, the result is 1; when applied to an array, the result is&#160;<br/>the total number of&#160;bytes in the array. When applied to a structure or union, the result is the&#160;<br/>number of&#160;bytes in the object, including any padding required to make the object tile an array:&#160;<br/>the size of an array of&#160;<i>n</i>&#160;elements is&#160;<i>n</i>&#160;times the size of one element. The operator may not be&#160;<br/>applied to an operand of function type, or of incomplete type, or to a bit-field. The result is an&#160;<br/>unsigned integral constant; the particular type&#160;is implementation-defined. The standard header&#160;<br/>&lt;stddef.h&gt;<a href="">&#160;(See&#160;appendix B) defines this type as&#160;</a>size_t. &#160;<br/>
<b>A.7.5 Casts&#160;</b><br/>
A unary expression preceded by the parenthesized&#160;name&#160;of a type causes conversion of the&#160;<br/>value of the expression to the named type. &#160;<br/>
<i>&#160; &#160; cast-expression:&#160;<br/>&#160; &#160; &#160; unary expression&#160;<br/>&#160; &#160; &#160; (type-name)&#160;cast-expression&#160;</i><br/>
This construction is called a&#160;<i>cast</i>. The nam<a href="cs.html#198">es are described in&#160;Par.A.8.8. The effects of&#160;<br/></a>conversions are described in&#160;<a href="cs.html#173">Par.A.6. An expression with a cast is not an lvalue. &#160;</a><br/>
<b>A.7.6 Multiplicative Operators&#160;</b><br/>
The multiplicative operators&#160;*,&#160;/, and&#160;%&#160;group left-to-right. &#160;<br/>
&#160; &#160;&#160;<i>multiplicative-expression</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>multiplicative-expression</i>&#160;*&#160;<i>cast-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>multiplicative-expression</i>&#160;/&#160;<i>cast-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>multiplicative-expression</i>&#160;%&#160;<i>cast-expression</i>&#160;&#160;<br/>
The operands of&#160;*&#160;and&#160;/&#160;must have arithmetic type; the operands of&#160;%&#160;must have integral type.&#160;<br/>The usual arithmetic conversions are performed&#160;on the operands, and predict the type of the&#160;<br/>result. &#160;<br/>
The binary&#160;*&#160;operator denotes multiplication. &#160;<br/>
<hr/>
<a name=182></a>&#160;&#160;<br/>
182&#160;<br/>
The binary&#160;/&#160;operator yields the quotient, and the&#160;%&#160;operator the remainder, of the division of&#160;<br/>the first operand by the second; if the second operand is 0, the result is undefined. Otherwise,&#160;<br/>it is always true that&#160;(a/b)*b + a%b&#160;is equal to&#160;a. If both operands are non-negative, then the&#160;<br/>remainder is non-negative and smaller than the divisor, if not, it is guaranteed only that the&#160;<br/>absolute value of&#160;the remainder is smaller than the absolute value of&#160;the divisor. &#160;<br/>
<b>A.7.7 Additive Operators&#160;</b><br/>
The additive operators&#160;+&#160;and&#160;-&#160;group left-to-right. If the operands have arithmetic type, the&#160;<br/>usual arithmetic conversions are performed. There are some additional type possibilities for&#160;<br/>each operator. &#160;<br/>
&#160; &#160;&#160;<i>additive-expression</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>multiplicative-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>additive-expression</i>&#160;+&#160;<i>multiplicative-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>additive-expression</i>&#160;-&#160;<i>multiplicative-expression</i>&#160;&#160;<br/>
The result of&#160;the&#160;+&#160;operator is the sum&#160;of the operands. A pointer to an object in an array and a&#160;<br/>value of any integral type may be added. The latter is converted to an address offset by&#160;<br/>multiplying it by the size of&#160;the object to which the pointer points. The sum&#160;is a pointer of&#160;the&#160;<br/>same type as the original pointer, and points to&#160;another object in the same array, appropriately&#160;<br/>offset from&#160;the original object. Thus if&#160;P&#160;is a pointer to an object in an array, the expression&#160;<br/>P+1&#160;is a pointer to the next object in the array.&#160;If the sum&#160;pointer points outside the bounds of&#160;<br/>the array, except at the first location beyond the high end, the result is undefined. &#160;<br/>
The provision for pointers just beyond the end of an array is new. It legitimizes a&#160;common&#160;idiom&#160;for&#160;<br/>looping over the elements&#160;of an array.&#160;&#160;<br/>
The result of&#160;the&#160;-&#160;operator is the difference of the operands. A value of any integral type may&#160;<br/>be subtracted from&#160;a pointer, and then the same conversions and conditions as for addition&#160;<br/>apply. &#160;<br/>
If two pointers to objects of the same type are subtracted, the result is a signed integral value&#160;<br/>representing the displacement between the pointed-to objects; pointers to successive objects&#160;<br/>differ by 1. The type of&#160;the result is defined as&#160;ptrdiff_t&#160;in the standard header&#160;<br/>&lt;stddef.h&gt;. The value is undefined unless the pointers point to objects within the same&#160;<br/>array; however, if&#160;P&#160;points to the last member of an array, then&#160;(P+1)-P&#160;has value 1. &#160;<br/>
<b>A.7.8 Shift Operators&#160;</b><br/>
The shift operators&#160;&lt;&lt;&#160;and&#160;&gt;&gt;&#160;group left-to-right. For both operators, each operand must be&#160;<br/>integral, and is subject to integral the promotions. The type of&#160;the result is that of&#160;the&#160;<br/>promoted left operand. The result is undefined if&#160;the right operand is negative, or greater than&#160;<br/>or equal to the number of bits in the left expression's type. &#160;<br/>
&#160; &#160;&#160;<i>shift-expression</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>additive-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>shift-expression</i>&#160;&lt;&lt;&#160;<i>additive-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>shift-expression</i>&#160;&gt;&gt;&#160;<i>additive-expression</i>&#160;&#160;<br/>
The value of&#160;E1&lt;&lt;E2&#160;is&#160;E1&#160;(interpreted as a bit pattern) left-shifted&#160;E2&#160;bits; in the absence of&#160;<br/>overflow, this is equivalent to multiplication by 2E2. The value of&#160;E1&gt;&gt;E2&#160;is&#160;E1&#160;right-shifted&#160;<br/>
<hr/>
<a name=183></a>&#160;&#160;<br/>
183&#160;<br/>
E2&#160;bit positions. The right shift is equivalent to division by 2E2&#160;if&#160;E1&#160;is unsigned or it has a&#160;<br/>non-negative value; otherwise the result is implementation-defined. &#160;<br/>
<b>A.7.9 Relational Operators&#160;</b><br/>
The relational operators group left-to-right, but this fact is not useful;&#160;a&lt;b&lt;c&#160;is parsed as&#160;<br/>(a&lt;b)&lt;c, and evaluates to either 0 or 1. &#160;<br/>
&#160; &#160;&#160;<i>relational-expression</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>shift-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>relational-expression</i>&#160;&lt;&#160;<i>shift-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>relational-expression</i>&#160;&gt;&#160;<i>shift-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>relational-expression</i>&#160;&lt;=&#160;<i>shift-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>relational-expression</i>&#160;&gt;=&#160;<i>shift-expression</i>&#160;&#160;<br/>
The operators&#160;&lt;&#160;(less),&#160;&gt;&#160;(greater),&#160;&lt;=&#160;(less or equal) and&#160;&gt;=&#160;(greater or equal) all yield 0 if the&#160;<br/>specified relation is false and 1 if&#160;it is true. The type of&#160;the result is&#160;int. The usual arithmetic&#160;<br/>conversions are performed on arithmetic operands. Pointers to objects of the same type&#160;<br/>(ignoring any qualifiers) may be compared; the result depends on the relative locations in the&#160;<br/>address space of the pointed-to objects. Pointer&#160;comparison is defined only for parts of the&#160;<br/>same object; if&#160;two pointers point to the same simple object, they compare equal; if&#160;the&#160;<br/>pointers are to members of the same structure, pointers to objects declared later in the&#160;<br/>structure compare higher; if the pointers refer&#160;to members of an array, the comparison is&#160;<br/>equivalent to comparison of the the corresponding subscripts. If&#160;P&#160;points to the last member of&#160;<br/>an array, then&#160;P+1&#160;compares higher than&#160;P, even though&#160;P+1&#160;points outside the array.&#160;<br/>Otherwise, pointer comparison is undefined. &#160;<br/>
These rules slightly liberalize the restrictions&#160;stated&#160;in&#160;the&#160;first&#160;edition,&#160;by&#160;permitting&#160;comparison&#160;of&#160;<br/>pointers to&#160;different&#160;members of a structure or union. They&#160;also&#160;legalize&#160;comparison&#160;with&#160;a&#160;pointer&#160;just&#160;<br/>off the end of an array.&#160;&#160;<br/>
<b>A.7.10 Equality Operators&#160;</b><br/>
&#160; &#160;&#160;<i>equality-expression</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>relational-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>equality-expression</i>&#160;==&#160;<i>relational-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>equality-expression</i>&#160;!=&#160;<i>relational-expression</i>&#160;&#160;<br/>
The&#160;==&#160;(equal to) and the&#160;!=&#160;(not equal to) operators are analogous to the relational operators&#160;<br/>except for their lower precedence. (Thus&#160;a&lt;b == c&lt;d&#160;is 1 whenever&#160;a&lt;b&#160;and&#160;c&lt;d&#160;have the&#160;<br/>same truth-value.) &#160;<br/>
The equality operators follow the same rules as the relational operators, but permit additional&#160;<br/>possibilities: a pointer may be compared to a constant integral expression with value 0, or to a&#160;<br/>pointer to&#160;void<a href="cs.html#175">. See&#160;Par.A.6.6. &#160;</a><br/>
<b>A.7.11 Bitwise AND Operator&#160;</b><br/>
&#160; &#160;&#160;<i>AND-expression</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>equality-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>AND-expression</i>&#160;&amp;&#160;<i>equality-expression</i>&#160;&#160;<br/>
<hr/>
<a name=184></a>&#160;&#160;<br/>
184&#160;<br/>
The usual arithmetic conversions are performed;&#160;the result is the bitwise AND function of the&#160;<br/>operands. The operator applies only to integral operands. &#160;<br/>
<b>A.7.12 Bitwise Exclusive OR Operator&#160;</b><br/>
&#160; &#160;&#160;<i>exclusive-OR-expression</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>AND-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>exclusive-OR-expression</i>&#160;^&#160;<i>AND-expression</i>&#160;&#160;<br/>
The usual arithmetic conversions are performed; the result is the bitwise exclusive OR&#160;<br/>function of the operands. The operator applies only to integral operands. &#160;<br/>
<b>A.7.13 Bitwise Inclusive OR Operator&#160;</b><br/>
&#160; &#160;&#160;<i>inclusive-OR-expression</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>exclusive-OR-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>inclusive-OR-expression</i>&#160;|&#160;<i>exclusive-OR-expression</i>&#160;&#160;<br/>
The usual arithmetic conversions are performed; the result is the bitwise inclusive OR&#160;<br/>function of the operands. The operator applies only to integral operands. &#160;<br/>
<b>A.7.14 Logical AND Operator&#160;</b><br/>
&#160; &#160;&#160;<i>logical-AND-expression</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>inclusive-OR-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>logical-AND-expression</i>&#160;&amp;&amp;&#160;<i>inclusive-OR-expression</i>&#160;&#160;<br/>
The&#160;&amp;&amp;&#160;operator groups left-to-right. It returns 1&#160;if both its operands compare unequal to zero,&#160;<br/>0 otherwise. Unlike&#160;&amp;,&#160;&#160;&amp;&amp;&#160;guarantees left-to-right evaluation:&#160;the first operand is evaluated,&#160;<br/>including all side effects; if&#160;it is equal to 0,&#160;the value of the expression is 0. Otherwise, the&#160;<br/>right operand is evaluated, and if it is equal to&#160;0, the expression's value is 0, otherwise 1. &#160;<br/>
The operands need not have the same type, but each&#160;must have arithmetic type or be a pointer.&#160;<br/>The result is&#160;int. &#160;<br/>
<b>A.7.15 Logical OR Operator&#160;</b><br/>
&#160; &#160;&#160;<i>logical-OR-expression</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>logical-AND-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>logical-OR-expression</i>&#160;||&#160;<i>logical-AND-expression</i>&#160;&#160;<br/>
The&#160;||&#160;operator groups left-to-right. It returns 1 if either of its operands compare unequal to&#160;<br/>zero, and 0 otherwise. Unlike&#160;|,&#160;&#160;||&#160;guarantees left-to-right evaluation: the first operand is&#160;<br/>evaluated, including all side effects; if&#160;it is&#160;unequal to 0, the value of the expression is 1.&#160;<br/>Otherwise, the right operand is evaluated, and if&#160;it is unequal to 0, the expression's value is 1,&#160;<br/>otherwise 0. &#160;<br/>
The operands need not have the same type, but each&#160;must have arithmetic type or be a pointer.&#160;<br/>The result is&#160;int. &#160;<br/>
<b>A.7.16 Conditional Operator&#160;</b><br/>
<hr/>
<a name=185></a>&#160;&#160;<br/>
185&#160;<br/>
&#160; &#160;&#160;<i>conditional-expression</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>logical-OR-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>logical-OR-expression</i>&#160;?&#160;<i>expression</i>&#160;:&#160;<i>conditional-expression</i>&#160;&#160;<br/>
The first expression is evaluated, including all side effects; if it compares unequal to 0, the&#160;<br/>result is the value of the second expression, otherwise that of the third expression. Only one of&#160;<br/>the second and third operands is evaluated. If the second and third operands are arithmetic,&#160;<br/>the usual arithmetic conversions are performed to bring them&#160;to a common type, and that type&#160;<br/>is the type of&#160;the result. If&#160;both are&#160;void, or structures or unions of the same type, or pointers&#160;<br/>to objects of&#160;the same type, the result has the&#160;common type. If one is a pointer and the other&#160;<br/>the constant 0, the 0 is converted to the pointer&#160;type, and the result has that type. If one is a&#160;<br/>pointer to&#160;void&#160;and the other is another pointer, the other pointer is converted to a pointer to&#160;<br/>void, and that is the type of&#160;the result. &#160;<br/>
In the type comp<a href="cs.html#188">arison for pointers, any type qualifiers (Par.A.8.2) in the type to which the&#160;<br/></a>pointer points are insignificant, but the result type inherits qualifiers from&#160;both arms of the&#160;<br/>conditional. &#160;<br/>
<b>A.7.17 Assignment Expressions&#160;</b><br/>
There are several assignment operators; all group right-to-left. &#160;<br/>
&#160; &#160;&#160;<i>assignment-expression</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>conditional-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>unary-expression assignment-operator assignment-expression</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>assignment-operator</i>: one of&#160;<br/>&#160; &#160; &#160;&#160;= *= /= %= += -= &lt;&lt;= &gt;&gt;= &amp;= ^= |=&#160;&#160;<br/>
All require an lvalue as left operand, and the&#160;lvalue must be modifiable: it must not be an&#160;<br/>array, and must not have an incomplete type,&#160;or be a function. Also,&#160;its type must not be&#160;<br/>qualified with&#160;const; if it is a structure or union, it must not have any member or, recursively,&#160;<br/>submember qualified with&#160;const. The type of an assignment expression is that of&#160;its left&#160;<br/>operand, and the value is the value stored in&#160;the left operand after the assignment has taken&#160;<br/>place. &#160;<br/>
In the simple assignment with&#160;=, the value of the expression replaces that of the object&#160;<br/>referred to by the lvalue. One of the following&#160;must be true: both operands have arithmetic&#160;<br/>type, in which case the right operand is converted&#160;to the type of the left by the assignment; or&#160;<br/>both operands are structures or unions of the same type; or one operand is a pointer and the&#160;<br/>other is a pointer to&#160;void, or the left operand is a pointer&#160;and the right operand is a constant&#160;<br/>expression with value 0; or both operands are pointers to functions or objects whose types are&#160;<br/>the same except for the possible absence of&#160;const&#160;or&#160;volatile&#160;in the right operand. &#160;<br/>
An expression of the form&#160;E1&#160;<i>op</i>= E2&#160;is equivalent to&#160;E1 = E1&#160;<i>op</i>&#160;(E2)&#160;except that&#160;E1&#160;is&#160;<br/>evaluated only once. &#160;<br/>
<b>A.7.18 Comma Operator&#160;</b><br/>
&#160; &#160;&#160;<i>expression</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>assignment-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>expression</i>&#160;,&#160;<i>assignment-expression</i>&#160;&#160;<br/>
<hr/>
<a name=186></a>&#160;&#160;<br/>
186&#160;<br/>
A pair of expressions separated by a comma is evaluated left-to-right, and the value of the left&#160;<br/>expression is discarded. The type and value of&#160;the result are the type and value of the right&#160;<br/>operand. All side effects from&#160;the evaluation of the left-operand are completed before&#160;<br/>beginning the evaluation of the right operand. In&#160;contexts where comma is given a special&#160;<br/>meaning, for example in lists of function argum<a href="cs.html#178">ents (Par.A.7.3.2</a>) and lists of&#160;initializers&#160;<br/><a href="cs.html#196">(Par.A.8.7), the required syntactic unit is an assi</a>gnment expression, so the comma operator&#160;<br/>appears only in a parenthetical grouping, for example, &#160;<br/>
&#160;<br/>&#160; &#160;f(a, (t=3, t+2), c)&#160;<br/>
has three arguments, the second of which has the value 5. &#160;<br/>
<b>A.7.19 Constant Expressions&#160;</b><br/>
Syntactically, a constant expression is an expression restricted to a subset of operators: &#160;<br/>
&#160; &#160;&#160;<i>constant-expression</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>conditional-expression</i>&#160;&#160;<br/>
Expressions that evaluate to a constant are required in several contexts: after&#160;case, as array&#160;<br/>bounds and bit-field lengths, as the value of an&#160;enumeration constant, in initializers, and in&#160;<br/>certain preprocessor expressions. &#160;<br/>
Constant expressions may not contain assignments, increment or decrement operators,&#160;<br/>function calls, or comma operators; except in an operand of&#160;sizeof. If the constant&#160;<br/>expression is required to be integral, its operands must consist of integer, enumeration,&#160;<br/>character, and floating constants; casts must&#160;specify an integral type, and any floating&#160;<br/>constants must be cast to integer. This necessarily rules out arrays, indirection, address-of,&#160;<br/>and structure member operations. (However, any operand is permitted for&#160;sizeof.) &#160;<br/>
More latitude is permitted for the constant expressions of&#160;initializers; the operands may be&#160;<br/>any type of constant, and the unary&#160;&amp;&#160;operator may be applied to external or static objects, and&#160;<br/>to external and static arrays subscripted with a constant expression. The unary&#160;&amp;&#160;operator can&#160;<br/>also be applied implicitly by appearance of&#160;unsubscripted arrays and functions. Initializers&#160;<br/>must evaluate either to a constant or to the address of a previously declared external or static&#160;<br/>object plus or minus a constant. &#160;<br/>
Less latitude is allowed for the integral constant expressions after&#160;#if;&#160;sizeof&#160;expressions,&#160;<br/>enumeration constants, and casts are not permitted. See&#160;<a href="cs.html#210">Par.A.12.5</a>. &#160;<br/>
<b>A.8 Declarations&#160;</b><br/>
Declarations specify the interpretation given to&#160;each identifier; they do&#160;not necessarily reserve&#160;<br/>storage associated with the identifier. Declarations that reserve storage are called&#160;<i>definitions</i>.&#160;<br/>Declarations have the form&#160;&#160;<br/>
&#160; &#160;&#160;<i>declaration</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>declaration-specifiers init-declarator-listopt</i>;&#160;&#160;<br/>
The declarators in the init-declarator list&#160;contain the identifiers being declared; the&#160;<br/>declaration-specifiers consist of a sequence&#160;of type and storage class specifiers. &#160;<br/>
<hr/>
<a name=187></a>&#160;&#160;<br/>
187&#160;<br/>
&#160; &#160;&#160;<i>declaration-specifiers</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>storage-class-specifier declaration-specifiersopt</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>type-specifier declaration-specifiersopt</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>type-qualifier declaration-specifiersopt</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>init-declarator-list</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>init-declarator</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>init-declarator-list</i>&#160;,&#160;<i>init-declarator</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>init-declarator</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>declarator</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>declarator</i>&#160;=&#160;<i>initializer</i>&#160;&#160;<br/>
Declarators will be discussed later (<a href="cs.html#192">Par.A.8.5</a>); they contain the names being declared. A&#160;<br/>declaration must have at least one declarator, or&#160;its type specifier must declare a structure tag,&#160;<br/>a union tag, or the members of&#160;an enumeration; empty declarations are not permitted. &#160;<br/>
<b>A.8.1 Storage Class Specifiers&#160;</b><br/>
The storage class specifiers are: &#160;<br/>
&#160; &#160;&#160;<i>storage-class specifier</i>:&#160;<br/>&#160; &#160; &#160;&#160;auto&#160;<br/>&#160; &#160; &#160;&#160;register&#160;<br/>&#160; &#160; &#160;&#160;static&#160;<br/>&#160; &#160; &#160;&#160;extern&#160;<br/>&#160; &#160; &#160;&#160;typedef&#160;&#160;<br/>
The m<a href="cs.html#173">eaning of the storage classes were discussed in&#160;Par.A.4.4. &#160;</a><br/>
The&#160;auto&#160;and&#160;register&#160;specifiers give the declared objects automatic storage class, and may&#160;<br/>be used only within functions. Such declarations&#160;also serve as definitions and cause storage to&#160;<br/>be reserved. A&#160;register&#160;declaration is equivalent to an&#160;auto&#160;declaration, but hints that the&#160;<br/>declared objects will be accessed frequently.&#160;Only a few objects are actually placed into&#160;<br/>registers, and only certain types are eligible;&#160;the restrictions are implementation-dependent.&#160;<br/>However, if an object is declared&#160;register, the unary&#160;&amp;&#160;operator may not be applied to it,&#160;<br/>explicitly or implicitly. &#160;<br/>
The&#160;rule that it is illegal to&#160;calculate the address of&#160;an&#160;object declared&#160;register, but&#160;actually&#160;taken to&#160;<br/>be&#160;auto, is new.&#160;&#160;<br/>
The&#160;&#160;static&#160;specifier gives the declared objects static&#160;storage class, and may be used either&#160;<br/>inside or outside functions. Inside a function, this specifier causes storage to be allocated, and&#160;<br/>serves as a definition; for its effect outside a function, see&#160;<a href="cs.html#206">Par.A.11.2</a>. &#160;<br/>
A declaration with&#160;extern, used inside a function, specifies that the storage for the declared&#160;<br/>objects is defined elsewhere; for its effects outside a function, see&#160;<a href="cs.html#206">Par.A.11.2</a>. &#160;<br/>
The&#160;typedef&#160;specifier does not reserve storage and is&#160;called a storage class specifier only for&#160;<br/>syntactic convenience; it is discussed in&#160;<a href="cs.html#199">Par.A.8.9</a>. &#160;<br/>
<hr/>
<a name=188></a>&#160;&#160;<br/>
188&#160;<br/>
At most one storage class specifier&#160;may be given in a declaration. If none is given, these rules&#160;<br/>are used: objects declared inside&#160;a function are taken to be&#160;auto; functions declared within a&#160;<br/>function are taken to be&#160;extern; objects and functions declared&#160;outside a function are taken to&#160;<br/>be&#160;static, with external linkage. See&#160;<a href="cs.html#203">Pars. A.10</a>-A.11. &#160;<br/>
<b>A.8.2 Type Specifiers&#160;</b><br/>
The type-specifiers are &#160;<br/>
&#160; &#160;&#160;<i>type specifier</i>:&#160;<br/>&#160; &#160; &#160;&#160;void&#160;<br/>&#160; &#160; &#160;&#160;char&#160;<br/>&#160; &#160; &#160;&#160;short&#160;<br/>&#160; &#160; &#160;&#160;int&#160;<br/>&#160; &#160; &#160;&#160;long&#160;<br/>&#160; &#160; &#160;&#160;float&#160;<br/>&#160; &#160; &#160;&#160;double&#160;<br/>&#160; &#160; &#160;&#160;signed&#160;<br/>&#160; &#160; &#160;&#160;unsigned&#160;<br/>&#160; &#160; &#160;&#160;<i>struct-or-union-specifier</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>enum-specifier</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>typedef-name</i>&#160;&#160;<br/>
At most one of the words&#160;long&#160;or&#160;short&#160;may be specified together with&#160;int; the meaning is&#160;<br/>the same if&#160;int&#160;is not mentioned. The word&#160;long&#160;may be specified together with&#160;double. At&#160;<br/>most one of&#160;signed&#160;or&#160;unsigned&#160;may be specified together with&#160;int&#160;or any of its&#160;short&#160;or&#160;<br/>long&#160;varieties, or with&#160;char. Either may appear alone in which case&#160;int&#160;is understood. The&#160;<br/>
signed&#160;specifier is useful for forcing&#160;char&#160;objects to carry a sign; it is permissible but&#160;<br/>redundant with other integral types. &#160;<br/>
Otherwise, at most one type-specifier may be given in a declaration. If the type-specifier is&#160;<br/>missing from&#160;a declaration, it is taken to be&#160;int. &#160;<br/>
Types may also be qualified, to indicate special properties of the objects being declared. &#160;<br/>
&#160; &#160;&#160;<i>type-qualifier</i>:&#160;<br/>&#160; &#160; &#160;&#160;const&#160;<br/>&#160; &#160; &#160;&#160;volatile&#160;&#160;<br/>
Type qualifiers may appear&#160;with any type specifier. A&#160;const&#160;object may be initialized, but not&#160;<br/>thereafter assigned to. There are no implementation-dependent semantics for&#160;volatile&#160;<br/>objects. &#160;<br/>
The&#160;const&#160;and&#160;volatile&#160;properties are new with&#160;the ANSI standard. The purpose of&#160;const&#160;is&#160;to&#160;<br/>announce&#160;objects&#160;that may be placed in read-only&#160;memory, and perhaps to increase opportunities for&#160;<br/>optimization. The purpose of&#160;volatile&#160;is&#160;to&#160;force an implementation to&#160;suppress optimization that&#160;<br/>could&#160;otherwise&#160;occur.&#160;For&#160;example,&#160;for a machine with&#160;memory-mapped input/output, a pointer to&#160;a&#160;<br/>device register might&#160;be declared as a&#160;pointer&#160;to&#160;volatile, in&#160;order to&#160;prevent the compiler from&#160;<br/>removing apparently&#160;redundant&#160;references&#160;through&#160;the&#160;pointer. Except&#160;that&#160;it&#160;should diagnose explicit&#160;<br/>attempts to&#160;change&#160;const&#160;objects, a compiler may&#160;ignore these qualifiers.&#160;&#160;<br/>
<b>A.8.3 Structure and Union Declarations&#160;</b><br/>
<hr/>
<a name=189></a>&#160;&#160;<br/>
189&#160;<br/>
A structure is an object consisting of a sequence of named members of various types. A union&#160;<br/>is an object that contains, at different times, any of several members of various types.&#160;<br/>Structure and union specifiers have the same form. &#160;<br/>
&#160; &#160;&#160;<i>struct-or-union-specifier</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>struct-or-union identifieropt</i>{&#160;<i>struct-declaration-list</i>&#160;}&#160;<br/>&#160; &#160; &#160;&#160;<i>struct-or-union identifier</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>struct-or-union</i>:&#160;<br/>&#160; &#160; &#160;&#160;struct&#160;<br/>&#160; &#160; &#160;&#160;union&#160;&#160;<br/>
A struct-declaration-list is a sequence of declarations for the members of the structure or&#160;<br/>union: &#160;<br/>
&#160; &#160;&#160;<i>struct-declaration-list</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>struct declaration</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>struct-declaration-list struct declaration</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>struct-declaration</i>: &#160; &#160; &#160;&#160;<i>specifier-qualifier-list struct-declarator-list</i>;&#160;&#160;<br/>
&#160; &#160;&#160;<i>specifier-qualifier-list</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>type-specifier specifier-qualifier-listopt</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>type-qualifier specifier-qualifier-listopt</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>struct-declarator-list</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>struct-declarator</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>struct-declarator-list</i>&#160;,&#160;<i>struct-declarator</i>&#160;&#160;<br/>
Usually, a struct-declarator is just a declarator for a member of a structure or union. A&#160;<br/>structure member may also consist of a specified&#160;number of bits. Such a member is also called&#160;<br/>a&#160;<i>bit-field</i>; its length is set off from&#160;the declarator for the field name by a colon. &#160;<br/>
&#160; &#160;&#160;<i>struct-declarator</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>declarator</i>&#160; &#160; &#160; &#160;<i>declaratoropt</i>&#160;:&#160;<i>constant-expression</i>&#160;&#160;<br/>
A type specifier of the form&#160;&#160;<br/>
&#160; &#160;&#160;<i>struct-or-union identifier</i>&#160;{&#160;<i>struct-declaration-list</i>&#160;}&#160;&#160;<br/>
declares the identifier to be the&#160;<i>tag</i>&#160;of the structure or union specified by the list. A subsequent&#160;<br/>declaration in the same or an inner scope may refer to the same type by using the tag in a&#160;<br/>specifier without the list: &#160;<br/>
&#160; &#160;&#160;<i>struct-or-union identifier</i>&#160;&#160;<br/>
If a specifier with a tag but&#160;without a list appears when the tag is not declared, an&#160;<i>incomplete&#160;<br/>type</i>&#160;is specified. Objects with an incomplete&#160;structure or union type may be mentioned in&#160;<br/>contexts where their size is not needed, for example in declarations (not definitions), for&#160;<br/>specifying a pointer, or for creating a&#160;typedef, but not otherwise. The type becomes complete&#160;<br/>on occurrence of a subsequent specifier with that&#160;tag, and containing a declaration list. Even&#160;<br/>
<hr/>
<a name=190></a>&#160;&#160;<br/>
190&#160;<br/>
in specifiers with a list, the structure or union&#160;type being declared is incomplete within the&#160;<br/>list, and becomes complete only at the&#160;}&#160;terminating the specifier. &#160;<br/>
A structure may not contain a member of&#160;incomplete type. Therefore, it is impossible to&#160;<br/>declare a structure or union containing an instance of itself. However, besides giving a name&#160;<br/>to the structure or union type, tags allow definition of self-referential structures; a structure or&#160;<br/>union may contain a pointer to an instance of itself, because pointers to incomplete types may&#160;<br/>be declared. &#160;<br/>
A very special rule applies to declarations of the form&#160;&#160;<br/>
&#160; &#160;&#160;<i>struct-or-union identifier</i>;&#160;&#160;<br/>
that declare a structure or union,&#160;but have no declaration list and no declarators. Even if the&#160;<br/>identifier is a structure or union tag already declared in an outer scope (<a href="cs.html#205">Par.A.11.1</a>), this&#160;<br/>declaration makes the identifier the tag of&#160;a new, incompletely-typed structure or union in the&#160;<br/>current scope. &#160;<br/>
This recondite is new with&#160;ANSI.&#160;It&#160;is&#160;intended&#160;to&#160;deal with&#160;mutually-recursive structures declared in an&#160;<br/>inner scope, but&#160;whose tags might&#160;already&#160;be declared in&#160;the outer scope.&#160;&#160;<br/>
A structure or union specifier with a list but no&#160;tag creates a unique type; it can be referred to&#160;<br/>directly only in the declaration of which it is a part. &#160;<br/>
The names of members and tags do not conflict with each other or with ordinary variables. A&#160;<br/>member name may not appear twice in the same structure or union, but the same member&#160;<br/>name&#160;may be used in different structures or unions. &#160;<br/>
In the first&#160;edition of this&#160;book, the names of structure&#160;and&#160;union&#160;members&#160;were&#160;not&#160;associated&#160;with&#160;<br/>their parent. However, this association became common in compilers well before the ANSI standard.&#160;&#160;<br/>
A non-field member of a structure or union may&#160;have any object type. A field member (which&#160;<br/>need not have a declarator and&#160;thus may be unnamed) has type&#160;int,&#160;&#160;unsigned int, or&#160;<br/>signed int, and is interpreted as an object of&#160;integral type of&#160;the specified length in bits;&#160;<br/>whether an&#160;int&#160;field is treated as signed is implementation-dependent. Adjacent field&#160;<br/>members of structures are packed into implementation-dependent storage units in an&#160;<br/>implementation-dependent direction. When a field following another field will not fit into a&#160;<br/>partially-filled storage unit, it may be split between units, or the unit may be padded. An&#160;<br/>unnamed field with width 0 forces this padding, so&#160;that the next field will begin at the edge of&#160;<br/>the next allocation unit. &#160;<br/>
The&#160;ANSI&#160;standard&#160;makes&#160;fields&#160;even&#160;more implementation-dependent&#160;than did the first&#160;edition. It&#160;is&#160;<br/>advisable&#160;to&#160;read the language rules for storing&#160;bit-fields as ``implementation-dependent''&#160;without&#160;<br/>qualification. Structures with&#160;bit-fields may&#160;be used as a&#160;portable&#160;way&#160;of&#160;attempting&#160;to&#160;reduce&#160;the&#160;<br/>storage required for a structure (with the probable cost of increasing the instruction space,&#160;and&#160;time,&#160;<br/>needed to access the fields), or as a non-portable way to describe a storage layout&#160;known&#160;at&#160;the&#160;bit-<br/>level. In the second case, it is necessary to&#160;understand the rules of the local implementation.&#160;&#160;<br/>
The members of a structure have addresses increasing in the order of their declarations. A&#160;<br/>non-field member of a structure is aligned&#160;at an addressing boundary depending on its type;&#160;<br/>therefore, there may be unnamed holes in a structure. If a pointer to a structure is cast to the&#160;<br/>type of&#160;a pointer to its first member, the result refers to the first member. &#160;<br/>
<hr/>
<a name=191></a>&#160;&#160;<br/>
191&#160;<br/>
A union may be thought of as a structure all of&#160;whose members begin at offset 0 and whose&#160;<br/>size is sufficient to contain any of its members.&#160;At&#160;most&#160;one&#160;of&#160;the&#160;members can be stored in a&#160;<br/>union at any time. If a pointr to a union is cast to&#160;the type of a pointer to a member, the result&#160;<br/>refers to that member. &#160;<br/>
A simple example of a structure declaration is &#160;<br/>
&#160;<br/>&#160; &#160;struct tnode {&#160;<br/>&#160; &#160; &#160; &#160;char tword[20];&#160;<br/>&#160; &#160; &#160; &#160;int count;&#160;<br/>&#160; &#160; &#160; &#160;struct tnode *left;&#160;<br/>&#160; &#160; &#160; &#160;struct tnode *right;&#160;<br/>&#160; &#160;}&#160;<br/>
which contains an array of 20 characters, an integer, and two pointers to similar structures.&#160;<br/>Once this declaration has bene given, the declaration &#160;<br/>&#160;<br/>&#160; &#160;struct tnode s, *sp;&#160;<br/>
declares&#160;s&#160;to be a structure of the given sort, and&#160;sp&#160;to be a pointer to a structure of the given&#160;<br/>sort. With these declarations, the expression &#160;<br/>&#160;<br/>&#160; &#160;sp-&gt;count&#160;<br/>
refers to the&#160;count&#160;field of the structure to which&#160;sp&#160;points; &#160;<br/>&#160;<br/>&#160; &#160;s.left&#160;<br/>
refers to the left subtree pointer of the structure&#160;s, and &#160;<br/>&#160;<br/>&#160; &#160;s.right-&gt;tword[0]&#160;<br/>
refers to the first character of the&#160;tword&#160;member of the right subtree of&#160;s. &#160;<br/>
In general, a member of a union may not be inspected unless the value of the union has been&#160;<br/>assigned using the same member. However, one special guarantee simplifies the use of&#160;<br/>unions: if&#160;a union contains several structures&#160;that share a common initial sequence, and the&#160;<br/>union currently contains one of&#160;these structures, it is permitted to refer to the common initial&#160;<br/>part of any of the contained structures. For example, the following is a legal fragment: &#160;<br/>
&#160;<br/>&#160; &#160;union {&#160;<br/>&#160; &#160; &#160; &#160;struct {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;int type;&#160;<br/>&#160; &#160; &#160; &#160;} n;&#160;<br/>&#160; &#160; &#160; &#160;struct {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;int type;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;int intnode;&#160;<br/>&#160; &#160; &#160; &#160;} ni;&#160;<br/>&#160; &#160; &#160; &#160;struct {&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;int type;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;float floatnode;&#160;<br/>&#160; &#160; &#160; &#160;} nf;&#160;<br/>&#160; &#160;} u;&#160;<br/>&#160; &#160;...&#160;<br/>&#160; &#160;u.nf.type = FLOAT;&#160;<br/>&#160; &#160;u.nf.floatnode = 3.14;&#160;<br/>&#160; &#160;...&#160;<br/>&#160; &#160;if (u.n.type == FLOAT)&#160;<br/>&#160; &#160; &#160; &#160;... sin(u.nf.floatnode) ...&#160;<br/>
<b>A.8.4 Enumerations&#160;</b><br/>
<hr/>
<a name=192></a>&#160;&#160;<br/>
192&#160;<br/>
Enumerations are unique types with values&#160;ranging over a set of named constants called&#160;<br/>enumerators. The form&#160;of an enumeration specifier borrows from&#160;that of structures and&#160;<br/>unions. &#160;<br/>
&#160; &#160;&#160;<i>enum-specifier</i>:&#160;<br/>&#160; &#160; &#160;&#160;enum&#160;<i>identifieropt</i>&#160;{&#160;<i>enumerator-list</i>&#160;}&#160;<br/>&#160; &#160; &#160;&#160;enum&#160;<i>identifier</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>enumerator-list</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>enumerator</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>enumerator-list</i>&#160;,&#160;<i>enumerator</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>enumerator</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>identifier</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>identifier</i>&#160;=&#160;<i>constant-expression</i>&#160;&#160;<br/>
The identifiers in an enumerator list&#160;are declared as constants of type&#160;int, and may appear&#160;<br/>wherever constants are required. If no enumerations with&#160;=&#160;appear, then the values of the&#160;<br/>corresponding constants begin at 0 and increase by 1&#160;as the declaration is read from&#160;left to&#160;<br/>right. An enumerator with&#160;=&#160;gives the associated identifier&#160;the value specified; subsequent&#160;<br/>identifiers continue the progression from&#160;the assigned value. &#160;<br/>
Enumerator names in the same scope must all be&#160;distinct from&#160;each other and from&#160;ordinary&#160;<br/>variable names, but the values need not be distinct. &#160;<br/>
The role of the identifier in the enum-specifier&#160;is analogous to that of the structure tag in a&#160;<br/>struct-specifier; it names a particular enumeration. The rules for enum-specifiers with and&#160;<br/>without tags and lists are the same as those for structure or union specifiers, except that&#160;<br/>incomplete enumeration types do not exist; the tag of an enum-specifier without an&#160;<br/>enumerator list must refer to an in-scope specifier with a list. &#160;<br/>
Enumerations&#160;are&#160;new&#160;since&#160;the&#160;first&#160;edition&#160;of&#160;this&#160;book, but&#160;have been part&#160;of the language for some&#160;<br/>years.&#160;&#160;<br/>
<b>A.8.5 Declarators&#160;</b><br/>
Declarators have the syntax: &#160;<br/>
&#160; &#160;&#160;<i>declarator</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>pointeropt&#160;direct-declarator</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>direct-declarator</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>identifier</i>&#160;<br/>&#160; &#160; &#160;&#160;(<i>declarator</i>)&#160;<br/>&#160; &#160; &#160;&#160;<i>direct-declarator</i>&#160;[&#160;<i>constant-expressionopt</i>&#160;]&#160;<br/>&#160; &#160; &#160;&#160;<i>direct-declarator</i>&#160;(&#160;<i>parameter-type-list</i>&#160;)&#160;<br/>&#160; &#160; &#160;&#160;<i>direct-declarator</i>&#160;(&#160;<i>identifier-listopt</i>&#160;)&#160;&#160;<br/>
&#160; &#160;&#160;<i>pointer</i>:&#160;<br/>&#160; &#160; &#160;&#160;*&#160;<i>type-qualifier-listopt</i>&#160;<br/>&#160; &#160; &#160;&#160;*&#160;<i>type-qualifier-listopt&#160;pointer</i>&#160;&#160;<br/>
<hr/>
<a name=193></a>&#160;&#160;<br/>
193&#160;<br/>
&#160; &#160;&#160;<i>type-qualifier-list</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>type-qualifier</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>type-qualifier-list type-qualifier</i>&#160;&#160;<br/>
The structure of declarators resembles that of&#160;indirection, function, and array expressions; the&#160;<br/>grouping is the same. &#160;<br/>
<b>A.8.6 Meaning of Declarators&#160;</b><br/>
A list of declarators appears after a sequence&#160;of type and storage class specifiers. Each&#160;<br/>declarator declares a unique main identifier, the&#160;one that appears as the first alternative of the&#160;<br/>production for&#160;<i>direct-declarator</i>. The storage class specifiers apply directly to this identifier,&#160;<br/>but its type depends on the form&#160;of its declarator. A declarator is read as an assertion that&#160;<br/>when its identifier appears in an expression of&#160;the same form&#160;as the declarator, it yields an&#160;<br/>object of the specified type. &#160;<br/>
Considering only the type parts of the declaration specifiers (<a href="cs.html#188">Par. A.8.2) and a particular&#160;<br/></a>declarator, a declaration has the form&#160;``T D,''&#160;where&#160;T&#160;is a type and&#160;D&#160;is a declarator. The type&#160;<br/>attributed to the identifier in the various forms&#160;of declarator is described inductively using this&#160;<br/>notation. &#160;<br/>
In a declaration&#160;T D&#160;where&#160;D&#160;is an unadored identifier, the type of&#160;the identifier is&#160;T. &#160;<br/>
In a declaration&#160;T D&#160;where&#160;D&#160;has the form&#160;&#160;<br/>
&#160;<br/>&#160; &#160; &#160; ( D1 )&#160;<br/>
then the type of&#160;the identifier in&#160;D1&#160;is the same as that of&#160;D. The parentheses do not alter the&#160;<br/>type, but may change the binding of complex declarators. &#160;<br/>
<b>A.8.6.1 Pointer Declarators&#160;</b><br/>
In a declaration&#160;T D&#160;where&#160;D&#160;has the form&#160;&#160;<br/>
&#160; &#160;&#160;*&#160;<i>type-qualifier-listopt</i>&#160;D1&#160;&#160;<br/>
and the type of&#160;the identifier in the declaration&#160;T D1&#160;is ``<i>type-modifier</i>&#160;&#160;T,'' the type of the&#160;<br/>identifier of&#160;D&#160;is ``<i>type-modifier type-qualifier-list</i>&#160;pointer to&#160;T.''&#160;Qualifiers following&#160;*&#160;apply&#160;<br/>to pointer itself, rather than to the object to which the pointer points. &#160;<br/>
For example, consider the declaration &#160;<br/>
&#160;<br/>&#160; &#160; &#160; int *ap[];&#160;<br/>
Here,&#160;&#160;ap[]&#160;plays the role of&#160;D1; a declaration ``int ap[]'' (below) would give&#160;ap&#160;the type&#160;<br/>``array of&#160;int,''&#160;the type-qualifier list is empty,&#160;and the type-modifier is ``array of.'' Hence the&#160;<br/>actual declaration gives&#160;ap&#160;the type ``array to pointers to&#160;int.'' &#160;<br/>
As other examples, the declarations &#160;<br/>
&#160;<br/>&#160; &#160; &#160; int i, *pi, *const cpi = &amp;i;&#160;<br/>&#160; &#160; &#160; const int ci = 3, *pci;&#160;<br/>
<hr/>
<a name=194></a>&#160;&#160;<br/>
194&#160;<br/>
declare an integer&#160;i&#160;and a pointer to an integer&#160;pi. The value of the constant pointer&#160;cpi&#160;may&#160;<br/>not be changed; it will always point to the same&#160;location, although the value to which it refers&#160;<br/>may be altered. The integer&#160;ci&#160;is constant, and may not&#160;be changed (though it may be&#160;<br/>initialized, as here.) The type of&#160;pci&#160;is ``pointer to&#160;const int,'' and&#160;pci&#160;itself may be&#160;<br/>changed to point to another place, but the value to which it points may not be altered by&#160;<br/>assigning through&#160;pci. &#160;<br/>
<b>A.8.6.2 Array Declarators&#160;</b><br/>
In a declaration&#160;T D&#160;where&#160;D&#160;has the form&#160;&#160;<br/>
&#160; &#160;&#160;D1 [<i>constant-expressionopt</i>]&#160;&#160;<br/>
and the type of&#160;the identifier in the declaration&#160;T D1&#160;is ``<i>type-modifier</i>&#160;&#160;T,'' the type of the&#160;<br/>identifier of&#160;D&#160;is ``<i>type-modifier</i>&#160;array of&#160;T.'' If the constant-expression is present, it must have&#160;<br/>integral type, and value greater than 0. If&#160;the constant expression specifying the bound is&#160;<br/>missing, the array has an incomplete type. &#160;<br/>
An array may be constructed from&#160;an arithmetic&#160;type, from&#160;a pointer,&#160;from&#160;a structure or&#160;<br/>union, or from&#160;another array (to generate a multi-dimensional array). Any type from&#160;which an&#160;<br/>array is constructed must be complete; it must not&#160;be an array of structure of incomplete type.&#160;<br/>This implies that for a multi-dimensional array,&#160;only the first dimension may be missing. The&#160;<br/>type of an object of incomplete aray type is&#160;completed by another, complete, declaration for&#160;<br/>the object (<a href="cs.html#204">Par.A.10.2</a>), or by initializing it (<a href="cs.html#196">Par.A.8.7</a>). For example, &#160;<br/>
&#160;<br/>&#160; &#160; &#160; float fa[17], *afp[17];&#160;<br/>
declares an array of&#160;float&#160;numbers and an array of pointers to&#160;float&#160;numbers. Also, &#160;<br/>&#160;<br/>&#160; &#160; &#160; static int x3d[3][5][7];&#160;<br/>
declares a static three-dimensional array of integers, with rank 3&#160;X&#160;5&#160;X&#160;7. In complete detail,&#160;<br/>x3d&#160;is an array of three items: each item&#160;is an array of five arrays; each of the latter arrays is&#160;<br/>an array of seven integers. Any of the expressions&#160;x3d,&#160;x3d[i],&#160;x3d[i][j],&#160;x3d[i][j][k]&#160;<br/>may reasonably appear in an expression. The first three have type ``array,'', the last has type&#160;<br/>int. More specifically,&#160;x3d[i][j]&#160;is an array of 7 integers, and&#160;x3d[i]&#160;is an array of 5&#160;<br/>arrays of 7 integers. &#160;<br/>
The array subscripting operation is defined so that&#160;E1[E2]&#160;is identical to&#160;*(E1+E2).&#160;<br/>Therefore, despite its asymmetric appearance, subscripting is a commutative operation.&#160;<br/>Because of the conversion rules that apply to&#160;+<a href="cs.html#175">&#160;and to arrays (Pars.A6.6,&#160;</a><a href="cs.html#177">A.7.1,&#160;</a><a href="cs.html#182">A.7.7), if&#160;</a>E1&#160;is&#160;<br/>an array and&#160;E2&#160;an integer, then&#160;E1[E2]&#160;refers to the&#160;E2-th&#160;member&#160;of&#160;E1. &#160;<br/>
In the example,&#160;x3d[i][j][k]&#160;is equivalent to&#160;*(x3d[i][j] + k). The first subexpression&#160;<br/>x3d[i][j]&#160;is converted by&#160;<a href="cs.html#177">Par.A.7.1</a><a href="cs.html#182">&#160;to type ``pointer to array of integers,'' by&#160;Par.A.7.7, the&#160;<br/></a>addition involves multiplication by the size of an integer. It follows from&#160;the rules that arrays&#160;<br/>are stored by rows (last subscript varies fastest)&#160;and that the first subscript in the declaration&#160;<br/>helps determine the amount of storage consumed&#160;by an array, but plays no other part in&#160;<br/>subscript calculations. &#160;<br/>
<b>A.8.6.3 Function Declarators&#160;</b><br/>
In a new-style function declaration&#160;T D&#160;where&#160;D&#160;has the form&#160;&#160;<br/>
<hr/>
<a name=195></a>&#160;&#160;<br/>
195&#160;<br/>
&#160; &#160;&#160;D1&#160;(<i>parameter-type-list</i>) &#160;<br/>
and the type of&#160;the identifier in the declaration&#160;T D1&#160;is ``<i>type-modifier</i>&#160;&#160;T,'' the type of the&#160;<br/>identifier of&#160;D&#160;is ``<i>type-modifier</i>&#160;function with arguments&#160;<i>parameter-type-list</i>&#160;returning&#160;T.'' &#160;<br/>
The syntax of the parameters is &#160;<br/>
&#160; &#160;&#160;<i>parameter-type-list</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>parameter-list</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>parameter-list</i>&#160;, ...&#160;&#160;<br/>
&#160; &#160;&#160;<i>parameter-list</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>parameter-declaration</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>parameter-list</i>&#160;,&#160;<i>parameter-declaration</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>parameter-declaration</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>declaration-specifiers declarator</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>declaration-specifiers abstract-declaratoropt</i>&#160;&#160;<br/>
In the new-style declaration, the parameter list specifies the types of the parameters. As a&#160;<br/>special case, the declarator for a new-style function with no parameters has a parameter list&#160;<br/>consisting soley of the keyword&#160;void. If&#160;the parameter list ends with an ellipsis ``, ...'',&#160;then&#160;<br/>the function may accept more arguments than the&#160;number of parameters explicitly described,&#160;<br/>see&#160;<a href="cs.html#178">Par.A.7.3.2. &#160;</a><br/>
The types of parameters that are arrays or functions are altered to pointers, in accordance with&#160;<br/>the rules for parameter conversions; see&#160;Par.A.10.1. The only storage class specifier permitted&#160;<br/>in a parameter's declaration is&#160;register, and this specifier is ignored unless the function&#160;<br/>declarator heads a function definition. Similarly, if the declarators in the parameter&#160;<br/>declarations contain identifiers and the function&#160;declarator does not head&#160;a function definition,&#160;<br/>the identifiers go out of scope immediately. Abstract declarators, which do not mention the&#160;<br/>identifiers, are discussed in&#160;Par.A.8.8. &#160;<br/>
In an old-style function declaration&#160;T D&#160;where&#160;D&#160;has the form&#160;&#160;<br/>
&#160; &#160;&#160;D1(<i>identifier-listopt</i>) &#160;<br/>
and the type of&#160;the identifier in the declaration&#160;T D1&#160;is ``<i>type-modifier</i>&#160;&#160;T,'' the type of the&#160;<br/>identifier of&#160;D&#160;is ``<i>type-modifier</i>&#160;function of unspecified arguments returning&#160;T.'' The&#160;<br/>parameters (if present) have the form&#160;&#160;<br/>
&#160; &#160;&#160;<i>identifier-list</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>identifier</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>identifier-list</i>&#160;,&#160;<i>identifier</i>&#160;&#160;<br/>
In the old-style declarator, the identifier list must&#160;be absent unless the declarator is used in the&#160;<br/><a href="cs.html#203">head of a function definition (Par.A.10.1). No inform</a>ation about the types of the parameters is&#160;<br/>supplied by the declaration. &#160;<br/>
For example, the declaration &#160;<br/>
&#160;<br/>
<hr/>
<a name=196></a>&#160;&#160;<br/>
196&#160;<br/>
&#160; &#160; &#160; int f(), *fpi(), (*pfi)();&#160;<br/>
declares a function&#160;f&#160;returning an integer, a function&#160;fpi&#160;returning a pointer to an integer, and&#160;<br/>a pointer&#160;pfi&#160;to a function returning an integer. In&#160;none of these are the parameter types&#160;<br/>specified; they are old-style. &#160;<br/>
In the new-style declaration &#160;<br/>
&#160;<br/>&#160; &#160; &#160; int strcpy(char *dest, const char *source), rand(void);&#160;<br/>
strcpy&#160;is a function returning&#160;int, with two arguments, the first a character pointer, and the&#160;<br/>second a pointer to constant characters. The&#160;parameter names are effectively comments. The&#160;<br/>second function&#160;rand&#160;takes no arguments and returns&#160;int. &#160;<br/>
Function declarators with&#160;parameter prototypes are, by&#160;far, the most&#160;important&#160;language&#160;change&#160;<br/>introduced by&#160;the ANSI standard. They&#160;offer an advantage over the ``old-style''&#160;declarators of the&#160;first&#160;<br/>edition&#160;by&#160;providing error-detection and coercion of arguments&#160;across function calls, but&#160;at&#160;a cost:&#160;<br/>turmoil and confusion during their&#160;introduction, and the necessity&#160;of accomodating both forms. Some&#160;<br/>syntactic ugliness was required&#160;for the sake&#160;of&#160;compatibility,&#160;namely&#160;void&#160;as an explicit marker of&#160;<br/>new-style functions without&#160;parameters. &#160;<br/>
The ellipsis notation&#160;``, ...''&#160;for variadic&#160;functions is&#160;also new, and,&#160;together&#160;with&#160;the&#160;macros&#160;in&#160;the&#160;<br/>standard header&#160;&lt;stdarg.h&gt;, formalizes a mechanism&#160;that was officially&#160;forbidden but&#160;unofficially&#160;<br/>condoned in the first edition. &#160;<br/>
These notations were adapted from&#160;the C++ language.&#160;&#160;<br/>
<b>A.8.7 Initialization&#160;</b><br/>
When an object is declared, its init-declarator&#160;may specify&#160;an initial value for the identifier&#160;<br/>being declared. The initializer is preceded by&#160;=, and is either an expression, or a list of&#160;<br/>initializers nested in braces. A list may end with a comma, a nicety for neat formatting. &#160;<br/>
&#160; &#160;&#160;<i>initializer</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>assignment-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;{&#160;<i>initializer-list</i>&#160;}&#160;<br/>&#160; &#160; &#160;&#160;{&#160;<i>initializer-list</i>&#160;, }&#160;&#160;<br/>
&#160; &#160;&#160;<i>initializer-list</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>initializer</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>initializer-list</i>&#160;,&#160;<i>initializer</i>&#160;&#160;<br/>
All the expressions in the initializer for a static&#160;object or array must be constant expressions as&#160;<br/>described in&#160;<a href="cs.html#186">Par.A.7.19</a>. The expressions in the initializer for an&#160;auto&#160;or&#160;register&#160;object or&#160;<br/>array must likewise be constant expressions if&#160;the initializer is a brace-enclosed list. However,&#160;<br/>if&#160;the initializer for an automatic object is a&#160;single expression, it need not be a constant&#160;<br/>expression, but must merely have appropriate type for assignment to the object. &#160;<br/>
The first edition did not countenance&#160;initialization of automatic structures,&#160;unions,&#160;or arrays. The ANSI&#160;<br/>standard&#160;allows it, but&#160;only by&#160;constant&#160;constructions&#160;unless the initializer can&#160;be&#160;expressed&#160;by&#160;a&#160;simple&#160;<br/>expression.&#160;&#160;<br/>
A static object not explicitly initialized is initialized as if&#160;it (or its members) were assigned the&#160;<br/>constant 0. The initial value of an automatic object not explicitly intialized is undefined. &#160;<br/>
<hr/>
<a name=197></a>&#160;&#160;<br/>
197&#160;<br/>
The initializer for a pointer or an object of&#160;arithmetic type is a single expression, perhaps in&#160;<br/>braces. The expression is assigned to the object. &#160;<br/>
The initializer for a structure is either an expression of the same type, or a brace-enclosed list&#160;<br/>of initializers for its members in order. Unnamed bit-field members are ignored, and are not&#160;<br/>initialized. If&#160;there are fewer initializers in the list than members of&#160;the structure, the trailing&#160;<br/>members are initialized with 0. There may not be more initializers than members. Unnamed&#160;<br/>bit-field members are ignored,and are not initialized. &#160;<br/>
The initializer for an array is a brace-enclosed list of initializers for its members. If the array&#160;<br/>has unknown size, the number of initializers determines the size of the array, and its type&#160;<br/>becomes complete. If the array has fixed size,&#160;the number of initializers may not exceed the&#160;<br/>number of&#160;members of&#160;the array; if&#160;there are&#160;fewer, the trailing members are initialized with&#160;<br/>0. &#160;<br/>
As a special case, a character array may be initialized by a string literal; successive characters&#160;<br/>of the string initialize successive members of the array. Similarly, a wide character literal&#160;<br/><a href="cs.html#171">(Par.A.2.6) m</a>ay initialize an array of&#160;type&#160;wchar_t. If the array has unknown size, the&#160;<br/>number of characters in the string, including the terminating null character, determines its&#160;<br/>size; if its size is fixed, the number of characters in the string, not counting the terminating&#160;<br/>null character, must not exceed the size of the array. &#160;<br/>
The initializer for a union is either a single expression of the same type, or a brace-enclosed&#160;<br/>initializer for the first member of&#160;the union. &#160;<br/>
The&#160;first&#160;edition did not allow initialization of unions. The ``first-member''&#160;rule is clumsy, but is hard to&#160;<br/>generalize&#160;without new syntax. Besides allowing unions to be explicitly initialized in at least a primitive&#160;<br/>way, this ANSI rule makes definite the semantics of&#160;static unions&#160;not&#160;explicitly initialized.&#160;&#160;<br/>
An&#160;<i>aggregate</i>&#160;is a structure or array. If an aggregate contains members of aggregate type, the&#160;<br/>initialization rules apply recursively. Braces may&#160;be elided in the initialization as follows: if&#160;<br/>the initializer for an aggregate's member that itself is an aggregate begins with a left brace,&#160;<br/>then the succeding comma-separated list of&#160;initializers initializes the members of the&#160;<br/>subaggregate; it is erroneous for there to be&#160;more initializers than members. If, however, the&#160;<br/>initializer for a subaggregate does not begin with&#160;a left brace, then only enough elements from&#160;<br/>the list are taken into account for the members&#160;of the subaggregate; any remaining members&#160;<br/>are left&#160;to initialize the next member of&#160;the aggregate of&#160;which the subaggregate is a part. &#160;<br/>
For example, &#160;<br/>
&#160;<br/>&#160; &#160;int x[] = { 1, 3, 5 };&#160;<br/>
declares and initializes&#160;x&#160;as a 1-dimensional array with&#160;three members, since no size was&#160;<br/>specified and there are three initializers. &#160;<br/>&#160;<br/>&#160; &#160;float y[4][3] = {&#160;<br/>&#160; &#160; &#160; &#160;{ 1, 3, 5 },&#160;<br/>&#160; &#160; &#160; &#160;{ 2, 4, 6 },&#160;<br/>&#160; &#160; &#160; &#160;{ 3, 5, 7 },&#160;<br/>&#160; &#160;};&#160;<br/>
is a completely-bracketed initialization: 1, 3 and 5 initialize the first row of&#160;the array&#160;y[0],&#160;<br/>namely&#160;&#160;y[0][0],&#160;&#160;y[0][1], and&#160;y[0][2]. Likewise the next two lines initialize&#160;y[1]&#160;and&#160;<br/>y[2]. The initializer ends early, and therefore the elements of&#160;y[3]&#160;are initialized with 0.&#160;<br/>Precisely the same&#160;effect could have been achieved by &#160;<br/>
<hr/>
<a name=198></a>&#160;&#160;<br/>
198&#160;<br/>
&#160;<br/>&#160; &#160;float y[4][3] = {&#160;<br/>&#160; &#160; &#160; &#160;1, 3, 5, 2, 4, 6, 3, 5, 7&#160;<br/>&#160; &#160;};&#160;<br/>
The initializer for&#160;y&#160;begins with a left brace, but that for&#160;y[0]&#160;does not; therefore three&#160;<br/>elements from&#160;the list are used. Likewise&#160;the next three are taken successively for&#160;y[1]&#160;and&#160;<br/>for&#160;y[2]. Also, &#160;<br/>&#160;<br/>&#160; &#160;float y[4][3] = {&#160;<br/>&#160; &#160; &#160; &#160;{ 1 }, { 2 }, { 3 }, { 4 }&#160;<br/>&#160; &#160;};&#160;<br/>
initializes the first column&#160;of&#160;y&#160;(regarded as a two-dimensional array) and leaves the rest 0. &#160;<br/>
Finally, &#160;<br/>
&#160;<br/>&#160; &#160;char msg[] = &#34;Syntax error on line %s\n&#34;;&#160;<br/>
shows a character array whose members are initialized with a string; its size includes the&#160;<br/>terminating null character. &#160;<br/>
<b>A.8.8 Type names&#160;</b><br/>
In several contexts (to specify type conversions&#160;explicitly with a cast, to declare parameter&#160;<br/>types in function declarators, and as argument of&#160;sizeof) it is necessary to supply the name&#160;<br/>of a data type. This is accomplished using a&#160;<i>type name</i>, which is syntactically a declaration for&#160;<br/>an object of&#160;that type omitting the name of&#160;the object. &#160;<br/>
&#160; &#160;&#160;<i>type-name</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>specifier-qualifier-list abstract-declaratoropt</i>&#160;<br/>
&#160; &#160;&#160;<i>abstract-declarator</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>pointer</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>pointeropt&#160;direct-abstract-declarator</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>direct-abstract-declarator</i>:&#160;<br/>&#160; &#160; &#160; (&#160;<i>abstract-declarator</i>&#160;)&#160;<br/>&#160; &#160; &#160;&#160;<i>direct-abstract-declaratoropt</i>&#160;[<i>constant-expressionopt</i>]&#160;<br/>&#160; &#160; &#160;&#160;<i>direct-abstract-declaratoropt</i>&#160;(<i>parameter-type-listopt</i>) &#160;<br/>
It is possible to identify uniquely the location&#160;in the abstract-declarator where the identifier&#160;<br/>would appear if the construction were a declarator in a declaration. The named type is then the&#160;<br/>same as the type of the hypothetical identifier. For example, &#160;<br/>
&#160;<br/>&#160; &#160;int&#160;<br/>&#160; &#160;int *&#160;<br/>&#160; &#160;int *[3]&#160;<br/>&#160; &#160;int (*)[]&#160;<br/>&#160; &#160;int *()&#160;<br/>&#160; &#160;int (*[])(void)&#160;<br/>
name respectively the types ``integer,'' ``pointer&#160;to integer,'' ``array of 3 pointers to integers,''&#160;<br/>``pointer to an unspecified number of integers,'' ``function of unspecified parameters returning&#160;<br/>pointer to integer,'' and ``array, of unspecified size, of pointers to functions with no&#160;<br/>parameters each returning an integer.''&#160;&#160;<br/>
<hr/>
<a name=199></a>&#160;&#160;<br/>
199&#160;<br/>
<b>A.8.9 Typedef&#160;</b><br/>
Declarations whose storage class specifier is&#160;typedef&#160;do not declare objects; instead they&#160;<br/>define identifiers that name types. These identifiers are called typedef&#160;names. &#160;<br/>
&#160; &#160;&#160;<i>typedef-name</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>identifier</i>&#160;&#160;<br/>
A&#160;typedef&#160;declaration attributes a type to each name among its declarators in the usual way&#160;<br/>(see&#160;&#160;<a href="cs.html#193">Par.A.8.6</a>). Thereafter, each such typedef name&#160;is&#160;syntactically equivalent to a type&#160;<br/>specifier keyword for the associated type. &#160;<br/>
For example, after &#160;<br/>
&#160;<br/>&#160; &#160;typedef long Blockno, *Blockptr;&#160;<br/>&#160; &#160;typedef struct { double r, theta; } Complex;&#160;<br/>
the constructions &#160;<br/>&#160;<br/>&#160; &#160;Blockno b;&#160;<br/>&#160; &#160;extern Blockptr bp;&#160;<br/>&#160; &#160;Complex z, *zp;&#160;<br/>
are legal declarations. The type of&#160;b&#160;is&#160;long, that of&#160;bp&#160;is ``pointer to&#160;long,'' and that of&#160;z&#160;is&#160;<br/>the specified structure;&#160;zp&#160;is a pointer to such a structure. &#160;<br/>
typedef&#160;does not introduce new types, only synonyms for types that could be specified in&#160;<br/>another way. In the example,&#160;b&#160;has the same type as any&#160;long&#160;object. &#160;<br/>
Typedef names may be redeclared in an inner scope, but a non-empty set of type specifiers&#160;<br/>must be given. For example, &#160;<br/>
&#160;<br/>&#160; &#160;extern Blockno;&#160;<br/>
does not redeclare&#160;Blockno, but &#160;<br/>&#160;<br/>&#160; &#160;extern int Blockno;&#160;<br/>
does. &#160;<br/>
<b>A.8.10 Type Equivalence&#160;</b><br/>
Two type specifier lists are equivalent if they&#160;contain the same set of type specifiers, taking&#160;<br/>into account that some specifiers can&#160;be implied by others (for example,&#160;long&#160;alone implies&#160;<br/>long int). Structures, unions, and enumerations with&#160;different tags are distinct, and a tagless&#160;<br/>union, structure, or enumeration specifies a unique type. &#160;<br/>
Two types are the sam<a href="cs.html#198">e if their abstract declarators (Par.A.8.8), after expanding any&#160;</a>typedef&#160;<br/>types, and deleting any function parameter specifiers, are the same up to the equivalence of&#160;<br/>type specifier lists. Array sizes and function parameter types are significant. &#160;<br/>
<b>A.9 Statements&#160;</b><br/>
Except as described, statements are executed in sequence. Statements are executed for their&#160;<br/>effect, and do not have values. They fall into several groups. &#160;<br/>
<hr/>
<a name=200></a>200<br/>
&#160; &#160;&#160;<i>statement</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>labeled-statement</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>expression-statement</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>compound-statement</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>selection-statement</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>iteration-statement</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>jump-statement</i>&#160;&#160;<br/>
<b>A.9.1 Labeled Statements&#160;</b><br/>
Statements may carry label prefixes. &#160;<br/>
&#160; &#160;&#160;<i>labeled-statement</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>identifier</i>&#160;:&#160;<i>statement</i>&#160;<br/>&#160; &#160; &#160;&#160;case&#160;<i>constant-expression</i>&#160;:&#160;<i>statement</i>&#160;<br/>&#160; &#160; &#160;&#160;default :&#160;<i>statement</i>&#160;&#160;<br/>
A label consisting of&#160;an identifier declares the identifier. The only use of&#160;an identifier label is&#160;<br/>as a target of&#160;goto. The scope of the identifier is the current function. Because labels have&#160;<br/>their own name space, they do not interfere with&#160;other identifiers and cannot be redeclared.&#160;<br/>See&#160;<a href="cs.html#205">Par.A.11.1</a>. &#160;<br/>
Case labels and default labels are used with the&#160;switch&#160;statem<a href="cs.html#201">ent (Par.A.9.4). The constant&#160;<br/></a>expression of&#160;case&#160;must have integral type. &#160;<br/>
Labels themselves do not alter the flow of control. &#160;<br/>
<b>A.9.2 Expression Statement&#160;</b><br/>
Most statements are expression statements, which have the form&#160;&#160;<br/>
&#160; &#160;&#160;<i>expression-statement</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>expressionopt</i>;&#160;&#160;<br/>
Most expression statements are assignments or&#160;function calls. All side effects from&#160;the&#160;<br/>expression are completed before the next statement is executed. If the expression is missing,&#160;<br/>the construction is called a null statement; it is&#160;often used to supply an empty body to an&#160;<br/>iteration statement to place a label. &#160;<br/>
<b>A.9.3 Compound Statement&#160;</b><br/>
So that several statements can be used where one is expected, the compound statement (also&#160;<br/>called ``block'')&#160;is provided. The body of a function definition is a compound statement. &#160;<br/>
&#160; &#160;&#160;<i>compound-statement</i>:&#160;<br/>&#160; &#160; &#160;&#160;{&#160;<i>declaration-listopt</i>&#160;statement-listopt&#160;}&#160;&#160;<br/>
&#160; &#160;&#160;<i>declaration-list</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>declaration</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>declaration-list declaration</i>&#160;&#160;<br/>
<hr/>
<a name=201></a>&#160;&#160;<br/>
201&#160;<br/>
&#160; &#160;&#160;<i>statement-list</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>statement</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>statement-list statement</i>&#160;&#160;<br/>
If&#160;an identifier in the declaration-list was in scope outside the block, the outer declaration is&#160;<br/><a href="cs.html#205">suspended within the block (see&#160;Par.A.11.1), af</a>ter which it resumes its force. An identifier&#160;<br/>may be declared only once in the same block.&#160;These rules apply to identifiers in the same&#160;<br/>nam<a href="cs.html#205">e space (Par.A.11</a>); identifiers in different name spaces are treated as distinct. &#160;<br/>
Initialization of automatic objects is performed each&#160;time the block is entered at the top, and&#160;<br/>proceeds in the order of the declarators. If&#160;a jump&#160;into the block is executed, these&#160;<br/>initializations are not performed. Initialization of&#160;static&#160;objects are performed only once,&#160;<br/>before the program&#160;begins execution. &#160;<br/>
<b>A.9.4 Selection Statements&#160;</b><br/>
Selection statements choose one of several flows of control. &#160;<br/>
&#160; &#160;&#160;<i>selection-statement</i>:&#160;<br/>&#160; &#160; &#160;&#160;if&#160;(<i>expression</i>)&#160;<i>statement</i>&#160;<br/>&#160; &#160; &#160;&#160;if&#160;(<i>expression</i>)&#160;<i>statement</i>&#160;else&#160;<i>statement</i>&#160;<br/>&#160; &#160; &#160;&#160;switch&#160;(<i>expression</i>)&#160;<i>statement</i>&#160;&#160;<br/>
In both forms of the&#160;if&#160;statement, the expression, which must have arithmetic or pointer type,&#160;<br/>is evaluated, including all side effects, and if it compares unequal to 0, the first substatement&#160;<br/>is executed. In the second form, the second substatement is executed if the expression is 0.&#160;<br/>The&#160;else&#160;ambiguity is resolved by connecting an&#160;else&#160;with the last encountered&#160;else-less&#160;if&#160;<br/>at the same block nesting level. &#160;<br/>
The&#160;switch&#160;statement causes control to be transferred to one of several statements depending&#160;<br/>on the value of an expression, which must have&#160;integral type. The substatement controlled by&#160;<br/>a&#160;switch&#160;is typically compound. Any statement within&#160;the substatement may be labeled with&#160;<br/>one or more&#160;case&#160;labels (<a href="cs.html#200">Par.A.9.1</a>). The controlling expression undergoes integral promotion&#160;<br/><a href="cs.html#174">(Par.A.6.1), and the case constants are converted to&#160;</a>the promoted type. No two of these case&#160;<br/>constants associated with the same switch may&#160;have the same value after conversion. There&#160;<br/>may also be at most one&#160;default&#160;label associated with a switch. Switches may be nested; a&#160;<br/>case&#160;or&#160;default&#160;label is associated with the smallest switch that contains it. &#160;<br/>
When the&#160;switch&#160;statement is executed, its expression is&#160;evaluated, including all side effects,&#160;<br/>and compared with each case constant. If one of the case constants is equal to the value of the&#160;<br/>expression, control passes to the statement of the matched&#160;case&#160;label. If no case constant&#160;<br/>matches the expression, and if there is a&#160;default&#160;label, control passes to the labeled&#160;<br/>statement. If no case matches, and if there is no&#160;default, then none of the substatements of&#160;<br/>the swtich is executed. &#160;<br/>
In the first edition of&#160;this&#160;book,&#160;the controlling expression of&#160;switch, and the case constants, were&#160;<br/>required to&#160;have&#160;int&#160;type.&#160;&#160;<br/>
<b>A.9.5 Iteration Statements&#160;</b><br/>
Iteration statements specify looping. &#160;<br/>
<hr/>
<a name=202></a>&#160;&#160;<br/>
202&#160;<br/>
&#160; &#160;&#160;<i>iteration-statement</i>:&#160;<br/>&#160; &#160; &#160;&#160;while&#160;(<i>expression</i>)&#160;<i>statement</i>&#160;<br/>&#160; &#160; &#160;&#160;do&#160;<i>statement</i>&#160;while&#160;(<i>expression</i>);&#160;<br/>&#160; &#160; &#160;&#160;for&#160;(<i>expressionopt</i>;&#160;<i>expressionopt</i>;&#160;<i>expressionopt</i>)&#160;<i>statement</i>&#160;&#160;<br/>
In the&#160;while&#160;and&#160;do&#160;statements, the substatement is executed repeatedly so long as the value&#160;<br/>of the expression remains unequal to 0; the expression must have arithmetic or pointer type.&#160;<br/>With&#160;&#160;while, the test, including all side effects from&#160;the expression, occurs before each&#160;<br/>execution of the statement; with&#160;do, the test follows each iteration. &#160;<br/>
In the&#160;for&#160;statement, the first expression is evaluated once, and thus specifies initialization for&#160;<br/>the loop. There is no restriction on its type.&#160;The second expression must have arithmetic or&#160;<br/>pointer type; it is evaluated before each iteration, and if it becomes equal to 0, the&#160;for&#160;is&#160;<br/>terminated. The third expression is evaluated&#160;after each iteration, and thus specifies a re-<br/>initialization for the loop. There is no restriction on its type. Side-effects from&#160;each expression&#160;<br/>are completed immediately after its evaluation. If the substatement does not contain&#160;<br/>continue, a statement &#160;<br/>
&#160; &#160;&#160;for&#160;(<i>expression1</i>;&#160;<i>expression2</i>;&#160;<i>expression3</i>)&#160;<i>statement</i>&#160;&#160;<br/>
is equivalent to &#160;<br/>
&#160;<br/><i>expression1</i>;&#160;<br/>while (<i>expression2</i>) {&#160;<br/>&#160; &#160;&#160;<i>statement</i>&#160;<br/>&#160; &#160;&#160;<i>expression3</i>;&#160;<br/>}&#160;<br/>
Any of the three expressions may be dropped. A missing second expression makes the&#160;<br/>implied test equivalent to testing a non-zero element. &#160;<br/>
<b>A.9.6 Jump statements&#160;</b><br/>
Jump&#160;statements transfer control unconditionally. &#160;<br/>
&#160; &#160;&#160;<i>jump-statement</i>:&#160;<br/>&#160; &#160; &#160;&#160;goto&#160;<i>identifier</i>;&#160;<br/>&#160; &#160; &#160;&#160;continue;&#160;<br/>&#160; &#160; &#160;&#160;break;&#160;<br/>&#160; &#160; &#160;&#160;return&#160;<i>expressionopt</i>;&#160;&#160;<br/>
In the&#160;goto&#160;statement, the identifier must be a label (<a href="cs.html#200">Par.A.9.1</a>) located in the current&#160;<br/>function. Control transfers to the labeled statement. &#160;<br/>
A&#160;continue&#160;statement may appear only within an iteration statement. It causes control to pass&#160;<br/>to the loop-continuation portion of the smallest&#160;enclosing such statement. More precisely,&#160;<br/>within each of the statements &#160;<br/>
&#160;<br/>&#160; &#160;while (...) { &#160; &#160; &#160; do { &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; for (...) {&#160;<br/>&#160; &#160; &#160;... &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; ... &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;...&#160;<br/>&#160; &#160;contin: ; &#160; &#160; &#160; &#160; &#160; contin: ; &#160; &#160; &#160; &#160; &#160; &#160;contin: ;&#160;<br/>&#160; &#160;} &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; } while (...); &#160; &#160; &#160; }&#160;<br/>
<hr/>
<a name=203></a>&#160;&#160;<br/>
203&#160;<br/>
a&#160;continue&#160;not contained in a smaller iteration statement is the same as&#160;goto contin. &#160;<br/>
A&#160;&#160;break&#160;statement may appear only in an iteration statement or a&#160;switch&#160;statement, and&#160;<br/>terminates execution of the smallest enclosing such statement; control passes to the statement&#160;<br/>following the terminated statement. &#160;<br/>
A function returns to its caller by the&#160;return&#160;statement. When&#160;return&#160;is followed by an&#160;<br/>expression, the value is returned to the caller&#160;of the function. The expression is converted, as&#160;<br/>by assignment, to the type returned by the function in which it appears. &#160;<br/>
Flowing off the end of a function is equivalent to&#160;a return with no expression. In either case,&#160;<br/>the returned value is undefined. &#160;<br/>
<b>A.10 External Declarations&#160;</b><br/>
The unit of input provided to the C compiler is&#160;called a translation unit; it consists of a&#160;<br/>sequence of external declarations, which are either declarations or function definitions. &#160;<br/>
&#160; &#160;&#160;<i>translation-unit</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>external-declaration</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>translation-unit external-declaration</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>external-declaration</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>function-definition</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>declaration</i>&#160;&#160;<br/>
The scope of&#160;external declarations persists to the end of&#160;the translation unit in which they are&#160;<br/>declared, just as the effect of&#160;declarations within the blocks persists to the end of the block.&#160;<br/>The syntax of external declarations is the same&#160;as that of all declarations, except that only at&#160;<br/>this level may the code for functions be given. &#160;<br/>
<b>A.10.1 Function Definitions&#160;</b><br/>
Function definitions have the form&#160;&#160;<br/>
&#160; &#160;&#160;<i>function-definition</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>declaration-specifiersopt&#160;declarator declaration-listopt&#160;compound-statement</i>&#160;&#160;<br/>
The only storage-class specifiers allowed among the declaration specifiers are&#160;extern&#160;or&#160;<br/>static<a href="cs.html#206">; see&#160;Par.A.11.2&#160;f</a>or the distinction between them. &#160;<br/>
A function may return an arithmetic type, a structure, a union, a pointer, or&#160;void, but not a&#160;<br/>function or an array. The declarator in a function declaration must specify&#160;explicitly that the&#160;<br/>declared identifier has function type; that&#160;is, it must contain one of the forms (see&#160;<br/><a href="cs.html#194">Par.A.8.6.3</a>). &#160;<br/>
&#160; &#160; &#160;&#160;<i>direct-declarator</i>&#160;(&#160;<i>parameter-type-list</i>&#160;)&#160;<br/>&#160; &#160; &#160;&#160;<i>direct-declarator</i>&#160;(&#160;<i>identifier-listopt</i>&#160;) &#160;<br/>
where the direct-declarator is an identifier or a&#160;parenthesized identifier. In particular, it must&#160;<br/>not achieve function type by means of a&#160;typedef. &#160;<br/>
<hr/>
<a name=204></a>&#160;&#160;<br/>
204&#160;<br/>
In the first form, the definition is a new-style function, and its parameters, together with their&#160;<br/>types, are declared in its parameter type list; the declaration-list following the function's&#160;<br/>declarator must be absent. Unless the parameter type list consists solely of&#160;void, showing that&#160;<br/>the function takes no parameters, each declarator&#160;in the parameter type list must contain an&#160;<br/>identifier. If&#160;the parameter type list ends with ``, ...'' then the function may be called with&#160;<br/>more arguments than parameters; the&#160;va_arg&#160;macro mechanism&#160;defined in the standard&#160;<br/>header&#160;&#160;&lt;stdarg.h&gt;<a href="">&#160;and described in&#160;Appendix B&#160;m</a>ust be used to refer to the extra&#160;<br/>arguments. Variadic functions must have at least one named parameter. &#160;<br/>
In the second form, the definition is old-style: the identifier list names the parameters, while&#160;<br/>the declaration list attributes types to them. If&#160;no declaration is given for a parameter, its type&#160;<br/>is taken to be&#160;int. The declaration list must declare only parameters named in the list,&#160;<br/>initialization is not permitted, and the only storage-class specifier possible is&#160;register. &#160;<br/>
In both styles of function definition, the parameters are understood to be declared just after&#160;<br/>the beginning of the compound statement constituting the function's body, and thus the same&#160;<br/>identifiers must not be redeclared there&#160;(although they may, like other identifiers, be&#160;<br/>redeclared in inner blocks). If a parameter is declared to have type ``array of&#160;<i>type</i>,'' the&#160;<br/>declaration is adjusted to read ``pointer to&#160;<i>type</i>;''&#160;similarly, if&#160;a parameter is declared to have&#160;<br/>type ``function returning&#160;<i>type</i>,''&#160;the declaration is adjusted to read ``pointer to function&#160;<br/>returning&#160;&#160;<i>type</i>.''&#160;During the call to a function, the arguments are converted as necessary and&#160;<br/>assigned to the param<a href="cs.html#178">eters; see&#160;Par.A.7.3.2</a>. &#160;<br/>
New-style function definitions are new with&#160;the ANSI&#160;standard.&#160;There&#160;is&#160;also&#160;a small change in the&#160;<br/>details&#160;of promotion;&#160;the first&#160;edition specified that&#160;the declarations of&#160;float&#160;parameters were adjusted&#160;<br/>to read&#160;double. The difference becomes noticable when a pointer to&#160;a parameter is generated&#160;within&#160;a&#160;<br/>function.&#160;&#160;<br/>
A complete example of a new-style function definition is &#160;<br/>
&#160;<br/>&#160; &#160;int max(int a, int b, int c)&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;int m;&#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160;m = (a &gt; b) ? a : b;&#160;<br/>&#160; &#160; &#160; &#160;return (m &gt; c) ? m : c;&#160;<br/>&#160; &#160;}&#160;<br/>
Here&#160;&#160;int&#160;is the declaration specifier;&#160;max(int a, int b, int c)&#160;is the function's&#160;<br/>declarator, and&#160;{ ...&#160;}&#160;is the block giving the code for the function. The corresponding old-<br/>style definition would be &#160;<br/>&#160;<br/>&#160; &#160;int max(a, b, c)&#160;<br/>&#160; &#160;int a, b, c;&#160;<br/>&#160; &#160;{&#160;<br/>&#160; &#160; &#160; &#160;/* ... */&#160;<br/>&#160; &#160;}&#160;<br/>
where now&#160;int max(a, b, c)&#160;is the declarator, and&#160;int a, b, c;&#160;is the declaration list for&#160;<br/>the parameters. &#160;<br/>
<b>A.10.2 External Declarations&#160;</b><br/>
External declarations specify the characteristics&#160;of objects, functions and other identifiers. The&#160;<br/>term&#160;``external'' refers to their location outside&#160;functions, and is not directly connected with&#160;<br/>
<hr/>
<a name=205></a>&#160;&#160;<br/>
205&#160;<br/>
the&#160;extern&#160;keyword; the storage class for an externally-declared object may be left empty, or&#160;<br/>it may be specified as&#160;extern&#160;or&#160;static. &#160;<br/>
Several external declarations for the same identifier may exist within the same translation unit&#160;<br/>if&#160;they agree in type and linkage, and if&#160;there is at most one definition for the identifier. &#160;<br/>
Two declarations for an object or function are deemed to agree in type under the rule&#160;<br/><a href="cs.html#199">discussed in&#160;Par.A.8.10. In addition, if the declarations</a>&#160;differ because one type is an&#160;<br/>incomplete structure, union, or enum<a href="cs.html#188">eration type (Par.A.8.3) and the other is the&#160;<br/></a>corresponding completed type with the same tag,&#160;the types are taken to agree. Moreover, if&#160;<br/>one type is an incomplete array type (<a href="cs.html#194">Par.A.8.6.2) and the other is a com</a>pleted array type, the&#160;<br/>types, if otherwise identical, are also taken to agree. Finally, if one type&#160;specifies an old-style&#160;<br/>function, and the other an otherwise identical new-style function, with parameter declarations,&#160;<br/>the types are taken to agree. &#160;<br/>
If the first external declarator&#160;for a function or object includes the&#160;static&#160;specifier, the&#160;<br/>identifier has&#160;<i>internal linkage</i>; otherwise it has&#160;<i>external linkage</i>. Linkage is discussed in&#160;<br/><a href="cs.html#206">Par.11.2</a>. &#160;<br/>
An external declaration for an object is a definition if&#160;it has an initializer. An external object&#160;<br/>declaration that does not have an initializer, and does not contain the&#160;extern&#160;specifier, is a&#160;<br/><i>tentative definition</i>. If a definition for an object appears&#160;in a translation unit, any tentative&#160;<br/>definitions are treated merely as redundant declarations. If no definition for the object appears&#160;<br/>in the translation unit, all its tentative definitions become a single definition with initializer 0. &#160;<br/>
Each object must have exactly one definition.&#160;For objects with internal linkage, this rule&#160;<br/>applies separately to each translation unit, because internally-linked objects are unique to a&#160;<br/>translation unit. For objects with external linkage, it applies to the entire program. &#160;<br/>
Although the one-definition rule is&#160;formulated somewhat differently in the first edition of this book, it is&#160;<br/>in&#160;effect&#160;identical&#160;to&#160;the one stated&#160;here. Some implementations&#160;relax&#160;it by&#160;generalizing&#160;the notion&#160;of&#160;<br/>tentative definition. In the alternate formulation, which is&#160;usual&#160;in&#160;UNIX systems and&#160;recognized&#160;as&#160;a&#160;<br/>common extension by&#160;the Standard, all&#160;the tentative definitions&#160;for&#160;an&#160;externally&#160;linked&#160;object,&#160;<br/>throughout all the translation units of&#160;the program, are considered&#160;together instead of in each translation&#160;<br/>unit&#160;separately.&#160;If&#160;a&#160;definition&#160;occurs&#160;somewhere in&#160;the program, then&#160;the tentative definitions&#160;become&#160;<br/>merely&#160;declarations, but&#160;if&#160;no definition appears, then&#160;all its tentative definitions&#160;become&#160;a definition&#160;<br/>with&#160;initializer 0.&#160;&#160;<br/>
<b>A.11 Scope and Linkage&#160;</b><br/>
A program&#160;need not all be compiled at one time:&#160;the source text may be kept in several files&#160;<br/>containing translation units, and precompiled routines may be loaded from&#160;libraries.&#160;<br/>Communication among the functions of a program&#160;may be carried out both through calls and&#160;<br/>through manipulation of external data. &#160;<br/>
Therefore, there are two kinds of&#160;scope to consider: first, the&#160;<i>lexical scope</i>&#160;of&#160;an identifier&#160;<br/>which is the region of the program&#160;text within which the identifier's characteristics are&#160;<br/>understood; and second, the scope associated with&#160;objects and functions with external linkage,&#160;<br/>which determines the connections between identifiers in separately compiled translation units. &#160;<br/>
<b>A.11.1 Lexical Scope&#160;</b><br/>
<hr/>
<a name=206></a>&#160;&#160;<br/>
206&#160;<br/>
Identifiers fall into several name spaces that&#160;do not interfere with one another; the same&#160;<br/>identifier may be used for different purposes, even in the same scope, if the uses are in&#160;<br/>different name spaces. These classes are:&#160;objects, functions, typedef names, and&#160;enum&#160;<br/>constants; labels; tags of structures or unions, and enumerations; and members of each&#160;<br/>structure or union individually. &#160;<br/>
These rules differ in several ways&#160;from&#160;those described in&#160;the first&#160;edition of this&#160;manual. Labels&#160;did not&#160;<br/>previously have their own name&#160;space; tags of structures and unions&#160;each&#160;had a separate space, and in&#160;<br/>some&#160;implementations enumerations tags did as well;&#160;putting different kinds of tags into the same&#160;space&#160;<br/>is a new restriction. The most important departure from&#160;the first&#160;edition is that each structure or union&#160;<br/>creates a separate name&#160;space for its members,&#160;so&#160;that the same&#160;name&#160;may appear in several different&#160;<br/>structures. This rule has been&#160;common practice for several years.&#160;&#160;<br/>
The lexical scope of an object or function identifier in an external declaration begins at the&#160;<br/>end of its declarator and persists to the end&#160;of&#160;the translation unit in which it appears. The&#160;<br/>scope of a parameter of a function definition begins at the start of the block defining the&#160;<br/>function, and persists through the function; the&#160;scope of a parameter in a function declaration&#160;<br/>ends at the end of the declarator. The scope of&#160;an identifier declared at the head of a block&#160;<br/>begins at the end of its declarator, and persists&#160;to the end of the block.&#160;The scope of a label is&#160;<br/>the whole of the function in which it appears. The scope of a structure, union, or enumeration&#160;<br/>tag, or an enumeration constant, begins at its appearance in a type specifier, and persists to the&#160;<br/>end of a translation unit (for declarations at the&#160;external level) or to the end of the block (for&#160;<br/>declarations within a function). &#160;<br/>
If&#160;an identifier is explicitly declared at the&#160;head of&#160;a block, including the block constituting a&#160;<br/>function, any declaration of&#160;the identifier outside the block is suspended until the end of&#160;the&#160;<br/>block. &#160;<br/>
<b>A.11.2 Linkage&#160;</b><br/>
Within a translation unit, all declarations of&#160;the same object or function identifier with&#160;<br/>internal linkage refer to the same thing, and the object or function is unique to that translation&#160;<br/>unit. All declarations for the same object or function identifier with external linkage refer to&#160;<br/>the same thing, and the object or function is shared by the entire program. &#160;<br/>
<a href="cs.html#204">As discussed in&#160;Par.A.10.2, the f</a>irst external declaration for an identifier gives the identifier&#160;<br/>internal linkage if&#160;the&#160;static&#160;specifier is used, external linkage&#160;otherwise. If a declaration for&#160;<br/>an identifier within a block does not include the&#160;extern&#160;specifier, then the identifier has no&#160;<br/>linkage and is unique to the function. If it does include&#160;extern, and an external declaration&#160;<br/>for is active in the scope surrounding the block, then the identifier has the same linkage as the&#160;<br/>external declaration, and refers to the same object&#160;or function; but if no external declaration is&#160;<br/>visible, its linkage is external. &#160;<br/>
<b>A.12 Preprocessing&#160;</b><br/>
A preprocessor performs macro substitution, conditional compilation, and inclusion of named&#160;<br/>files. Lines beginning with&#160;#, perhaps preceded by white space, communicate with this&#160;<br/>preprocessor. The syntax of these lines is independent of the rest of the language; they may&#160;<br/>appear anywhere and have effect that lasts (independent of&#160;scope) until the end of&#160;the&#160;<br/>translation unit. Line boundaries are significant;&#160;each line is analyzed individually (bus see&#160;<br/><a href="cs.html#207">Par.A.12.2&#160;for how to adjoin lines).&#160;</a>To the preprocessor, a token is any language token, or a&#160;<br/>character sequence giving a file name as in the&#160;#include<a href="cs.html#209">&#160;directive (Par.A.12.4); in addition,&#160;</a><br/>
<hr/>
<a name=207></a>&#160;&#160;<br/>
207&#160;<br/>
any character not otherwise defined is taken as&#160;a token. However, the effect of white spaces&#160;<br/>other than space and horizontal tab is undefined within preprocessor lines. &#160;<br/>
Preprocessing itself takes place in several logically&#160;successive phases that may, in a particular&#160;<br/>implementation, be condensed. &#160;<br/>
1.&#160;&#160;<a href="cs.html#207">First, trigraph sequences as described in&#160;Par.A.12.1&#160;are replaced by their equivalents.&#160;</a><br/>
Should the operating system&#160;environment require it, newline characters are introduced&#160;<br/>between the lines of the source file. &#160;<br/>
2.&#160;&#160;Each occurrence of a backslash character&#160;\&#160;followed by a newline is deleted, this&#160;<br/>
splicing lines (<a href="cs.html#207">Par.A.12.2</a>). &#160;<br/>
3.&#160;&#160;The program&#160;is split into tokens separated by white-space characters; comments are&#160;<br/>
replaced by a single space. Then preprocessing directives are obeyed, and macros&#160;<br/>(Pars.<a href="cs.html#207">A.12.3-</a><a href="cs.html#212">A.12.10) are expanded. &#160;</a><br/>
4.&#160;&#160;Escape sequences in character constants and string literals (Pars.&#160;<a href="cs.html#170">A.2.5.2</a>,&#160;&#160;<a href="cs.html#171">A.2.6</a>) are&#160;<br/>
replaced by their equivalents; then adjacent string literals are concatenated. &#160;<br/>
5.&#160;&#160;The result is translated, then linked together with other programs and libraries, by&#160;<br/>
collecting the necessary programs and data, and connecting external functions and&#160;<br/>object references to their definitions. &#160;<br/>
<b>A.12.1 Trigraph Sequences&#160;</b><br/>
The character set of C source programs is contained within seven-bit ASCII, but is a superset&#160;<br/>of the ISO 646-1983 Invariant Code Set. In order to enable programs to be represented in the&#160;<br/>reduced set, all occurrences of the following trigraph sequences are replaced by the&#160;<br/>corresponding single character. This replacement occurs before any other processing. &#160;<br/>&#160;<br/>&#160; &#160; &#160; &#160; &#160;??= &#160;# &#160; &#160; &#160; &#160; &#160; &#160;??( &#160;[ &#160; &#160; &#160; &#160; &#160; &#160;??&lt; &#160;{&#160;<br/>&#160; &#160; &#160; &#160; &#160;??/ &#160;\ &#160; &#160; &#160; &#160; &#160; &#160;??) &#160;] &#160; &#160; &#160; &#160; &#160; &#160;??&gt; &#160;}&#160;<br/>&#160; &#160; &#160; &#160; &#160;??' &#160;^ &#160; &#160; &#160; &#160; &#160; &#160;??! &#160;| &#160; &#160; &#160; &#160; &#160; &#160;??- &#160;~&#160;<br/>
No other such replacements occur. &#160;<br/>
Trigraph sequences are new with&#160;the ANSI standard.&#160;&#160;<br/>
<b>A.12.2 Line Splicing&#160;</b><br/>
Lines that end with the backslash character&#160;\&#160;are folded by deleting the backslash and the&#160;<br/>following newline character. This occurs before division into tokens. &#160;<br/>
<b>A.12.3 Macro Definition and Expansion&#160;</b><br/>
A control line of&#160;the form&#160;&#160;<br/>
&#160; &#160;&#160;# define&#160;<i>identifier token-sequence</i>&#160;&#160;<br/>
causes the preprocessor to replace subsequent&#160;instances of the identifier with the given&#160;<br/>sequence of tokens; leading and trailing white&#160;space around the token sequence is discarded.&#160;<br/>A second&#160;#define&#160;for the same identifier is erroneous unless the second token sequence is&#160;<br/>identical to the first, where all white space separations are taken to be equivalent. &#160;<br/>
A line of&#160;the form&#160;&#160;<br/>
&#160; &#160;&#160;# define&#160;<i>identifier</i>&#160;(<i>identifier-list</i>)&#160;<i>token-sequence</i>&#160;&#160;<br/>
<hr/>
<a name=208></a>&#160;&#160;<br/>
208&#160;<br/>
where there is no space between the first identifier and the (, is a macro definition with&#160;<br/>parameters given by the identifier list. As with&#160;the first form, leading and trailing white space&#160;<br/>arround the token sequence is discarded, and the macro may be redefined only with a&#160;<br/>definition in which the number and spelling of parameters, and the token sequence, is&#160;<br/>identical. &#160;<br/>
A control line of&#160;the form&#160;&#160;<br/>
&#160; &#160;&#160;# undef&#160;<i>identifier</i>&#160;&#160;<br/>
causes the identifier's preprocessor definition to&#160;be forgotten. It is not erroneous to apply&#160;<br/>#undef&#160;to an unknown identifier. &#160;<br/>
When a macro has been defined in the second form, subsequent textual instances of the macro&#160;<br/>identifier followed by optional white space, and then by (, a sequence of tokens separated by&#160;<br/>commas, and a ) constitute a call of&#160;the macro. The arguments of&#160;the call are the comma-<br/>separated token sequences; commas that are quoted&#160;or protected by nested parentheses do not&#160;<br/>separate arguments. During collection, arguments are not macro-expanded. The number of&#160;<br/>arguments in the call must match the number of&#160;parameters in the definition. After the&#160;<br/>arguments are isolated, leading and trailing white space is removed from&#160;them. Then the&#160;<br/>token sequence resulting from&#160;each argument is&#160;substituted for each unquoted occurrence of&#160;<br/>the corresponding parameter's identifier in the replacement token sequence of the macro.&#160;<br/>Unless the parameter in the replacement sequence is preceded by&#160;#, or preceded or followed&#160;<br/>by&#160;&#160;##, the argument tokens are examined for macro calls, and expanded as necessary, just&#160;<br/>before insertion. &#160;<br/>
Two special operators influence the replacement process. First, if an occurrence of a&#160;<br/>parameter in the replacement token sequence is immediately preceded by&#160;#, string quotes (&#34;)&#160;<br/>are placed around the corresponding parameter, and then both the&#160;#&#160;and the parameter&#160;<br/>identifier are replaced by the quoted argument. A&#160;\&#160;character is inserted before each&#160;&#34;&#160;or&#160;\&#160;<br/>character that appears surrounding, or inside,&#160;a string literal or character constant in the&#160;<br/>argument. &#160;<br/>
Second, if the definition token sequence&#160;for either kind of macro contains a&#160;##&#160;operator, then&#160;<br/>just after replacement of the parameters, each&#160;##&#160;is deleted, together with any white space on&#160;<br/>either side, so as to concatenate the adjacent&#160;tokens and form&#160;a new token. The effect is&#160;<br/>undefined if invalid tokens are produced, or if&#160;the result depends on the order of processing of&#160;<br/>the&#160;&#160;##&#160;operators. Also,&#160;##&#160;may not appear at the beginning or end of a replacement token&#160;<br/>sequence. &#160;<br/>
In both kinds of macro, the replacement token&#160;sequence is repeatedly rescanned for more&#160;<br/>defined identifiers. However, once a given identifier has been replaced in a given expansion,&#160;<br/>it is not replaced if it turns up again during rescanning; instead it is left unchanged. &#160;<br/>
Even if&#160;the final value of&#160;a macro expansion begins with with&#160;#, it is not taken to be a&#160;<br/>preprocessing directive. &#160;<br/>
The&#160;details&#160;of the macro-expansion process are described&#160;more precisely in&#160;the ANSI standard&#160;than&#160;in&#160;<br/>the&#160;first&#160;edition.&#160;The most important&#160;change&#160;is the addition&#160;of&#160;the&#160;#&#160;and&#160;##&#160;operators, which make&#160;<br/>quotation and concatenation admissible. Some&#160;of the new rules,&#160;especially&#160;those&#160;involving&#160;<br/>concatenation, are bizarre. (See example below.)&#160;&#160;<br/>
<hr/>
<a name=209></a>&#160;&#160;<br/>
209&#160;<br/>
For example, this facility may be used for ``manifest-constants,''&#160;as in &#160;<br/>
&#160;<br/>&#160; &#160;#define TABSIZE 100&#160;<br/>&#160; &#160;int table[TABSIZE];&#160;<br/>
The definition &#160;<br/>&#160;<br/>&#160; &#160;#define ABSDIFF(a, b) &#160;((a)&gt;(b) ? (a)-(b) : (b)-(a))&#160;<br/>
defines a macro to return the absolute value&#160;of the difference between its arguments. Unlike a&#160;<br/>function to do the same thing, the arguments and returned value may have any arithmetic type&#160;<br/>or even be pointers. Also, the arguments, which&#160;might have side effects, are evaluated twice,&#160;<br/>once for the test and once to produce the value. &#160;<br/>
Given the definition &#160;<br/>
&#160;<br/>&#160; &#160;#define tempfile(dir) &#160; &#160;#dir &#34;%s&#34;&#160;<br/>
the macro call&#160;tempfile(/usr/tmp)&#160;yields &#160;<br/>&#160;<br/>&#160; &#160;&#34;/usr/tmp&#34; &#34;%s&#34;&#160;<br/>
which will subsequently be catenated into a single string. After &#160;<br/>&#160;<br/>&#160; &#160;#define cat(x, y) &#160; &#160; &#160; x ## y&#160;<br/>
the call&#160;cat(var, 123)&#160;yields&#160;var123. However, the call&#160;cat(cat(1,2),3)&#160;is undefined:&#160;<br/>the presence of&#160;##&#160;prevents the arguments of the outer call from&#160;being expanded. Thus it&#160;<br/>produces the token string &#160;<br/>&#160;<br/>&#160; &#160;cat &#160;( &#160;1 &#160;, &#160;2 &#160;)3&#160;<br/>
and&#160;)3&#160;(the catenation of the last token of the first argument with the first token of the second)&#160;<br/>is not a legal token. If a second level of macro definition is introduced, &#160;<br/>&#160;<br/>&#160; &#160;#define xcat(x, y) &#160; &#160; &#160;cat(x,y)&#160;<br/>
things work more smoothly;&#160;xcat(xcat(1, 2), 3)&#160;does produce&#160;123, because the&#160;<br/>expansion of&#160;xcat&#160;itself does not involve the&#160;##&#160;operator. &#160;<br/>
Likewise,&#160;ABSDIFF(ABSDIFF(a,b),c)&#160;produces the expected, fully-expanded result. &#160;<br/>
<b>A.12.4 File Inclusion&#160;</b><br/>
A control line of&#160;the form&#160;&#160;<br/>
&#160;&#160;# include &lt;<i>filename</i>&gt;&#160;&#160;<br/>
causes the replacement of that line by&#160;the entire contents of the file&#160;<i>filename</i>. The characters&#160;<br/>in the name&#160;<i>filename</i>&#160;must not include&#160;&gt;&#160;or newline, and the effect is undefined if it contains&#160;<br/>any of&#160;&#34;,&#160;',&#160;\, or&#160;/*. The named file is searched for in a sequence of implementation-defined&#160;<br/>places. &#160;<br/>
Similarly, a control line of&#160;the form&#160;&#160;<br/>
&#160;&#160;# include &#34;<i>filename</i>&#34;&#160;&#160;<br/>
<hr/>
<a name=210></a>&#160;&#160;<br/>
210&#160;<br/>
searches first in association with the original source file (a deliberately implementation-<br/>dependent phrase), and if that search fails, then&#160;as in the first form. The effect of using&#160;',&#160;\, or&#160;<br/>/*&#160;in the filename remains undefined, but&#160;&gt;&#160;is permitted. &#160;<br/>
Finally, a directive of&#160;the form&#160;&#160;<br/>
&#160;&#160;# include&#160;<i>token-sequence</i>&#160;&#160;<br/>
not matching one of the previous forms is interpreted by expanding the token sequence as for&#160;<br/>normal text; one of&#160;the two forms with&#160;&lt;...&gt;&#160;or&#160;&#34;...&#34;&#160;must result, and is then treated as&#160;<br/>previously described. &#160;<br/>
#include&#160;files may be nested. &#160;<br/>
<b>A.12.5 Conditional Compilation&#160;</b><br/>
Parts of a program&#160;may be compiled conditionally, according to the following schematic&#160;<br/>syntax. &#160;<br/>
&#160; &#160;&#160;<i>preprocessor-conditional</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>if-line text elif-parts else-partopt</i>&#160;#endif&#160;&#160;<br/>
&#160; &#160;&#160;<i>if-line</i>:&#160;<br/>&#160; &#160; &#160;&#160;# if&#160;<i>constant-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;# ifdef&#160;<i>identifier</i>&#160;<br/>&#160; &#160; &#160;&#160;# ifndef&#160;<i>identifier</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>elif-parts</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>elif-line text</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>elif-partsopt</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>elif-line</i>:&#160;<br/>&#160; &#160; &#160;&#160;# elif&#160;<i>constant-expression</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>else-part</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>else-line text</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>else-line</i>:&#160;<br/>&#160; &#160; &#160;&#160;#else&#160;&#160;<br/>
Each of the directives (if-line, elif-line, else-line, and&#160;#endif) appears alone on a line. The&#160;<br/>constant expressions in&#160;#if&#160;and subsequent&#160;#elif&#160;lines are evaluated in order until an&#160;<br/>expression with a non-zero value is found; text following a line with a zero value is discarded.&#160;<br/>The text following the successful directive line is&#160;treated normally. ``Text''&#160;here refers to any&#160;<br/>material, including preprocessor lines, that is not part of the conditional structure; it may be&#160;<br/>empty. Once a successful&#160;#if&#160;or&#160;#elif&#160;line has been found and its text processed, succeeding&#160;<br/>#elif&#160;and&#160;#else&#160;lines, together with their text, are discarded. If all the expressions are zero,&#160;<br/>and there is an&#160;#else, the text following the&#160;#else&#160;is treated normally. Text controlled by&#160;<br/>inactive arms of the conditional is ignored except for checking the nesting of conditionals. &#160;<br/>
<hr/>
<a name=211></a>&#160;&#160;<br/>
211&#160;<br/>
The constant expression in&#160;#if&#160;and&#160;#elif&#160;is subject to ordinary macro replacement.&#160;<br/>Moreover, any expressions of the form&#160;&#160;<br/>
&#160; &#160;&#160;defined&#160;<i>identifier</i>&#160;&#160;<br/>
or &#160;<br/>
&#160; &#160;&#160;defined&#160;(<i>identifier</i>) &#160;<br/>
are replaced, before scanning for macros, by&#160;1L&#160;if&#160;the identifier is defined in the preprocessor,&#160;<br/>and by&#160;0L&#160;if not. Any identifiers remaining&#160;after macro expansion are replaced by&#160;0L. Finally,&#160;<br/>each integer constant is considered to be suffixed with&#160;L, so that all arithmetic is taken to be&#160;<br/>long or unsigned long. &#160;<br/>
<a href="cs.html#186">The resulting constant expression (Par.A.7.19) is restricted: it m</a>ust be integral, and may not&#160;<br/>contain&#160;sizeof, a cast, or an enumeration constant. &#160;<br/>
The control lines &#160;<br/>
&#160; &#160;&#160;#ifdef&#160;<i>identifier</i>&#160;<br/>&#160; &#160;&#160;#ifndef&#160;<i>identifier</i>&#160;&#160;<br/>
are equivalent to &#160;<br/>
&#160; &#160;&#160;# if defined&#160;<i>identifier</i>&#160;<br/>&#160; &#160;&#160;# if ! defined&#160;<i>identifier</i>&#160;&#160;<br/>
respectively. &#160;<br/>
#elif&#160;is&#160;new since the first&#160;edition, although it&#160;has been available is&#160;some&#160;preprocessors.&#160;The&#160;<br/>defined&#160;preprocessor operator is also new.&#160;&#160;<br/>
<b>A.12.6 Line Control&#160;</b><br/>
For the benefit of other preprocessors that generate C programs, a line in one of the forms &#160;<br/>
&#160; &#160;&#160;# line&#160;<i>constant</i>&#160;&#34;<i>filename</i>&#34;&#160;<br/>&#160; &#160;&#160;# line&#160;<i>constant</i>&#160;&#160;<br/>
causes the compiler to believe, for purposes of&#160;error diagnostics, that the line number of the&#160;<br/>next source line is given by the decimal integer constant and the current input file is named by&#160;<br/>the identifier. If the quoted filename is absent, the remembered name&#160;does not change. Macros&#160;<br/>in the line are expanded before it is interpreted. &#160;<br/>
<b>A.12.7 Error Generation&#160;</b><br/>
A preprocessor line of the form&#160;&#160;<br/>
&#160; &#160;&#160;# error&#160;<i>token-sequenceopt</i>&#160;&#160;<br/>
causes the preprocessor to write a diagnostic message that includes the token sequence. &#160;<br/>
<hr/>
<a name=212></a>&#160;&#160;<br/>
212&#160;<br/>
<b>A.12.8 Pragmas&#160;</b><br/>
A control line of&#160;the form&#160;&#160;<br/>
&#160; &#160;&#160;# pragma&#160;<i>token-sequenceopt</i>&#160;&#160;<br/>
causes the preprocessor to perform&#160;an implementation-dependent action. An unrecognized&#160;<br/>pragma is ignored. &#160;<br/>
<b>A.12.9 Null directive&#160;</b><br/>
A control line of&#160;the form&#160;&#160;<br/>
&#160; &#160;&#160;#&#160;&#160;<br/>
has no effect. &#160;<br/>
<b>A.12.10 Predefined names&#160;</b><br/>
Several identifiers are predefined, and expand to&#160;produce special information. They, and also&#160;<br/>the preprocessor expansion operator&#160;defined, may not be undefined or redefined. &#160;<br/>
__LINE__&#160;&#160;A decimal constant containing the current source line number.&#160;<br/>
__FILE__&#160;&#160;A string literal containing the name of&#160;the file being compiled.&#160;<br/>
__DATE__&#160;&#160;A string literal containing the date of&#160;compilation, in the form&#160;&#34;Mmmm dd yyyy&#34;&#160;<br/>
__TIME__&#160;&#160;A string literal containing the time of&#160;compilation, in the form&#160;&#34;hh:mm:ss&#34;&#160;<br/>
__STDC__&#160;&#160;The constant&#160;1. It is intended that this identifier be defined to be&#160;1&#160;only in standard-<br/>
conforming implementations.&#160;<br/>
#error&#160;and&#160;#pragma&#160;are new with&#160;the ANSI standard; the predefined preprocessor macros are new,&#160;<br/>but&#160;some&#160;of them&#160;have been available in&#160;some&#160;implementations.&#160;&#160;<br/>
<b>A.13 Grammar&#160;</b><br/>
Below is a recapitulation of the grammar that&#160;was given throughout the earlier part of this&#160;<br/>appendix. It has exactly the same content, but is in different order. &#160;<br/>
The grammar has undefined terminal symbols&#160;<i>integer-constant</i>,&#160;<i>character-constant</i>,&#160;<i>floating-<br/>constant</i>,&#160;&#160;<i>identifier</i>,&#160;&#160;<i>string</i>, and&#160;<i>enumeration-constant</i>; the&#160;typewriter&#160;style words and&#160;<br/>symbols are terminals given literally. This grammar can be transformed mechanically into&#160;<br/>input acceptable for an automatic parser-generator. Besides adding whatever syntactic&#160;<br/>marking is used to indicate alternatives in productions, it is necessary to expand the ``one of''&#160;<br/>constructions, and (depending on the rules of the parser-generator) to duplicate each&#160;<br/>production with an&#160;<i>opt</i>&#160;symbol, once with the symbol and once without. With one further&#160;<br/>change, namely deleting the production&#160;<i>typedef-name</i>:&#160;<i>identifier</i>&#160;and making&#160;<i>typedef-name</i>&#160;a&#160;<br/>terminal symbol, this grammar is acceptable to the YACC parser-generator. It has only one&#160;<br/>conflict, generated by the&#160;if-else&#160;ambiguity. &#160;<br/>
&#160; &#160;&#160;<i>translation-unit</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>external-declaration</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>translation-unit external-declaration</i>&#160;&#160;<br/>
<hr/>
<a name=213></a>&#160;&#160;<br/>
213&#160;<br/>
&#160; &#160;&#160;<i>external-declaration</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>function-definition</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>declaration</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>function-definition</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>declaration-specifiersopt&#160;declarator declaration-listopt&#160;compound-statement</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>declaration</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>declaration-specifiers init-declarator-listopt</i>;&#160;&#160;<br/>
&#160; &#160;&#160;<i>declaration-list</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>declaration</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>declaration-list declaration</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>declaration-specifiers</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>storage-class-specifier declaration-specifiersopt</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>type-specifier declaration-specifiersopt</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>type-qualifier declaration-specifiersopt</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>storage-class specifier</i>: one of&#160;<br/>&#160; &#160; &#160;&#160;auto register static extern typedef&#160;&#160;<br/>
&#160; &#160;&#160;<i>type specifier</i>: one of&#160;<br/>&#160; &#160; &#160;&#160;void char short int long float double signed&#160;<br/>&#160; &#160; &#160;&#160;unsigned&#160;<i>struct-or-union-specifier enum-specifier typedef-name</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>type-qualifier</i>: one of&#160;<br/>&#160; &#160; &#160;&#160;const volatile&#160;&#160;<br/>
&#160; &#160;&#160;<i>struct-or-union-specifier</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>struct-or-union identifieropt</i>&#160;{&#160;<i>struct-declaration-list</i>&#160;}&#160;<br/>&#160; &#160; &#160;&#160;<i>struct-or-union identifier</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>struct-or-union</i>: one of&#160;<br/>&#160; &#160; &#160;&#160;struct union&#160;&#160;<br/>
&#160; &#160;&#160;<i>struct-declaration-list</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>struct declaration</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>struct-declaration-list struct declaration</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>init-declarator-list</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>init-declarator</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>init-declarator-list</i>,&#160;<i>init-declarator</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>init-declarator</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>declarator</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>declarator</i>&#160;=&#160;<i>initializer</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>struct-declaration</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>specifier-qualifier-list struct-declarator-list</i>;&#160;&#160;<br/>
<hr/>
<a name=214></a>&#160;&#160;<br/>
214&#160;<br/>
&#160; &#160;&#160;<i>specifier-qualifier-list</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>type-specifier specifier-qualifier-listopt</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>type-qualifier specifier-qualifier-listopt</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>struct-declarator-list</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>struct-declarator</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>struct-declarator-list</i>&#160;,&#160;<i>struct-declarator</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>struct-declarator</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>declarator</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>declaratoropt</i>&#160;:&#160;<i>constant-expression</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>enum-specifier</i>:&#160;<br/>&#160; &#160; &#160;&#160;enum&#160;<i>identifieropt</i>&#160;{&#160;<i>enumerator-list</i>&#160;}&#160;<br/>&#160; &#160; &#160;&#160;enum&#160;<i>identifier</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>enumerator-list</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>enumerator</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>enumerator-list</i>&#160;,&#160;<i>enumerator</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>enumerator</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>identifier</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>identifier</i>&#160;=&#160;<i>constant-expression</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>declarator</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>pointeropt&#160;direct-declarator</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>direct-declarator</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>identifier</i>&#160;<br/>&#160; &#160; &#160;&#160;(<i>declarator</i>)&#160;<br/>&#160; &#160; &#160;&#160;<i>direct-declarator</i>&#160;[&#160;<i>constant-expressionopt</i>&#160;]&#160;<br/>&#160; &#160; &#160;&#160;<i>direct-declarator</i>&#160;(&#160;<i>parameter-type-list</i>&#160;)&#160;<br/>&#160; &#160; &#160;&#160;<i>direct-declarator</i>&#160;(&#160;<i>identifier-listopt</i>&#160;)&#160;&#160;<br/>
&#160; &#160;&#160;<i>pointer</i>:&#160;<br/>&#160; &#160; &#160;&#160;*&#160;<i>type-qualifier-listopt</i>&#160;<br/>&#160; &#160; &#160;&#160;*&#160;<i>type-qualifier-listopt&#160;pointer</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>type-qualifier-list</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>type-qualifier</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>type-qualifier-list type-qualifier</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>parameter-type-list</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>parameter-list</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>parameter-list</i>&#160;, ...&#160;&#160;<br/>
&#160; &#160;&#160;<i>parameter-list</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>parameter-declaration</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>parameter-list</i>&#160;,&#160;<i>parameter-declaration</i>&#160;&#160;<br/>
<hr/>
<a name=215></a>&#160;&#160;<br/>
215&#160;<br/>
&#160; &#160;&#160;<i>parameter-declaration</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>declaration-specifiers declarator</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>declaration-specifiers abstract-declaratoropt</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>identifier-list</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>identifier</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>identifier-list</i>&#160;,&#160;<i>identifier</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>initializer</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>assignment-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;{&#160;<i>initializer-list</i>&#160;}&#160;<br/>&#160; &#160; &#160;&#160;{&#160;<i>initializer-list</i>&#160;, }&#160;&#160;<br/>
&#160; &#160;&#160;<i>initializer-list</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>initializer</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>initializer-list</i>&#160;,&#160;<i>initializer</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>type-name</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>specifier-qualifier-list abstract-declaratoropt</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>abstract-declarator</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>pointer</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>pointeropt&#160;direct-abstract-declarator</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>direct-abstract-declarator</i>:&#160;<br/>&#160; &#160; &#160; (&#160;<i>abstract-declarator</i>&#160;)&#160;<br/>&#160; &#160; &#160;&#160;<i>direct-abstract-declaratoropt</i>&#160;[<i>constant-expressionopt</i>]&#160;<br/>&#160; &#160; &#160;&#160;<i>direct-abstract-declaratoropt</i>&#160;(<i>parameter-type-listopt</i>) &#160;<br/>
&#160; &#160;&#160;<i>typedef-name</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>identifier</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>statement</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>labeled-statement</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>expression-statement</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>compound-statement</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>selection-statement</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>iteration-statement</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>jump-statement</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>labeled-statement</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>identifier</i>&#160;:&#160;<i>statement</i>&#160;<br/>&#160; &#160; &#160;&#160;case&#160;<i>constant-expression</i>&#160;:&#160;<i>statement</i>&#160;<br/>&#160; &#160; &#160;&#160;default :&#160;<i>statement</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>expression-statement</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>expressionopt</i>;&#160;&#160;<br/>
&#160; &#160;&#160;<i>compound-statement</i>:&#160;<br/>&#160; &#160; &#160;&#160;{&#160;<i>declaration-listopt&#160;statement-listopt</i>&#160;}&#160;&#160;<br/>
<hr/>
<a name=216></a>&#160;&#160;<br/>
216&#160;<br/>
&#160; &#160;&#160;<i>statement-list</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>statement</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>statement-list statement</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>selection-statement</i>:&#160;<br/>&#160; &#160; &#160;&#160;if&#160;(<i>expression</i>)&#160;<i>statement</i>&#160;<br/>&#160; &#160; &#160;&#160;if&#160;(<i>expression</i>)&#160;<i>statement</i>&#160;else&#160;<i>statement</i>&#160;<br/>&#160; &#160; &#160;&#160;switch&#160;(<i>expression</i>)&#160;<i>statement</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>iteration-statement</i>:&#160;<br/>&#160; &#160; &#160;&#160;while&#160;(<i>expression</i>)&#160;<i>statement</i>&#160;<br/>&#160; &#160; &#160;&#160;do&#160;<i>statement</i>&#160;while&#160;(<i>expression</i>);&#160;<br/>&#160; &#160; &#160;&#160;for&#160;(<i>expressionopt</i>;&#160;<i>expressionopt</i>;&#160;<i>expressionopt</i>)&#160;<i>statement</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>jump-statement</i>:&#160;<br/>&#160; &#160; &#160;&#160;goto&#160;<i>identifier</i>;&#160;<br/>&#160; &#160; &#160;&#160;continue;&#160;<br/>&#160; &#160; &#160;&#160;break;&#160;<br/>&#160; &#160; &#160;&#160;return&#160;<i>expressionopt</i>;&#160;&#160;<br/>
&#160; &#160;&#160;<i>expression</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>assignment-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>expression</i>&#160;,&#160;<i>assignment-expression</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>assignment-expression</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>conditional-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>unary-expression assignment-operator assignment-expression</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>assignment-operator</i>: one of&#160;<br/>&#160; &#160; &#160;&#160;= *= /= %= += -= &lt;&lt;= &gt;&gt;= &amp;= ^= |=&#160;&#160;<br/>
&#160; &#160;&#160;<i>conditional-expression</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>logical-OR-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>logical-OR-expression</i>&#160;?&#160;<i>expression</i>&#160;:&#160;<i>conditional-expression</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>constant-expression</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>conditional-expression</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>logical-OR-expression</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>logical-AND-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>logical-OR-expression</i>&#160;||&#160;<i>logical-AND-expression</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>logical-AND-expression</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>inclusive-OR-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>logical-AND-expression</i>&#160;&amp;&amp;&#160;<i>inclusive-OR-expression</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>inclusive-OR-expression</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>exclusive-OR-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>inclusive-OR-expression</i>&#160;|&#160;<i>exclusive-OR-expression</i>&#160;&#160;<br/>
<hr/>
<a name=217></a>&#160;&#160;<br/>
217&#160;<br/>
&#160; &#160;&#160;<i>exclusive-OR-expression</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>AND-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>exclusive-OR-expression</i>&#160;^&#160;<i>AND-expression</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>AND-expression</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>equality-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>AND-expression</i>&#160;&amp;&#160;<i>equality-expression</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>equality-expression</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>relational-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>equality-expression</i>&#160;==&#160;<i>relational-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>equality-expression</i>&#160;!=&#160;<i>relational-expression</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>relational-expression</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>shift-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>relational-expression</i>&#160;&lt;&#160;<i>shift-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>relational-expression</i>&#160;&gt;&#160;<i>shift-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>relational-expression</i>&#160;&lt;=&#160;<i>shift-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>relational-expression</i>&#160;&gt;=&#160;<i>shift-expression</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>shift-expression</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>additive-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>shift-expression</i>&#160;&lt;&lt;&#160;<i>additive-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>shift-expression</i>&#160;&gt;&gt;&#160;<i>additive-expression</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>additive-expression</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>multiplicative-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>additive-expression</i>&#160;+&#160;<i>multiplicative-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>additive-expression</i>&#160;-&#160;<i>multiplicative-expression</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>multiplicative-expression</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>multiplicative-expression</i>&#160;*&#160;<i>cast-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>multiplicative-expression</i>&#160;/&#160;<i>cast-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>multiplicative-expression</i>&#160;%&#160;<i>cast-expression</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>cast-expression</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>unary expression</i>&#160;<br/>&#160; &#160; &#160; (<i>type-name</i>)&#160;<i>cast-expression</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>unary-expression</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>postfix expression</i>&#160;<br/>&#160; &#160; &#160;&#160;++<i>unary expression</i>&#160;<br/>&#160; &#160; &#160;&#160;--<i>unary expression</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>unary-operator cast-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;sizeof&#160;<i>unary-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;sizeof&#160;(<i>type-name</i>) &#160;<br/>
&#160; &#160;&#160;<i>unary operator</i>: one of&#160;<br/>&#160; &#160; &#160;&#160;&amp; * + - ~ !&#160;&#160;<br/>
&#160; &#160;&#160;<i>postfix-expression</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>primary-expression</i>&#160;<br/>
<hr/>
<a name=218></a>&#160;&#160;<br/>
218&#160;<br/>
&#160; &#160; &#160;&#160;<i>postfix-expression</i>[<i>expression</i>]&#160;<br/>&#160; &#160; &#160;&#160;<i>postfix-expression</i>(<i>argument-expression-listopt</i>)&#160;<br/>&#160; &#160; &#160;&#160;<i>postfix-expression</i>.<i>identifier</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>postfix-expression</i>-&gt;+<i>identifier</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>postfix-expression</i>++&#160;<br/>&#160; &#160; &#160;&#160;<i>postfix-expression</i>--&#160;<br/>
&#160; &#160;&#160;<i>primary-expression</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>identifier</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>constant</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>string</i>&#160;<br/>&#160; &#160; &#160; (<i>expression</i>) &#160;<br/>
&#160; &#160;&#160;<i>argument-expression-list</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>assignment-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>assignment-expression-list</i>&#160;,&#160;<i>assignment-expression</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>constant</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>integer-constant</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>character-constant</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>floating-constant</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>enumeration-constant</i>&#160;&#160;<br/>
The following grammar for the preprocessor summarizes the structure of control lines, but is&#160;<br/>not suitable for mechanized parsing. It includes the symbol&#160;<i>text</i>, which means ordinary&#160;<br/>program&#160;text, non-conditional preprocessor control lines, or complete preprocessor&#160;<br/>conditional instructions. &#160;<br/>
&#160; &#160;&#160;<i>control-line</i>:&#160;<br/>&#160; &#160; &#160;&#160;# define&#160;<i>identifier token-sequence</i>&#160;<br/>&#160; &#160; &#160;&#160;# define&#160;<i>identifier</i>(<i>identifier, ... , identifier</i>)&#160;<i>token-sequence</i>&#160;<br/>&#160; &#160; &#160;&#160;# undef&#160;<i>identifier</i>&#160;<br/>&#160; &#160; &#160;&#160;# include &lt;<i>filename</i>&gt;&#160;<br/>&#160; &#160; &#160;&#160;# include &#34;<i>filename</i>&#34;&#160;<br/>&#160; &#160; &#160;&#160;# line&#160;<i>constant</i>&#160;&#34;<i>filename</i>&#34;&#160;<br/>&#160; &#160; &#160;&#160;# line&#160;<i>constant</i>&#160;<br/>&#160; &#160; &#160;&#160;# error&#160;<i>token-sequenceopt</i>&#160;<br/>&#160; &#160; &#160;&#160;# pragma&#160;<i>token-sequenceopt</i>&#160;<br/>&#160; &#160; &#160;&#160;#&#160;<br/>&#160; &#160; &#160;&#160;<i>preprocessor-conditional</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>preprocessor-conditional</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>if-line text elif-parts else-partopt</i>&#160;#endif&#160;&#160;<br/>
&#160; &#160;&#160;<i>if-line</i>:&#160;<br/>&#160; &#160; &#160;&#160;# if&#160;<i>constant-expression</i>&#160;<br/>&#160; &#160; &#160;&#160;# ifdef&#160;<i>identifier</i>&#160;<br/>&#160; &#160; &#160;&#160;# ifndef&#160;<i>identifier</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>elif-parts</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>elif-line text</i>&#160;<br/>&#160; &#160; &#160;&#160;<i>elif-partsopt</i>&#160;&#160;<br/>
<hr/>
<a name=219></a>&#160;&#160;<br/>
219&#160;<br/>
&#160; &#160;&#160;<i>elif-line</i>:&#160;<br/>&#160; &#160; &#160;&#160;# elif&#160;<i>constant-expression</i>&#160;&#160;<br/>
&#160; &#160;&#160;<i>else-part</i>:&#160;<br/>&#160; &#160; &#160;&#160;<i>else-line text</i>&#160;<br/>
&#160; &#160;&#160;<i>else-line</i>:&#160;<br/>&#160; &#160; &#160;&#160;#else&#160;&#160;<br/>
<hr/>
<a name=220></a>&#160;&#160;<br/>
220&#160;<br/>
&#160;<br/>
<b>Appendix B - Standard Library&#160;</b><br/>
This appendix is a summary of the library defined by the ANSI standard. The standard library&#160;<br/>is not part of the C language proper, but an environment that supports standard C will provide&#160;<br/>the function declarations and type and macro definitions of&#160;this library. We have omitted a&#160;<br/>few functions that are of&#160;limited utility or easily synthesized from&#160;others; we have omitted&#160;<br/>multi-byte characters; and we have omitted discussion of&#160;locale issues; that is, properties that&#160;<br/>depend on local language, nationality, or culture. &#160;<br/>
The functions, types and macros of the standard library are declared in standard&#160;<i>headers</i>: &#160;<br/>
&#160;<br/>&#160; &#160;&lt;assert.h&gt; &#160;&lt;float.h&gt; &#160; &lt;math.h&gt; &#160; &#160;&lt;stdarg.h&gt; &#160;&lt;stdlib.h&gt;&#160;<br/>&#160; &#160;&lt;ctype.h&gt; &#160; &lt;limits.h&gt; &#160;&lt;setjmp.h&gt; &#160;&lt;stddef.h&gt; &#160;&lt;string.h&gt;&#160;<br/>&#160; &#160;&lt;errno.h&gt; &#160; &lt;locale.h&gt; &#160;&lt;signal.h&gt; &#160;&lt;stdio.h&gt; &#160; &lt;time.h&gt;&#160;<br/>
A header can be accessed by &#160;<br/>
&#160;&#160;#include&#160;&lt;<i>header</i>&gt; &#160;<br/>
Headers may be included in any order and any&#160;number of times. A header must be included&#160;<br/>outside of any external declaration or definition and before any use of anything it declares. A&#160;<br/>header need not be a source file. &#160;<br/>
External identifiers that begin with an underscore&#160;are reserved for use by the library, as are all&#160;<br/>other identifiers that begin with an underscore and an upper-case letter or another underscore. &#160;<br/>
<b>B.1 Input and Output: &lt;stdio.h&gt;&#160;</b><br/>
The input and output functions, types, and macros defined in&#160;&lt;stdio.h&gt;&#160;represent nearly one&#160;<br/>third of&#160;the library. &#160;<br/>
A&#160;&#160;<i>stream</i>&#160;is a source or destination of data that&#160;may be associated with a disk or other&#160;<br/>peripheral. The library supports text streams&#160;and binary streams, although on some systems,&#160;<br/>notably UNIX, these are identical. A text stream&#160;is a sequence of lines; each line has zero or&#160;<br/>more characters and is terminated by&#160;'\n'. An environment may need to convert a text stream&#160;<br/>to or from&#160;some other representation (such as mapping&#160;'\n'&#160;to carriage return and linefeed).&#160;<br/>A binary stream&#160;is a sequence of unprocessed bytes&#160;that record internal data, with the property&#160;<br/>that if&#160;it is written, then read back on the same system, it will compare equal. &#160;<br/>
A stream&#160;is connected to a file or device by&#160;<i>opening</i>&#160;it; the connection is broken by&#160;<i>closing</i>&#160;<br/>the stream. Opening a file returns a pointer to an object of type&#160;FILE, which records whatever&#160;<br/>information is necessary to control the stream. We will use ``file pointer''&#160;and ``stream''&#160;<br/>interchangeably when there is no ambiguity. &#160;<br/>
When a program&#160;begins execution, the three streams&#160;stdin,&#160;stdout, and&#160;stderr&#160;are already&#160;<br/>open. &#160;<br/>
<b>B.1.1 File Operations&#160;</b><br/>
<hr/>
<a name=221></a>&#160;&#160;<br/>
221&#160;<br/>
The following functions deal with operations on files. The type&#160;size_t&#160;is the unsigned&#160;<br/>integral type produced by the&#160;sizeof&#160;operator. &#160;<br/>FILE *fopen(const char *filename, const char *mode)&#160;&#160;<br/>
fopen&#160;opens the named file, and returns a stream, or&#160;NULL&#160;if&#160;the attempt fails. Legal&#160;<br/>values for&#160;mode&#160;include: &#160;<br/>
&#34;r&#34;&#160;&#160;open text file for reading&#160;<br/>
&#34;w&#34;&#160;&#160;create text file for writing; discard previous contents if any&#160;<br/>
&#34;a&#34;&#160;&#160;append; open or create text file for writing at end of file&#160;<br/>
&#34;r+&#34;&#160;&#160;open text file for update (i.e., reading and writing)&#160;<br/>
&#34;w+&#34;&#160;&#160;create text file for update, discard previous contents if any&#160;<br/>
&#34;a+&#34;&#160;&#160;append; open or create text file for update, writing at end &#160;<br/>
Update mode permits reading and writing the same file;&#160;fflush&#160;or a file-positioning&#160;<br/>function must be called between a read and a write or vice versa. If the mode includes&#160;<br/>b&#160;after the initial letter, as in&#160;&#34;rb&#34;&#160;or&#160;&#34;w+b&#34;, that indicates a binary file. Filenames are&#160;<br/>limited to&#160;FILENAME_MAX&#160;characters. At most&#160;FOPEN_MAX&#160;files may be open at once. &#160;<br/>
FILE *freopen(const char *filename, const char *mode, FILE *stream)&#160;&#160;<br/>
freopen&#160;opens the file with the specified mode&#160;and associates the stream&#160;with it. It&#160;<br/>returns&#160;&#160;stream, or&#160;NULL&#160;if an error occurs.&#160;freopen&#160;is normally used to change the&#160;<br/>files associated with&#160;stdin,&#160;stdout, or&#160;stderr. &#160;<br/>
int fflush(FILE *stream)&#160;&#160;<br/>
On an output stream,&#160;fflush&#160;causes any buffered but unwritten data to be written; on&#160;<br/>an input stream, the effect is undefined. It returns&#160;EOF&#160;for a write error, and zero&#160;<br/>otherwise.&#160;fflush(NULL)&#160;flushes all output streams. &#160;<br/>
int fclose(FILE *stream)&#160;&#160;<br/>
fclose&#160;flushes any unwritten data for&#160;stream, discards any unread buffered input,&#160;<br/>frees any automatically allocated buffer,&#160;then closes the stream. It returns&#160;EOF&#160;if any&#160;<br/>errors occurred, and zero otherwise. &#160;<br/>
int remove(const char *filename)&#160;&#160;<br/>
remove&#160;removes the named file, so that a subsequent attempt to open it will fail. It&#160;<br/>returns non-zero if the attempt fails. &#160;<br/>
int rename(const char *oldname, const char *newname)&#160;&#160;<br/>
rename&#160;changes the name of a file; it returns non-zero if the attempt fails. &#160;<br/>
FILE *tmpfile(void)&#160;&#160;<br/>
tmpfile&#160;creates a temporary file of mode&#160;&#34;wb+&#34;&#160;that will be automatically removed&#160;<br/>when closed or when the program&#160;terminates normally.&#160;tmpfile&#160;returns a stream, or&#160;<br/>NULL&#160;if it could not create the file. &#160;<br/>
char *tmpnam(char s[L_tmpnam])&#160;&#160;<br/>
tmpnam(NULL)&#160;creates a string that is not the name&#160;of&#160;an existing file, and returns a&#160;<br/>pointer to an internal static array.&#160;tmpnam(s)&#160;stores the string in&#160;s&#160;as well as returning&#160;<br/>it as the function value;&#160;s&#160;must have room&#160;for at least&#160;L_tmpnam&#160;characters.&#160;tmpnam&#160;<br/>generates a different name each time it is called; at most&#160;TMP_MAX&#160;different names are&#160;<br/>guaranteed during execution of the program. Note that&#160;tmpnam&#160;creates a name, not a&#160;<br/>file. &#160;<br/>
int setvbuf(FILE *stream, char *buf, int mode, size_t size)&#160;&#160;<br/>
setvbuf&#160;controls buffering for the stream; it must&#160;be called before reading, writing or&#160;<br/>any other operation. A&#160;mode&#160;of&#160;_IOFBF&#160;causes full&#160;buffering,&#160;_IOLBF&#160;line buffering of&#160;<br/>text files, and&#160;_IONBF&#160;no buffering. If&#160;buf&#160;is not&#160;NULL, it will be used as the buffer,&#160;<br/>otherwise a buffer will be allocated.&#160;size&#160;determines the buffer size.&#160;setvbuf&#160;returns&#160;<br/>non-zero for any error. &#160;<br/>
void setbuf(FILE *stream, char *buf)&#160;&#160;<br/>
<hr/>
<a name=222></a>&#160;&#160;<br/>
222&#160;<br/>
If&#160;buf&#160;is&#160;NULL, buffering is turned off for the stream. Otherwise,&#160;setbuf&#160;is equivalent&#160;<br/>to&#160;(void) setvbuf(stream, buf, _IOFBF, BUFSIZ). &#160;<br/>
<b>B.1.2 Formatted Output&#160;</b><br/>
The&#160;printf&#160;functions provide formatted output conversion. &#160;<br/>&#160;<br/>&#160; &#160;int fprintf(FILE *stream, const char *format, ...)&#160;<br/>
fprintf&#160;converts and writes output to&#160;stream&#160;under the control of&#160;format. The return value&#160;<br/>is the number of&#160;characters written, or negative if&#160;an error occurred. &#160;<br/>
The format string contains two types of objects:&#160;ordinary characters, which are copied to the&#160;<br/>output stream, and conversion specifications, each&#160;of which causes conversion and printing of&#160;<br/>the next successive argument to&#160;fprintf. Each conversion specification begins with the&#160;<br/>character&#160;%&#160;and ends with a conversion character. Between the&#160;%&#160;and the conversion character&#160;<br/>there may be, in order: &#160;<br/>
•&#160;&#160;Flags (in any order), which modify the specification: &#160;<br/>
o -, which specifies left adjustment of the converted argument in its field. &#160;<br/>
o +, which specifies that the number will always be printed with a sign. &#160;<br/>
o&#160;&#160;<i>space</i>: if the first character is not a sign, a space will be prefixed. &#160;<br/>
o 0: for numeric conversions, specifies padding to the field width with leading&#160;<br/>
zeros. &#160;<br/>
o #, which specifies an alternate output form. For&#160;o, the first digit will become&#160;<br/>
zero. For&#160;x&#160;or&#160;X,&#160;0x&#160;or&#160;0X&#160;will be prefixed to a non-zero result. For&#160;e,&#160;E,&#160;f,&#160;g,&#160;<br/>and&#160;G, the output will always have a decimal point; for&#160;g&#160;and&#160;G, trailing zeros&#160;<br/>will not be removed. &#160;<br/>
•&#160;&#160;A number specifying a minimum&#160;field width.&#160;The converted argument will be printed&#160;<br/>
in a field at least this wide, and wider&#160;if necessary. If the converted argument has&#160;<br/>fewer characters than the field width it will&#160;be padded on the left&#160;(or right, if&#160;left&#160;<br/>adjustment has been requested) to make up&#160;the field width. The padding character is&#160;<br/>normally space, but is&#160;0&#160;if the zero padding flag is present. &#160;<br/>
•&#160;&#160;A period, which separates the field width from&#160;the precision. &#160;<br/>•&#160;&#160;A number, the precision, that specifies&#160;the maximum&#160;number of characters to be&#160;<br/>
printed from&#160;a string, or the number of digits&#160;to be printed after the decimal point for&#160;<br/>e,&#160;E, or&#160;f&#160;conversions, or the number of significant digits for&#160;g&#160;or&#160;G&#160;conversion, or the&#160;<br/>number of digits to be printed for an integer (leading&#160;0s will be added to make up the&#160;<br/>necessary width). &#160;<br/>
•&#160;&#160;A length modifier&#160;h,&#160;l&#160;(letter ell), or&#160;L. ``h'' indicates that the corresponding argument&#160;<br/>
is to be printed as a&#160;short&#160;or&#160;unsigned short; ``l''&#160;indicates that the argument is a&#160;<br/>long&#160;or&#160;unsigned long, ``L''&#160;indicates that the argument is a&#160;long double. &#160;<br/>
Width or precision or both may be specified as&#160;*, in which case the value is computed by&#160;<br/>converting the next argument(s), which must be&#160;int. &#160;<br/>
The conversion characters and their meanings are&#160;shown in Table B.1. If the character after&#160;<br/>the&#160;%&#160;is not a conversion character, the behavior is undefined. &#160;<br/>
<i><b>Table B.1</b>&#160;Printf Conversions</i>&#160;&#160;<br/>
<b>Character&#160;</b><br/>
<b>Argument type; Printed As &#160;</b><br/>
<hr/>
<a name=223></a>&#160;&#160;<br/>
223&#160;<br/>
d,i&#160;<br/>
int; signed decimal notation.&#160;<br/>
o&#160;<br/>
int; unsigned octal notation (without a leading zero).&#160;<br/>
x,X&#160;<br/>
unsigned int; unsigned hexadecimal notation (without a leading&#160;0x&#160;or&#160;0X),&#160;<br/>using&#160;abcdef&#160;for&#160;0x&#160;or&#160;ABCDEF&#160;for&#160;0X.&#160;<br/>
u&#160;<br/>
int; unsigned decimal notation.&#160;<br/>
c&#160;<br/>
int; single character, after conversion to&#160;unsigned char&#160;<br/>
s&#160;<br/>
char *; characters from&#160;the string are printed until a&#160;'\0'&#160;is reached or until the&#160;<br/>number of characters indicated by the precision have been printed.&#160;<br/>
double; decimal notation of the form&#160;[-]<i>mmm.ddd</i>, where the number of&#160;<i>d</i>'s&#160;is&#160;<br/>
f&#160;<br/>
given by the precision. The default precision is 6; a precision of 0 suppresses the&#160;<br/>decimal point.&#160;<br/>
double; decimal notation of the form&#160;[-]<i>m.dddddd</i>e+/-<i>xx</i>&#160;or&#160;[-]<i>m.dddddd</i>E+/-<br/>
e,E&#160;<br/>
<i>xx</i>, where the number of&#160;<i>d</i>'s is specified by the precision. The default precision is&#160;<br/>6; a precision of 0 suppresses the decimal point.&#160;<br/>
double;&#160;%e&#160;or&#160;%E&#160;is used if the exponent is less than -4 or greater than or equal to&#160;<br/>
g,G&#160;<br/>
the precision; otherwise&#160;%f&#160;is used. Trailing zeros and a trailing decimal point are&#160;<br/>not printed.&#160;<br/>
p&#160;<br/>
void *; print as a pointer (implementation-dependent representation).&#160;<br/>
n&#160;<br/>
int *; the number of&#160;characters written so far by this call to&#160;printf&#160;is&#160;<i>written&#160;<br/>into</i>&#160;the argument. No argument is converted.&#160;<br/>
%&#160;<br/>
no argument is converted; print a %&#160;<br/>
int printf(const char *format, ...)&#160;&#160;<br/>
printf(...)&#160;is equivalent to&#160;fprintf(stdout, ...). &#160;<br/>
int sprintf(char *s, const char *format, ...)&#160;&#160;<br/>
sprintf&#160;is the same as&#160;printf&#160;except that the output is written into the string&#160;s,&#160;<br/>terminated with&#160;'\0'.&#160;s&#160;must be big enough to hold the result. The return count does&#160;<br/>not include the&#160;'\0'. &#160;<br/>
int vprintf(const char *format,&#160;va_list&#160;arg)&#160;<br/>int vfprintf(FILE *stream, const char *format, va_list&#160;arg)&#160;<br/>int vsprintf(char *s, const char *format, va_list arg)&#160;&#160;<br/>
The functions&#160;vprintf,&#160;vfprintf, and&#160;vsprintf&#160;are equivalent to the corresponding&#160;<br/>printf&#160;functions, except that the variable argument list is replaced by&#160;arg, which has&#160;<br/>been initialized by the&#160;va_start&#160;macro and perhaps&#160;va_arg&#160;calls. See the discussion&#160;<br/>of&#160;&lt;stdarg.h&gt;&#160;in&#160;<a href="">Section B.7. &#160;</a><br/>
<b>B.1.3 Formatted Input&#160;</b><br/>
The&#160;scanf&#160;function deals with formatted input conversion. &#160;<br/>&#160;<br/>int fscanf(FILE *stream, const char *format, ...)&#160;<br/>
fscanf&#160;reads from&#160;stream&#160;under control of&#160;format, and assigns converted values through&#160;<br/>subsequent arguments,&#160;<i>each of which must be a pointer</i>. It returns when&#160;format&#160;is exhausted.&#160;<br/>fscanf&#160;returns&#160;EOF&#160;if end of file or an error occurs before any conversion; otherwise it returns&#160;<br/>the number of input items converted and assigned. &#160;<br/>
The format string usually contains conversion specifications, which are used to direct&#160;<br/>interpretation of input. The format string may contain: &#160;<br/>
•&#160;&#160;Blanks or tabs, which are not ignored. &#160;<br/>
<hr/>
<a name=224></a>&#160;&#160;<br/>
224&#160;<br/>
•&#160;&#160;Ordinary characters (not %), which are expected to match the next non-white space&#160;<br/>
character of the input stream. &#160;<br/>
•&#160;&#160;Conversion specifications, consisting of a&#160;%, an optional assignment suppression&#160;<br/>
character&#160;*, an optional number specifying a maximum&#160;field width, an optional&#160;h,&#160;l, or&#160;<br/>L&#160;indicating the width of the target, and a conversion character. &#160;<br/>
A conversion specification determines the conversion of the next input field. Normally the&#160;<br/>result is placed in the variable pointed to by the corresponding argument. If assignment&#160;<br/>suppression is indicated by&#160;*, as in&#160;%*s, however, the input field is simply skipped; no&#160;<br/>assignment is made. An input field is defined as a string of non-white space characters; it&#160;<br/>extends either to the next white space character&#160;or until the field width, if specified, is&#160;<br/>exhausted. This implies that&#160;scanf&#160;will read across line boundaries to find its input, since&#160;<br/>newlines are white space. (White space characters are blank, tab, newline, carriage return,&#160;<br/>vertical tab, and formfeed.) &#160;<br/>
The conversion character indicates the interpretation of the input field. The corresponding&#160;<br/>argument must be a pointer. The legal conversion characters are shown in Table B.2. &#160;<br/>
The conversion characters&#160;d,&#160;&#160;i,&#160;&#160;n,&#160;&#160;o,&#160;&#160;u, and&#160;x&#160;may be preceded by&#160;h&#160;if&#160;the argument is a&#160;<br/>pointer to&#160;short&#160;rather than int, or by&#160;l&#160;(letter ell) if&#160;the argument is a pointer to&#160;long. The&#160;<br/>conversion characters&#160;e,&#160;&#160;f, and&#160;g&#160;may be preceded by&#160;l&#160;if a pointer to&#160;double&#160;rather than&#160;<br/>float&#160;is in the argument list, and by&#160;L&#160;if a pointer to a&#160;long double. &#160;<br/>
<i><b>Table B.2</b>&#160;Scanf Conversions</i>&#160;&#160;<br/>
<b>Character&#160;</b><br/>
<b>Input Data; Argument type &#160;</b><br/>
d&#160;<br/>
decimal integer;&#160;int*&#160;&#160;<br/>
integer;&#160;int*. The integer may be in octal (leading&#160;0) or hexadecimal (leading&#160;0x&#160;<br/>
i&#160;<br/>
or&#160;0X). &#160;<br/>
o&#160;<br/>
octal integer (with or without leading zero);&#160;int *. &#160;<br/>
u&#160;<br/>
unsigned decimal integer;&#160;unsigned int *. &#160;<br/>
x&#160;<br/>
hexadecimal integer (with or without leading&#160;0x&#160;or&#160;0X);&#160;int*. &#160;<br/>
characters;&#160;char*. The next input characters are placed in the indicated array, up&#160;<br/>to the number given by the width field; the default is 1. No&#160;'\0'&#160;is added. The&#160;<br/>
c&#160;<br/>
normal skip over white space characters is suppressed in this case; to read the next&#160;<br/>non-white space character, use&#160;%1s. &#160;<br/>
string of non-white space characters (not quoted);&#160;char *, pointing to an array of&#160;<br/>
s&#160;<br/>
characters large enough to hold the string and a terminating&#160;'\0'&#160;that will be&#160;<br/>added. &#160;<br/>
floating-point number;&#160;float *. The input format for&#160;float's is an optional sign,&#160;<br/>
e,f,g&#160;<br/>
a string of numbers possibly containing a&#160;decimal point, and an optional exponent&#160;<br/>field containing an&#160;E&#160;or&#160;e&#160;followed by a possibly signed integer. &#160;<br/>
p&#160;<br/>
pointer value as printed by&#160;printf(&#34;%p&#34;);,&#160;void *. &#160;<br/>
n&#160;<br/>
writes into the argument the number of&#160;characters read so far by this call;&#160;int *.&#160;<br/>No input is read. The converted item&#160;count is not incremented. &#160;<br/>
matches the longest non-empty string of input characters from&#160;the set between&#160;<br/>
[...]&#160;<br/>
brackets;&#160;char *. A&#160;'\0'&#160;is added.&#160;[]...]&#160;includes&#160;]&#160;in the set. &#160;<br/>
<hr/>
<a name=225></a>&#160;&#160;<br/>
225&#160;<br/>
matches the longest non-empty string of input characters&#160;<i>not</i>&#160;from&#160;the set between&#160;<br/>
[^...]&#160;<br/>
brackets;&#160;char *. A&#160;'\0'&#160;is added.&#160;[^]...]&#160;includes&#160;]&#160;in the set. &#160;<br/>
%&#160;<br/>
literal %; no assignment is made.&#160;<br/>
int scanf(const char *format, ...)&#160;&#160;<br/>
scanf(...)&#160;is identical to&#160;fscanf(stdin, ...). &#160;<br/>
int sscanf(const char *s, const char *format, ...)&#160;&#160;<br/>
sscanf(s, ...)&#160;is equivalent to&#160;scanf(...)&#160;except that the input characters are&#160;<br/>taken from&#160;the string&#160;s. &#160;<br/>
<b>B.1.4 Character Input and Output Functions&#160;</b><br/>
int fgetc(FILE *stream)&#160;&#160;<br/>
fgetc&#160;returns the next character of&#160;stream&#160;as an&#160;unsigned char&#160;(converted to an&#160;<br/>
int), or&#160;EOF&#160;if end of file or error occurs. &#160;<br/>
char *fgets(char *s, int n, FILE *stream)&#160;&#160;<br/>
fgets&#160;reads at most the next&#160;n-1&#160;characters into the array&#160;s, stopping if a newline is&#160;<br/>encountered; the newline is included in the array, which is terminated by&#160;'\0'.&#160;fgets&#160;<br/>returns&#160;s, or&#160;NULL&#160;if end of file or error occurs. &#160;<br/>
int fputc(int c, FILE *stream)&#160;&#160;<br/>
fputc&#160;writes the character&#160;c&#160;(converted to an&#160;unsigend char) on&#160;stream. It returns&#160;<br/>the character written, or&#160;EOF&#160;for error. &#160;<br/>
int fputs(const char *s, FILE *stream)&#160;&#160;<br/>
fputs&#160;writes the string&#160;s&#160;(which need not contain&#160;\n) on&#160;stream; it returns non-<br/>negative, or&#160;EOF&#160;for an error. &#160;<br/>
int getc(FILE *stream)&#160;&#160;<br/>
getc&#160;is equivalent to&#160;fgetc&#160;except that if&#160;it is a&#160;macro, it may evaluate&#160;stream&#160;more&#160;<br/>than once. &#160;<br/>
int getchar(void)&#160;&#160;<br/>
getchar&#160;is equivalent to&#160;getc(stdin). &#160;<br/>
char *gets(char *s)&#160;&#160;<br/>
gets&#160;reads the next input line into the array&#160;s; it replaces the terminating newline with&#160;<br/>
'\0'. It returns&#160;s, or&#160;NULL&#160;if end of file or error occurs. &#160;<br/>
int putc(int c, FILE *stream)&#160;&#160;<br/>
putc&#160;is equivalent to&#160;fputc&#160;except that if&#160;it is a&#160;macro, it may evaluate&#160;stream&#160;more&#160;<br/>than once. &#160;<br/>
int putchar(int c)&#160;&#160;<br/>
putchar(c)&#160;is equivalent to&#160;putc(c,stdout). &#160;<br/>
int puts(const char *s)&#160;&#160;<br/>
puts&#160;writes the string&#160;s&#160;and a newline to&#160;stdout. It returns&#160;EOF&#160;if an error occurs,&#160;<br/>non-negative otherwise. &#160;<br/>
int ungetc(int c, FILE *stream)&#160;&#160;<br/>
ungetc&#160;pushes&#160;c&#160;(converted to an&#160;unsigned char) back onto&#160;stream, where it will be&#160;<br/>returned on the next read. Only one character of pushback per stream&#160;is guaranteed.&#160;<br/>EOF&#160;may not be pushed back.&#160;ungetc&#160;returns the character pushed back, or&#160;EOF&#160;for&#160;<br/>error. &#160;<br/>
<b>B.1.5 Direct Input and Output Functions&#160;</b><br/>
size_t fread(void *ptr, size_t size, size_t nobj, FILE *stream)&#160;&#160;<br/>
fread&#160;reads from&#160;stream&#160;into the array&#160;ptr&#160;at most&#160;nobj&#160;objects of size&#160;size.&#160;fread&#160;<br/>returns the number of objects read; this may be less than the number requested.&#160;feof&#160;<br/>and&#160;ferror&#160;must be used to determine status. &#160;<br/>
size_t fwrite(const void *ptr, size_t size, size_t nobj, FILE *stream)&#160;&#160;<br/>
<hr/>
<a name=226></a>&#160;&#160;<br/>
226&#160;<br/>
fwrite&#160;writes, from&#160;the array&#160;ptr,&#160;nobj&#160;objects of size&#160;size&#160;on&#160;stream. It returns the&#160;<br/>number of&#160;objects written, which is less than&#160;nobj&#160;on error. &#160;<br/>
<b>B.1.6 File Positioning Functions&#160;</b><br/>
int fseek(FILE *stream, long offset, int origin)&#160;&#160;<br/>
fseek&#160;sets the file position for&#160;stream; a subsequent read or write will access data&#160;<br/>beginning at the new position. For a binary file, the position is set to&#160;offset&#160;<br/>characters from&#160;origin, which may be&#160;SEEK_SET&#160;(beginning),&#160;SEEK_CUR&#160;(current&#160;<br/>position), or&#160;SEEK_END&#160;(end of file). For a text stream,&#160;offset&#160;must be zero, or a value&#160;<br/>returned by&#160;ftell&#160;(in which case&#160;origin&#160;must&#160;be&#160;SEEK_SET).&#160;fseek&#160;returns non-zero&#160;<br/>on error. &#160;<br/>
long ftell(FILE *stream)&#160;&#160;<br/>
ftell&#160;returns the current file position for&#160;stream, or&#160;-1&#160;on error. &#160;<br/>
void rewind(FILE *stream)&#160;&#160;<br/>
rewind(fp)&#160;is equivalent to&#160;fseek(fp, 0L, SEEK_SET); clearerr(fp). &#160;<br/>
int fgetpos(FILE *stream, fpos_t *ptr)&#160;&#160;<br/>
fgetpos&#160;records the current position in&#160;stream&#160;in&#160;*ptr, for subsequent use by&#160;<br/>
fsetpos. The type&#160;fpos_t&#160;is suitable for recording such values.&#160;fgetpos&#160;returns non-<br/>zero on error. &#160;<br/>
int fsetpos(FILE *stream, const fpos_t *ptr)&#160;&#160;<br/>
fsetpos&#160;positions&#160;stream&#160;at the position recorded by&#160;fgetpos&#160;in&#160;*ptr.&#160;&#160;fsetpos&#160;<br/>returns non-zero on error. &#160;<br/>
<b>B.1.7 Error Functions&#160;</b><br/>
Many of&#160;the functions in the library set status indicators when error or end of file occur. These&#160;<br/>indicators may be set and tested explicitly. In addition, the integer expression&#160;errno&#160;(declared&#160;<br/>in&#160;&#160;&lt;errno.h&gt;) may contain an error number that gives further information about the most&#160;<br/>recent error. &#160;<br/>void clearerr(FILE *stream)&#160;&#160;<br/>
clearerr&#160;clears the end of file and error indicators for&#160;stream. &#160;<br/>
int feof(FILE *stream)&#160;&#160;<br/>
feof&#160;returns non-zero if the end of file indicator for&#160;stream&#160;is set. &#160;<br/>
int ferror(FILE *stream)&#160;&#160;<br/>
ferror&#160;returns non-zero if the error indicator for&#160;stream&#160;is set. &#160;<br/>
void perror(const char *s)&#160;&#160;<br/>
perror(s)&#160;prints&#160;s&#160;and an implementation-defined error message corresponding to&#160;<br/>the integer in&#160;errno, as if by &#160;<br/>
&#160; &#160;&#160;fprintf(stderr, &#34;%s: %s\n&#34;, s, &#34;<i>error message</i>&#34;);&#160;&#160;<br/>
See&#160;strerror&#160;in&#160;<a href="">Section B.3. &#160;</a><br/>
<b>B.2 Character Class Tests: &lt;ctype.h&gt;&#160;</b><br/>
The header&#160;&lt;ctype.h&gt;&#160;declares functions for testing&#160;characters. For each function, the&#160;<br/>argument list is an&#160;int, whose value must be&#160;EOF&#160;or representable as an&#160;unsigned char, and&#160;<br/>the return value is an&#160;int. The functions return non-zero (true) if the argument&#160;c&#160;satisfies the&#160;<br/>condition described, and zero if not. &#160;<br/>
isalnum(c)&#160;&#160;isalpha(c)&#160;or&#160;isdigit(c)&#160;is true&#160;<br/>
isalpha(c)&#160;&#160;isupper(c)&#160;or&#160;islower(c)&#160;is true&#160;<br/>
<hr/>
<a name=227></a>&#160;&#160;<br/>
227&#160;<br/>
iscntrl(c)&#160;&#160;control character&#160;<br/>
isdigit(c)&#160;&#160;decimal digit&#160;<br/>
isgraph(c)&#160;&#160;printing character except space&#160;<br/>
islower(c)&#160;&#160;lower-case letter&#160;<br/>
isprint(c)&#160;&#160;printing character including space&#160;<br/>
ispunct(c)&#160;&#160;printing character except space or letter or digit&#160;<br/>
isspace(c)&#160;&#160;space, formfeed, newline, carriage return, tab, vertical tab&#160;<br/>
isupper(c)&#160;&#160;upper-case letter&#160;<br/>
isxdigit(c)&#160;&#160;hexadecimal digit&#160;<br/>
In the seven-bit ASCII character set, the printing characters are&#160;0x20 ('&#160;')&#160;to&#160;0x7E ('-');&#160;<br/>the control characters are 0&#160;NUL&#160;to&#160;0x1F&#160;(US), and&#160;0x7F&#160;(DEL). &#160;<br/>
In addition, there are two functions that convert the case of letters: &#160;<br/>
int tolower(c)&#160;convert&#160;c&#160;to lower case<br/>
int toupper(c)&#160;convert&#160;c&#160;to upper case<br/>
If&#160;&#160;c&#160;is an upper-case letter,&#160;tolower(c)&#160;returns the corresponding lower-case letter,&#160;<br/>toupper(c)&#160;returns the corresponding upper-case letter; otherwise it returns&#160;c. &#160;<br/>
<b>B.3 String Functions: &lt;string.h&gt;&#160;</b><br/>
There are two groups of string functions defined in the header&#160;&lt;string.h&gt;. The first have&#160;<br/>names beginning with&#160;str; the second have names beginning with&#160;mem. Except for&#160;memmove,&#160;<br/>the behavior is undefined if copying takes&#160;place between overlapping objects. Comparison&#160;<br/>functions treat arguments as&#160;unsigned char&#160;arrays. &#160;<br/>
In the following table, variables&#160;s&#160;and&#160;t&#160;are of type&#160;char *;&#160;&#160;cs&#160;and&#160;ct&#160;are of type&#160;const&#160;<br/>char *;&#160;n&#160;is of type&#160;size_t; and&#160;c&#160;is an&#160;int&#160;converted to&#160;char. &#160;<br/>
char *strcpy(s,ct)&#160;&#160;copy string&#160;ct&#160;to string&#160;s, including&#160;'\0'; return&#160;s.&#160;<br/>
char&#160;<br/>
copy at most&#160;n&#160;characters of string&#160;ct&#160;to&#160;s; return&#160;s. Pad with&#160;'\0''s&#160;<br/>
*strncpy(s,ct,n)&#160;<br/>
if&#160;ct&#160;has fewer than&#160;n&#160;characters.&#160;<br/>
char *strcat(s,ct)&#160;&#160;concatenate string&#160;ct&#160;to end of string&#160;s; return&#160;s.&#160;<br/>
char&#160;<br/>
concatenate at most&#160;n&#160;characters of string&#160;ct&#160;to string&#160;s, terminate&#160;s&#160;<br/>
*strncat(s,ct,n)&#160;<br/>
with&#160;'\0'; return&#160;s.&#160;<br/>
compare string&#160;cs&#160;to string&#160;ct, return &lt;0 if&#160;cs&lt;ct, 0 if&#160;cs==ct, or &gt;0&#160;<br/>
int strcmp(cs,ct)&#160;<br/>
if&#160;cs&gt;ct.&#160;<br/>
int&#160;<br/>
compare at most&#160;n&#160;characters of string&#160;cs&#160;to string&#160;ct; return &lt;0 if&#160;<br/>
strncmp(cs,ct,n)&#160;<br/>
cs&lt;ct, 0 if&#160;cs==ct, or &gt;0 if&#160;cs&gt;ct.&#160;<br/>
char *strchr(cs,c)&#160;&#160;return pointer to first occurrence of&#160;c&#160;in&#160;cs&#160;or&#160;NULL&#160;if not present.&#160;<br/>
char *strrchr(cs,c)&#160;&#160;return pointer to last occurrence of&#160;c&#160;in&#160;cs&#160;or&#160;NULL&#160;if not present.&#160;<br/>
size_t&#160;<br/>strspn(cs,ct)&#160;<br/>
return length of prefix of&#160;cs&#160;consisting of characters in&#160;ct.&#160;<br/>
<hr/>
<a name=228></a>&#160;&#160;<br/>
228&#160;<br/>
size_t&#160;<br/>strcspn(cs,ct)&#160;<br/>
return length of prefix of&#160;cs&#160;consisting of characters&#160;<i>not</i>&#160;in&#160;ct.&#160;<br/>
char&#160;<br/>
return pointer to first occurrence in string&#160;cs&#160;of any character string&#160;<br/>
*strpbrk(cs,ct)&#160;<br/>
ct, or&#160;NULL&#160;if not present.&#160;<br/>
return pointer to first occurrence of string&#160;ct&#160;in&#160;cs, or&#160;NULL&#160;if not&#160;<br/>
char *strstr(cs,ct)&#160;&#160;present.&#160;<br/>size_t strlen(cs)&#160;<br/>
return length of&#160;cs.&#160;<br/>
return pointer to implementation-defined string corresponding to&#160;<br/>
char *strerror(n)&#160;<br/>
error&#160;n.&#160;<br/>
char *strtok(s,ct)&#160;&#160;strtok&#160;searches&#160;s&#160;for tokens delimited by characters from&#160;ct; see&#160;<br/>
below.&#160;<br/>
A sequence of calls of&#160;strtok(s,ct)&#160;splits&#160;s&#160;into tokens, each delimited by a character from&#160;<br/>ct. The first call in a sequence has a non-NULL s, it finds the first token in&#160;s&#160;consisting of&#160;<br/>characters not in&#160;ct; it terminates that by overwriting the next character of&#160;s&#160;with&#160;'\0'&#160;and&#160;<br/>returns a pointer to the token. Each subsequent call, indicated by a&#160;NULL&#160;value of&#160;s, returns the&#160;<br/>next such token, searching from&#160;just&#160;past the end of the previous one.&#160;strtok&#160;returns&#160;NULL&#160;<br/>when no further token is found. The string&#160;ct&#160;may be different on each call. &#160;<br/>
The&#160;mem...&#160;functions are meant for manipulating objects as character arrays; the intent is an&#160;<br/>interface to efficient routines. In the following table,&#160;s&#160;and&#160;t&#160;are of type&#160;void *;&#160;cs&#160;and&#160;ct&#160;<br/>are of type&#160;const void *;&#160;&#160;n&#160;is of type&#160;size_t; and&#160;c&#160;is an&#160;int&#160;converted to an&#160;unsigned&#160;<br/>char. &#160;<br/>
void&#160;<br/>*memcpy(s,ct,n)&#160;<br/>
copy&#160;n&#160;characters from&#160;ct&#160;to&#160;s, and return&#160;s.&#160;<br/>
void&#160;<br/>*memmove(s,ct,n)&#160;<br/>
same as&#160;memcpy&#160;except that it works even if the objects overlap.&#160;<br/>
int memcmp(cs,ct,n)&#160;&#160;compare the first&#160;n&#160;characters of&#160;cs&#160;with&#160;ct; return as with&#160;strcmp.&#160;<br/>
void&#160;<br/>
return pointer to first occurrence of character&#160;c&#160;in&#160;cs, or&#160;NULL&#160;if not&#160;<br/>
*memchr(cs,c,n)&#160;<br/>
present among the first&#160;n&#160;characters.&#160;<br/>
void *memset(s,c,n)&#160;&#160;place character&#160;c&#160;into first&#160;n&#160;characters of&#160;s, return&#160;s.&#160;<br/>
<b>B.4 Mathematical Functions: &lt;math.h&gt;&#160;</b><br/>
The header&#160;&lt;math.h&gt;&#160;declares mathematical functions and macros. &#160;<br/>
The macros&#160;EDOM&#160;and&#160;ERANGE&#160;(found in&#160;&lt;errno.h&gt;) are non-zero integral constants that are&#160;<br/>used to signal domain and range errors for the functions;&#160;HUGE_VAL&#160;is a positive&#160;double&#160;<br/>value. A&#160;<i>domain error</i>&#160;occurs if an argument is outside&#160;the domain over which the function is&#160;<br/>defined. On a domain error,&#160;errno&#160;is set to&#160;EDOM; the return value is implementation-defined.&#160;<br/>A&#160;&#160;<i>range error</i>&#160;occurs if the result of the function cannot be represented as a&#160;double. If the&#160;<br/>result overflows, the function returns&#160;HUGE_VAL&#160;with the right sign, and&#160;errno&#160;is set to&#160;<br/>ERANGE. If the result underflows, the&#160;function returns zero; whether&#160;errno&#160;is set to&#160;ERANGE&#160;is&#160;<br/>implementation-defined. &#160;<br/>
In the following table,&#160;x&#160;and&#160;y&#160;are of type&#160;double,&#160;&#160;n&#160;is an&#160;int, and all functions return&#160;<br/>double. Angles for trigonometric functions are expressed in radians. &#160;<br/>
<hr/>
<a name=229></a>&#160;&#160;<br/>
229&#160;<br/>
sin(x)&#160;&#160;<br/>
sine of&#160;<i>x</i>&#160;<br/>
cos(x)&#160;&#160;<br/>
cosine of&#160;<i>x</i>&#160;<br/>
tan(x)&#160;&#160;<br/>
tangent of&#160;<i>x</i>&#160;<br/>
asin(x)&#160;&#160;<br/>
sin-1(x) in range [-pi/2,pi/2],&#160;x in [-1,1].&#160;<br/>
acos(x)&#160;&#160;<br/>
cos-1(x) in range [0,pi], x in [-1,1].&#160;<br/>
atan(x)&#160;&#160;<br/>
tan-1(x) in range [-pi/2,pi/2].&#160;<br/>
atan2(y,x)&#160;<br/>
tan-1(y/x) in range [-pi,pi].&#160;<br/>
sinh(x)&#160;&#160;<br/>
hyperbolic sine of&#160;<i>x</i>&#160;<br/>
cosh(x)&#160;&#160;<br/>
hyperbolic cosine of&#160;<i>x</i>&#160;<br/>
tanh(x)&#160;&#160;<br/>
hyperbolic tangent of&#160;<i>x</i>&#160;<br/>
exp(x)&#160;&#160;<br/>
exponential function&#160;<i>ex</i>&#160;<br/>
log(x)&#160;&#160;<br/>
natural logarithm&#160;ln(x),&#160;<i>x</i>&gt;0.&#160;<br/>
log10(x)&#160;&#160;<br/>
base 10 logarithm&#160;log10(x),&#160;<i>x</i>&gt;0.&#160;<br/>
<i>xy</i>. A domain error occurs if&#160;<i>x=0</i>&#160;and&#160;<i>y&lt;=0</i>, or if&#160;<i>x&lt;0</i>&#160;and&#160;<i>y</i>&#160;is not an&#160;<br/>
pow(x,y)&#160;&#160;<br/>
integer.&#160;<br/>
sqrt(x)&#160;&#160;<br/>
sqare root of x, x&gt;=0.&#160;<br/>
ceil(x)&#160;&#160;<br/>
smallest integer not less than&#160;x, as a&#160;double.&#160;<br/>
floor(x)&#160;&#160;<br/>
largest integer not greater than&#160;x, as a&#160;double.&#160;<br/>
fabs(x)&#160;&#160;<br/>
absolute value |x|&#160;<br/>
ldexp(x,n)&#160;<br/>
x*2n&#160;<br/>
splits&#160;<i>x</i>&#160;into a normalized fraction in the interval [1/2,1) which is returned,&#160;<br/>
frexp(x, int&#160;<br/>
and a power of 2, which is stored in&#160;*exp. If&#160;<i>x</i>&#160;is zero, both parts of the&#160;<br/>
*ip)&#160;<br/>
result are zero.&#160;<br/>
modf(x,&#160;<br/>
splits&#160;<i>x</i>&#160;into integral and fractional parts, each with the same sign as&#160;<i>x</i>. It&#160;<br/>
double *ip)&#160;<br/>
stores the integral part in&#160;*ip, and returns the fractional part.&#160;<br/>
floating-point remainder of&#160;<i>x/y</i>, with the same sign as&#160;<i>x</i>. If&#160;<i>y</i>&#160;is zero, the&#160;<br/>
fmod(x,y)&#160;<br/>
result is implementation-defined. &#160;<br/>
<b>B.5 Utility Functions: &lt;stdlib.h&gt;&#160;</b><br/>
The header&#160;&lt;stdlib.h&gt;&#160;declares functions for number conversion, storage allocation, and&#160;<br/>similar tasks.&#160;double atof(const char *s)&#160;&#160;<br/>
atof&#160;converts&#160;s&#160;to&#160;double; it is equivalent to&#160;strtod(s, (char**)NULL). &#160;<br/>
int atoi(const char *s)&#160;&#160;<br/>
converts&#160;s&#160;to&#160;int; it is equivalent to&#160;(int)strtol(s, (char**)NULL, 10). &#160;<br/>
long atol(const char *s)&#160;&#160;<br/>
converts&#160;s&#160;to&#160;long; it is equivalent to&#160;strtol(s, (char**)NULL, 10). &#160;<br/>
double strtod(const char *s, char **endp)&#160;&#160;<br/>
strtod&#160;converts the prefix of&#160;s&#160;to&#160;double, ignoring leading white space; it stores a&#160;<br/>pointer to any unconverted suffix in&#160;*endp&#160;unless&#160;endp&#160;is&#160;NULL. If the answer would&#160;<br/>overflow,&#160;HUGE_VAL&#160;is returned with the proper sign;&#160;if the answer would underflow,&#160;<br/>zero is returned. In either case&#160;errno&#160;is set to&#160;ERANGE. &#160;<br/>
long strtol(const char *s, char **endp, int base)&#160;&#160;<br/>
strtol&#160;converts the prefix of&#160;s&#160;to&#160;long, ignoring leading white space; it stores a&#160;<br/>pointer to any unconverted suffix in&#160;*endp&#160;unless&#160;endp&#160;is&#160;NULL. If&#160;base&#160;is between 2&#160;<br/>
<hr/>
<a name=230></a>230<br/>
and 36, conversion is done assuming that the input is written in that base. If&#160;base&#160;is&#160;<br/>zero, the base is 8, 10, or 16; leading 0 implies octal and leading&#160;0x&#160;or&#160;0X&#160;<br/>hexadecimal. Letters in either case represent digits from&#160;10 to&#160;base-1; a leading&#160;0x&#160;or&#160;<br/>0X&#160;is permitted in base 16. If&#160;the answer would overflow,&#160;LONG_MAX&#160;or&#160;LONG_MIN&#160;is&#160;<br/>returned, depending on the sign of the result, and&#160;errno&#160;is set to&#160;ERANGE. &#160;<br/>
unsigned long strtoul(const char *s, char **endp, int base)<br/>
strtoul&#160;is the same as&#160;strtol&#160;except that the result is&#160;unsigned long&#160;and the error&#160;<br/>value is&#160;ULONG_MAX. &#160;<br/>
int rand(void)<br/>
rand&#160;returns a pseudo-random&#160;integer in the range 0 to&#160;RAND_MAX, which is at least&#160;<br/>32767. &#160;<br/>
void srand(unsigned int seed)<br/>
srand&#160;uses&#160;seed&#160;as the seed for a new sequence of pseudo-random&#160;numbers. The&#160;<br/>initial seed is 1. &#160;<br/>
void *calloc(size_t nobj, size_t size)<br/>
calloc&#160;returns a pointer to space for an array of&#160;nobj&#160;objects, each of size&#160;size, or&#160;<br/>
NULL&#160;if the request cannot be satisfied. The space is initialized to zero bytes. &#160;<br/>
void *malloc(size_t size)<br/>
malloc&#160;returns a pointer to space for an object of size&#160;size, or&#160;NULL&#160;if&#160;the request&#160;<br/>cannot be satisfied. The space is uninitialized. &#160;<br/>
void *realloc(void *p, size_t size)<br/>
realloc&#160;changes the size of the object pointed to by&#160;p&#160;to&#160;size. The contents will be&#160;<br/>unchanged up to the minimum&#160;of the old and&#160;new sizes. If the new size is larger, the&#160;<br/>new space is uninitialized.&#160;realloc&#160;returns a pointer to the new space, or&#160;NULL&#160;if&#160;the&#160;<br/>request cannot be satisfied, in which case&#160;*p&#160;is unchanged. &#160;<br/>
void free(void *p)<br/>
free&#160;deallocates the space pointed to by&#160;p; it does nothing if&#160;p&#160;is&#160;NULL.&#160;&#160;p&#160;must&#160;be&#160;a&#160;<br/>pointer to space previously allocated by&#160;calloc,&#160;malloc, or&#160;realloc. &#160;<br/>
void abort(void)<br/>
abort&#160;causes the program&#160;to terminate abnormally, as if by&#160;raise(SIGABRT). &#160;<br/>
void exit(int status)<br/>
exit&#160;causes normal program&#160;termination.&#160;atexit&#160;functions are called in reverse order&#160;<br/>of registration, open files are flushed, open&#160;streams are closed, and control is returned&#160;<br/>to the environment. How&#160;status&#160;is returned to the environment is implementation-<br/>dependent, but zero is taken as successful termination. The values&#160;EXIT_SUCCESS&#160;and&#160;<br/>EXIT_FAILURE&#160;may also be used. &#160;<br/>
int atexit(void (*fcn)(void))<br/>
atexit&#160;registers the function&#160;fcn&#160;to be called when the program&#160;terminates normally;&#160;<br/>it returns non-zero if the registration cannot be made. &#160;<br/>
int system(const char *s)<br/>
system&#160;passes the string&#160;s&#160;to the environment for execution. If&#160;s&#160;is&#160;NULL,&#160;&#160;system&#160;<br/>returns non-zero if there is a command processor. If&#160;s&#160;is not&#160;NULL, the return value is&#160;<br/>implementation-dependent. &#160;<br/>
char *getenv(const char *name)<br/>
getenv&#160;returns the environment string associated with&#160;name, or&#160;NULL&#160;if no string&#160;<br/>exists. Details are implementation-dependent. &#160;<br/>
void *bsearch(const void *key, const void *base,&#160;<br/>
size_t n, size_t size,&#160;<br/>int (*cmp)(const void *keyval, const void *datum))&#160;<br/>
bsearch&#160;searches&#160;base[0]...base[n-1]&#160;for an item&#160;that matches&#160;*key. The function&#160;<br/>
cmp&#160;must return negative if its first argument (the search key) is less than its second (a&#160;<br/>table entry), zero if&#160;equal, and positive if&#160;greater. Items in the array&#160;base&#160;must&#160;be&#160;in&#160;<br/>ascending order.&#160;bsearch&#160;returns a pointer to a matching item,&#160;or&#160;NULL&#160;if none exists. &#160;<br/>
<hr/>
<a name=231></a>&#160;&#160;<br/>
231&#160;<br/>
&#160;<br/>void qsort(void *base, size_t n, size_t size,&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;int (*cmp)(const void *, const void *))&#160;<br/>
qsort&#160;sorts into ascending order an array&#160;base[0]...base[n-1]&#160;of objects of size&#160;<br/>
size. The comparison function&#160;cmp&#160;is as in&#160;bsearch. &#160;<br/>
int abs(int n)&#160;&#160;<br/>
abs&#160;returns the absolute value of&#160;its&#160;int&#160;argument. &#160;<br/>
long labs(long n)&#160;&#160;<br/>
labs&#160;returns the absolute value of&#160;its&#160;long&#160;argument. &#160;<br/>
div_t div(int num, int denom)&#160;&#160;<br/>
div&#160;computes the quotient and remainder of&#160;num/denom. The results are stored in the&#160;<br/>
int&#160;members&#160;quot&#160;and&#160;rem&#160;of a structure of type&#160;div_t. &#160;<br/>
ldiv_t ldiv(long num, long denom)&#160;&#160;<br/>
ldiv&#160;computes the quotient and remainder of&#160;num/denom. The results are stored in the&#160;<br/>
long&#160;members&#160;quot&#160;and&#160;rem&#160;of a structure of type&#160;ldiv_t. &#160;<br/>
<b>B.6 Diagnostics: &lt;assert.h&gt;&#160;</b><br/>
The&#160;assert&#160;macro is used to add diagnostics to programs: &#160;<br/>
&#160;&#160;void assert(int&#160;<i>expression</i>)&#160;&#160;<br/>
If&#160;<i>expression</i>&#160;is zero when &#160;<br/>
&#160;&#160;assert(<i>expression</i>)&#160;&#160;<br/>
is executed, the&#160;assert&#160;macro will print on&#160;stderr&#160;a message, such as &#160;<br/>
&#160;&#160;Assertion failed:&#160;<i>expression</i>,&#160;file&#160;<i>filename</i>,&#160;line&#160;<i>nnn</i>&#160;&#160;<br/>
It then calls&#160;abort&#160;to terminate execution. The source filename and line number come from&#160;<br/>the preprocessor macros&#160;__FILE__&#160;and&#160;__LINE__. &#160;<br/>
If&#160;NDEBUG&#160;is defined at the time&#160;&lt;assert.h&gt;&#160;is included, the assert macro is ignored. &#160;<br/>
<b>B.7 Variable Argument Lists: &lt;stdarg.h&gt;&#160;</b><br/>
The header&#160;&lt;stdarg.h&gt;&#160;provides facilities for stepping through a list of function arguments&#160;<br/>of unknown number and type. &#160;<br/>
Suppose&#160;&#160;lastarg&#160;is the last named parameter of a function&#160;f&#160;with a variable number of&#160;<br/>arguments. Then declare within&#160;f&#160;a variable of type&#160;va_list&#160;that will point to each argument&#160;<br/>in turn: &#160;<br/>
&#160;<br/>&#160; &#160;va_list ap;&#160;<br/>
ap&#160;must be initialized once with the macro&#160;va_start&#160;before any unnamed argument is&#160;<br/>accessed: &#160;<br/>
&#160;&#160;va_start(va_list ap,&#160;<i>lastarg</i>);&#160;&#160;<br/>
<hr/>
<a name=232></a>&#160;&#160;<br/>
232&#160;<br/>
Thereafter, each execution of the macro&#160;va_arg&#160;will produce a value that has the type and&#160;<br/>value of the next unnamed argument, and will also modify&#160;ap&#160;so the next use of&#160;va_arg&#160;<br/>returns the next argument: &#160;<br/>
&#160;&#160;<i>type</i>&#160;va_arg(va_list ap,&#160;<i>type</i>);&#160;&#160;<br/>
The macro &#160;<br/>
&#160;<br/>&#160; &#160;void va_end(va_list ap);&#160;<br/>
must be called once after the arguments have been processed but before&#160;f&#160;is exited. &#160;<br/>
<b>B.8 Non-local Jumps: &lt;setjmp.h&gt;&#160;</b><br/>
The declarations in&#160;&lt;setjmp.h&gt;&#160;provide a way to avoid the normal function call and return&#160;<br/>sequence, typically to permit an immediate return from&#160;a deeply nested function call. &#160;<br/>int setjmp(jmp_buf env)&#160;&#160;<br/>
The macro&#160;setjmp&#160;saves state information in&#160;env&#160;for use by&#160;longjmp. The return is&#160;<br/>zero from&#160;a direct call of&#160;setjmp, and non-zero from&#160;a subsequent call of&#160;longjmp. A&#160;<br/>call to&#160;setjmp&#160;can only occur in certain contexts, basically the test of&#160;if,&#160;switch, and&#160;<br/>loops, and only in simple relational expressions. &#160;<br/>
&#160;<br/>&#160; &#160; &#160; if (setjmp(env) == 0)&#160;<br/>&#160; &#160; &#160; &#160; &#160; /* get here on direct call */&#160;<br/>&#160; &#160; &#160; else&#160;<br/>&#160; &#160; &#160; &#160; &#160; /* get here by calling longjmp */&#160;<br/>void longjmp(jmp_buf env, int val)&#160;&#160;<br/>
longjmp&#160;restores the state saved by the most recent call to&#160;setjmp, using the&#160;<br/>information saved in&#160;env, and execution resumes as if the&#160;setjmp&#160;function had just&#160;<br/>executed and returned the non-zero value&#160;val. The function containing the&#160;setjmp&#160;<br/>must not have terminated. Accessible objects have the values they had at the time&#160;<br/>longjmp&#160;was called, except that non-volatile&#160;automatic variables in the function&#160;<br/>calling&#160;setjmp&#160;become&#160;undefined if they were changed after the&#160;setjmp&#160;call. &#160;<br/>
<b>B.9 Signals: &lt;signal.h&gt;&#160;</b><br/>
The header&#160;&lt;signal.h&gt;&#160;provides facilities for handling exceptional conditions that arise&#160;<br/>during execution, such as an interrupt signal from&#160;an external source or an error in execution. &#160;<br/>&#160;<br/>void (*signal(int sig, void (*handler)(int)))(int)&#160;<br/>
signal&#160;determines how subsequent signals will be handled. If&#160;handler&#160;is&#160;SIG_DFL, the&#160;<br/>implementation-defined default behavior is used, if it is&#160;SIG_IGN, the signal is ignored;&#160;<br/>otherwise, the function pointed to by&#160;handler&#160;will be called, with the argument of&#160;the type of&#160;<br/>signal. Valid signals include &#160;<br/>
SIGABRT&#160;<br/>
abnormal termination, e.g., from&#160;abort&#160;<br/>
SIGFPE&#160;&#160;<br/>
arithmetic error, e.g., zero divide or overflow&#160;<br/>
SIGILL&#160;&#160;<br/>
illegal function image, e.g., illegal instruction&#160;<br/>
SIGINT&#160;&#160;<br/>
interactive attention, e.g., interrupt&#160;<br/>
SIGSEGV&#160;<br/>
illegal storage access, e.g., access outside memory limits&#160;<br/>
SIGTERM &#160;&#160;&#160;termination request sent to this program&#160;<br/>
<hr/>
<a name=233></a>&#160;&#160;<br/>
233&#160;<br/>
&#160;<br/>
&#160;<br/>
signal&#160;returns the previous value of&#160;handler&#160;for the specific signal, or&#160;SIG_ERR&#160;if an error&#160;<br/>occurs. &#160;<br/>
When a signal&#160;sig&#160;subsequently occurs, the signal is restored to its default behavior; then the&#160;<br/>signal-handler function is called, as if by&#160;(*handler)(sig). If the handler returns, execution&#160;<br/>will resume where it was when the signal occurred. &#160;<br/>
The initial state of&#160;signals is implementation-defined. &#160;<br/>
&#160;<br/>int raise(int sig)&#160;<br/>
raise&#160;sends the signal&#160;sig&#160;to the program; it returns non-zero if unsuccessful. &#160;<br/>
<b>B.10 Date and Time Functions: &lt;time.h&gt;&#160;</b><br/>
The header&#160;&lt;time.h&gt;&#160;declares types and functions for&#160;manipulating date and time. Some&#160;<br/>functions process&#160;<i>local time</i>, which may differ from&#160;calendar&#160;time, for example because of&#160;<br/>time zone.&#160;clock_t&#160;and&#160;time_t&#160;are arithmetic types representing times, and&#160;struct tm&#160;holds&#160;<br/>the components of a calendar time: &#160;<br/>
int tm_sec;&#160;&#160;&#160;seconds after the minute (0,61)<br/>
int tm_min;&#160;&#160;&#160;minutes after the hour (0,59)&#160;<br/>
int tm_hour;&#160;&#160;hours since midnight (0,23)&#160;<br/>
int tm_mday;&#160;&#160;day of the month (1,31)&#160;<br/>
int tm_mon;&#160;&#160;&#160;months&#160;<i>since</i>&#160;January (0,11)&#160;<br/>
int tm_year;&#160;&#160;years since 1900&#160;<br/>
int tm_wday;&#160;&#160;days since Sunday (0,6)&#160;<br/>
int tm_yday;&#160;&#160;days since January 1 (0,365)&#160;<br/>
int tm_isdst;&#160;Daylight Saving Time&#160;flag&#160;<br/>
tm_isdst&#160;is positive if&#160;Daylight Saving Time is in&#160;effect, zero if&#160;not, and negative if&#160;the&#160;<br/>information is not available. &#160;<br/>
clock_t clock(void)&#160;&#160;<br/>
clock&#160;returns the processor time used by&#160;the program&#160;since the beginning of&#160;<br/>execution, or&#160;-1&#160;if unavailable.&#160;clock()/CLK_PER_SEC&#160;is a time in seconds. &#160;<br/>
time_t time(time_t *tp)&#160;&#160;<br/>
time&#160;returns the current calendar time or&#160;-1&#160;if&#160;the time is not available. If&#160;tp&#160;is not&#160;<br/>
NULL, the return value is also assigned to&#160;*tp. &#160;<br/>
double difftime(time_t time2, time_t time1)&#160;&#160;<br/>
difftime&#160;returns&#160;time2-time1&#160;expressed in seconds. &#160;<br/>
time_t mktime(struct tm *tp)&#160;&#160;<br/>
mktime&#160;converts the local time in the structure&#160;*tp&#160;into calendar time in the same&#160;<br/>representation used by&#160;time. The components will have values in the ranges shown.&#160;<br/>mktime&#160;returns the calendar time or&#160;-1&#160;if it cannot be represented. &#160;<br/>
The next four functions return pointers to static objects that may be overwritten by other calls. &#160;<br/>char *asctime(const struct tm *tp)&#160;&#160;<br/>
<hr/>
<a name=234></a>&#160;&#160;<br/>
234&#160;<br/>
asctime&lt;/tt&lt;&#160;converts&#160;the&#160;time&#160;in the structure *tp into a string of&#160;<br/>the form &#160;<br/>&#160;<br/>&#160; &#160; &#160; Sun Jan &#160;3 15:14:13 1988\n\0&#160;<br/>
char *ctime(const time_t *tp) &#160;<br/>
ctime&#160;converts&#160;the&#160;calendar&#160;time *tp to local time; it is equivalent&#160;<br/>to &#160;<br/>&#160;<br/>&#160; &#160; &#160; asctime(localtime(tp)) &#160;<br/>
struct tm *gmtime(const time_t *tp) &#160;<br/>
gmtime&#160;converts&#160;the&#160;calendar&#160;time *tp into Coordinated Universal Time&#160;<br/>(UTC). It returns NULL if UTC is&#160;not&#160;available.&#160;The&#160;name&#160;gmtime&#160;has&#160;<br/>historical significance. &#160;<br/>
struct tm *localtime(const time_t *tp) &#160;<br/>
localtime converts the calendar time *tp into local time. &#160;<br/>
size_t strftime(char *s, size_t smax, const char *fmt, const struct tm *tp) &#160;<br/>
strftime formats date and time information from *tp into&#160;s&#160;according&#160;<br/>to fmt, which is analogous to a printf format.&#160;Ordinary&#160;characters&#160;<br/>(including the terminating '\0') are copied into s. Each&#160;%c&#160;is&#160;<br/>replaced as described below, using values appropriate&#160;for&#160;the&#160;local&#160;<br/>environment. No more than smax characters are placed into&#160;s.&#160;strftime&#160;<br/>returns&#160;the&#160;number&#160;of characters, excluding the '\0', or zero if more&#160;<br/>than smax characters were produced. &#160;<br/>
%a&#160;<br/>
abbreviated weekday name.&#160;<br/>
%A&#160;<br/>
full weekday name.&#160;<br/>
%b&#160;<br/>
abbreviated month name.&#160;<br/>
%B&#160;<br/>
full month name.&#160;<br/>
%c&#160;<br/>
local date and time representation.&#160;<br/>
%d&#160;<br/>
day of the month (01-31).&#160;<br/>
%H&#160;<br/>
hour (24-hour clock)&#160;(00-23).&#160;<br/>
%I&#160;<br/>
hour (12-hour clock)&#160;(01-12).&#160;<br/>
%j&#160;<br/>
day of the year&#160;(001-366).&#160;<br/>
%m&#160;<br/>
month&#160;(01-12).&#160;<br/>
%M&#160;<br/>
minute&#160;(00-59).&#160;<br/>
%p&#160;<br/>
local equivalent of AM or PM.&#160;<br/>
%S&#160;<br/>
second&#160;(00-61).&#160;<br/>
%U&#160;<br/>
week number of the year (Sunday as 1st day of week)&#160;(00-53).&#160;<br/>
%w&#160;<br/>
weekday (0-6, Sunday is 0).&#160;<br/>
%W&#160;<br/>
week number of the year (Monday as 1st day of week)&#160;(00-53).&#160;<br/>
%x&#160;<br/>
local date representation.&#160;<br/>
%X&#160;<br/>
local time representation.&#160;<br/>
%y&#160;<br/>
year without century&#160;(00-99).&#160;<br/>
%Y&#160;<br/>
year with century.&#160;<br/>
%Z&#160;<br/>
time zone name, if any.&#160;<br/>
%% &#160;&#160;&#160;%&#160;<br/>
<b>B.11 Implementation-defined Limits:&#160;<br/>&lt;limits.h&gt; and &lt;float.h&gt;&#160;</b><br/>
<hr/>
<a name=235></a>&#160;&#160;<br/>
235&#160;<br/>
The header &lt;limits.h&gt; defines constants for the sizes of&#160;integral&#160;types.&#160;<br/>The values below are acceptable minimum magnitudes; larger values&#160;may&#160;be&#160;<br/>used. &#160;<br/>
CHAR_BIT &#160;&#160;8&#160;<br/>
bits in a&#160;char&#160;<br/>
CHAR_MAX&#160;&#160;&#160;UCHAR_MAX&#160;<i>or</i>&#160;SCHAR_MAX&#160;&#160;&#160;maximum value&#160;of&#160;char&#160;&#160;<br/>
CHAR_MIN&#160;&#160;&#160;0&#160;<i>or</i>&#160;SCHAR_MIN&#160;<br/>
maximum value&#160;of&#160;char&#160;<br/>
INT_MAX&#160;&#160;<br/>
32767&#160;<br/>
maximum value&#160;of&#160;int&#160;<br/>
INT_MIN&#160;&#160;<br/>
-32767&#160;<br/>
minimum value&#160;of&#160;int&#160;<br/>
LONG_MAX&#160;&#160;&#160;2147483647&#160;<br/>
maximum value&#160;of&#160;long&#160;<br/>
LONG_MIN&#160;&#160;&#160;-2147483647&#160;<br/>
minimum value&#160;of&#160;long&#160;<br/>
SCHAR_MAX&#160;&#160;+127&#160;<br/>
maximum value&#160;of&#160;signed char&#160;<br/>
SCHAR_MIN&#160;&#160;-127&#160;<br/>
minimum value&#160;of&#160;signed char&#160;<br/>
SHRT_MAX&#160;&#160;&#160;+32767&#160;<br/>
maximum value&#160;of&#160;short&#160;<br/>
SHRT_MIN&#160;&#160;&#160;-32767&#160;<br/>
minimum value&#160;of&#160;short&#160;<br/>
UCHAR_MAX&#160;&#160;255&#160;<br/>
maximum value&#160;of&#160;unsigned char&#160;<br/>
UINT_MAX&#160;&#160;&#160;65535&#160;<br/>
maximum value&#160;of&#160;unsigned int&#160;<br/>
ULONG_MAX&#160;&#160;4294967295&#160;<br/>
maximum value&#160;of&#160;unsigned long&#160;<br/>
USHRT_MAX&#160;&#160;65535&#160;<br/>
maximum value&#160;of&#160;unsigned short&#160;<br/>
The&#160;names&#160;in the table below, a subset of &lt;float.h&gt;, are constants related&#160;<br/>to floating-point arithmetic. When a value is given, it&#160;represents&#160;the&#160;<br/>minimum magnitude for the corresponding quantity. Each implementation&#160;<br/>defines appropriate values. &#160;<br/>
FLT_RADIX&#160;&#160;<br/>
2&#160;<br/>
radix of exponent, representation, e.g., 2, 16&#160;<br/>
FLT_ROUNDS&#160;&#160;<br/>
&#160;<br/>
floating-point rounding mode for addition&#160;<br/>
FLT_DIG&#160;&#160;<br/>
6&#160;<br/>
decimal digits of precision&#160;<br/>
FLT_EPSILON&#160;&#160;<br/>
1E-5&#160;<br/>
smallest number&#160;<i>x</i>&#160;such that 1.0+x != 1.0&#160;<br/>
FLT_MANT_DIG &#160;&#160;&#160;&#160;<br/>
number of base&#160;FLT_RADIX&#160;in mantissa&#160;<br/>
FLT_MAX&#160;&#160;<br/>
1E+37 &#160;&#160;&#160;maximum&#160;floating-point number&#160;<br/>
FLT_MAX_EXP&#160;&#160;<br/>
&#160;<br/>
maximum&#160;<i>n</i>&#160;such that&#160;<br/>
n-1<br/>
FLT_RADIX<br/>
&#160;is representable&#160;<br/>
FLT_MIN&#160;&#160;<br/>
1E-37&#160;<br/>
minimum&#160;normalized floating-point number&#160;<br/>
FLT_MIN_EXP&#160;&#160;<br/>
&#160;minimum&#160;<br/>
<i>n</i>&#160;such that 10<i>n</i>&#160;is a normalized number&#160;<br/>
DBL_DIG&#160;&#160;<br/>
10&#160;<br/>
decimal digits of precision&#160;<br/>
DBL_EPSILON&#160;&#160;<br/>
1E-9&#160;<br/>
smallest number&#160;<i>x</i>&#160;such that 1.0+x != 1.0&#160;<br/>
DBL_MANT_DIG&#160;<br/>
&#160;<br/>
number of base&#160;FLT_RADIX&#160;in mantissa&#160;<br/>
DBL_MAX&#160;&#160;<br/>
1E+37&#160;<br/>
maximum&#160;double&#160;floating-point number&#160;<br/>
DBL_MAX_EXP&#160;&#160;<br/>
&#160;<br/>
maximum&#160;<i>n</i>&#160;such that&#160;<br/>
n-1<br/>
FLT_RADIX<br/>
&#160;is representable&#160;<br/>
DBL_MIN&#160;&#160;<br/>
1E-37&#160;<br/>
minimum normalized&#160;double&#160;floating-point number&#160;<br/>
DBL_MIN_EXP&#160;&#160;<br/>
&#160;minimum&#160;<br/>
<i>n</i>&#160;such that 10<i>n</i>&#160;is a normalized number&#160;<br/>
&#160;<br/>
<hr/>
<a name=236></a>&#160;&#160;<br/>
236&#160;<br/>
&#160;<br/>
<b>Appendix C - Summary of Changes&#160;</b><br/>
Since the publication of the first edition of this book, the definition of the C language has&#160;<br/>undergone changes. Almost all were extensions&#160;of the original language, and were carefully&#160;<br/>designed to remain compatible with existing&#160;practice; some repaired ambiguities in the&#160;<br/>original description; and some represent modifications that change existing practice. Many of&#160;<br/>the new facilities were announced in the documents accompanying compilers available from&#160;<br/>AT&amp;T, and have subsequently been adopted by other suppliers of C compilers. More&#160;<br/>recently, the ANSI committee standardizing the language incorporated most of the changes,&#160;<br/>and also introduced other significant modifications. Their report was in part participated by&#160;<br/>some commercial compilers even before issuance of the formal C standard. &#160;<br/>
This Appendix summarizes the differences between the language defined by the first edition&#160;<br/>of this book, and that expected to be defined&#160;by the final standard. It treats only the language&#160;<br/>itself, not its environment and library; although these are an important part of the standard,&#160;<br/>there is little to compare with, because the first edition did not attempt to prescribe an&#160;<br/>environment or library. &#160;<br/>
•&#160;&#160;Preprocessing is more carefully defined in the&#160;Standard than in the first edition, and is&#160;<br/>
extended: it is explicitly token based; there are new operators for concatenation of&#160;<br/>tokens (##), and creation of strings (#); there are new control lines like&#160;#elif&#160;and&#160;<br/>#pragma; redeclaration of&#160;macros by the same token sequence is explicitly permitted;&#160;<br/>parameters inside strings are no longer replaced. Splicing of lines by \ is permitted&#160;<br/>everywhere, not just in strings and m<a href="">acro definitions. See&#160;Par.A.12</a>. &#160;<br/>
•&#160;&#160;The minimum&#160;significance of all internal identifiers increased to 31 characters; the&#160;<br/>
smallest mandated significance of&#160;identifiers with external linkage remains 6&#160;<br/>monocase letters. (Many implementations provide more.) &#160;<br/>
•&#160;&#160;Trigraph sequences introduced by&#160;??&#160;allow representation of characters lacking in&#160;<br/>
some character sets. Escapes for&#160;#\^[]{}|~<a href="">&#160;are defined, see&#160;Par.A.12.1. Observe that&#160;<br/></a>the introduction of trigraphs may change&#160;the meaning of strings containing the&#160;<br/>sequence&#160;??. &#160;<br/>
•&#160;&#160;New keywords (void, const, volatile, signed, enum) are introduced. The&#160;<br/>
stillborn&#160;entry&#160;keyword is withdrawn. &#160;<br/>
•&#160;&#160;New escape sequences, for use within character constants and string literals, are&#160;<br/>
defined. The effect of following \ by a character not part of an approved escape&#160;<br/><a href="">sequence is undefined. See&#160;Par.A.2.5.2</a>. &#160;<br/>
•&#160;&#160;Everyone's favorite trivial change:&#160;8&#160;and&#160;9&#160;are not octal digits. &#160;<br/>•&#160;&#160;The standard introduces a larger set of&#160;suffixes to make the type of&#160;constants explicit:&#160;<br/>
U&#160;or&#160;L&#160;for integers,&#160;F&#160;or&#160;L&#160;for floating. It also refines the rules for the type of unsiffixed&#160;<br/><a href="">constants (Par.A.2.5). &#160;</a><br/>
•&#160;&#160;Adjacent string literals are concatenated. &#160;<br/>•&#160;&#160;There is a notation for wide-character string literals and character constants; see&#160;<br/>
<a href="">Par.A.2.6. &#160;</a><br/>
•&#160;&#160;Characters as well as other types, may be explicitly declared to carry, or not to carry, a&#160;<br/>
sign by using the keywords&#160;signed&#160;or&#160;unsigned. The locution&#160;long float&#160;as a&#160;<br/>synonym&#160;for&#160;double&#160;is withdrawn, but&#160;long double&#160;may be used to declare an extra-<br/>precision floating quantity. &#160;<br/>
•&#160;&#160;For some time, type&#160;unsigned char&#160;has been available. The standard introduces the&#160;<br/>
signed&#160;keyword to make signedness explicit for&#160;char&#160;and other integral objects. &#160;<br/>
<hr/>
<a name=237></a>&#160;&#160;<br/>
237&#160;<br/>
•&#160;&#160;The&#160;&#160;void&#160;type has been available in most&#160;implementations for some years. The&#160;<br/>
Standard introduces the use of the&#160;void *&#160;type as a generic pointer type; previously&#160;<br/>char *&#160;played this role. At the same time, explicit rules are enacted against mixing&#160;<br/>pointers and integers, and pointers of different type, without the use of casts. &#160;<br/>
•&#160;&#160;The Standard places explicit minima on the ranges of the arithmetic types, and&#160;<br/>
mandates headers (&lt;limits.h&gt;&#160;and&#160;&lt;float.h&gt;) giving the characteristics of each&#160;<br/>particular implementation. &#160;<br/>
•&#160;&#160;Enumerations are new since the first edition of this book. &#160;<br/>•&#160;&#160;The Standard adopts from&#160;C++ the notion of type qualifier, for example&#160;const&#160;<br/>
<a href="">(Par.A.8.2). &#160;</a><br/>
•&#160;&#160;Strings are no longer modifiable, and so may be placed in read-only memory. &#160;<br/>•&#160;&#160;The ``usual arithmetic conversions'' are changed, essentially from&#160;``for integers,&#160;<br/>
unsigned&#160;always wins; for floating point, always use&#160;double''&#160;to ``promote to the&#160;<br/>sm<a href="">allest capacious-enough type.'' See&#160;Par.A.6.5. &#160;</a><br/>
•&#160;&#160;The old assignment operators like&#160;=+&#160;are truly gone. Also, assignment operators are&#160;<br/>
now single tokens; in the first edition, they&#160;were pairs, and could be separated by&#160;<br/>white space. &#160;<br/>
•&#160;&#160;A compiler's license to treat mathematically associative operators as computationally&#160;<br/>
associative is revoked. &#160;<br/>
•&#160;&#160;A unary&#160;+&#160;operator is introduced for symmetry with unary&#160;-. &#160;<br/>•&#160;&#160;A pointer to a function may be used as&#160;a function designator without an explicit&#160;*&#160;<br/>
operator. See&#160;<a href="">Par.A.7.3.2</a>. &#160;<br/>
•&#160;&#160;Structures may be assigned, passed to functions, and returned by functions. &#160;<br/>•&#160;&#160;Applying the address-of&#160;operator to arrays is&#160;permitted, and the result is a pointer to&#160;<br/>
the array. &#160;<br/>
•&#160;&#160;The&#160;&#160;sizeof&#160;operator, in the first edition, yielded type&#160;int; subsequently, many&#160;<br/>
implementations made it&#160;unsigned. The Standard makes its type explicitly&#160;<br/>implementation-dependent, but requires the type,&#160;size_t, to be defined in a standard&#160;<br/>header (&lt;stddef.h&gt;). A similar change occurs in the type (ptrdiff_t) of the&#160;<br/><a href="">difference between pointers. See&#160;Par.A.7.4.8&#160;and&#160;Par.A.7.7. &#160;</a><br/>
•&#160;&#160;The address-of operator&#160;&amp;&#160;may not be applied to an object declared&#160;register, even if&#160;<br/>
the implementation chooses not to keep the object in a register. &#160;<br/>
•&#160;&#160;The type of a shift expression is that of&#160;the left operand; the right operand can't&#160;<br/>
prom<a href="">ote the result. See&#160;Par.A.7.8. &#160;</a><br/>
•&#160;&#160;The Standard legalizes the creation of a pointer just beyond the end of an array, and&#160;<br/>
allows arithm<a href="">etic and relations on it; see&#160;Par.A.7.7. &#160;</a><br/>
•&#160;&#160;The Standard introduces (borrowing from&#160;C++) the notion of a function prototype&#160;<br/>
declaration that incorporates the types of&#160;the parameters, and includes an explicit&#160;<br/>recognition of variadic functions together with an approved way of dealing with them.&#160;<br/>See Pars.&#160;<a href="">A.7.3.2,&#160;A.8.6.3,&#160;B.7</a>. The older style is still accepted, with restrictions. &#160;<br/>
•&#160;&#160;Empty declarations, which have no declarators and don't declare at least a structure,&#160;<br/>
union, or enumeration, are forbidden by the&#160;Standard. On the other hand, a declaration&#160;<br/>with just a structure or union tag redeclares that tag even if it was declared in an outer&#160;<br/>scope. &#160;<br/>
•&#160;&#160;External data declarations without any specifiers or qualifiers (just a naked declarator)&#160;<br/>
are forbidden. &#160;<br/>
•&#160;&#160;Some implementations, when presented with an&#160;extern&#160;declaration in an inner block,&#160;<br/>
would export the declaration to the rest of the file. The Standard makes it clear that the&#160;<br/>scope of such a declaration is just the block. &#160;<br/>
•&#160;&#160;The scope of parameters is injected into&#160;a function's compound statement, so that&#160;<br/>
variable declarations at the top level of the function cannot hide the parameters. &#160;<br/>
<hr/>
<a name=238></a>238<br/>
•<br/>
The name spaces of identifiers are somewhat&#160;different. The Standard puts all tags in a<br/>single name space, and also introduces&#160;a separate name space for labels; see<br/><a href="">Par.A.11.1. Also, m</a>ember names are associated&#160;with the structure or union of which<br/>they are a part. (This has been common practice from&#160;some time.)<br/>
•<br/>
Unions may be initialized; the initializer refers to the first member.<br/>
•<br/>
Automatic structures, unions, and arrays may be initialized, albeit in a restricted way.<br/>
•<br/>
Character arrays with an explicit size may&#160;be initialized by a string literal with exactly<br/>that many characters (the&#160;\0&#160;is quietly squeezed out).<br/>
•<br/>
The controlling expression, and the case labels, of a switch may have any integral<br/>type.<br/>
<hr/>
<a name="outline"></a><h1>Document Outline</h1>
<ul>
<li><a href="cs.html#6">Preface</a></li>
<li><a href="cs.html#8">Preface to the first edition</a></li>
<li><a href="cs.html#9">Chapter 1 - A Tutorial Introduction</a>
<ul>
<li><a href="cs.html#9">1.1 Getting Started</a></li>
<li><a href="cs.html#11">1.2 Variables and Arithmetic Expressions</a></li>
<li><a href="cs.html#16">1.3 The for statement</a></li>
<li><a href="cs.html#17">1.4 Symbolic Constants</a></li>
<li><a href="cs.html#18">1.5 Character Input and Output</a>
<ul>
<li><a href="cs.html#18">1.5.1 File Copying</a></li>
<li><a href="cs.html#20">1.5.2 Character Counting</a></li>
<li><a href="cs.html#21">1.5.3 Line Counting</a></li>
<li><a href="cs.html#22">1.5.4 Word Counting</a></li>
</ul>
</li>
<li><a href="cs.html#23">1.6 Arrays</a></li>
<li><a href="cs.html#25">1.7 Functions</a></li>
<li><a href="cs.html#28">1.8 Arguments - Call by Value</a></li>
<li><a href="cs.html#29">1.9 Character Arrays</a></li>
<li><a href="cs.html#31">1.10 External Variables and Scope</a></li>
</ul>
</li>
<li><a href="cs.html#35">Chapter 2 - Types, Operators and Expressions</a>
<ul>
<li><a href="cs.html#35">2.1 Variable Names</a></li>
<li><a href="cs.html#35">2.2 Data Types and Sizes</a></li>
<li><a href="cs.html#36">2.3 Constants</a></li>
<li><a href="cs.html#39">2.4 Declarations</a></li>
<li><a href="cs.html#40">2.5 Arithmetic Operators</a></li>
<li><a href="cs.html#40">2.6 Relational and Logical Operators</a></li>
<li><a href="cs.html#41">2.7 Type Conversions</a></li>
<li><a href="cs.html#44">2.8 Increment and Decrement Operators</a></li>
<li><a href="cs.html#46">2.9 Bitwise Operators</a></li>
<li><a href="cs.html#47">2.10 Assignment Operators and Expressions</a></li>
<li><a href="cs.html#49">2.11 Conditional Expressions</a></li>
<li><a href="cs.html#49">2.12 Precedence and Order of Evaluation</a></li>
</ul>
</li>
<li><a href="cs.html#52">Chapter 3 - Control Flow</a>
<ul>
<li><a href="cs.html#52">3.1 Statements and Blocks</a></li>
<li><a href="cs.html#52">3.2 If-Else</a></li>
<li><a href="cs.html#53">3.3 Else-If</a></li>
<li><a href="cs.html#54">3.4 Switch</a></li>
<li><a href="cs.html#56">3.5 Loops - While and For</a></li>
<li><a href="cs.html#58">3.6 Loops - Do-While</a></li>
<li><a href="cs.html#59">3.7 Break and Continue</a></li>
<li><a href="cs.html#60">3.8 Goto and labels</a></li>
</ul>
</li>
<li><a href="cs.html#62">Chapter 4 - Functions and Program Structure</a>
<ul>
<li><a href="cs.html#62">4.1 Basics of Functions</a></li>
<li><a href="cs.html#65">4.2 Functions Returning Non-integers</a></li>
<li><a href="cs.html#67">4.3 External Variables</a></li>
<li><a href="cs.html#72">4.4 Scope Rules</a></li>
<li><a href="cs.html#73">4.5 Header Files</a></li>
<li><a href="cs.html#75">4.6 Static Variables</a></li>
<li><a href="cs.html#75">4.7 Register Variables</a></li>
<li><a href="cs.html#76">4.8 Block Structure</a></li>
<li><a href="cs.html#76">4.9 Initialization</a></li>
<li><a href="cs.html#78">4.10 Recursion</a></li>
<li><a href="cs.html#79">4.11 The C Preprocessor</a>
<ul>
<li><a href="cs.html#79">4.11.1 File Inclusion</a></li>
<li><a href="cs.html#80">4.11.2 Macro Substitution</a></li>
<li><a href="cs.html#82">4.11.3 Conditional Inclusion</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="cs.html#83">Chapter 5 - Pointers and Arrays</a>
<ul>
<li><a href="cs.html#83">5.1 Pointers and Addresses</a></li>
<li><a href="cs.html#84">5.2 Pointers and Function Arguments</a></li>
<li><a href="cs.html#87">5.3 Pointers and Arrays</a></li>
<li><a href="cs.html#90">5.4 Address Arithmetic</a></li>
<li><a href="cs.html#93">5.5 Character Pointers and Functions</a></li>
<li><a href="cs.html#96">5.6 Pointer Arrays; Pointers to Pointers</a></li>
<li><a href="cs.html#99">5.7 Multi-dimensional Arrays</a></li>
<li><a href="cs.html#101">5.8 Initialization of Pointer Arrays</a></li>
<li><a href="cs.html#101">5.9 Pointers vs. Multi-dimensional Arrays</a></li>
<li><a href="cs.html#102">5.10 Command-line Arguments</a></li>
<li><a href="cs.html#106">5.11 Pointers to Functions</a></li>
<li><a href="cs.html#108">5.12 Complicated Declarations</a></li>
</ul>
</li>
<li><a href="cs.html#114">Chapter 6 - Structures</a>
<ul>
<li><a href="cs.html#114">6.1 Basics of Structures</a></li>
<li><a href="cs.html#116">6.2 Structures and Functions</a></li>
<li><a href="cs.html#118">6.3 Arrays of Structures</a></li>
<li><a href="cs.html#122">6.4 Pointers to Structures</a></li>
<li><a href="cs.html#124">6.5 Self-referential Structures</a></li>
<li><a href="cs.html#127">6.6 Table Lookup</a></li>
<li><a href="cs.html#129">6.7 Typedef</a></li>
<li><a href="cs.html#131">6.8 Unions</a></li>
<li><a href="cs.html#132">6.9 Bit-fields</a></li>
</ul>
</li>
<li><a href="cs.html#135">Chapter 7 - Input and Output</a>
<ul>
<li><a href="cs.html#135">7.1 Standard Input and Output</a></li>
<li><a href="cs.html#137">7.2 Formatted Output - printf</a></li>
<li><a href="cs.html#138">7.3 Variable-length Argument Lists</a></li>
<li><a href="cs.html#140">7.4 Formatted Input - Scanf</a></li>
<li><a href="cs.html#142">7.5 File Access</a></li>
<li><a href="cs.html#145">7.6 Error Handling - Stderr and Exit</a></li>
<li><a href="cs.html#146">7.7 Line Input and Output</a></li>
<li><a href="cs.html#147">7.8 Miscellaneous Functions</a>
<ul>
<li><a href="cs.html#147">7.8.1 String Operations</a></li>
<li><a href="cs.html#148">7.8.2 Character Class Testing and Conversion</a></li>
<li><a href="cs.html#148">7.8.3 Ungetc</a></li>
<li><a href="cs.html#148">7.8.4 Command Execution</a></li>
<li><a href="cs.html#148">7.8.5 Storage Management</a></li>
<li><a href="cs.html#149">7.8.6 Mathematical Functions</a></li>
<li><a href="cs.html#149">7.8.7 Random Number generation</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="cs.html#151">Chapter 8 - The UNIX System Interface</a>
<ul>
<li><a href="cs.html#151">8.1 File Descriptors</a></li>
<li><a href="cs.html#152">8.2 Low Level I/O - Read and Write</a></li>
<li><a href="cs.html#153">8.3 Open, Creat, Close, Unlink</a></li>
<li><a href="cs.html#155">8.4 Random Access - Lseek</a></li>
<li><a href="cs.html#156">8.5 Example - An implementation of Fopen and Getc</a></li>
<li><a href="cs.html#159">8.6 Example - Listing Directories</a></li>
<li><a href="cs.html#163">8.7 Example - A Storage Allocator</a></li>
</ul>
</li>
<li><a href="cs.html#168">Appendix A - Reference Manual</a>
<ul>
<li><a href="cs.html#168">A.1 Introduction</a></li>
<li><a href="cs.html#168">A.2 Lexical Conventions</a>
<ul>
<li><a href="cs.html#168">A.2.1 Tokens</a></li>
<li><a href="cs.html#168">A.2.2 Comments</a></li>
<li><a href="cs.html#168">A.2.3 Identifiers</a></li>
<li><a href="cs.html#169">A.2.4 Keywords</a></li>
<li><a href="cs.html#169">A.2.5 Constants</a>
<ul>
<li><a href="cs.html#169">A.2.5.1 Integer Constants</a></li>
<li><a href="cs.html#170">A.2.5.2 Character Constants</a></li>
<li><a href="cs.html#170">A.2.5.3 Floating Constants</a></li>
<li><a href="cs.html#170">A2.5.4 Enumeration Constants</a></li>
</ul>
</li>
<li><a href="cs.html#171">A.2.6 String Literals</a></li>
</ul>
</li>
<li><a href="cs.html#171">A.3 Syntax Notation</a></li>
<li><a href="cs.html#171">A.4 Meaning of Identifiers</a>
<ul>
<li><a href="cs.html#171">A.4.1 Storage Class</a></li>
<li><a href="cs.html#172">A.4.2 Basic Types</a></li>
<li><a href="cs.html#173">A.4.3 Derived types</a></li>
<li><a href="cs.html#173">A.4.4 Type Qualifiers</a></li>
</ul>
</li>
<li><a href="cs.html#173">A.5 Objects and Lvalues</a></li>
<li><a href="cs.html#173">A.6 Conversions</a>
<ul>
<li><a href="cs.html#174">A.6.1 Integral Promotion</a></li>
<li><a href="cs.html#174">A.6.2 Integral Conversions</a></li>
<li><a href="cs.html#174">A.6.3 Integer and Floating</a></li>
<li><a href="cs.html#174">A.6.4 Floating Types</a></li>
<li><a href="cs.html#174">A.6.5 Arithmetic Conversions</a></li>
<li><a href="cs.html#175">A.6.6 Pointers and Integers</a></li>
<li><a href="cs.html#176">A.6.7 Void</a></li>
<li><a href="cs.html#176">A.6.8 Pointers to Void</a></li>
</ul>
</li>
<li><a href="cs.html#176">A.7 Expressions</a>
<ul>
<li><a href="cs.html#177">A.7.1 Pointer Conversion</a></li>
<li><a href="cs.html#177">A.7.2 Primary Expressions</a></li>
<li><a href="cs.html#177">A.7.3 Postfix Expressions</a>
<ul>
<li><a href="cs.html#178">A.7.3.1 Array References</a></li>
<li><a href="cs.html#178">A.7.3.2 Function Calls</a></li>
<li><a href="cs.html#179">A.7.3.3 Structure References</a></li>
<li><a href="cs.html#179">A.7.3.4 Postfix Incrementation</a></li>
</ul>
</li>
<li><a href="cs.html#179">A.7.4 Unary Operators</a>
<ul>
<li><a href="cs.html#180">A.7.4.1 Prefix Incrementation Operators</a></li>
<li><a href="cs.html#180">A.7.4.2 Address Operator</a></li>
<li><a href="cs.html#180">A.7.4.3 Indirection Operator</a></li>
<li><a href="cs.html#180">A.7.4.4 Unary Plus Operator</a></li>
<li><a href="cs.html#180">A.7.4.5 Unary Minus Operator</a></li>
<li><a href="cs.html#180">A.7.4.6 One's Complement Operator</a></li>
<li><a href="cs.html#181">A.7.4.7 Logical Negation Operator</a></li>
<li><a href="cs.html#181">A.7.4.8 Sizeof Operator</a></li>
</ul>
</li>
<li><a href="cs.html#181">A.7.5 Casts</a></li>
<li><a href="cs.html#181">A.7.6 Multiplicative Operators</a></li>
<li><a href="cs.html#182">A.7.7 Additive Operators</a></li>
<li><a href="cs.html#182">A.7.8 Shift Operators</a></li>
<li><a href="cs.html#183">A.7.9 Relational Operators</a></li>
<li><a href="cs.html#183">A.7.10 Equality Operators</a></li>
<li><a href="cs.html#183">A.7.11 Bitwise AND Operator</a></li>
<li><a href="cs.html#184">A.7.12 Bitwise Exclusive OR Operator</a></li>
<li><a href="cs.html#184">A.7.13 Bitwise Inclusive OR Operator</a></li>
<li><a href="cs.html#184">A.7.14 Logical AND Operator</a></li>
<li><a href="cs.html#184">A.7.15 Logical OR Operator</a></li>
<li><a href="cs.html#184">A.7.16 Conditional Operator</a></li>
<li><a href="cs.html#185">A.7.17 Assignment Expressions</a></li>
<li><a href="cs.html#185">A.7.18 Comma Operator</a></li>
<li><a href="cs.html#186">A.7.19 Constant Expressions</a></li>
</ul>
</li>
<li><a href="cs.html#186">A.8 Declarations</a>
<ul>
<li><a href="cs.html#187">A.8.1 Storage Class Specifiers</a></li>
<li><a href="cs.html#188">A.8.2 Type Specifiers</a></li>
<li><a href="cs.html#188">A.8.3 Structure and Union Declarations</a></li>
<li><a href="cs.html#191">A.8.4 Enumerations</a></li>
<li><a href="cs.html#192">A.8.5 Declarators</a></li>
<li><a href="cs.html#193">A.8.6 Meaning of Declarators</a>
<ul>
<li><a href="cs.html#193">A.8.6.1 Pointer Declarators</a></li>
<li><a href="cs.html#194">A.8.6.2 Array Declarators</a></li>
<li><a href="cs.html#194">A.8.6.3 Function Declarators</a></li>
</ul>
</li>
<li><a href="cs.html#196">A.8.7 Initialization</a></li>
<li><a href="cs.html#198">A.8.8 Type names</a></li>
<li><a href="cs.html#199">A.8.9 Typedef</a></li>
<li><a href="cs.html#199">A.8.10 Type Equivalence</a></li>
</ul>
</li>
<li><a href="cs.html#199">A.9 Statements</a>
<ul>
<li><a href="cs.html#200">A.9.1 Labeled Statements</a></li>
<li><a href="cs.html#200">A.9.2 Expression Statement</a></li>
<li><a href="cs.html#200">A.9.3 Compound Statement</a></li>
<li><a href="cs.html#201">A.9.4 Selection Statements</a></li>
<li><a href="cs.html#201">A.9.5 Iteration Statements</a></li>
<li><a href="cs.html#202">A.9.6 Jump statements</a></li>
</ul>
</li>
<li><a href="cs.html#203">A.10 External Declarations</a>
<ul>
<li><a href="cs.html#203">A.10.1 Function Definitions</a></li>
<li><a href="cs.html#204">A.10.2 External Declarations</a></li>
</ul>
</li>
<li><a href="cs.html#205">A.11 Scope and Linkage</a>
<ul>
<li><a href="cs.html#205">A.11.1 Lexical Scope</a></li>
<li><a href="cs.html#206">A.11.2 Linkage</a></li>
</ul>
</li>
<li><a href="cs.html#206">A.12 Preprocessing</a>
<ul>
<li><a href="cs.html#207">A.12.1 Trigraph Sequences</a></li>
<li><a href="cs.html#207">A.12.2 Line Splicing</a></li>
<li><a href="cs.html#207">A.12.3 Macro Definition and Expansion</a></li>
<li><a href="cs.html#209">A.12.4 File Inclusion</a></li>
<li><a href="cs.html#210">A.12.5 Conditional Compilation</a></li>
<li><a href="cs.html#211">A.12.6 Line Control</a></li>
<li><a href="cs.html#211">A.12.7 Error Generation</a></li>
<li><a href="cs.html#212">A.12.8 Pragmas</a></li>
<li><a href="cs.html#212">A.12.9 Null directive</a></li>
<li><a href="cs.html#212">A.12.10 Predefined names</a></li>
</ul>
</li>
<li><a href="cs.html#212">A.13 Grammar</a></li>
</ul>
</li>
<li><a href="cs.html#220">Appendix B - Standard Library</a>
<ul>
<li><a href="cs.html#220">B.1 Input and Output: &lt;stdio.h&gt;</a>
<ul>
<li><a href="cs.html#220">B.1.1 File Operations</a></li>
<li><a href="cs.html#222">B.1.2 Formatted Output</a></li>
<li><a href="cs.html#223">B.1.3 Formatted Input</a></li>
<li><a href="cs.html#225">B.1.4 Character Input and Output Functions</a></li>
<li><a href="cs.html#225">B.1.5 Direct Input and Output Functions</a></li>
<li><a href="cs.html#226">B.1.6 File Positioning Functions</a></li>
<li><a href="cs.html#226">B.1.7 Error Functions</a></li>
</ul>
</li>
<li><a href="cs.html#226">B.2 Character Class Tests: &lt;ctype.h&gt;</a></li>
<li><a href="cs.html#227">B.3 String Functions: &lt;string.h&gt;</a></li>
<li><a href="cs.html#228">B.4 Mathematical Functions: &lt;math.h&gt;</a></li>
<li><a href="cs.html#229">B.5 Utility Functions: &lt;stdlib.h&gt;</a></li>
<li><a href="cs.html#231">B.6 Diagnostics: &lt;assert.h&gt;</a></li>
<li><a href="cs.html#231">B.7 Variable Argument Lists: &lt;stdarg.h&gt;</a></li>
<li><a href="cs.html#232">B.8 Non-local Jumps: &lt;setjmp.h&gt;</a></li>
<li><a href="cs.html#232">B.9 Signals: &lt;signal.h&gt;</a></li>
<li><a href="cs.html#233">B.10 Date and Time Functions: &lt;time.h&gt;</a></li>
<li><a href="cs.html#234">B.11 Implementation-defined Limits: &lt;limits.h&gt; and &lt;float.h&gt;</a></li>
</ul>
</li>
<li><a href="cs.html#236">Appendix C - Summary of Changes</a></li>
</ul>
<hr/>
</body>
</html>
